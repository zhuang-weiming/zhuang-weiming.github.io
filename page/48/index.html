<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhuang-weiming.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.3.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Zhuang&#39;s Diary">
<meta property="og:url" content="https://zhuang-weiming.github.io/page/48/index.html">
<meta property="og:site_name" content="Zhuang&#39;s Diary">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiming Zhuang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhuang-weiming.github.io/page/48/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Zhuang's Diary</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhuang's Diary</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">言之有物，持之以恒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weiming Zhuang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">255</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/zhuangweiming/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;zhuangweiming&#x2F;" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2018/03/07/Golang-gRPC%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/07/Golang-gRPC%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Golang gRPC笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-07 19:23:30" itemprop="dateCreated datePublished" datetime="2018-03-07T19:23:30+08:00">2018-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-09-14 13:55:12" itemprop="dateModified" datetime="2023-09-14T13:55:12+08:00">2023-09-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="gRPC-简介："><a href="#gRPC-简介：" class="headerlink" title="gRPC 简介："></a>gRPC 简介：</h3><blockquote>
<p>gRPC 是一款高性能、开源的 RPC（Remote Procedure Call）框架，产自 Google，基于 ProtoBuf 序列化协议进行开发，支持多种语言（Golang、Python、Java等），本篇只介绍 Golang 的 gRPC 使用。因为 gRPC 对 HTTP/2 协议的支持使其在 Android、IOS 等客户端后端服务的开发领域具有良好的前景。gRPC 提供了一种简单的方法来定义服务，同时客户端可以充分利用 HTTP/2 stream 的特性，从而有助于节省带宽、降低 TCP 的连接次数、节省CPU的使用等。</p>
</blockquote>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p>gRPC 的安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>
<p>因为 gRPC 是基于 protobuf 实现的接口序列化，所以也要安装 protobuf： 安装及简介教程(Golang 序列化之 ProtoBuf)。</p>
<p>实验：</p>
<p>下面我们使用 gRPC 定义一个接口，该接口实现对传入的数据进行大写的格式化处理。</p>
<ol>
<li>创建项目 golang Demo 工程：<br><img src="/2018/03/07/Golang-gRPC%E7%AC%94%E8%AE%B0/1.png"></li>
</ol>
<blockquote>
<p>client目录下的 main.go 实现了客户端用于发送数据并打印接收到 server 端处理后的数据</p>
</blockquote>
<ol>
<li>server 目录下的 main.go 实现了服务端用于接收客户端发送的数据，并对数据进行大写处理后返回给客户端</li>
<li>example 包用于编写 proto 文件并生成 data 接口</li>
<li>定义 gRPC 接口：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line">service FormatData &#123;</span><br><span class="line">    rpc DoFormat(Data) returns (Data)&#123;&#125; </span><br><span class="line">    <span class="comment">// 此处定义的方法为简单RPC。其余的服务器端流式 RPC，客户端流式 RPC，双向流式 RPC请查询参考链接</span></span><br><span class="line">&#125;</span><br><span class="line">message Data &#123;</span><br><span class="line">    <span class="keyword">string</span> text = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译 protobuf：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. *.proto // 在 example 目录中执行编译，会生成：data.pb.go</span><br></pre></td></tr></table></figure>
<p>实现 server 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gRPCDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义监听地址</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	HOST <span class="keyword">string</span> = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">	PORT <span class="keyword">string</span> = <span class="string">&quot;8080&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> FormatData <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FormatData)</span> <span class="title">DoFormat</span><span class="params">(ctx context.Context, in *example.Data)</span> <span class="params">(out *example.Data, err error)</span></span> &#123;</span><br><span class="line">	str := in.Text</span><br><span class="line">	out = &amp;example.Data&#123;Text: strings.ToUpper(str)&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接在 main 方法中注册接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动服务器</span></span><br><span class="line">	<span class="comment">// 指定我们期望客户端请求的监听端口</span></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, HOST+<span class="string">&quot;:&quot;</span>+PORT)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;faile listen at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;Demo server is listening at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建 gRPC 服务器的一个实例</span></span><br><span class="line">	rpcServer := grpc.NewServer()</span><br><span class="line">	<span class="comment">// 在 gRPC 服务器注册我们的服务实现</span></span><br><span class="line">	example.RegisterFormatDataServer(rpcServer, &amp;FormatData&#123;&#125;)</span><br><span class="line">	reflection.Register(rpcServer)</span><br><span class="line">	<span class="comment">// 实现阻塞等待，直到进程被杀死或者 Stop() 被调用</span></span><br><span class="line">	<span class="keyword">if</span> err = rpcServer.Serve(listener); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;faile serve at: &quot;</span> + HOST + <span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 client 端：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;gRPCDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义请求地址</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ADDRESS <span class="keyword">string</span> = <span class="string">&quot;localhost:8080&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// main 方法实现对 gRPC 接口的请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了调用服务方法，我们首先创建一个 gRPC channel 和服务器交互。</span></span><br><span class="line">	<span class="comment">// 可以使用 DialOptions 在 grpc.Dial 中设置授权认证（如， TLS，GCE认证，JWT认证）</span></span><br><span class="line">	conn, err := grpc.Dial(ADDRESS, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Can&#x27;t connect: &quot;</span> + ADDRESS)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="comment">// 一旦 gRPC channel 建立起来，我们需要一个客户端 存根 去执行 RPC</span></span><br><span class="line">	client := example.NewFormatDataClient(conn)</span><br><span class="line">	<span class="comment">// 调用简单 RPC</span></span><br><span class="line">	resp,err := client.DoFormat(context.Background(), &amp;example.Data&#123;Text:<span class="string">&quot;hello,world!&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 如果调用没有返回错误，那么我们就可以从服务器返回的第一个返回值中读到响应信息</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Do Format error:&quot;</span> + err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(resp.Text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行验证结果：<br>先启动 server，之后再执行 client<br>client 侧控制台如果打印的结果为： HELLO,WORLD! ，证明 gRPC 接口定义成功。</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="http://doc.oschina.net/grpc?t=60133">http://doc.oschina.net/grpc?t=60133</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a></p>
<p><a target="_blank" rel="noopener" href="https://grpc.io/">https://grpc.io/</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2018/03/07/Golang-ProtoBuf%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/07/Golang-ProtoBuf%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Golang ProtoBuf笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-07 19:16:30" itemprop="dateCreated datePublished" datetime="2018-03-07T19:16:30+08:00">2018-03-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-29 09:07:46" itemprop="dateModified" datetime="2022-09-29T09:07:46+08:00">2022-09-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是protobuf"><a href="#什么是protobuf" class="headerlink" title="什么是protobuf"></a>什么是protobuf</h3><blockquote>
<p>protobuf(Google Protocol Buffers) 是一套完整的 IDL（接口描述语言），出自Google，基于 C++ 进行的实现，开发人员可以根据 ProtoBuf 的语言规范生成多种编程语言（Golang、Python、Java 等）的接口代码，本篇只讲述 Golang 的基础操作。ProtoBuf 所生成的二进制文件在存储效率上比 XML 高 3<del>10 倍，并且处理性能高 1</del>2 个数量级，这也是选择 ProtoBuf 作为序列化方案的一个重要因素之一。</p>
</blockquote>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a target="_blank" rel="noopener" href="https://github.com/google/protobuf">https://github.com/golang/protobuf</a></p>
<h3 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h3><ol>
<li>直接安装</li>
</ol>
<p>从 <a target="_blank" rel="noopener" href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载最新版本。例如 Mac 机器下载 osx 版本</p>
<p>Mac 中默认的 go root 地址为 ++/usr/local/go++，将解压缩出来的 protoc 可执行文件 copy 到  /usr/local/go/bin 下。</p>
<p>执行 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --version</span><br><span class="line"><span class="comment"># 如果正常打印 libprotoc 的版本信息就表明 protoc 安装成功</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Will:bin zhuangweiming$ protoc --version</span><br><span class="line">libprotoc 3.5.1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>编译安装</p>
<ol>
<li>从 <a target="_blank" rel="noopener" href="https://github.com/google/protobuf/releases">https://github.com/google/protobuf/releases</a> 下载最新版本，++protobuf-all-3.5.1.tar.gz++。</li>
<li>解压缩，在终端执行：tar zxvf protobuf-all-3.5.1.tar.gz</li>
<li>进入文件目录，在终端执行：cd protobuf-3.5.1/</li>
<li>执行配置，在终端执行：./configure</li>
<li>编译，在终端执行：make</li>
<li>检测编译，在终端执行：make check</li>
<li>安装 protoc，在终端执行：make install</li>
</ol>
</li>
</ol>
<p>执行 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Will:bin zhuangweiming$ protoc --version</span><br><span class="line">libprotoc 3.5.1</span><br></pre></td></tr></table></figure>
<p>显示 libprotoc 3.5.1 则为成功。</p>
<h3 id="安装-ProtoBuf-相关的-golang-依赖库。获取-goprotobuf-提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。"><a href="#安装-ProtoBuf-相关的-golang-依赖库。获取-goprotobuf-提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。" class="headerlink" title="安装 ProtoBuf 相关的 golang 依赖库。获取 goprotobuf 提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。"></a>安装 ProtoBuf 相关的 golang 依赖库。获取 goprotobuf 提供的支持库，包含诸如编码（marshaling）、解码（unmarshaling）等功能。</h3><p>$ go get -u github.com/golang/protobuf/{protoc-gen-go,proto}</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.创建 protocDemo golang工程<br><img src="/2018/03/07/Golang-ProtoBuf%E7%AC%94%E8%AE%B0/1.png"></p>
<p>2.在 example 包中编写 person.proto</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package example;</span><br><span class="line"></span><br><span class="line">message person &#123;    &#x2F;&#x2F;  aa 会生成 Aa 命名的结构体</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    string name &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message all_person &#123;    &#x2F;&#x2F;  aa_bb 会生成 AaBb 的驼峰命名的结构体</span><br><span class="line">    repeated person Per &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.进入 Demo 工程的 example 目录，使用 protoc 编译 person.proto</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ protoc --go_out=. person.proto</span><br><span class="line"><span class="comment"># 就会生成 person.pb.go 文件</span></span><br></pre></td></tr></table></figure>
<p>4.在 golang 工程中使用 protobuf 进行序列化与反序列化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;protocDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为 AllPerson 填充数据</span></span><br><span class="line">	p1 := example.Person&#123;</span><br><span class="line">		Id:*proto.Int32(<span class="number">1</span>),</span><br><span class="line">		Name:*proto.String(<span class="string">&quot;xieyanke&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p2 := example.Person&#123;</span><br><span class="line">		Id:<span class="number">2</span>,</span><br><span class="line">		Name:<span class="string">&quot;gopher&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	all_p := example.AllPerson&#123;</span><br><span class="line">		Per:[]*example.Person&#123;&amp;p1, &amp;p2&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对数据进行序列化</span></span><br><span class="line">	data, err := proto.Marshal(&amp;all_p)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Mashal data error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">println</span>(data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对已经序列化的数据进行反序列化</span></span><br><span class="line">	<span class="keyword">var</span> target example.AllPerson</span><br><span class="line">	err = proto.Unmarshal(data, &amp;target)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;UnMashal data error:&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(target.Per[<span class="number">0</span>].Name) <span class="comment">// 打印第一个 person Name 的值进行反序列化验证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>console 输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[26&#x2F;32]0xc4200140e0</span><br><span class="line">xieyanke</span><br></pre></td></tr></table></figure>

<p>参考链接：<br><a target="_blank" rel="noopener" href="https://github.com/google/protobuf">https://github.com/google/protobuf</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">关于Token使用方法和价值的商业指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-04 13:54:31" itemprop="dateCreated datePublished" datetime="2018-03-04T13:54:31+08:00">2018-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-02 18:16:50" itemprop="dateModified" datetime="2020-11-02T18:16:50+08:00">2020-11-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>原文: <a target="_blank" rel="noopener" href="http://startupmanagement.org/2017/06/10/tokenomics-a-business-guide-to-token-usage-utility-and-value/">http://startupmanagement.org/2017/06/10/tokenomics-a-business-guide-to-token-usage-utility-and-value/</a></p>
<hr>
<p>关于加密货币代币的关注和材料非常多，但它们还没有一个主流定义。在区块链的技术领域，加密货币的概念很好理解。它代表了一种可编程的货币单位，它被固定在区块链上，是特定软件应用环境中智能合约逻辑的一部分。 但在非技术领域，是什么？</p>
<p>Token 只是私人发行货币的另一个术语。传统上，主权国家政府发行货币并设定其条款和治理；实质上是指导我们的经济如何与金钱作为价值的交换媒介。通过区块链，我们现在可以以数字货币形式发行自己的货币，将其作为加密货币的新型组织，他们正在为其运营设置自己的条款和规则。本质上，创造新的自我可持续的小型经济体。</p>
<p>政府的权限现在掌握在许多人手中。</p>
<p>在商业领域，我们可以将 Token 定义为：</p>
<blockquote>
<p>一个组织为了自治其商业模式而创建的价值单位，并赋予其用户与其产品互动的权力，同时促进向所有利益相关者分配和分享奖励和利益。</p>
</blockquote>
<p>Token 模型的致命弱点是如何将它们与商业模型进行交互。然而，多数关注点都集中于设计ICO来优化加密经济学(cryptoconomics)，即，根据给定的销售和所有权结构，这个术语描述了 Token 分布的机制和具体情况。</p>
<p>展望未来，Token 使用方法将比其潜在的加密经济学(cryptoconomics)设计重要得多。正如此文指出的那样，<a target="_blank" rel="noopener" href="https://blog.gdax.com/the-perfect-token-sale-structure-63c169789491">没有完美的Token销售结构</a>。您可以精确地设计一个ICO，让它正确地启动起来，但是，长期来看，您商业模式需要是可行的。</p>
<p>在2015年初，我在<a target="_blank" rel="noopener" href="http://startupmanagement.org/2015/02/04/an-operational-framework-for-decentralized-autonomous-organizations/">分布式自治组织运营框架</a>的一文中，解释了 Token 的用法，并且我总结了一些使用模型，包括现在正在使用的 <em>权利，奖励和工作</em> 模型。 我写的大部分内容今天适用，尤其是这部分：</p>
<blockquote>
<p>“DAO的主要目标是创造价值，为了实现这一目标，需要在用户行为与对组织整体价值的影响之间建立特定联系。”</p>
<p>“没有价值链接将是浪费，最终导致失败。新的DAO就像一个初创公司。它需要产品与市场相契合，实现商业模式以及服务（很多）用户/客户。”</p>
</blockquote>
<p>Token 的<em>角色</em>成为<em>权力</em>模型的首要因素。Token 是多用途的工具，我们开始更加清晰地看到 Token 如何应用。</p>
<p>在分析了数十个过去和即将到来的ICO后，我对Token的作用，特征和目的进行了以下全面的分类。 这将有助于未来和现有的ICO公司进行磨合，并将精力集中到未来成功的重要因素上。</p>
<p>我建议的框架有3个用于Token实用程序的原则：</p>
<h5 id="角色-特征-目的"><a href="#角色-特征-目的" class="headerlink" title="角色 - 特征 - 目的"></a>角色 - 特征 - 目的</h5><p><img src="/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/1.png"></p>
<p>每个角色都有一个关键的目的，如下图所示。</p>
<p><img src="/2018/03/04/%E5%85%B3%E4%BA%8EToken%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BB%B7%E5%80%BC%E7%9A%84%E5%95%86%E4%B8%9A%E6%8C%87%E5%8D%97/2.png"></p>
<h5 id="权利"><a href="#权利" class="headerlink" title="权利"></a>权利</h5><p>拥有Token可赋予产品使用权，治理，贡献，投票权，市场访问权。在一些案例中，Token 可以准许赋予真实的所有权，例如，Numerai，DigixDAO，FirstBlood和Tezos。</p>
<p>价值交换<br>Token也是特定市场或应用的价值交换的原子单位，在买卖双方之间创造交易经济。这包括允许用户获得价值，并将其花费在生态系统内部的服务和功能上。他们可以通过积极工作（实际工作和行动）或被动工作（例如共享数据）来赚取收入。这种内部经济的创造可以说是最重要的结果之一，而且必须持续一段时间。例如，Steemit，Kik，Tezos和Augur。</p>
<h5 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h5><p>就像支付高速公路的费用一样，Token 可以用于区块链基础设施或使用产品的按次付费。这也确保了用户在游戏中拥有皮肤。它可以包括运行智能合约以执行特定功能，支付保证金或以交易费用或其他计量指标的形式使用费。例如，Gnosis，Augur，Melonport，Tezos，Dfinity，Ethereum和Bitcoin。</p>
<h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>Token还可以用作杠杆来丰富用户体验，包括加入网络或与用户连接等基本操作。也可以作为奖励，例如作为开始使用或加入的汇报。例如，Dfinity，Steemit，Civic和Brave。</p>
<h5 id="货币"><a href="#货币" class="headerlink" title="货币"></a>货币</h5><p>Token是一种非常有效的支付方式和交易引擎。这是在这些封闭环境中实现无摩擦事务的关键。这是第一次，公司可以成为他们自己的支付处理器，而无需繁琐且昂贵的传统财务结算选项。在特定市场内，Token为端对端交易无障碍的运行提供了保障。</p>
<h5 id="收入"><a href="#收入" class="headerlink" title="收入"></a>收入</h5><p>基于区块链模型，由此而产生的增值部分被公平地再分配。包括利润分享，利益分配，其他利益（例如通货膨胀），预计与所有利益相关者分享利益。</p>
<h5 id="评估Token效用"><a href="#评估Token效用" class="headerlink" title="评估Token效用"></a>评估Token效用</h5><p>在评估一个给定的Token组织时，与Token角色相关的勾选框，能够勾选的项越多则越好。Token的作用就像钉入商业模式的钉子一样。你不仅需要一个结实的地方，而且要保证可持续性。</p>
<p>这正式企业家创造力一直在闪耀的地方，因为他们可以发明创造了许多Token可以使用的方法，像橡胶满足公路的发展一样。这是令人兴奋的创新。</p>
<p>如果Token用法不明确，没有很好的解释，那么该模型就存在问题。</p>
<p>我不确定应用程序Token与协议Token是否是Token分类的正确方法。目前还犹未可知。</p>
<p>这里提出了一组建议的问题。如果你是一个以ICO为基础的组织，给每一个肯定回答1分，总计最多20分：</p>
<ol>
<li>Token是否与产品使用情况相关联，即它是否允许用户对其进行独占访问，或为产品提供交互权限？</li>
<li>Token是否授予治理行为，如对共识相关或其他决策因素进行投票？</li>
<li>Token是否使用户能够为正在构建的网络或市场提供增值操作？</li>
<li>Token是否授予排序的所有权，无论它是真实的还是代指的？</li>
<li>Token是否会根据用户的行为（活跃工作）产生可获利的奖励？</li>
<li>Token是否授予用户基于共享或公开某些有关它们的数据（被动工作）的价值？</li>
<li>是购买某种商业模式的一部分？</li>
<li>是卖东西的商业模式的一部分？</li>
<li>用户可以创建新的产品或服务吗？</li>
<li>运行智能合同或资助预言机需要的Token吗？ （预言机是智能合约可以使用的信息或数据来源）</li>
<li>是否需要Token作为安全存款以确保区块链操作的某些方面？</li>
<li>Token（或其衍生物，如稳定的硬币或气体单位）是否用于支付某些用途？</li>
<li>加入网络或其他相关实体需要Token吗？</li>
<li>Token是否启用用户之间的真实连接？</li>
<li>作为鼓励产品试用或使用的动机，是否以折扣形式提供或提供Token？</li>
<li>Token是您的主要付款单位，基本上是作为内部货币运作的吗？</li>
<li>Token（或其衍生产品）是所有内部交易的主要会计单位吗？</li>
<li>您的区块链是否自动向代币持有者分配利润？</li>
<li>您的区块链是否会自动为代币持有者分配其他好处？</li>
<li>内置货币通胀情况下，用户是否有相关的好处？</li>
</ol>
<p>谨记：基于上述题目，即使公司取得了高分，仍然需要彻底的执行它。对于成功而言，这份清单是必要条件。</p>
<p>我们鼓励所有基于ICO的公司审查其Token使用情况。他们可以检查的使用场景越多，其Token-to-Market契合度则可能越高。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" class="post-title-link" itemprop="url">Raft论文翻译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-03-04 00:06:57" itemprop="dateCreated datePublished" datetime="2018-03-04T00:06:57+08:00">2018-03-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-09-14 13:56:00" itemprop="dateModified" datetime="2023-09-14T13:56:00+08:00">2023-09-14</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Raft 算法是可以用来替代 Paxos 算法的分布式一致性算法，而且 raft 算法比 Paxos 算法更易懂且更容易实现。本篇博客为著名的 RAFT 一致性算法论文的中文翻译，论文名为《<a target="_blank" rel="noopener" href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf">In search of an Understandable Consensus Algorithm (Extended Version)</a>》(寻找一种易于理解的一致性算法)。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Raft 是用来管理复制日志（replicated log）的一致性协议。它跟 multi-Paxos 作用相同，效率也相当，但是它的组织结构跟 Paxos 不同。这使得 Raft 比 Paxos 更容易理解并且更容易在工程实践中实现。为了使 Raft 协议更易懂，Raft将一致性的关键元素分开，如 leader 选举、日志复制和安全性，并且它实施更强的一致性以减少必须考虑的状态的数量。用户研究的结果表明，Raft 比 Paxos 更容易学习。 Raft 还包括一个用于变更集群成员的新机制，它使用重叠的大多数（overlapping majorities）来保证安全性。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>一致性算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。 正因为如此，一致性算法在建立可靠的大规模软件系统方面发挥了关键作用。 在过去十年中，Paxos [15,16] 主导了关于一致性算法的讨论：大多数一致性的实现都是基于 Paxos 或受其影响，Paxos 已成为用于教授学生一致性相关知识的主要工具。</p>
<p>不幸的是，Paxos 实在是太难以理解，尽管许多人一直在努力尝试使其更易懂。 此外，其架构需要复杂的改变来支持实际系统。 结果是，系统开发者和学生都在与 Paxos 斗争。</p>
<p>在我们自己与 Paxos 斗争之后，我们开始着手寻找一个新的一致性算法，可以为系统开发和教学提供更好的基础。 我们的方法是不寻常的，因为我们的主要目标是可理解性：我们可以为实际系统定义一个一致性算法，并以比 Paxos 更容易学习的方式描述它吗？在该算法的设计过程中，重要的不仅是如何让该算法起作用，还有清晰地知道该算法为什么会起作用。</p>
<p>这项工作的结果是一个称为 Raft 的一致性算法。 在设计 Raft 时，我们使用了特定的技术来提高可理解性，包括分解（Raft 分离 leader 选举，日志复制和安全）和状态空间减少（相对于 Paxos ，Raft 减少了不确定性程度和服务器之间彼此不一致的方式 ）。 一项针对两个大学的 43 名学生的用户研究表明，Raft 比 Paxos 更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答关于 Raft 的问题。</p>
<p>Raft 在许多方面类似于现有的一致性算法（尤其是 <a target="_blank" rel="noopener" href="http://www.pmg.csail.mit.edu/papers/vr.pdf">Oki 和 Liskov 的 Viewstamped Replication [29,22]</a>），但它有几个新特性：</p>
<ul>
<li>Strong leader：在 Raft 中，日志条目（log entries）只从 leader 流向其他服务器。 这简化了复制日志的管理，使得 raft 更容易理解。</li>
<li>Leader 选举：Raft 使用随机计时器进行 leader 选举。这只需在任何一致性算法都需要的心跳（heartbeats）上增加少量机制，同时能够简单快速地解决冲突。</li>
<li>成员变更：Raft 使用了一种新的联合一致性方法，其中两个不同配置的大多数在过渡期间重叠。 这允许集群在配置更改期间继续正常运行。</li>
</ul>
<p>我们认为，Raft 优于 Paxos 和其他一致性算法，不仅在教学方面，在工程实现方面也是。 它比其他算法更简单且更易于理解; 它被描述得十分详细足以满足实际系统的需要; 它有多个开源实现，并被多家公司使用; 它的安全性已被正式规定和验证; 它的效率与其他算法相当。</p>
<p>本文的剩余部分介绍了复制状态机问题（第 2 节），讨论了 Paxos 的优点和缺点（第3节），描述了我们实现易理解性的方法（第 4 节），提出了Raft一致性算法（第 5-8 节），评估Raft（第 9 节），并讨论了相关工作（第 10 节）。</p>
<h3 id="复制状态机（Replicated-state-machines）"><a href="#复制状态机（Replicated-state-machines）" class="headerlink" title="复制状态机（Replicated state machines）"></a>复制状态机（Replicated state machines）</h3><p>一致性算法是在<a target="_blank" rel="noopener" href="https://www.cs.cornell.edu/fbs/publications/SMSurvey.pdf">复制状态机[37]</a>的背景下产生的。 在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器宕机，也可以继续运行。</p>
<p>复制状态机用于解决分布式系统中的各种容错问题。 例如，具有单个 leader 的大规模系统，如 GFS [8]，HDFS [38] 和 RAMCloud [33] ，通常使用单独的复制状态机来进行 leader 选举和存储 leader 崩溃后重新选举需要的配置信息。Chubby [2] 和 ZooKeeper [11] 都是复制状态机。</p>
<p>复制状态机通常使用复制日志实现，如图1所示。每个服务器存储一个包含一系列命令的日志，其状态机按顺序执行日志中的命令。 每个日志中命令都相同并且顺序也一样，因此每个状态机处理相同的命令序列。 这样就能得到相同的状态和相同的输出序列。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/1.png"><br>图1</p>
<p>一致性算法的工作就是保证复制日志的一致性。 每台服务器上的一致性模块接收来自客户端的命令，并将它们添加到其日志中。 它与其他服务器上的一致性模块通信，以确保每个日志最终以相同的顺序包含相同的命令，即使有一些服务器失败。 一旦命令被正确复制，每个服务器上的状态机按日志顺序处理它们，并将输出返回给客户端。 这样就形成了高可用的复制状态机。</p>
<p>实际系统中的一致性算法通常具有以下属性：</p>
<ul>
<li><p>它们确保在所有非拜占庭条件下（包括网络延迟，分区和数据包丢失，重复和乱序）的安全性（不会返回不正确的结果）。</p>
</li>
<li><p>只要任何大多数（过半）服务器都可以运行，并且可以相互通信和与客户通信，一致性算法就可用。 因此，五台服务器的典型集群可以容忍任何两台服务器的故障。 假设服务器突然宕机; 它们可以稍后从状态恢复并重新加入群集。</p>
</li>
<li><p>它们不依赖于时序来确保日志的一致性：错误的时钟和极端消息延迟可能在最坏的情况下导致可用性问题。</p>
</li>
<li><p>在通常情况下，只要集群的大部分（过半服务器）已经响应了单轮远程过程调用，命令就可以完成; 少数（一半以下）慢服务器不需要影响整个系统性能。</p>
</li>
</ul>
<h3 id="Paxos-存在的问题"><a href="#Paxos-存在的问题" class="headerlink" title="Paxos 存在的问题"></a>Paxos 存在的问题</h3><p>在过去十年里，Leslie Lamport 的 Paxos 协议[15]几乎成为一致性的同义词：它是课堂上教授最多的一致性协议，并且大多数一致性的实现也以它为起点。 Paxos 首先定义了能够在单个决策（例如单个复制日志条目）上达成一致的协议。 我们将这个子集称为 single-decree Paxos。 然后 Paxos 组合该协议的多个实例以促进一系列决策，例如日志（multi-Paxos）。 Paxos能够确保安全性和活性，并且支持集群成员的变更。它的正确性已被证明，并且在正常情况下是高效的。</p>
<p>不幸的是，Paxos 有两个显著的缺点。 第一个缺点是 Paxos 非常难以理解。 Paxos 的描述晦涩难懂，臭名昭著（译者注：《The Part-time Parliament》比较晦涩难懂，但是《Paxos Made Simple》就比较容易理解）; 很少有人成功地理解它，即使能理解也必须付出巨大的努力。 因此，已有几个尝试以更简单的方式来描述 Paxos [16,20,21] 。 这些描述集中在 single-degree Paxos ，但它们仍然具有挑战性。 在对 NSDI 2012 参会者的非正式调查中，我们发现很少有人喜欢 Paxos ，即使是经验丰富的研究人员。 我们自己也跟 Paxos 进行了艰苦的斗争; 我们也无法完全理解整个协议，直到阅读了几个更简单的描述和自己设计替代 Paxos 的协议，整个过程花了将近一年。</p>
<p>Paxos 晦涩难懂的原因是作者选择了single-degree Paxos作为基础。Single-decree Paxos 分成两个阶段，这两个阶段没有简单直观的说明，并且不能被单独理解。因此，很难理解为什么该算法能起作用。Multi-Paxos 的合成规则又增加了许多复杂性。我们相信，对多个决定（日志而不是单个日志条目）达成一致的总体问题可以用其他更直接和更明显的方式进行分解。</p>
<p>Paxos的第二个问题是它不能为构建实际的实现提供良好的基础。 一个原因是没有针对 multi-Paxos 的广泛同意的算法。 Lamport的描述主要是关于 single-decree Paxos; 他描述了 multi-Paxos 的可能方法，但缺少许多细节。 已经有几个尝试来具体化和优化 Paxos ，例如[26]，[39]和[13]，但这些彼此各不相同并且跟 Lamport 描述的也不同。 像Chubby [4] 这样的系统已经实现了类 Paxos（Paxos-like）算法，但大多数情况下，它们的细节并没有公布。</p>
<p>此外，Paxos 的架构对于构建实际系统来说是一个糟糕的设计，这是 single-decree 分解的另一个结果。 例如，独立地选择日志条目集合，然后再将它们合并到顺序日志中几乎没有任何好处，这只会增加复杂性。 围绕日志设计系统是更简单和有效的方法，新日志条目按照约束顺序地添加到日志中。 Paxos 的做法适用于只需要做一次决策的情况，如果需要做一系列决策，更简单和快速的方法是先选择一个 leader ，然后让该 leader 协调这些决策。</p>
<p>因此，实际的系统跟 Paxos 相差很大。几乎所有的实现都是从 Paxos 开始，然后发现很多实现上的难题，接着就开发了一种和 Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos 本身晦涩难懂使得该问题更加严重。Paxos 的公式可能可以很好地证明它的正确性，但是现实的系统和 Paxos 差别是如此之大，以至于这些证明并没有什么太大的价值。下面来自 Chubby 作者的评论非常典型：</p>
<blockquote>
<p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统往往建立在一个还未被证明的协议之上。</p>
</blockquote>
<p>由于以上问题，我们得出的结论是 Paxos 算法没有为系统实践和教学提供一个良好的基础。考虑到一致性问题在大规模软件系统中的重要性，我们决定尝试设计一个能够替代 Paxos 并且具有更好特性的一致性算法。Raft算法就是这次实验的结果。</p>
<h3 id="为可理解性而设计"><a href="#为可理解性而设计" class="headerlink" title="为可理解性而设计"></a>为可理解性而设计</h3><p>在设计 Raft 算法过程中我们有几个目标：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在典型的应用条件下是可用的；并且在正常情况下是高效的。但是我们最重要的目标也是最大的挑战是可理解性。它必须保证能够被大多数人容易地理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行扩展。</p>
<p>在设计 Raft 算法的时候，很多情况下我们需要在多个备选方案中进行选择。在这种情况下，我们基于可理解性来评估备选方案：解释各个备选方案的难道有多大（例如，Raft 的状态空间有多复杂，是否有微妙的含义）？对于一个读者而言，完全理解这个方案和含义是否容易？</p>
<p>我们意识到这样的分析具有高度的主观性；但是我们使用了两种通用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成 <strong>leader 选举，日志复制，安全性和成员变更</strong>几个部分。</p>
<p>我们使用的第二个方法是通过减少状态的数量来简化状态空间，使得系统更加连贯并且尽可能消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了使日志之间不一致的方式。尽管在大多数情况下我们都试图去消除不确定性，但是在某些情况下不确定性可以提高可理解性。特别是，随机化方法虽然引入了不确定性，但是他们往往能够通过使用相近的方法处理可能的选择来减少状态空间。我们使用随机化来简化 Raft 中的 leader 选举算法。</p>
<h3 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h3><p>Raft 是一种用来管理第 2 节中描述的复制日志的算法。图 2 是该算法的浓缩，可用作参考，图 3 列举了该算法的一些关键特性。图中的这些内容将在剩下的章节中逐一介绍。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/2.png"><br>图2</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/3.png"><br>图3</p>
<p><strong>状态</strong> ：</p>
<p>在所有服务器上持久存在的：（在响应远程过程调用 RPC 之前稳定存储的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>currentTerm</td>
<td>服务器最后知道的任期号（从0开始递增）</td>
</tr>
<tr>
<td>votedFor</td>
<td>在当前任期内收到选票的 Candidate  id（如果没有就为 null）</td>
</tr>
<tr>
<td>log[]</td>
<td>日志条目；每个条目包含状态机的要执行命令和从 Leader 处收到时的任期号</td>
</tr>
</tbody></table>
<p>在所有服务器上不稳定存在的：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>commitIndex</td>
<td>已知的被提交的最大日志条目的索引值（从0开始递增）</td>
</tr>
<tr>
<td>lastApplied</td>
<td>被状态机执行的最大日志条目的索引值（从0开始递增）</td>
</tr>
</tbody></table>
<p>在 Leader 服务器上不稳定存在的：（在选举之后初始化的）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，记录需要发给它的下一个日志条目的索引（初始化为 Leader 上一条日志的索引值+1）</td>
</tr>
<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，记录已经复制到该服务器的日志的最高索引值（从0开始递增）</td>
</tr>
</tbody></table>
<p>表-2-i</p>
<p><strong>附加日志远程过程调用 （AppendEntries RPC）</strong></p>
<p>由 Leader 来调用复制日志（5.3节）；也会用作heartbeat。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Leader 的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>Leader 的 id，为了其他服务器能重定向到客户端</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>最新日志之前的日志的索引值</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>最新日志之前的日志的 Leader 任期号</td>
</tr>
<tr>
<td>entries[]</td>
<td>将要存储的日志条目（表示 heartbeat 时为空，有时会为了效率发送超过一条）</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>Leader 提交的日志条目索引值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，用于 Leader 更新自己的任期号</td>
</tr>
<tr>
<td>success</td>
<td>如果其它服务器包含能够匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td>
</tr>
</tbody></table>
<p><strong>接受者需要实现：</strong></p>
<ol>
<li>如果 term &lt; currentTerm返回 false（5.1节）</li>
<li>如果在prevLogIndex处的日志的任期号与prevLogTerm不匹配时，返回 false（5.3节）</li>
<li>如果一条已经存在的日志与新的冲突（index 相同但是任期号 term 不同），则删除已经存在的日志和它之后所有的日志（5.3节）</li>
<li>添加任何在已有的日志中不存在的条目</li>
<li>如果leaderCommit &gt; commitIndex，将commitIndex设置为leaderCommit和最新日志条目索引号中较小的一个</li>
</ol>
<p>表-2-ii</p>
<p><strong>投票请求 RPC（RequestVote RPC</strong>）</p>
<p>由 Candidate 发起收集选票（5.2节）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Candidate 的任期号</td>
</tr>
<tr>
<td>candidateId</td>
<td>请求投票的 Candidate  id</td>
</tr>
<tr>
<td>lastLogIndex</td>
<td>Candidate 最新日志条目的索引值</td>
</tr>
<tr>
<td>lastLogTerm</td>
<td>Candidate 最新日志条目对应的任期号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，用于 Candidate 更新自己的任期号</td>
</tr>
<tr>
<td>voteGranted</td>
<td>如果 Candidate 收到选票为 true</td>
</tr>
</tbody></table>
<p><strong>接受者需要实现：</strong></p>
<ol>
<li>如果term &lt; currentTerm返回 false（5.1节）</li>
<li>如果votedFor为空或者与candidateId相同，并且 Candidate 的日志和自己的日志一样新，则给该 Candidate 投票（5.2节 和 5.4节）</li>
</ol>
<p>表-2-iii</p>
<p><strong>服务器需要遵守的规则：</strong></p>
<ul>
<li><p><strong>All Server：</strong></p>
<ul>
<li>如果commitIndex &gt; lastApplied，lastApplied自增，将log[lastApplied]应用到状态机（5.3节）</li>
<li>如果 RPC 的请求或者响应中包含一个 term T 大于 currentTerm，则currentTerm赋值为 T，并切换状态为 Follower （Follower）（5.1节）</li>
</ul>
</li>
<li><p><strong>Followers: 5.2节</strong></p>
<ul>
<li>响应来自 Candidate 和 Leader 的 RPC</li>
<li>如果在超过选取 Leader 时间之前没有收到来自当前 Leader 的AppendEntries RPC或者没有收到 Candidate 的投票请求，则自己转换状态为 Candidate </li>
</ul>
</li>
<li><p><strong>Candidate：5.2节</strong></p>
<ul>
<li>转变为选举人之后开始选举：<ul>
<li>currentTerm自增</li>
<li>给自己投票</li>
<li>重置选举计时器</li>
<li>向其他服务器发送RequestVote RPC</li>
</ul>
</li>
<li>如果收到了来自大多数服务器的投票：成为 Leader </li>
<li>如果收到了来自新 Leader 的AppendEntries RPC（heartbeat）：转换状态为 Follower </li>
<li>如果选举超时：开始新一轮的选举</li>
</ul>
</li>
<li><p><strong>Leader：</strong></p>
<ul>
<li>一旦成为 Leader ：向其他所有服务器发送空的AppendEntries RPC（heartbeat）;在空闲时间重复发送以防止选举超时（5.2节）</li>
<li>如果收到来自客户端的请求：向本地日志增加条目，在该条目应用到状态机后响应客户端（5.3节）</li>
<li>对于一个 Follower 来说，如果上一次收到的日志索引大于将要收到的日志索引（nextIndex）：通过AppendEntries RPC将 nextIndex 之后的所有日志条目发送出去</li>
<li>如果发送成功：将该 Follower 的 nextIndex和matchIndex更新</li>
<li>如果由于日志不一致导致AppendEntries RPC失败：nextIndex递减并且重新发送（5.3节）</li>
<li>如果存在一个满足N &gt; commitIndex和matchIndex[i] &gt;= N并且log[N].term == currentTerm的 N，则将commitIndex赋值为 N</li>
</ul>
</li>
</ul>
<p>表-2-iv</p>
<p>表-2：Raft 一致性算法的总结（不包括成员变化 membership changes 和日志压缩 log compaction）</p>
<table>
<thead>
<tr>
<th>性质</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>选举安全原则（Election Safety）</td>
<td>一个任期（term）内最多允许有一个 Leader 被选上（5.2节）</td>
</tr>
<tr>
<td>Leader 只增加原则（Leader Append-Only）</td>
<td>Leader 永远不会覆盖或者删除自己的日志，它只会增加条目</td>
</tr>
<tr>
<td>日志匹配原则（Log Matching）</td>
<td>如果两个日志在相同的索引位置上的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间的条目完全相同（5.3 节）</td>
</tr>
<tr>
<td>Leader 完全原则（Leader Completeness)</td>
<td>如果一个日志条目在一个给定任期内被提交，那么这个条目一定会出现在所有任期号更大的 Leader 中</td>
</tr>
<tr>
<td>状态机安全原则（State Machine Safety）</td>
<td>如果一个服务器已经将给定索引位置的日志条目应用到状态机中，则所有其他服务器不会在该索引位置应用不同的条目（5.4.3节）</td>
</tr>
<tr>
<td>表-3：Raft 算法保证这些特性任何时刻都成立</td>
<td></td>
</tr>
</tbody></table>
<p>Raft 通过首先选举一个 distinguished leader，然后让它全权负责管理复制日志来实现一致性。Leader 从客户端接收日志条目，把日志条目复制到其他服务器上，并且在保证安全性的时候通知其他服务器将日志条目应用到他们的状态机中。拥有一个 leader 大大简化了对复制日志的管理。例如， Leader 可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都是从 leader 流向其他服务器。leader 可能宕机，也可能和其他服务器断开连接，这时一个新的 leader 会被选举出来。</p>
<p>通过选举一个 leader 的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题将会在接下来的子章节中进行讨论：</p>
<ul>
<li>Leader 选举：当前的 leader 宕机时，一个新的 leader 必须被选举出来。（章节 5.2）</li>
<li>日志复制：Leader 必须从客户端接收日志条目然后复制到集群中的其他节点，并且强制要求其他节点的日志和自己的保持一致。</li>
<li>安全性：Raft 中安全性的关键是图 3 中状态机的安全性：如果有任何的服务器节点已经应用了一个特定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一条不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；该解决方案在选举机制（5.2 节）上增加了额外的限制。</li>
</ul>
<p>在展示一致性算法之后，本章节将讨论可用性的一些问题以及时序在系统中的作用。</p>
<h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这样的系统可以容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：leader、follower 或者 candidate 。在正常情况下，集群中只有一个 leader 并且其他的节点全部都是 follower 。Follower 都是被动的：他们不会发送任何请求，只是简单的响应来自 leader 和 candidate 的请求。Leader 处理所有的客户端请求（如果一个客户端和 follower 通信，follower 会将请求重定向给 leader）。第三种状态，candidate ，是用来选举一个新的 leader（章节 5.2）。图 4 展示了这些状态和他们之间的转换关系；这些转换关系在接下来会进行讨论。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/4.png"><br>图4</p>
<p>Raft 把时间分割成任意长度的任期（term），如图 5 所示。任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个 candidate 尝试成为 leader 。如果一个 candidate 赢得选举，然后他就在该任期剩下的时间里充当 leader 。在某些情况下，一次选举无法选出 leader 。在这种情况下，这一任期会以没有 leader 结束；一个新的任期（包含一次新的选举）会很快重新开始。Raft 保证了在任意一个任期内，最多只有一个 leader 。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/5.png"><br>图5</p>
<p>不同的服务器节点观察到的任期转换的次数可能不同，在某些情况下，一个服务器节点可能没有看到 leader 选举过程或者甚至整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这使得服务器节点可以发现一些过期的信息比如过时的 leader 。每一个服务器节点存储一个当前任期号，该编号随着时间单调递增。服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他的小，该服务器会将自己的任期号更新为较大的那个值。如果一个 candidate 或者 leader 发现自己的任期号过期了，它会立即回到 follower 状态。如果一个节点接收到一个包含过期的任期号的请求，它会直接拒绝这个请求。</p>
<p>Raft 算法中服务器节点之间使用 RPC 进行通信，并且基本的一致性算法只需要两种类型的 RPC。请求投票（RequestVote） RPC 由 candidate 在选举期间发起（章节 5.2），追加条目（AppendEntries）RPC 由 leader 发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPC 来获得最佳的性能。</p>
<h3 id="5-2-Leader-选举"><a href="#5-2-Leader-选举" class="headerlink" title="5.2 Leader 选举"></a>5.2 Leader 选举</h3><p>Raft 使用一种心跳机制来触发 leader 选举。当服务器程序启动时，他们都是 follower 。一个服务器节点只要能从 leader 或 candidate 处接收到有效的 RPC 就一直保持 follower 状态。Leader 周期性地向所有 follower 发送心跳（不包含日志条目的 AppendEntries RPC）来维持自己的地位。如果一个 follower 在一段选举超时时间内没有接收到任何消息，它就假设系统中没有可用的 leader ，然后开始进行选举以选出新的leader。</p>
<p>要开始一次选举过程，follower 先增加自己的当前任期号并且转换到 candidate 状态。然后投票给自己并且并行地向集群中的其他服务器节点发送 RequestVote RPC（让其他服务器节点投票给它）。Candidate 会一直保持当前状态直到以下三件事情之一发生：(a) 它自己赢得了这次的选举（收到过半的投票），(b) 其他的服务器节点成为 leader ，(c) 一段时间之后没有任何获胜者。这些结果会在下面的章节里分别讨论。</p>
<p>当一个 candidate 获得集群中过半服务器节点针对同一个任期的投票，它就赢得了这次选举并成为 leader 。对于同一个任期，每个服务器节点只会投给一个 candidate ，按照先来先服务（first-come-first-served）的原则（注意：5.4 节在投票上增加了额外的限制）。要求获得过半投票的规则确保了最多只有一个 candidate 赢得此次选举（图 3 中的选举安全性）。一旦 candidate 赢得选举，就立即成为 leader 。然后它会向其他的服务器节点发送心跳消息来确定自己的地位并阻止新的选举。</p>
<p>在等待投票期间，candidate 可能会收到另一个声称自己是 leader 的服务器节点发来的 AppendEntries RPC 。如果这个 leader 的任期号（包含在RPC中）不小于 candidate 当前的任期号，那么 candidate 会承认该 leader 的合法地位并回到 follower 状态。 如果 RPC 中的任期号比自己的小，那么 candidate 就会拒绝这次的 RPC 并且继续保持 candidate 状态。</p>
<p>第三种可能的结果是 candidate 既没有赢得选举也没有输：如果有多个 follower 同时成为 candidate ，那么选票可能会被瓜分以至于没有 candidate 赢得过半的投票。当这种情况发生时，每一个 Candidate 都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，如果没有其他机制的话，该情况可能会无限重复。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少发生选票瓜分的情况，就算发生也能很快地解决。为了阻止选票一开始就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后该服务器赢得选举并在其他服务器超时之前发送心跳。同样的机制被用来解决选票被瓜分的情况。每个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后一直等待直到选举超时；这样减小了在新的选举中再次发生选票瓜分情况的可能性。9.3 节展示了该方案能够快速地选出一个 leader 。</p>
<p>选举的例子可以很好地展示可理解性是如何指导我们选择设计方案的。起初我们打算使用一种等级系统（ranking system）：每一个 candidate 都被赋予一个唯一的等级（rank），等级用来在竞争的 candidate 之间进行选择。如果一个 candidate 发现另一个 candidate 拥有更高的等级，它就会回到 follower 状态，这样高等级的 candidate 能够更加容易地赢得下一次选举。但是我们发现这种方法在可用性方面会有一下小问题。我们对该算法进行了多次调整，但是每次调整之后都会有新的小问题。最终我们认为随机重试的方法更加显然且易于理解。</p>
<h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>Leader 一旦被选举出来，就开始为客户端请求提供服务。客户端的每一个请求都包含一条将被复制状态机执行的指令。Leader 把该指令作为一个新的条目追加到日志中去，然后并行的发起 AppendEntries RPC 给其他的服务器，让它们复制该条目。当该条目被安全地复制（下面会介绍），leader 会应用该条目到它的状态机中（状态机执行该指令）然后把执行的结果返回给客户端。如果 follower 崩溃或者运行缓慢，或者网络丢包， Leader 会不断地重试 AppendEntries RPC（即使已经回复了客户端）直到所有的 follower 最终都存储了所有的日志条目。</p>
<p>日志以图 6 展示的方式组织。每个日志条目存储一条状态机指令和 leader 收到该指令时的任期号。任期号用来检测多个日志副本之间的不一致情况，同时也用来保证图 3 中的某些性质。每个日志条目都有一个整数索引值来表明它在日志中的位置。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/6.png"><br>图6</p>
<p>Leader 决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交的。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。一旦创建该日志条目的 leader 将它复制到过半的服务器上，该日志条目就会被提交（例如在图 6 中的条目 7）。同时，leader 日志中该日志条目之前的所有日志条目也都会被提交，包括由其他 leader 创建的条目。5.4 节讨论在 leader 变更之后应用该规则的一些细节，并且证明了这种提交的规则是安全的。Leader 追踪将会被提交的日志条目的最大索引，未来的所有 AppendEntries RPC 都会包含该索引，这样其他的服务器才能最终知道哪些日志条目需要被提交。Follower 一旦知道某个日志条目已经被提交就会将该日志条目应用到自己的本地状态机中（按照日志的顺序）。</p>
<p>我们设计了 Raft 的日志机制来维持不同服务器之间日志高层次的一致性。这么做不仅简化了系统的行为也使得系统行为更加可预测，同时该机制也是保证安全性的重要组成部分。Raft 维护着以下特性，这些同时也构成了图 3 中的日志匹配特性：</p>
<ul>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>
<li>如果不同日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也都相同。</li>
</ul>
<p>Leader 在特定的任期号内的一个日志索引处最多创建一个日志条目，同时日志条目在日志中的位置也从来不会改变。该点保证了上面的第一条特性。第二个特性是由 AppendEntries RPC 执行一个简单的一致性检查所保证的。在发送 AppendEntries RPC 的时候，leader 会将前一个日志条目的索引位置和任期号包含在里面。如果 follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝该新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足 Log Matching Property（日志匹配特性） 的，然后一致性检查保证了日志扩展时的日志匹配特性。因此，每当 AppendEntries RPC 返回成功时，leader 就知道 follower 的日志一定和自己相同（从第一个日志条目到最新条目）。</p>
<p>正常操作期间，leader 和 follower 的日志保持一致，所以 AppendEntries RPC 的一致性检查从来不会失败。然而，leader 崩溃的情况会使日志处于不一致的状态（老的 leader 可能还没有完全复制它日志里的所有条目）。这种不一致会在一系列的 leader 和 follower 崩溃的情况下加剧。图 7 展示了在什么情况下 follower 的日志可能和新的 leader 的日志不同。Follower 可能缺少一些在新 leader 中有的日志条目，也可能拥有一些新 leader 没有的日志条目，或者同时发生。缺失或多出日志条目的情况可能会涉及到多个任期。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/7.png"><br>图7</p>
<blockquote>
<p>图 7：当一个 leader 成功当选时（最上面那条日志），follower 可能是（a-f）中的任何情况。每一个盒子表示一个日志条目；里面的数字表示任期号。Follower 可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能这样发生，f 对应的服务器在任期 2 的时候是 leader ，追加了一些日志条目到自己的日志中，一条都还没提交（commit）就崩溃了；该服务器很快重启，在任期 3 重新被选为 leader，又追加了一些日志条目到自己的日志中；在这些任期 2 和任期 3 中的日志都还没被提交之前，该服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>
</blockquote>
<p>在 Raft 算法中，leader 通过强制 follower 复制它的日志来解决不一致的问题。这意味着 follower 中跟 leader 冲突的日志条目会被 leader 的日志条目覆盖。5.4 节会证明通过增加一个限制可以保证安全性。</p>
<p>要使得 follower 的日志跟自己一致，leader 必须找到两者达成一致的最大的日志条目（索引最大），删除 follower 日志中从那个点之后的所有日志条目，并且将自己从那个点之后的所有日志条目发送给 follower 。所有的这些操作都发生在对 AppendEntries RPCs 中一致性检查的回复中。Leader 针对每一个 follower 都维护了一个 nextIndex ，表示 leader 要发送给 follower 的下一个日志条目的索引。当选出一个新 leader 时，该 leader 将所有 nextIndex 的值都初始化为自己最后一个日志条目的 index 加1（图 7 中的 11）。如果 follower 的日志和 leader 的不一致，那么下一次 AppendEntries RPC 中的一致性检查就会失败。在被 follower 拒绝之后，leaer 就会减小 nextIndex 值并重试 AppendEntries RPC 。最终 nextIndex 会在某个位置使得 leader 和 follower 的日志达成一致。此时，AppendEntries RPC 就会成功，将 follower 中跟 leader 冲突的日志条目全部删除然后追加 leader 中的日志条目（如果有需要追加的日志条目的话）。一旦 AppendEntries RPC 成功，follower 的日志就和 leader 一致，并且在该任期接下来的时间里保持一致。</p>
<blockquote>
<p>如果想要的话，该协议可以被优化来减少被拒绝的 AppendEntries RPC 的个数。例如，当拒绝一个 AppendEntries RPC 的请求的时候，follower 可以包含冲突条目的任期号和自己存储的那个任期的第一个 index 。借助这些信息，leader 可以跳过那个任期内所有冲突的日志条目来减小 nextIndex；这样就变成每个有冲突日志条目的任期需要一个 AppendEntries RPC 而不是每个条目一次。在实践中，我们认为这种优化是没有必要的，因为失败不经常发生并且也不可能有很多不一致的日志条目。</p>
</blockquote>
<p>通过这种机制，leader 在当权之后就不需要任何特殊的操作来使日志恢复到一致状态。Leader 只需要进行正常的操作，然后日志就能在回复 AppendEntries 一致性检查失败的时候自动趋于一致。Leader 从来不会覆盖或者删除自己的日志条目（图 3 的 Leader Append-Only 属性）。</p>
<p>这样的日志复制机制展示了第 2 节中描述的一致性特性：只要过半的服务器能正常运行，Raft 就能够接受，复制并应用新的日志条目；在正常情况下，新的日志条目可以在一个 RPC 来回中被复制给集群中的过半机器；并且单个运行慢的 follower 不会影响整体的性能。</p>
<h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何进行 leader 选举和日志复制的。然而，到目前为止描述的机制并不能充分地保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目，然后这个 follower 可能会被选举为 leader 并且用新的日志条目覆盖这些日志条目；结果，不同的状态机可能会执行不同的指令序列。</p>
<p>这节通过对 leader 选举增加一个限制来完善 Raft 算法。这一限制保证了对于给定的任意任期号， leader 都包含了之前各个任期所有被提交的日志条目（图 3 中的 Leader Completeness 性质）。有了这一 leader 选举的限制，我们也使得提交规则更加清晰。最后，我们展示了对于 Leader Completeness 性质的简要证明并且说明该性质是如何领导复制状态机执行正确的行为的。</p>
<h3 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h3><p>在任何基于 leader 的一致性算法中，leader 最终都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication[22]，一开始并没有包含所有已经提交的日志条目的服务器也可能被选为 leader 。这种算法包含一些额外的机制来识别丢失的日志条目并将它们传送给新的 leader ，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证新 leader 在当选时就包含了之前所有任期号中已经提交的日志条目，不需要再传送这些日志条目给新 leader 。这意味着日志条目的传送是单向的，只从 leader 到 follower，并且 leader 从不会覆盖本地日志中已经存在的条目。</p>
<p>Raft 使用投票的方式来阻止 candidate 赢得选举除非该 candidate 包含了所有已经提交的日志条目。 Candidate 为了赢得选举必须与集群中的过半节点通信，这意味着至少其中一个服务器节点包含了所有已提交的日志条目。如果 candidate 的日志至少和过半的服务器节点一样新（接下来会精确地定义“新”），那么他一定包含了所有已经提交的日志条目。RequestVote RPC 执行了这样的限制： RPC 中包含了 candidate 的日志信息，如果投票者自己的日志比 candidate 的还新，它会拒绝掉该投票请求。</p>
<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。如果两份日志最后条目的任期号不同，那么任期号大的日志更新。如果两份日志最后条目的任期号相同，那么日志较长的那个更新。</p>
<h3 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h3><p>如同 5.3 节描述的那样，一旦当前任期内的某个日志条目已经存储到过半的服务器节点上，leader 就知道该日志条目已经被提交了。如果某个 leader 在提交某个日志条目之前崩溃了，以后的 leader 会试图完成该日志条目的复制。然而，如果是之前任期内的某个日志条目已经存储到过半的服务器节点上，leader 也无法立即断定该日志条目已经被提交了。图 8 展示了一种情况，一个已经被存储到过半节点上的老日志条目，仍然有可能会被未来的 leader 覆盖掉。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/8.png"><br>图8</p>
<blockquote>
<p>图 8：如图的时间序列展示了为什么 leader 无法判断老的任期号内的日志是否已经被提交。在 (a) 中，S1 是 leader ，部分地复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 中通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，继续复制日志。此时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。但是，在崩溃之前，如果 S1 在自己的任期里复制了日志条目到大多数机器上，如 (e) 中，然后这个条目就会被提交（S5 就不可能选举成功）。 在这种情况下，之前的所有日志也被提交了。</p>
</blockquote>
<p>为了消除图 8 中描述的问题，Raft 永远不会通过计算副本数目的方式来提交之前任期内的日志条目。只有 leader 当前任期内的日志条目才通过计算副本数目的方式来提交；一旦当前任期的某个日志条目以这种方式被提交，那么由于日志匹配特性，之前的所有日志条目也都会被间接地提交。在某些情况下， Leader 可以安全地断定一个老的日志条目已经被提交（例如，如果该条目已经存储到所有服务器上），但是 Raft 为了简化问题使用了一种更加保守的方法。</p>
<p>Raft 会在提交规则上增加额外的复杂性是因为当 leader 复制之前任期内的日志条目时，这些日志条目都保留原来的任期号。在其他的一致性算法中，如果一个新的 leader 要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 的做法使得更加容易推导出（reason about）日志条目，因为他们自始至终都使用同一个任期号。另外，和其他的算法相比，Raft 中的新 leader 只需要发送更少的日志条目（其他算法中必须在它们被提交之前发送更多的冗余日志条目来给它们重新编号）。</p>
<h3 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h3><p>在给出了完整的 Raft 算法之后，我们现在可以更加精确的讨论 Leader 完整性特性（Leader Completeness Prop-erty）（这一讨论基于 9.2 节的安全性证明）。我们假设 Leader 完全性特性是不满足的，然后我们推出矛盾来。假设任期 T 的 leader（leader T）在任期内提交了一个日志条目，但是该日志条目没有被存储到未来某些任期的 leader 中。假设 U 是大于 T 的没有存储该日志条目的最小任期号。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/9.png"><br>图9</p>
<blockquote>
<p>图 9：如果 S1 （任期 T 的 leader）在它的任期里提交了一个新的日志条目，然后 S5 在之后的任期 U 里被选举为 leader ，那么肯定至少会有一个节点，如 S3，既接收了来自 S1 的日志条目，也给 S5 投票了。</p>
</blockquote>
<ol>
<li>U 一定在刚成为 leader 的时候就没有那条被提交的日志条目了（leader 从不会删除或者覆盖任何条目）。</li>
<li>Leader T 复制该日志条目给集群中的过半节点，同时，leader U 从集群中的过半节点赢得了选票。因此，至少有一个节点（投票者）同时接受了来自 leader T 的日志条目和给 leader U 投票了，如图 9。该投票者是产生矛盾的关键。</li>
<li>该投票者必须在给 leader U 投票之前先接受了从 leader T 发来的已经被提交的日志条目；否则它就会拒绝来自 leader T 的 AppendEntries 请求（因为此时它的任期号会比 T 大）。</li>
<li>该投票者在给 leader U 投票时依然保有这该日志条目，因为任何 U 、T 之间的 leader 都包含该日志条目（根据上述的假设），leader 从不会删除条目，并且 follower 只有跟 leader 冲突的时候才会删除条目。</li>
<li>该投票者把自己选票投给 leader U 时，leader U 的日志必须至少和投票者的一样新。这就导致了以下两个矛盾之一。</li>
<li>首先，如果该投票者和 leader U 的最后一个日志条目的任期号相同，那么 leader U 的日志至少和该投票者的一样长，所以 leader U 的日志一定包含该投票者日志中的所有日志条目。这是一个矛盾，因为该投票者包含了该已被提交的日志条目，但是在上述的假设里，leader U 是不包含的。</li>
<li>否则，leader U 的最后一个日志条目的任期号就必须比该投票者的大了。此外，该任期号也比 T 大，因为该投票者的最后一个日志条目的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了 leader U 最后一个日志条目的之前的 leader 一定已经包含了该已被提交的日志条目（根据上述假设，leader U 是第一个不包含该日志条目的 leader）。所以，根据日志匹配特性，leader U 一定也包含该已被提交的日志条目，这里产生了矛盾。</li>
<li>因此，所有比 T 大的任期的 leader 一定都包含了任期 T 中提交的所有日志条目。</li>
<li>日志匹配特性保证了未来的 leader 也会包含被间接提交的日志条目，例如图 8 (d) 中的索引 2。</li>
</ol>
<p>通过 Leader Completeness 特性，我们就能证明图 3 中的状态机安全特性，即如果某个服务器已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的服务器就不会在相同的索引处应用一个不同的日志条目。在一个服务器应用一个日志条目到自己的状态机中时，它的日志和 leader 的日志从开始到该日志条目都相同，并且该日志条目必须被提交。现在考虑如下最小任期号：某服务器在该任期号中某个特定的索引处应用了一个日志条目；日志完整性特性保证拥有更高任期号的 leader 会存储相同的日志条目，所以之后任期里服务器应用该索引处的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p>
<p>最后，Raft 要求服务器按照日志索引顺序应用日志条目。再加上状态机安全特性，这就意味着所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中。</p>
<h3 id="5-5-Follower-和-candidate-崩溃"><a href="#5-5-Follower-和-candidate-崩溃" class="headerlink" title="5.5 Follower 和 candidate 崩溃"></a>5.5 Follower 和 candidate 崩溃</h3><p>到目前为止，我们只关注了 leader 崩溃的情况。Follower 和 candidate 崩溃后的处理方式比 leader 崩溃要简单的多，并且两者的处理方式是相同的。如果 follower 或者 candidate 崩溃了，那么后续发送给他们的 RequestVote 和 AppendEntries RPCs 都会失败。Raft 通过无限的重试来处理这种失败；如果崩溃的机器重启了，那么这些 RPC 就会成功地完成。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在它重启之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样的重试不会造成任何伤害。例如，一个 follower 如果收到 AppendEntries 请求但是它的日志中已经包含了这些日志条目，它就会直接忽略这个新的请求中的这些日志条目。</p>
<h3 id="5-6-定时（timing）和可用性"><a href="#5-6-定时（timing）和可用性" class="headerlink" title="5.6 定时（timing）和可用性"></a>5.6 定时（timing）和可用性</h3><p>Raft 的要求之一就是安全性不能依赖定时：整个系统不能因为某些事件运行得比预期快一点或者慢一点就产生错误的结果。但是，可用性（系统能够及时响应客户端）不可避免的要依赖于定时。例如，当有服务器崩溃时，消息交换的时间就会比正常情况下长，candidate 将不会等待太长的时间来赢得选举；没有一个稳定的 leader ，Raft 将无法工作。</p>
<p>Leader 选举是 Raft 中定时最为关键的方面。 只要整个系统满足下面的时间要求，Raft 就可以选举出并维持一个稳定的 leader：</p>
<blockquote>
<p>广播时间（broadcastTime） &lt;&lt; 选举超时时间（electionTimeout） &lt;&lt; 平均故障间隔时间（MTBF）</p>
</blockquote>
<p>在这个不等式中，广播时间指的是一个服务器并行地发送 RPCs 给集群中所有的其他服务器并接收到响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举超时时间；平均故障间隔时间就是对于一台服务器而言，两次故障间隔时间的平均值。广播时间必须比选举超时时间小一个量级，这样 leader 才能够可靠地发送心跳消息来阻止 follower 开始进入选举状态；再加上随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间需要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定地运行。当 leader 崩溃后，整个系统会有大约选举超时时间不可用；我们希望该情况在整个时间里只占一小部分。</p>
<p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化地保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒之间，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的要求。</p>
<h3 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h3><p>到目前为止，我们都假设集群的配置（参与一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔会改变集群的配置的，例如替换那些宕机的机器或者改变复制程度。尽管可以通过使整个集群下线，更新所有配置，然后重启整个集群的方式来实现，但是在更改期间集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定将配置变更自动化并将其纳入到 Raft 一致性算法中来。</p>
<p>为了使配置变更机制能够安全，在转换的过程中不能够存在任何时间点使得同一个任期里可能选出两个 leader 。不幸的是，任何服务器直接从旧的配置转换到新的配置的方案都是不安全的。一次性自动地转换所有服务器是不可能的，所以在转换期间整个集群可能划分成两个独立的大多数（见图 10）。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/10.png"><br>图10</p>
<blockquote>
<p>图 10：直接从一种配置转到另一种配置是不安全的，因为各个机器会在不同的时候进行转换。在这个例子中，集群从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，同一个任期里两个不同的 leader 会被选出。一个获得旧配置里过半机器的投票，一个获得新配置里过半机器的投票。</p>
</blockquote>
<p>为了保证安全性，配置变更必须采用一种两阶段方法。目前有很多种两阶段的实现。例如，有些系统（比如，[22]）在第一阶段停掉旧的配置所以不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为联合一致（joint consensus）；一旦联合一致已经被提交了，那么系统就切换到新的配置上。联合一致结合了老配置和新配置：</p>
<ul>
<li>日志条目被复制给集群中新、老配置的所有服务器。</li>
<li>新、旧配置的服务器都可以成为 leader 。</li>
<li>达成一致（针对选举和提交）需要分别在两种配置上获得过半的支持。</li>
</ul>
<p>联合一致允许独立的服务器在不妥协安全性的前提下，在不同的时刻进行配置转换过程。此外，联合一致允许集群在配置变更期间依然响应客户端请求。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/11.png"><br>图11</p>
<p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置变更过程。当一个 leader 接收到一个改变配置从 C-old 到 C-new 的请求，它就为联合一致将该配置（图中的 C-old,new）存储为一个日志条目，并以前面描述的方式复制该条目。一旦某个服务器将该新配置日志条目增加到自己的日志中，它就会用该配置来做出未来所有的决策（服务器总是使用它日志中最新的配置，无论该配置日志是否已经被提交）。这就意味着 leader 会使用 C-old,new 的规则来决定 C-old,new 的日志条目是什么时候被提交的。如果 leader 崩溃了，新 leader 可能是在 C-old 配置也可能是在 C-old,new 配置下选出来的，这取决于赢得选举的 candidate 是否已经接收到了 C-old,new 配置。在任何情况下， C-new 在这一时期都不能做出单方面决定。</p>
<p>一旦 C-old,new 被提交，那么 C-old 和 C-new 都不能在没有得到对方认可的情况下做出决定，并且 leader 完整性特性保证了只有拥有 C-old,new 日志条目的服务器才能被选举为 leader 。现在 leader 创建一个描述 C-new 配置的日志条目并复制到集群其他节点就是安全的了。此外，新的配置被服务器收到后就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新配置的服务器就可以被关闭了。如图 11 所示，任何时刻 C-old 和 C-new 都不能单方面做出决定；这保证了安全性。</p>
<p>在关于配置变更还有三个问题需要解决。第一个问题是，新的服务器开始时可能没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，它们需要一段时间来更新来赶上其他服务器，这段它们无法提交新的日志条目。为了避免因此而造成的系统短时间的不可用，Raft 在配置变更前引入了一个额外的阶段，在该阶段，新的服务器以没有投票权身份加入到集群中来（leader 也复制日志给它们，但是考虑过半的时候不用考虑它们）。一旦该新的服务器追赶上了集群中的其他机器，配置变更就可以按上面描述的方式进行。</p>
<p>第二个问题是，集群的 leader 可能不是新配置中的一员。在这种情况下，leader 一旦提交了 C-new 日志条目就会退位（回到 follower 状态）。这意味着有这样的一段时间（leader 提交 C-new 期间），leader 管理着一个不包括自己的集群；它复制着日志但不把自己算在过半里面。Leader 转换发生在 C-new 被提交的时候，因为这是新配置可以独立运转的最早时刻（将总是能够在 C-new 配置下选出新的 Leader ）。在此之前，可能只能从 C-old 中选出 Leader 。</p>
<p>第三个问题是，那些被移除的服务器（不在 C-new 中）可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，它们就会进行新的选举过程。它们会发送带有新任期号的 RequestVote RPCs ，这样会导致当前的 leader 回到 follower 状态。新的 leader 最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致系统可用性很差。</p>
<p>为了防止这种问题，当服务器认为当前 leader 存在时，服务器会忽略RequestVote RPCs 。特别的，当服务器在最小选举超时时间内收到一个 RequestVote RPC，它不会更新任期号或者投票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待最小选举超时时间。相反，这有利于避免被移除的服务器的扰乱：如果 leader 能够发送心跳给集群，那它就不会被更大的任期号废黜。</p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h3><p>Raft 的日志在正常操作中随着包含更多的客户端请求不断地增长，但是在实际的系统中，日志不能无限制地增长。随着日志越来越长，它会占用越来越多的空间，并且需要花更多的时间来回放。如果没有一定的机制来清除日志中积累的过期的信息，最终就会带来可用性问题。</p>
<p>快照技术是日志压缩最简单的方法。在快照技术中，整个当前系统的状态都以快照的形式持久化到稳定的存储中，该时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p>
<p>增量压缩方法，例如日志清理或者日志结构合并树（log-structured merge trees，LSM 树），都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，它们先选择一个积累了大量已经被删除或者被覆盖的对象的数据区域，然后重写该区域还活着的对象，之后释放该区域。和快照技术相比，它们需要大量额外的机制和复杂性，快照技术通过操作整个数据集来简化该问题。状态机可以用和快照技术相同的接口来实现 LSM 树，但是日志清除方法就需要修改 Raft 了。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/12.png"><br>图12</p>
<blockquote>
<p>一台服务器用一个新快照替代了它日志中已经提交了的条目（索引 1 到 5），该快照只存储了当前的状态（变量 x 和 y 的值）。快照的 last included index 和 last included term 被保存来定位日志中条目 6 之前的快照</p>
</blockquote>
<p>图 12 展示了 Raft 中快照的基本思想。每个服务器独立地创建快照，快照只包括自己日志中已经被提交的条目。主要的工作是状态机将自己的状态写入快照中。Raft 快照中也包含了少量的元数据：the last included index 指的是最后一个被快照取代的日志条目的索引值（状态机最后应用的日志条目），the last included term 是该条目的任期号。保留这些元数据是为了支持快照后第一个条目的 AppendEntries 一致性检查，因为该条目需要之前的索引值和任期号。为了支持集群成员变更（第 6 节），快照中也包括日志中最新的配置作为 last included index 。一旦服务器完成写快照，他就可以删除 last included index 之前的所有日志条目，包括之前的快照。</p>
<p>尽管通常服务器都是独立地创建快照，但是 leader 必须偶尔发送快照给一些落后的 Follower 。这通常发生在 leader 已经丢弃了需要发送给 follower 的下一条日志条目的时候。幸运的是这种情况在常规操作中是不可能的：一个与 leader 保持同步的 follower 通常都会有该日志条目。然而一个例外的运行缓慢的 follower 或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让该 follower 更新到最新的状态的方式就是通过网络把快照发送给它。</p>
<p>Leader 使用 InstallSnapshot RPC 来发送快照给太落后的 follower ；见图 13。当 follower 收到带有这种 RPC 的快照时，它必须决定如何处理已经存在的日志条目。通常该快照会包含接收者日志中没有的信息。在这种情况下，follower 丢弃它所有的日志；这些会被该快照所取代，并且可能一些没有提交的条目会和该快照产生冲突。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照之后的条目仍然有用并保留。</p>
<p><img src="/2018/03/04/Raft%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/13.png"><br>图13</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>Leader 的任期</td>
</tr>
<tr>
<td>leaderId</td>
<td>为了 Follower 能重定向到客户端</td>
</tr>
<tr>
<td>lastIncludedIndex</td>
<td>快照中包含的最后日志条目的索引值</td>
</tr>
<tr>
<td>lastIncludedTerm</td>
<td>快照中包含的最后日志条目的任期号</td>
</tr>
<tr>
<td>offset</td>
<td>分块在快照中的偏移量</td>
</tr>
<tr>
<td>data[]</td>
<td>快照块的原始数据</td>
</tr>
<tr>
<td>done</td>
<td>如果是最后一块数据则为 true</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>currentTerm，用于 Leader 更新自己的任期</td>
</tr>
</tbody></table>
<p>接受者需要实现：</p>
<ol>
<li>如果term &lt; currentTerm立刻回复</li>
<li>如果是第一个分块（offset 为 0）则创建新的快照</li>
<li>在指定的偏移量写入数据</li>
<li>如果 done为 false，则回复并继续等待之后的数据</li>
<li>保存快照文件，丢弃所有存在的或者部分有着更小索引号的快照</li>
<li>如果现存的日志拥有相同的最后任期号和索引值，则后面的数据继续保留并且回复</li>
<li>丢弃全部日志</li>
<li>能够使用快照来恢复状态机（并且装载快照中的集群配置）</li>
</ol>
<p>表-13：InstallSnapshot RPC 的总结。为了便于传输，快照都是被分成分块的；每个分块都给了 Follower 生存的信号，所以 Follower 可以重置选举超时计时</p>
<p>这种快照的方式违反了 Raft 的 strong leader 原则，因为 follower 可以在不知道 leader 状态的情况下创建快照。但是我们认为这种违背是合乎情理的。Leader 的存在，是为了防止在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，因此没有决策会冲突。数据依然只能从 leader 流到 follower ，只是 follower 可以重新组织它们的数据了。</p>
<p>我们考虑过一种可替代的基于 leader 的快照方案，在该方案中，只有leader 会创建快照，然后 leader 会发送它的快照给所有的 follower 。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照过程。每个 follower 都已经拥有了创建自己的快照所需要的信息，而且很显然，follower 从本地的状态中创建快照远比通过网络接收别人发来的要来得经济。第二，leader 的实现会更加复杂。例如，leader 发送快照给 follower 的同时也要并行地将新的日志条目发送给它们，这样才不会阻塞新的客户端请求。</p>
<p>还有两个问题会影响快照的性能。首先，服务器必须决定什么时候创建快照。如果快照创建过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，就要承担耗尽存储容量的风险，同时也增加了重启时日志回放的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置得显著大于期望的快照的大小，那么快照的磁盘带宽负载就会很小。</p>
<p>第二个性能问题就是写入快照需要花费一段时间，并且我们不希望它影响到正常的操作。解决方案是通过写时复制的技术，这样新的更新就可以在不影响正在写的快照的情况下被接收。例如，具有泛函数据结构的状态机天然支持这样的功能。另外，操作系统对写时复制技术的支持（如 Linux 上的 fork）可以被用来创建整个状态机的内存快照（我们的实现用的就是这种方法）。</p>
<h3 id="客户端交互"><a href="#客户端交互" class="headerlink" title="客户端交互"></a>客户端交互</h3><p>本节介绍客户端如何和 Raft 进行交互，包括客户端如何找到 leader 和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p>
<p>Raft 的客户端发送所有的请求给 leader 。当客户端第一次启动的时候，它会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是 leader ，那么该服务器会拒绝客户端的请求并且提供关于它最近接收到的 Leader 的信息（AppendEntries 请求包含了 leader 的网络地址）。如果 leader 已经崩溃了，客户端请求就会超时；客户端之后会再次随机挑选服务器进行重试。</p>
<p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在它的调用和回复之间）。但是，如上述，Raft 可能执行同一条命令多次：例如，如果 leader 在提交了该日志条目之后，响应客户端之前崩溃了，那么客户端会和新的 leader 重试这条指令，导致这条命令被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每个客户端已经处理的最新的序列号以及相关联的回复。如果接收到一条指令，该指令的序列号已经被执行过了，就立即返回结果，而不重新执行该请求。</p>
<p>只读的操作可以直接处理而不需要记录日志。但是，如果不采取任何其他措施，这么做可能会有返回过时数据（stale data）的风险，因为 leader 响应客户端请求时可能已经被新的 leader 替代了，但是它还不知道自己已经不是最新的 leader 了。线性化的读操作肯定不会返回过时数据，Raft 需要使用两个额外的预防措施来在不使用日志的情况下保证这一点。首先，leader 必须有关于哪些日志条目被提交了的最新信息。Leader 完整性特性保证了 leader 一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，它可能不知道哪些是已经被提交的。为了知道这些信息，它需要在它的任期里提交一个日志条目。Raft 通过让 leader 在任期开始的时候提交一个空的没有任何操作的日志条目到日志中来处理该问题。第二，leader 在处理只读请求之前必须检查自己是否已经被替代了（如果一个更新的 leader 被选举出来了，它的信息就是过时的了）。Raft 通过让 leader 在响应只读请求之前，先和集群中的过半节点交换一次心跳信息来处理该问题。另一种可选的方案，leader 可以依赖心跳机制来实现一种租约的形式，但是这种方法依赖 timing 来保证安全性（假设时间误差是有界的）。</p>
<h3 id="实现和评价"><a href="#实现和评价" class="headerlink" title="实现和评价"></a>实现和评价</h3><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p>
<p>这一章会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p>
<h4 id="可理解性"><a href="#可理解性" class="headerlink" title="可理解性"></a>可理解性</h4><p>为了比较 Paxos 和 Raft 算法的可理解性，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文除了日志压缩之外的所有内容；Paxos 课程包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如 Leader 选举）。小测验测试一些对算法的基本理解和解释一些示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者独立的区别从第一个算法处学来的经验。我们计算参加人员的每一个小测验的得分来看参与者是否对 Raft 的理解更好。</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>消除偏见的手段</th>
<th>复习材料</th>
</tr>
</thead>
<tbody><tr>
<td>相同的讲课质量</td>
<td>使用相同的讲师。Paxos 的讲义是基于之前在几所大学中使用的材料的并且做了改进。Paxos 的讲义要长 14%</td>
<td>视频</td>
</tr>
<tr>
<td>相同的测试难度</td>
<td>用难度给问题分组，在测试中成对出现</td>
<td>测验</td>
</tr>
<tr>
<td>标准的打分</td>
<td>使用红字标题。随机顺序打分，两个测验交替进行</td>
<td>红字标题</td>
</tr>
</tbody></table>
<p>表-1：考虑到的可能造成偏见的因素，以及解决方案和对应的复习材料</p>
<p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些 Paxos 的经验，并且 Paxos 的视频要长 14%。如表-1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p>
<p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图-14 展示了每个参与者的得分。一对 t -测试表明，拥有 95% 的可信度，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p>
<p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型显示，对小测验的选择会产生 12.5 分的差别在对 Raft 的好感度上。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft 的小测验得分会比 Paxos 低 6.3 分；我们不知道为什么，但这在统计学上是这样的。</p>
<p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图-15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p>
<p>关于 Raft 用户学习有一个更加详细的讨论，详见<a target="_blank" rel="noopener" href="https://ramcloud.stanford.edu/~ongaro/thesis.pdf">http://ramcloud.stanford.edu/~ongaro/thesis.pdf</a></p>
<h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>在第5章，我们已经进行了一个<a target="_blank" rel="noopener" href="http://ramcloud.stanford.edu/~ongaro/thesis.pdf">正式的说明</a>，和对一致性机制的安全性证明。这个正式说明通过 TLA+ 让 表-2 中的信息非常清晰。它大约有 400 行并且充当了证明的主题。同时对于任何想实现的人也是十分有用的。我们非常机械的通过 TLA 证明系统证明了日志完全特性（Log Completeness Property）。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明这个说明中的类型安全 type safety）。而且，我们已经写了一个非正式的证明关于状态机安全性质是完备的，并且是相当清晰的（大约 3500 个词）。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当 Leader 被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从 Leader 到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p>
<p>我们使用我们自己的 Raft 实现来衡量 Raft  Leader 选举的性能并且回答以下两个问题。首先， Leader 选举的过程收敛是否快速？第二，在 Leader 宕机之后，最小的系统宕机时间是多久？</p>
<p>为了衡量 Leader 选举，我们反复的使一个拥有五个节点的服务器集群的 Leader 宕机，并计算需要多久才能发现 Leader 已经宕机并选出一个新的 Leader （见图-16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些 Candidate 是没有成为 Leader 的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止 Leader 之前同步的发送了一次心跳广播（这大约和 Leader 在崩溃前复制一个新的日志给其他机器很像）。 Leader 均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p>
<p>图-16 上面的图表表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程由于太多的选票瓜分的情况往往都需要花费超过 10 秒钟。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p>
<p>图-16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的 Leader （最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新 Leader 之前， Leader 就很难发送完心跳包。这会导致没有意义的 Leader 改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的 Leader 改变，而且依然提供不错的可用性。</p>
<h3 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h3><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p>
<p>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰的论文。<br>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。<br>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 有着很大的差别。<br>Paxos 可以应用的性能优化。<br>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于 Leader 的方法，和 Raft 有很多相似之处。<br>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用 Leader 选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了 Leader 身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中， Leader 选举和基本的一致性协议是正交的： Leader 选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对 Leader 选举的独立的机制。相比较而言，Raft 就直接将 Leader 选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p>
<p>像 Raft 一样，VR 和 ZooKeeper 也是基于 Leader 的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非 Leader 的功能。例如，Raft 中日志条目都遵循着从 Leader 发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（ Leader 可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p>
<p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在 Leader 改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p>
<p>Raft 的强 Leader 模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有 Leader 的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p>
<p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致（joint consensus）的方法因为它对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Raft 没有采用 Lamport 的基于 α 的方法是因为它假设在没有 Leader 的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较而言，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。和 VR、SMART 比较而言，Raft 的方法同时需要更少的额外机制来实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p>
<p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；这个过程是我们发现我们最终很少有技术上的重复，例如问题分解和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p>
<ul>
<li>原文参考： <a target="_blank" rel="noopener" href="https://raft.github.io/">Raft 网站</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/" class="post-title-link" itemprop="url">以太坊编程_III</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2018-02-24 21:36:12" itemprop="dateCreated datePublished" datetime="2018-02-24T21:36:12+08:00">2018-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-11-02 18:16:50" itemprop="dateModified" datetime="2020-11-02T18:16:50+08:00">2020-11-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>目录</strong></p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-I/">迈出第一步</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-II/">与合约进行交互</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://willzhuang.github.io/2018/02/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%BC%96%E7%A8%8B-III/">现实世界中的构架和工具</a></p>
</li>
</ol>
<p><strong>3. 现实世界中的构架和工具</strong></p>
<p>或许你已经注意到了，我们所做的工作大部分都很依赖人力。尽管这是一个新兴产业，但是一些工具将会降低开发难度。下面将介绍其中一部分。</p>
<p><strong>3.1. 通过Truffle部署</strong></p>
<p>目前为止，我们与合约进行交互的唯一方式是通过节点控制台将它们手动部署到一个 testrpc 节点上，再使用 Web3 加载它们。现在，我要向你介绍 Truffle 。它是一个以太坊开发构架，具有调试、部署和测试智能合约等功能。</p>
<p>我们要做的第一件事是通过Truffle部署合约。让我们为此创建一个新的目录，运行以下指令来安装Truffle，启动我们的项目：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir truffle-experiment</span><br><span class="line">$ <span class="built_in">cd</span> truffle-experiment/</span><br><span class="line">$ npm install truffle@4.0.4</span><br><span class="line">$ npx truffle init</span><br></pre></td></tr></table></figure>

<p>会看见有一些文件夹和文件被创建出来。目录结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">truffle-experiment&#x2F;</span><br><span class="line">├── contracts&#x2F;</span><br><span class="line">│   └── Migrations.sol</span><br><span class="line">├── migrations&#x2F;</span><br><span class="line">│   └── 1_initial_migration.js</span><br><span class="line">├── test&#x2F;</span><br><span class="line">├── truffle.js</span><br><span class="line">└── truffle-config.js</span><br></pre></td></tr></table></figure>

<p>智能合约应当放在 <em>contracts</em> 文件夹里。<em>migrations</em> 文件夹中的 javascript 文件将帮助我们把合约部署在网络上。你或许也看见了第一个文件夹中的 <em>Migrations</em> 合约，在这个文件夹中，迁移历史将会存储在区块链上。测试文件夹最初是空的，专门用来保存我们的测试文件。最后，你会看见 truffle.js 和 truffle-config.js 这两个文件。我们先略过它们不谈，你也可以查看<a target="_blank" rel="noopener" href="http://truffleframework.com/docs/">文档</a>了解详情。</p>
<p>现在，让我们抛开这些无聊的东西，聚焦于一些有趣的地方。要举例说明我们是如何通过Truffle 部署合约的，可以采用与该指南上一篇文章中相同的代币合约的例子。请复制该代码并将它粘贴至合约文件夹里的 <em>MyToken.sol</em> 文件中。之后，创建一个名为 <em>2_deploy_my_token.js</em> 的新迁移文件，并将下列几行代码复制进去：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyToken = artifacts.require(<span class="string">&#x27;./MyToken.sol&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(MyToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，迁移会将我们的代币部署于网络中。这次，我们无需运行 testrpc 节点，因为 <em>Truffle</em> 已经自带了一个模拟节点，可用于开发和测试之途。我们只需要打开一个终端运行 <em>npx truffle develop</em> 并使用 <em>truffle migrate</em> 运行迁移。<a target="_blank" rel="noopener" href="https://github.com/zkat/npx">npx介绍</a>。之后，你会看到下列输出值：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">truffle(develop)&gt; truffle migrate</span><br><span class="line"></span><br><span class="line">Using network ‘develop’.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">Deploying Migrations…</span><br><span class="line">… 0xf5776c9f32a9b5b7600d88a6a24b0ef433f559c31aaeb5eaf6e2fc5e2f7fa669</span><br><span class="line">Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span><br><span class="line">Saving successful migration to network…</span><br><span class="line">… 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span><br><span class="line">Saving artifacts…</span><br><span class="line"></span><br><span class="line">Running migration: 2_deploy_my_token.js</span><br><span class="line">Deploying MyToken…</span><br><span class="line">… 0xc74019c2fe3b3ef1d4e2033c2e4b9fa13611f3150f8b6b37334a8e29e24b056c</span><br><span class="line">MyToken: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span><br><span class="line">Saving successful migration to network…</span><br><span class="line">… 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span><br><span class="line">Saving artifacts…</span><br></pre></td></tr></table></figure>
<p>我们只关注 MyToken: <em>0x345ca3e014aaf5dca488057592ee47305d9b3e10</em> 这行代码，它是我们已部署的代币合约的地址。在默认情况下，Truffle 为模拟节点预置了10个拥有虚拟ETH的地址，就像使用 testrpc 时那样。我们可以通过 web3 以太币账户访问该地址列表。此外，Truffle 使用列表中的第一个地址（索引为0的那个）部署这些合约，这意味着它将成为 MyToken 的所有者。</p>
<p>鉴于 Web3 可用于Truffle控制台内，你可以运行下列指令来检查所有者的余额：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">truffle(develop)&gt; owner = web3.eth.accounts[0]</span><br><span class="line">truffle(develop)&gt; instance = MyToken.at(<span class="string">&#x27;[DEPLOYED_ADDRESS]&#x27;</span>)</span><br><span class="line">truffle(develop)&gt; instance.balanceOf(owner)</span><br></pre></td></tr></table></figure>
<p>注意：别忘了将 [DEPLOYED_ADDRESS] 替换成由Truffle赋予的已部署合约的地址，例如： <em>0x345ca3e014aaf5dca488057592ee47305d9b3e10</em> 。</p>
<p>我们也可以先将一些代币发送至另一个地址，再检查更新过后的余额：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send tokens</span></span><br><span class="line">amount = <span class="number">10</span></span><br><span class="line">recipient = web3.eth.accounts[<span class="number">1</span>]</span><br><span class="line">txHash = instance.sendTokens(recipient, amount, &#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balances</span></span><br><span class="line">instance.balanceOf(owner)</span><br><span class="line">instance.balanceOf(recipient)</span><br></pre></td></tr></table></figure>

<p>现在已经可以看到接受者的账户里有10枚代币了！我们可以通过下列代码搜索交易信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getTransaction(txHash)</span><br></pre></td></tr></table></figure>

<p><strong>3.2. 测试智能合约</strong><br>接下来，Truffle更有趣又有用的一点是，我们可以测试我们的合约。这一构架能让你通过两种不同方式编写测试代码：Javascript 和 Solidity。在这篇文章中，我们将学习一些关于JS测试这个最常用选项的基本知识。</p>
<p>Truffle使用后台的 <a target="_blank" rel="noopener" href="https://mochajs.org/">Mocha</a> 作为测试构架，并使用 <a target="_blank" rel="noopener" href="http://chaijs.com/">Chai</a> 来执行断言。如果你不熟悉这两个库也没有关系，它们真的都很简单，执行的语法也与其它测试架构相似。</p>
<p>准备好了，让我们开始介绍第一则测试实例吧。我们需要在测试文件夹里创建一个 MyToken.js 文件。一旦你创建完成之后，请将下方代码粘贴进去。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyToken = artifacts.require(<span class="string">&#x27;MyToken&#x27;</span>)</span><br><span class="line"></span><br><span class="line">contract(<span class="string">&#x27;MyToken&#x27;</span>, <span class="function"><span class="params">accounts</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;has a total supply and a creator&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> owner = accounts[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> myToken = <span class="keyword">await</span> MyToken.new(&#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> creator = <span class="keyword">await</span> myToken.creator()</span><br><span class="line">    <span class="keyword">const</span> totalSupply = <span class="keyword">await</span> myToken.totalSupply()</span><br><span class="line">    </span><br><span class="line">    assert(creator *= owner)</span><br><span class="line">    assert(totalSupply.eq(<span class="number">10000</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>要运行 <em>Truffle 测试</em>的话，你只需使用指令 <em>npx truffle test</em>。再次提醒：此处无需在后台运行 rpc 测试节点，因为 Truffle 会帮你运行好。</p>
<p>你可能已经注意到了，这是我们第二次在代码中使用 <em>artifacts.require()</em> 。第一次是在编写 <em>MyToken</em> migration 代码的时候。Artifact是分别编译每个合约的结果。这些 Artifacts 将被置于与你的项目根相关的 <em>build/contracts/</em> 目录之内。我们通过 <em>artifacts.require()</em> 告诉 Truffle 想与哪个合约进行交互。只提供合约名并实现抽象化使用。你也可以阅读<a target="_blank" rel="noopener" href="http://truffleframework.com/docs/getting_started/migrations#artifacts-require-">这篇文章</a>来详细了解 Truffle artifacts。</p>
<p>剩下的最后一个重点是 <em>contract()</em> 函数，它确实与Mocha的 <em>describe()</em> 函数相似。这就是 Truffle 保障<a target="_blank" rel="noopener" href="http://truffleframework.com/docs/getting_started/testing#clean-room-environment">clean-room environment</a>的方式。Truffle 将重新把合约部署给以太坊客户端，并在每次被调用之时提供一列可用账户。不过，我们不建议将已部署的合约实例用于测试。让每个测试管理它们自己的实例会更好。</p>
<p>既然我们了解了有关 Truttle 测试的一些基本知识，让我们再介绍一个有趣的场景吧。我们将测试账户之间的代币转让：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;allows token transfers&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> owner = accounts[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> recipient = accounts[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> myToken = <span class="keyword">await</span> MyToken.new(&#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> myToken.sendTokens(recipient, <span class="number">10</span>, &#123; <span class="attr">from</span>: owner &#125;)</span><br><span class="line">  <span class="keyword">const</span> ownerBalance = <span class="keyword">await</span> myToken.balanceOf(owner)</span><br><span class="line">  assert(ownerBalance.eq(<span class="number">9990</span>))</span><br><span class="line">  <span class="keyword">const</span> recipientBalance = <span class="keyword">await</span> myToken.balanceOf(recipient)</span><br><span class="line">  assert(recipientBalance.eq(<span class="number">10</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>其它的测试实例见<a target="_blank" rel="noopener" href="https://github.com/WillZhuang/ethereum-spiking/tree/master/3-using-truffle">此处</a>，从中你还可以看到我是如何使用 Truffle 来完成这个 mini DApp 的。你会看到我设置了同样的特性，就像我们在上一篇文章中对 app 所做的那样。 唯一改变之处是我们正在使用 Truffle 启动测试节点、部署合约并添加测试，从而确保我们的合约能达到我们预期的效果。</p>
<p><strong>3.3.OpenZeppelin</strong></p>
<p>如果你阅读到此处，想必你已经听说过 <a target="_blank" rel="noopener" href="https://openzeppelin.org/">OpenZeppelin</a> 了吧。如果你还没有的话，你只需要知道它是有助于你构建智能合约的最常用构架。它是一个开源构架，提供可重复使用的智能合约构建分布式应用、协议和组织，从而降低使用经测试和社区审查的标准代码所带来的安全隐患。</p>
<p>鉴于代币合约的数量之大，以太坊社区于两年前创建了一个名为 <a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md">ERC20</a> 的代币标准。其理念是允许 DApps 和钱包以共同的方式在多种界面和 DApps 之间处理代币。</p>
<p>也就是说，最常用的 OpenZeppelin 合约就是 ERC20 用例。这就是我们第一步要对 MyToken 合约做的事：使之与 ERC20 兼容。让我们先安装 OpenZeppelin 构架，这需要运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install zeppelin-solidity</span><br></pre></td></tr></table></figure>
<p>现在，看看我们用一些OpenZeppelin合约构建的新用例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#39;zeppelin-solidity&#x2F;contracts&#x2F;token&#x2F;BasicToken.sol&#39;;</span><br><span class="line">import &#39;zeppelin-solidity&#x2F;contracts&#x2F;ownership&#x2F;Ownable.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract MyToken is BasicToken, Ownable &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public constant INITIAL_SUPPLY &#x3D; 10000;</span><br><span class="line">  function MyToken() &#123;</span><br><span class="line">    totalSupply &#x3D; INITIAL_SUPPLY;</span><br><span class="line">    balances[msg.sender] &#x3D; INITIAL_SUPPLY;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如你所见，我们已经去除了很多核心功能。好吧，我们还没有去除这些功能，只是向OpenZeppelin 合约下达了该指令。这的确很有用，因为我们是在重复使用经过审核的安全代码，这意味着我们已经减少了合约的受攻击可能性。</p>
<p>此外，我们正将代币合约从 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/ownership/Ownable.sol">Ownable</a> 和 <a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.5.0/contracts/token/BasicToken.sol">BasicToken</a> 这两个 OpenZeppelin 合约扩展而来。是的，Solidity 支持多重继承，而且对你来说，知道顺序的重要性真的很重要。不过，这超出了本文的介绍范围，不过你可以从<a target="_blank" rel="noopener" href="https://solidity.readthedocs.io/en/develop/contracts.html#inheritance">此处</a>了解更多详情。</p>
<p>正如上文所说，我们正将<em>MyToken</em>从<em>Ownable</em>中扩展而来。让我们看一看这个合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">contract Ownable &#123;</span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span><br><span class="line"></span><br><span class="line">  function Ownable() public &#123;</span><br><span class="line">    owner &#x3D; msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier onlyOwner() &#123;</span><br><span class="line">    require(msg.sender * owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferOwnership(address newOwner) public onlyOwner &#123;</span><br><span class="line">    require(newOwner !&#x3D; address(0));</span><br><span class="line">    OwnershipTransferred(owner, newOwner);</span><br><span class="line">    owner &#x3D; newOwner;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ownable提供三大主要功能：</p>
<ul>
<li>它有一个特殊地址供我们调用其“owner”；</li>
<li>它允许我们转让合约的所有权；</li>
<li>它提供了有用的onlyOwner修改器，确保只有所有者才能调用某个函数。</li>
</ul>
<p>很有用对吧？另一方面，我们也在扩展 BasicTokencontract（基础代币合约）。让我们了解下它的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import &#39;..&#x2F;math&#x2F;SafeMath.sol&#39;;</span><br><span class="line"></span><br><span class="line">contract ERC20Basic &#123;</span><br><span class="line">  uint256 public totalSupply;</span><br><span class="line">  function balanceOf(address who) public view returns (uint256);</span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool);</span><br><span class="line">  event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract BasicToken is ERC20Basic &#123;</span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  mapping(address &#x3D;&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class="line">    require(_to !&#x3D; address(0));</span><br><span class="line">    require(_value &lt;&#x3D; balances[msg.sender]);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(_value);</span><br><span class="line">    balances[_to] &#x3D; balances[_to].add(_value);</span><br><span class="line">    Transfer(msg.sender, _to, _value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256 balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相信你更熟悉这个代码。这基本上是我们过去在 MyToken 合约中所做的事。这里存在一些细微的差异，因为我们没有遵循原始版本的ERC20标准。我们此处所说的 <a target="_blank" rel="noopener" href="https://github.com/WillZhuang/ethereum-spiking/blob/master/3-using-truffle/contracts/MyToken.sol">sendTokens</a> 只是转让，除了触发 <a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer"><em>transfer</em></a> <a target="_blank" rel="noopener" href="https://solidity.readthedocs.io/en/develop/contracts.html#events">事件</a>之外执行的几乎是同样的行为。</p>
<p>另一个重要的事是使用<em>SafeMath</em>编写<em>uint256</em>代码。SafeMath是 OpenZeppelin 推荐使用的库，用来进行带有安全检查的数学运算。这是另一个常用合约，因为它能保证数学运算不会溢出。</p>
<p>OpenZeppelin 本身就是一个完整的领域，请花点时间深入分析并学习它。你可以先从读取并密切关注已经审查的<a target="_blank" rel="noopener" href="https://github.com/OpenZeppelin/zeppelin-solidity">代码库</a>的安全细节开始。</p>
<blockquote>
<p>原文链接: <a target="_blank" rel="noopener" href="https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2">https://blog.zeppelin.solutions/a-gentle-introduction-to-ethereum-programming-part-3-abdd9644d0c2</a></p>
<p>作者: Facu Spagnuolo</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/47/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/47/">47</a><span class="page-number current">48</span><a class="page-number" href="/page/49/">49</a><span class="space">&hellip;</span><a class="page-number" href="/page/51/">51</a><a class="extend next" rel="next" href="/page/49/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weiming Zhuang</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>




</body>
</html>
