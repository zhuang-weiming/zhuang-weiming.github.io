<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhuang-weiming.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.3.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="Zhuang&#39;s Diary">
<meta property="og:url" content="https://zhuang-weiming.github.io/page/19/index.html">
<meta property="og:site_name" content="Zhuang&#39;s Diary">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Weiming Zhuang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhuang-weiming.github.io/page/19/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Zhuang's Diary</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhuang's Diary</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">言之有物，持之以恒</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Weiming Zhuang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">290</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">64</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/zhuangweiming/" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;zhuangweiming&#x2F;" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2022/11/25/FMR-%E5%B8%82%E5%9C%BA%E9%A3%8E%E9%99%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/25/FMR-%E5%B8%82%E5%9C%BA%E9%A3%8E%E9%99%A9/" class="post-title-link" itemprop="url">FMR-市场风险</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-25 15:21:00" itemprop="dateCreated datePublished" datetime="2022-11-25T15:21:00+08:00">2022-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2025-09-05 16:22:23" itemprop="dateModified" datetime="2025-09-05T16:22:23+08:00">2025-09-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>按照风险的驱动因素，金融风险可以分为市场风险market risk，信用风险credit risk，操作风险operational risk，流动性风险liquidity risk。</p>
<p>最常见的市场风险包括利率风险，汇率风险，通货膨胀风险，证券价格风险，波动率风险等。</p>
<p>市场风险分析方法：</p>
<ol>
<li><p>缺口分析法 gap analysis，即资产负债缺口分析法。当利率发生变化时，资产和负债之间产生“缺口”，通过比较缺口的大小，可以得到利率变化时市场价值变动的程度，亦即产生的<strong>利率风险</strong>的大小。GAP（缺口）= RSA（利率敏感性资产）- RSL（利率敏感性负债）</p>
</li>
<li><p>久期分析法 duration analysis，即持续期分析法或者期限弹性分析法。其通过对各时间段段缺口赋予相应权重，得到加权缺口，然后对这些加权缺口求和，以此估算<strong>利率</strong>变动对市场价值的影响。</p>
</li>
</ol>
<p>相对于缺口分析只是考虑净收入的变化，久期分析则考察资产或者负债的价值，是一种更为准确的利率风险计量方法。</p>
<ol start="3">
<li>场景分析法 scenario analysis，又称假设分析法 what-if analysis。通过设定不同的情景，分析在每一种情景下的收益或者亏损，从而对<strong>整个投资组合的未来风险情况进行评估</strong>，做出最佳决策。</li>
<li>投资组合理论 portfolio theory，是一种衡量<strong>市场风险</strong>的方法。</li>
<li>希腊字母估计市场风险。</li>
</ol>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>符号</th>
<th>风险评估</th>
</tr>
</thead>
<tbody><tr>
<td>Delta</td>
<td>Δ</td>
<td>标的资产价格变化引起金融衍生品价格变化</td>
</tr>
<tr>
<td>Gamma</td>
<td>Γ</td>
<td>标的资产价格变化引起Delta变化</td>
</tr>
<tr>
<td>Theta</td>
<td>Θ</td>
<td>时间引起衍生品价格变化</td>
</tr>
<tr>
<td>Vega</td>
<td>Λ</td>
<td>市场波动率变化引起金融衍生品价格变化</td>
</tr>
<tr>
<td>Rho</td>
<td>ρ</td>
<td>利率变化引起金融衍生品价格变化</td>
</tr>
</tbody></table>
<ol start="6">
<li><p>风险价值 Value at Risk - VaR，也叫在险价值。作为经典的市场风险度量，可以用来评估资产的风险，帮助金融机构合理分散或者规避风险。摩根大通J.P.Morgan Chase开源了RiskMetrics系统，很快被金融机构采用，<strong>广泛地用来计算包括市场风险、信用风险以及操作风险等在内的金融风险</strong>。</p>
<p>6.1 参数法计算风险价值 parametric approach，一般假设未来收益满足正态分布，这是因为如股票收益率等风险因子一般都可以用正态分布近似，而资产组合通常也可以用风险因子等线性组合来表示，并且正态分布的任意线性组合仍然为正态分布，因此资产祝贺的预期收益分布仍然为正态分布。</p>
<p>在市场上，价格低标准差通常变化较大，价格本身对于标准差来说，变化并不大。所以，<strong>参数法的关键是要计算出分布的标准差σ</strong>，正因为如此，参数法又时也被称为方差协方差方法。该原理容易理解，计算量也较小。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits <span class="keyword">import</span> mplot3d</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> cm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设投资组合包含以下公司</span></span><br><span class="line">tickers = [<span class="string">&#x27;GOOGL&#x27;</span>,<span class="string">&#x27;FB&#x27;</span>,<span class="string">&#x27;AAPL&#x27;</span>,<span class="string">&#x27;NFLX&#x27;</span>,<span class="string">&#x27;AMZN&#x27;</span>]</span><br><span class="line">ticker_num = <span class="built_in">len</span>(tickers)</span><br><span class="line">price_data = []</span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):</span><br><span class="line">    <span class="comment"># 获取股票的历史数据</span></span><br><span class="line">    prices = pandas_datareader.DataReader(tickers[ticker], start=<span class="string">&#x27;2015-11-30&#x27;</span>, end = <span class="string">&#x27;2020-11-30&#x27;</span>, data_source=<span class="string">&#x27;yahoo&#x27;</span>)   </span><br><span class="line">    price_data.append(prices[[<span class="string">&#x27;Adj Close&#x27;</span>]])</span><br><span class="line">    df_stocks = pd.concat(price_data, axis=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># stock log returns计算“日对数回报率”</span></span><br><span class="line">logreturns = np.log(df_stocks/df_stocks.shift(<span class="number">1</span>))[<span class="number">1</span>:]  </span><br><span class="line">logreturns.columns = tickers </span><br><span class="line">logreturns.head() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设它们的对数回报率满足正态分布，下面代码计算并展示股票的回报率分布</span></span><br><span class="line"><span class="comment"># plot log return distribution for GOOGL</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line">mu, std = stats.norm.fit(logreturns[<span class="string">&#x27;GOOGL&#x27;</span>])</span><br><span class="line">x = np.linspace(mu<span class="number">-5</span>*std, mu+<span class="number">5</span>*std, <span class="number">500</span>)</span><br><span class="line">logreturns[<span class="string">&#x27;GOOGL&#x27;</span>].hist(bins=<span class="number">60</span>, density=<span class="literal">True</span>, histtype=<span class="string">&quot;stepfilled&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">x = np.linspace(mu - <span class="number">3</span>*std, mu+<span class="number">3</span>*std, <span class="number">500</span>)</span><br><span class="line">plt.plot(x, stats.norm.pdf(x, mu, std))</span><br><span class="line">plt.title(<span class="string">&quot;Log return distribution for GOOGL&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot log return distribution</span></span><br><span class="line">rows = <span class="number">2</span></span><br><span class="line">cols = <span class="number">2</span></span><br><span class="line">fig, axs = plt.subplots(rows, cols, figsize=(<span class="number">12</span>,<span class="number">6</span>))</span><br><span class="line">ticker_n = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">        mu, std = stats.norm.fit(logreturns[tickers[ticker_n]])</span><br><span class="line">        x = np.linspace(mu<span class="number">-5</span>*std, mu+<span class="number">5</span>*std, <span class="number">500</span>)</span><br><span class="line">        axs[i,j].hist(logreturns[tickers[ticker_n]], bins=<span class="number">60</span>, density=<span class="literal">True</span>, histtype=<span class="string">&quot;stepfilled&quot;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">        axs[i,j].plot(x, stats.norm.pdf(x, mu, std))</span><br><span class="line">        axs[i,j].set_title(<span class="string">&quot;Log return distribution for &quot;</span>+tickers[ticker_n])</span><br><span class="line">        axs[i,j].set_xlabel(<span class="string">&quot;Return&quot;</span>)</span><br><span class="line">        axs[i,j].set_ylabel(<span class="string">&quot;Density&quot;</span>)</span><br><span class="line">        ticker_n = ticker_n + <span class="number">1</span></span><br><span class="line">plt.tight_layout()</span><br></pre></td></tr></table></figure>

<p>​    6.2 历史法计算风险价值 historical approach，这是一种全值估计方法 full revaluation，具体是指利用风险因子的历史数据，计算过去某段时期收益的频度分布，并以此来模拟风险因子的未来收益分布，然后根据置信水平，确定相应的最大可能损失。</p>
<p>​    6.3 蒙特卡洛法计算风险价值 Monte Carlo simulation，这也是风险价值计算中最常应用的模型之一。首先通过分析历史数据建立风险因子的随机过程模型，然后反复模拟风险因子变量的随机过程，每一次模拟都可以得到风险因子的一个未来变化的情景，以及投资组合在持有期期末的一个可能价值。通过大量的模拟，投资组合价值的模拟分布将最终收敛于该组合的真实分布，根据该分布，可以计算风险价值。</p>
<p><img src="/2022/11/25/FMR-%E5%B8%82%E5%9C%BA%E9%A3%8E%E9%99%A9/1.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设投资组合包含以下公司</span></span><br><span class="line">tickers = [<span class="string">&#x27;GOOGL&#x27;</span>,<span class="string">&#x27;FB&#x27;</span>,<span class="string">&#x27;AAPL&#x27;</span>,<span class="string">&#x27;NFLX&#x27;</span>,<span class="string">&#x27;AMZN&#x27;</span>]</span><br><span class="line">ticker_num = <span class="built_in">len</span>(tickers)</span><br><span class="line">price_data = []</span><br><span class="line"><span class="keyword">for</span> ticker <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):   </span><br><span class="line">    prices = pandas_datareader.DataReader(tickers[ticker], start=<span class="string">&#x27;2015-11-30&#x27;</span>, end = <span class="string">&#x27;2020-11-30&#x27;</span>, data_source=<span class="string">&#x27;yahoo&#x27;</span>)   </span><br><span class="line">    price_data.append(prices[[<span class="string">&#x27;Adj Close&#x27;</span>]])</span><br><span class="line">    df_stocks = pd.concat(price_data, axis=<span class="number">1</span>)</span><br><span class="line">df_stocks.columns = tickers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后计算股票的累积回报率</span></span><br><span class="line"><span class="comment"># cumulative returns</span></span><br><span class="line">stock_return = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ticker_num):  </span><br><span class="line">    return_tmp = np.log(df_stocks[[tickers[i]]]/df_stocks[[tickers[i]]].shift(<span class="number">1</span>))[<span class="number">1</span>:]  </span><br><span class="line">    return_tmp = (return_tmp+<span class="number">1</span>).cumprod()</span><br><span class="line">    stock_return.append(return_tmp[[tickers[i]]])</span><br><span class="line">    return_all = pd.concat(stock_return,axis=<span class="number">1</span>)</span><br><span class="line">return_all.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用曲线更直观地展示所有股票的回报率</span></span><br><span class="line"><span class="comment"># plot cumulative returns of all stocks</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(return_all.columns):</span><br><span class="line">    return_all[col].plot()</span><br><span class="line">plt.title(<span class="string">&#x27;Cumulative returns&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line">plt.xticks(rotation=<span class="number">30</span>)</span><br><span class="line">plt.legend(return_all.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定投资组合中各个股票的比重，并且在持有期内保持不变。进而计算得到整个投资组合的预期回报和股价</span></span><br><span class="line"><span class="comment"># lastest return and price values</span></span><br><span class="line">latest_return = return_all.iloc[<span class="number">-1</span>,:]</span><br><span class="line">latest_price = df_stocks.iloc[<span class="number">-1</span>,:]</span><br><span class="line">sigma = latest_return.std()</span><br><span class="line"><span class="comment"># weights for stocks in the portfolio</span></span><br><span class="line">stock_weight = [<span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.25</span>] </span><br><span class="line"><span class="comment"># calculate expected return</span></span><br><span class="line">expected_return = latest_return.dot(stock_weight)</span><br><span class="line">print(<span class="string">&#x27;The weighted expected portfolio return: %.2f&#x27;</span> % expected_return)</span><br><span class="line"><span class="comment"># calculate weighted price</span></span><br><span class="line">price = latest_price.dot(stock_weight)</span><br><span class="line">print(<span class="string">&#x27;The weighted price of the portfolio: %.0f&#x27;</span> % price)</span><br><span class="line"></span><br><span class="line"><span class="comment">#假设该投资组合的回报率符合正态分布，以一天中的每一分钟作为步长，即分为1440个节点，利用蒙特卡洛模拟随机产生500个回报率数值。</span></span><br><span class="line"><span class="comment"># monte carlo simulation</span></span><br><span class="line">MC_num = <span class="number">500</span></span><br><span class="line">confidence_level = <span class="number">0.95</span></span><br><span class="line">time_step = <span class="number">1440</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(MC_num):  </span><br><span class="line">  daily_returns = np.random.normal(expected_return/time_step, sigma/np.sqrt(time_step), time_step)</span><br><span class="line">  plt.plot(daily_returns)</span><br><span class="line">plt.axhline(np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>), color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.axhline(np.percentile(daily_returns,confidence_level*<span class="number">100</span>), color=<span class="string">&#x27;g&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.axhline(np.mean(daily_returns), color=<span class="string">&#x27;b&#x27;</span>, linestyle=<span class="string">&#x27;solid&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line"><span class="comment"># 可视化，红线处为风险价值</span></span><br><span class="line"><span class="comment"># plot return distribution</span></span><br><span class="line">sns.distplot(daily_returns, kde=<span class="literal">True</span>, color=<span class="string">&#x27;lightblue&#x27;</span>)</span><br><span class="line">plt.axvline(np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>), color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Return distribution&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Return&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设初始投资金额为100万美元，得到VaR值为 33185</span></span><br><span class="line">initial_investment  = <span class="number">1000000</span></span><br><span class="line">VaR = initial_investment*np.percentile(daily_returns,(<span class="number">1.0</span>-confidence_level)*<span class="number">100</span>)</span><br><span class="line">print(<span class="string">&#x27;The value at risk is %.0f&#x27;</span> % VaR)</span><br></pre></td></tr></table></figure>

<p>若为了获得更多的场景，更多的模拟，这里的计算量会迅速上升，从而导致整体的运算速度较慢。</p>
<p>关联阅读 - <a target="_blank" rel="noopener" href="https://willzhuang.github.io/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/">FMR-波动率</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/" class="post-title-link" itemprop="url">FMR-波动率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-11-21 15:21:00" itemprop="dateCreated datePublished" datetime="2022-11-21T15:21:00+08:00">2022-11-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2025-09-05 16:22:23" itemprop="dateModified" datetime="2025-09-05T16:22:23+08:00">2025-09-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>金融资产价格包括股票，期货，期权，目前本人在思考加密货币的价格是否可以套用经典的金融风险模型，学习笔记汇报如下，<u>由于比较书写数学公式不便，本文只记录了关键说明和程序代码</u>。</p>
<h3 id="1-EWMA"><a href="#1-EWMA" class="headerlink" title="1. EWMA"></a>1. EWMA</h3><p>指数移动加权平均 - Exponentially  Weighted Moving Average, EWMA.</p>
<p>EWMA波动率迭代告诉我们，当前一天的波动率是前一天波动率的函数，这也提供了一种用过去波动率预测未来波动率的方法。这种方法，不需要保存过去所有的数值，而且计算量较小，因此在实际中广泛使用。</p>
<p>The ewm() function is used to provide exponential weighted functions. 指数加权功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating the series. Using the range() function, we create a series and set the index to shot.</span></span><br><span class="line">my_series=pd.Series(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>), index=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;shot&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Printing the series</span></span><br><span class="line">print(my_series)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using Series.ewm(). We calculate the exponential weight of elements in the series using the ewm() function and set the com and adjust parameters.</span></span><br><span class="line">print(my_series.ewm(com=<span class="number">0.5</span>, adjust=<span class="literal">True</span>).mean())</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Series.ewm(self, com=<span class="literal">None</span>, span=<span class="literal">None</span>, halflife=<span class="literal">None</span>, alpha=<span class="literal">None</span>, min_periods=<span class="number">0</span>, adjust=<span class="literal">True</span>, ignore_na=<span class="literal">False</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>com</code></strong>: This represents the decay in terms of the center of mass, α=1/(1+com), for com≥0. 根据Center of Mass质心指定衰减。</p>
</li>
<li><p><strong><code>span</code></strong>: This represents the decay in terms of the span, α=2/(span+1), for span≥1. 根据跨度范围（例如，天数）指定衰减。</p>
</li>
<li><p><strong><code>halflife</code></strong>: This represents the decay in terms of the half-life, α=1−exp(log(0.5)/halflife), for halflife&gt;0. 根据半衰期指定衰减。</p>
</li>
<li><p><strong><code>alpha</code></strong>: This indicates smoothing factor α, 0&lt;α≤1. 衰减系数。</p>
</li>
<li><p><strong><code>min_periods</code></strong>: This represents the minimum number of observations needed to have a value in the window. The default value is <code>0</code>. </p>
</li>
<li><p><strong><code>adjust</code></strong>: This is divided by the decaying adjustment factor into the initial periods to consider the imbalance in the relative weightings (looking at the EWMA as a moving average). 计算权重的方式。</p>
</li>
<li><p><strong><code>ignore_na</code></strong>: This specifies that the missing values should be ignored when calculating weights. The default is <code>False</code>. 如何对待空值。</p>
</li>
<li><p><strong><code>axis</code></strong>: The default value is 0. It specifies the axis on which the function is to be performed. If the value is 0, the operation is performed across the rows. Otherwise, the operation is performed across the columns. 数轴。</p>
</li>
</ul>
<h3 id="2-自回归条件异方差模型ARCH"><a href="#2-自回归条件异方差模型ARCH" class="headerlink" title="2. 自回归条件异方差模型ARCH"></a>2. 自回归条件异方差模型ARCH</h3><p>EWMA与实际情况有不符合的地方，例如，股票收益的波动率是随着时间而变化的。异方差（heteroscedasticity）是指一系列的随机变量值的方差不同。这个模型以自回归方式，通过刻画随时间变异的条件方差，成功解决了时间序列的波动性问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas_datareader</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">from</span> arch <span class="keyword">import</span> arch_model</span><br><span class="line"><span class="comment"># sp500 price</span></span><br><span class="line">sp500 = pandas_datareader.data.DataReader([<span class="string">&#x27;sp500&#x27;</span>], data_source=<span class="string">&#x27;fred&#x27;</span>, start=<span class="string">&#x27;12-28-2009&#x27;</span>, end=<span class="string">&#x27;12-28-2020&#x27;</span>)</span><br><span class="line"><span class="comment"># daily log return</span></span><br><span class="line">log_return_daily = np.log(sp500 / sp500.shift(<span class="number">1</span>))</span><br><span class="line">log_return_daily.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># ARCH(1) model</span></span><br><span class="line">arch=arch_model(y=log_return_daily,mean=<span class="string">&#x27;Constant&#x27;</span>,lags=<span class="number">0</span>,vol=<span class="string">&#x27;ARCH&#x27;</span>,p=<span class="number">1</span>,o=<span class="number">0</span>,q=<span class="number">0</span>,dist=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">archmodel=arch.fit()</span><br><span class="line">archmodel.summary()</span><br><span class="line">archmodel.plot()</span><br></pre></td></tr></table></figure>



<h3 id="3-广义自回归条件异方差模型GARCH"><a href="#3-广义自回归条件异方差模型GARCH" class="headerlink" title="3. 广义自回归条件异方差模型GARCH"></a>3. 广义自回归条件异方差模型GARCH</h3><p>GARCH是对ARCH建模的一种重要推广。其后，又有诸如NGARCH，IGARCH，EGARCH等一系列针对不同应用等衍生模型相继出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GARCH(1,1) model</span></span><br><span class="line">garch=arch_model(y=log_return_daily,mean=<span class="string">&#x27;Constant&#x27;</span>,lags=<span class="number">0</span>,vol=<span class="string">&#x27;GARCH&#x27;</span>,p=<span class="number">1</span>,o=<span class="number">0</span>,q=<span class="number">1</span>,dist=<span class="string">&#x27;normal&#x27;</span>)</span><br><span class="line">garchmodel=garch.fit()</span><br><span class="line">garchmodel.summary()</span><br><span class="line">garchmodel.plot()</span><br></pre></td></tr></table></figure>



<h3 id="4-模型比较"><a href="#4-模型比较" class="headerlink" title="4.模型比较"></a>4.模型比较</h3><p>对于EWMA模型，利用了通常用的0.94，即 JP Morgan 的RiskMetrics采用的设定。所以，下图中，EWMA中的 λ 通常为 0.94。当GARCH(1, 1)模型的参数 β=0 时，即为ARCH(1, 1)模型。而当 ω=0，α=1-λ，β=λ 时，GARCH(1, 1)模型变换成为EWMA模型。</p>
<p><img src="/2022/11/21/FMR-%E6%B3%A2%E5%8A%A8%E7%8E%87/1.png"></p>
<h3 id="5-隐含波动率"><a href="#5-隐含波动率" class="headerlink" title="5.隐含波动率"></a>5.隐含波动率</h3><p>请参考相关阅读中的金融分享管理 - 视频 <a target="_blank" rel="noopener" href="https://space.bilibili.com/513194466/channel/seriesdetail?sid=650176%E3%80%82">https://space.bilibili.com/513194466/channel/seriesdetail?sid=650176。</a></p>
<p><strong>疑问：市场波动率模型以布朗运动位基础，这真的符合市场的实际情况吗？特别是长期投资？如乔布斯，国家资本主义，等等。</strong></p>
<p>相关阅读：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2022/10/27/AIGC-%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/10/27/AIGC-%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/" class="post-title-link" itemprop="url">AIGC-绘画初体验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-10-27 11:48:00" itemprop="dateCreated datePublished" datetime="2022-10-27T11:48:00+08:00">2022-10-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2025-09-05 16:43:57" itemprop="dateModified" datetime="2025-09-05T16:43:57+08:00">2025-09-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>AI-Generated Content，字面意思是AI生产内容。AI写诗、AI作曲、AI绘画、AI换脸……甚至有创始人认为，游戏中导入图片生成模型的“捏脸系统”都是AIGC。</p>
<p><a target="_blank" rel="noopener" href="https://jina.ai/product/disco-art/">https://jina.ai/product/disco-art/</a> 是较为直接的一个体验。</p>
<p>下图为其主页的静态展示：</p>
<p><img src="/2022/10/27/AIGC-%E7%BB%98%E7%94%BB%E5%88%9D%E4%BD%93%E9%AA%8C/1.png"></p>
<h3 id="在线体验"><a href="#在线体验" class="headerlink" title="在线体验"></a>在线体验</h3><p><a target="_blank" rel="noopener" href="https://colab.research.google.com/github/jina-ai/discoart/blob/main/discoart.ipynb">https://colab.research.google.com/github/jina-ai/discoart/blob/main/discoart.ipynb</a></p>
<ol>
<li>按照python notebook的步骤，逐步启动。</li>
<li>Specify parameters，在制定参数的步骤，输入描述文字，目前只支持英文，并输入初始图片。就可以开始Preview了。</li>
</ol>
<p>非常的简单哦～。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2022/09/19/golang-fsm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/golang-fsm/" class="post-title-link" itemprop="url">startup-product-20220917</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-19 09:40:00" itemprop="dateCreated datePublished" datetime="2022-09-19T09:40:00+08:00">2022-09-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-29 09:08:19" itemprop="dateModified" datetime="2022-09-29T09:08:19+08:00">2022-09-29</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="http://github.com/looplab/fsm">http://github.com/looplab/fsm</a></p>
<p>定义状态机的时候有三部分组成：状态机的初始状态，状态机的事</p>
<p>件（包括了多个源事件和一个目的事件），状态机的事件回调。整体来说，回</p>
<p>调可以分为四组8个回调，按执行顺序依次为：</p>
<p>1，事件开始之前</p>
<p>​    A，before_xxx，特定的状态之前</p>
<p>​    B，before_event所有状态之前</p>
<p>2，离开老状态</p>
<p>​    A，leave_xxx 离开特定状态</p>
<p>​    B，leave_state 离开所有状态</p>
<p>3，进入新状态</p>
<p>​    A，enter_xxx,进入特定状态</p>
<p>​    B，enter_state 进入所有状态</p>
<p>4，事件执行完毕之后</p>
<p>​    A，after_xxx 进入特定状态之后</p>
<p>​    B，after_event 进入所有状态</p>
<p>状态机实现的函数接口有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">AvailableTransitions</span><span class="params">()</span> []<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Can</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Cannot</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Current</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Event</span><span class="params">(event <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Is</span><span class="params">(state s/ring)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Metadata</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetMetadata</span><span class="params">(key <span class="keyword">string</span>, dataValue <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetState</span><span class="params">(state <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Transition</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Can</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line">  _, ok := f.transitions[eKey&#123;event, f.current&#125;]</span><br><span class="line">  <span class="keyword">return</span> ok &amp;&amp; (f.transition == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行事件流转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Event</span><span class="params">(event <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    e := &amp;Event&#123;f, event, f.current, dst, <span class="literal">nil</span>, args, <span class="literal">false</span>, <span class="literal">false</span>&#125;</span><br><span class="line">    err := f.beforeEventCallbacks(e)</span><br><span class="line">   f.transition = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">     f.enterStateCallbacks(e)</span><br><span class="line">     f.afterEventCallbacks(e)</span><br><span class="line">    &#125;</span><br><span class="line">   f.leaveStateCallbacks(e)</span><br><span class="line">   err = f.doTransition()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">enterStateCallbacks</span><span class="params">(e *Event)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;f.current, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">        fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">&quot;&quot;</span>, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">       fn(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Transition</span><span class="params">()</span> <span class="title">error</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> f.doTransition()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">doTransition</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> f.transitionerObj.transition(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhuang-weiming.github.io/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Weiming Zhuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhuang's Diary">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/" class="post-title-link" itemprop="url">用Go实现一个异步网络库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-09-19 09:40:00" itemprop="dateCreated datePublished" datetime="2022-09-19T09:40:00+08:00">2022-09-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-21 11:04:21" itemprop="dateModified" datetime="2023-02-21T11:04:21+08:00">2023-02-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在需要高性能、节省资源的场景下，比如海量的连接、很高的并发，我们发现Go开始变得吃力，不但内存开销大，而且还会有频繁的goroutine调度。GC时间也变得越来越长，甚至还会把系统搞挂。这时，我们就可以考虑用Go构建经典的Reactor网络模型，来应对这种场景。</p>
<h3 id="一、常见的服务端网络编程模型"><a href="#一、常见的服务端网络编程模型" class="headerlink" title="一、常见的服务端网络编程模型"></a>一、常见的服务端网络编程模型</h3><p>在具体讲Reactor网络库的实现前，我们先快速回顾下常见的服务端网络编程模型。</p>
<p>服务端网络编程主要解决两个问题，一个是<strong>服务端如何管理连接，特别是海量连接、高并发连接（经典的c10k/c100k问题）</strong>，二是<strong>服务端如何处理请求（高并发时正常响应）</strong>。</p>
<p>针对这两个问题，有三种解决方案，分别对应三种模型：</p>
<ul>
<li><p>传统IO阻塞模型。</p>
</li>
<li><p>Reactor模型。</p>
</li>
<li><p>Proactor模型。</p>
</li>
</ul>
<p>下面两图分别是传统IO阻塞模型和Reactor模型，传统IO阻塞模型的特点是每条连接都是由单独的线/进程管理，业务逻辑（crud）跟数据处理（网络连接上的read和write）都在该线/进程完成。<strong>缺点很明显，并发大时，需要创建大量的线/进程，系统资源开销大；连接建立后，如果当前线/进程暂时还没数据可读，会阻塞在Read调用上，浪费系统资源</strong>。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/1.png"></p>
<p>Reactor模型就是传统IO阻塞模型的改进，Reactor会起单独的线/进程去监听和分发事件，分发给其他EventHandlers处理数据读写和业务逻辑。这样，与传统IO阻塞模型不同的是，Reactor的连接都先到一个EventDispatcher上，一个核心的事件分发器，同时<strong>Reactor会使用IO多路复用在事件分发器上非阻塞地处理多个连接</strong>。</p>
<p>这个EventDispatcher跟后面的EventHandlers可以都在一个线/进程，也可以分开，下文会有区分。整体来看，Reactor就是一种事件分发机制，所以Reactor也被称为事件驱动模型。<strong>简而言之，Reactor=IO多路复用（I/O multiplexing）+非阻塞IO（non-blocking I/O）</strong>。</p>
<h4 id="（一）Reactor模型的三种实现"><a href="#（一）Reactor模型的三种实现" class="headerlink" title="（一）Reactor模型的三种实现"></a>（一）Reactor模型的三种实现</h4><p>根据Reactor的数量和业务线程的工作安排有3种典型实现：</p>
<ul>
<li><p>单Reactor多线程</p>
</li>
<li><p>单Reactor多线程带线程池</p>
</li>
<li><p>主从Reactor多线程（带线程池）</p>
</li>
</ul>
<p>先看两个单Reactor：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/2.png"></p>
<p><strong>一个Reactor接管所有的事件安排</strong>，如果是建立连接事件，就交给Acceptor处理，接着创建对应的Handler处理该连接后续的读写事件。如果不是建立连接事件，就调用连接对应的Event Handler来响应。单Reator1和2的区别是2带了个线程池，一定程度上解放Event Handler线程，让Handler专注数据读写处理，特别是在遇到一些笨重、高耗时的业务逻辑时。</p>
<p>再来看多Reactor，这个是本文的主角，第三节内容就是怎么实现它。多Reactor就是主从多Reactor，它的特点是<strong>多个Reactor在多个单独的线/进程中运行，MainReactor负责处理建立连接事件，交给它的Acceptor处理，处理完了，它再分配连接给SubReactor；SubReactor则处理这个连接后续的读写事件，SubReactor自己调用EventHandlers做事情</strong>。</p>
<p>这种实现看起来职责就很明确，可以方便通过增加SubReactor数量来充分利用CPU资源，也是当前主流的服务端网络编程模型。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/2.1.jpeg"></p>
<h4 id="（二）Proactor模型自带主角光环"><a href="#（二）Proactor模型自带主角光环" class="headerlink" title="（二）Proactor模型自带主角光环"></a>（二）Proactor模型自带主角光环</h4><p>尽管本文的主角是主从多Reactor，但如果Proactor要当主角，就没Reactor什么事。</p>
<p>Proactor模型跟Reactor模型的<strong>本质区别是异步I/O和同步I/O的区别，即底层I/O实现</strong>。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/3.png"></p>
<p>从上面两张图可以看出，Reactor模型依赖的同步I/O需要不断检查事件发生，然后拷贝数据处理，而Proactor模型使用的异步I/O只需等待系统通知，直接处理内核拷贝过来的数据，孰优孰劣，一言便知。</p>
<p>基于异步I/O的Proactor模型实现如下图：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/4.png"></p>
<p>那为什么主角光环如此明显的Proactor不是当前主流的服务端网络编程模型呢？</p>
<p>原因是在Linux下的AIO API–io_uring还没有像同步I/O那样能够覆盖和支持很多场景，即还没成熟到被广泛使用。</p>
<h3 id="二、Go原生网络模型简介"><a href="#二、Go原生网络模型简介" class="headerlink" title="二、Go原生网络模型简介"></a>二、Go原生网络模型简介</h3><p>关于Go原生网络模型的实现，网上已经有很多文章，这里就不过多展开，读者可以结合下图追踪整个代码流程：</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/5.png"></p>
<p>总结来说，<strong>Go所有的网络操作围绕网络描述符netFD展开，netFD与底层pollDesc结构绑定，当在一个netFD上读写遇到EAGAIN错误时，就将当前goroutine存储到绑定的pollDesc中，同时将goroutine给park住，直到这个netFD上的数据准备好，再唤醒goroutine完成数据读写</strong>。</p>
<p>再总结来说，<strong>Go原生网络模型就是个单Reactor多协程模型</strong>。</p>
<h4 id="三、如何从0到1实现异步网络库"><a href="#三、如何从0到1实现异步网络库" class="headerlink" title="三、如何从0到1实现异步网络库"></a>三、如何从0到1实现异步网络库</h4><p>我们现在回顾了常见的服务端网络编程模型，也知道Go处理连接的方式是一个连接给分配一个协程处理，即goroutine-per-conn模式。</p>
<p>那本节就到了我们的重点，怎么去实现一个异步网络库（因为Reactor模型的实现，一般是主线程accept一个连接后，分给其他的线/进程异步处理后续的业务逻辑和数据读写，所以一般Reactor模型的网络库被称为异步网络库，并不是使用异步I/O的API）。</p>
<p>在具体实现之前，笔者先介绍下需求背景。</p>
<h4 id="（一）需求背景"><a href="#（一）需求背景" class="headerlink" title="（一）需求背景"></a>（一）需求背景</h4><p>Go的协程非常轻量，大部分场景下，基于Go原生网络库构建的应用都不会有什么性能瓶颈，资源占用也很可观。</p>
<p>我们现在使用的网关是基于C++自研的一款网关，我们想统一技术栈，换成Go的，我们现在峰值会在百万连接上下，大概用了几十台机器，单机能稳定支撑几十万的连接。如果换成Go的话，我们一直疑惑，基于Go实现的网关单机能撑多少，内存跟CPU怎么样？能不能省点机器？</p>
<p>于是，笔者开始针对这种有大量连接的场景对Go做了一波压测，得出的结论也显而易见：<strong>随着连接数上升，Go的协程数也随之线性上升，内存开销增大，GC时间占比增加。当连接数到达一定数值时，Go的强制GC还会把进程搞挂，服务不可用</strong>。（下文会有网络库的对比压测数据）</p>
<p>接着，笔者翻阅内外网有同样场景的解决方案，基本都是往经典Reactor模型实现上做文章。比如最早的A Million WebSockets and Go，作者Sergey Kamardin使用epoll的方式代替goroutine-per-conn模式，百万连接场景下用少量的goroutine去代替一百万的goroutine。</p>
<p>A Million WebSockets and Go：</p>
<p><a target="_blank" rel="noopener" href="https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/">https://www.freecodecamp.org/news/million-websockets-and-go-cc58418460bb/</a></p>
<p>Sergey Kamardin的方案总结：</p>
<p>Let’s structure the optimizations I told you about.</p>
<ul>
<li>A read goroutine with a buffer inside is expensive. Solution: netpoll (epoll, kqueue); reuse the buffers.</li>
<li>A write goroutine with a buffer inside is expensive. Solution: start the goroutine when necessary; reuse the buffers.</li>
<li>With a storm of connections, netpoll won’t work. Solution: reuse the goroutines with the limit on their number.</li>
<li>net/http is not the fastest way to handle Upgrade to WebSocket. Solution: use the zero-copy upgrade on bare TCP connection.</li>
</ul>
<p>又比如字节基于Reactor网络库netpoll开发了RPC框架Kitex来应对高并发场景。</p>
<p>笔者简单用Go实现了一个网关，使用这些Reactor网络库再进行了一波压测，结果符合预期：连接数上去后的Go网关确实比之前的稳定，内存占用也很可观。但最终都没有选用这些开源Reactor库，原因是<strong>这些开源库都不是开箱即用，都没有实现HTTP/1.x、TLS等常见协议；API设计不够灵活且专注的场景并不适合网关，比如netpoll目前主要专注于RPC场景</strong>（字节上周才正式对外开源HTTP框架Hertz）；<strong>整体改造成本高，难以适配运用到Go网关中</strong>。</p>
<p>Netpoll的场景说明：</p>
<p>另一方面，开源社区目前缺少专注于RPC方案的Go网络库。类似的项目如：evio，gnet等，均面向Redis，HAProxy这样的场景。</p>
<h4 id="（二）总体分层设计"><a href="#（二）总体分层设计" class="headerlink" title="（二）总体分层设计"></a>（二）总体分层设计</h4><p>终于到了实现部分，我们先看一个Reactor库的总体分层设计，总体分为三层：应用层、连接层和基础层。</p>
<p>应用层就是常见的EchoServer、HTTPServer、TLSServer和GRPCServer等等，主要负责协议解析、执行业务逻辑，对应Reactor模型里边的EventHandler。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/6.png"></p>
<p>在Reactor模型中，应用层会实现事件处理的接口，等待连接层调用。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler Core 注册接口type Handler interface &#123;  OnOpen(c *Conn)</span></span><br><span class="line"><span class="comment">// happen on accept conn  OnClose(c *Conn, err error)</span></span><br><span class="line"><span class="comment">// happen ob delete conn  OnData(c *Conn, data []byte)</span></span><br><span class="line"><span class="comment">// happen on epoll wait  OnStop()&#125;</span></span><br></pre></td></tr></table></figure>

<p>比如当连接建立后，可以调用OnOpen函数做些初始化逻辑，当连接上有新数据到来，可以调用OnData函数完成具体的协议解析和业务逻辑。</p>
<h4 id="（三）连接层设计"><a href="#（三）连接层设计" class="headerlink" title="（三）连接层设计"></a>（三）连接层设计</h4><p>连接层就是整个Reactor模型的核心，根据上文的主从Reactor多线程模型，连接层主要有两种Reactor，一主（Main Reactor）多从（Sub Reactor），也可以多主多从。</p>
<p>Main Reactor主要负责监听和接收连接，接着分配连接，它里边有个for循环，不断去accept新连接，这里的方法可以叫做acceptorLoop；Sub Reactor拿到Main Reactor分配的连接，它也是个for循环，一直等待着读写事件到来，然后干活，即回调应用层执行具体业务逻辑，它的方法可以叫做readWriteLoop。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/7.png"></p>
<p>根据连接层的工作安排，可以发现我们需要以下三个数据结构：</p>
<ul>
<li><p>EventLoop：事件循环，即Reactor，用isMain区分主从，如果是Sub Reactor，每个SubReactor上挂着很多Conn。</p>
</li>
<li><p>Poller：Sub Reactor的里的readWriteLoop需要不断处理读写事件，这些事件在不同系统下由不同的I/O API监听和通知，在Linux系统下就是经典的Epoll三组函数，在Unix系统下（比如Mac）就是Kqueue。</p>
</li>
<li><p>Conn：Main Reactor的listener accept之后建立的连接，与一个文件描述符fd绑定。</p>
</li>
</ul>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/8.png"></p>
<h4 id="值得注意的fd竞态"><a href="#值得注意的fd竞态" class="headerlink" title="值得注意的fd竞态"></a>值得注意的fd竞态</h4><p>每个连接都会与一个fd绑定，当某个连接关闭后，它会释放掉fd，供新连接绑定，这也叫<strong>fd的复用</strong>。</p>
<p>通常我们的应用层会在一个协程池中执行它的业务逻辑，在连接层有个Sub Reactor在处理这个连接上的读写事件。</p>
<p>如果在应用层那边关闭了连接，而在Sub Reactor那边刚好在准备读这个连接上的数据，即操作这个fd。</p>
<p>当Sub Reactor还没来得及读，但被应用层关闭释放掉的fd，已经给到了一个新连接，这时Sub Reactor继续读这个fd上的数据，就会把新连接的数据读走。</p>
<p>因此，我们需要<strong>针对fd的操作前后加个锁，即在关闭连接跟在连接上读写前先上锁，关闭后才释放掉锁，并且在连接上读写前判断连接是否关闭</strong>，这样才会避免脏数据。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/9.png"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95VxoqjGm1IfuicBMt3YLNVkg8j3Kte9fFPQgrTfkibf0xlCLkARz5cTdA5GDDzrRicXcruJrlsEuic6A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<h4 id="不可忽略的负载均衡"><a href="#不可忽略的负载均衡" class="headerlink" title="不可忽略的负载均衡"></a>不可忽略的负载均衡</h4><p>除了注意fd复用带来的竞态，还有一个不可忽略的负载均衡，在Main Reactor分配连接到Sub Reactor这个环节。</p>
<p>未来避免某个Sub Reactor过载，我们可以参考Nginx的负载均衡策略，大概有以下三种方式：</p>
<ul>
<li><p>轮询调度（Round-Robin Scheduling）：轮询Sub Reactors，逐个分配。</p>
</li>
<li><p>Fd哈希：c.fd%len(s.workLoops)，以fd值哈希整个Sub Reactors数量。</p>
</li>
<li><p>最小连接数（Least Connections）：优先分配给连接数最小的sub reactor。</p>
</li>
</ul>
<h3 id="（四）基础层设"><a href="#（四）基础层设" class="headerlink" title="（四）基础层设"></a>（四）基础层设</h3><p>Reactor的核心的活都在连接层干完了，<strong>基础层的作用是提供底层系统调用支持及做好内存管理</strong>。</p>
<p>系统调用就是常见的listen/accept/read/write/epoll_create/epoll_ctl/epoll_wait等，这里不展开。但内存管理的方式会极大地影响网络库的性能。</p>
<p>笔者曾经在处理连接上读事件的时候，先是用动态内存池的方式提供临时Buffer承接，对比使用固定Buffer去承接，前者需要一借一还，在某个简单Echo场景下压测，后者较前者提升了12wQPS，恐怖如斯。</p>
<p>以下是常见的内存管理方案，针对连接上读写处理时的内存使用优劣对比：</p>
<ul>
<li><p><strong>固定数组</strong></p>
</li>
<li><p>每次读都申请固定大小的buffer。</p>
</li>
<li><p>好处是实现简单，坏处是会积累临时对象。</p>
</li>
<li><p><strong>RingBuffer</strong></p>
</li>
</ul>
<p>读写分离，节省内存，但频繁扩容有性能损耗（扩容时需要搬迁老数据到新RingBuffer上）</p>
<ul>
<li><p><strong>LinkBuffer</strong></p>
</li>
<li><p>读写分离，节省内存</p>
</li>
<li><p>池化Block节点，方便扩容缩容且无性能损耗</p>
</li>
<li><p>可以实现NoCopy API，进一步提高性能。</p>
</li>
</ul>
<p>这里最理想的是第三种内存管理方案，字节的netpoll有实现。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/10.png"></p>
<p>这里引用某个项目的实现说明，<strong>NoCopy体现在连接层读到的数据，可以不用拷贝给应用层使用，而是让应用层引用LinkBuffer使用</strong>。</p>
<p>首先来讲零拷贝读取接口，我们将读取操作分成了「引用读」「释放」两个步骤，「引用读」会把 Linked Buffer 中一定长度的字节数组以指针的形式取出，用户使用完这些数据后，主动执行「释放」告知 Linked Buffer 刚刚「引用读」的数据空间不会再被使用，可以释放掉，被「释放」了的数据不能再被读取和修改。</p>
<p>零拷贝写入接口则是将用户传入的字节数组构造成一个个节点，每个节点里包含了字节数组的指针，再将这些节点添加到Linked Buffer中，自始至终都是对字节数组的指针进行操作，没有任何的拷贝行为。</p>
<h3 id="（五）性能测试"><a href="#（五）性能测试" class="headerlink" title="（五）性能测试"></a>（五）性能测试</h3><p>以上3小节就是一个Reactor网络库的框架和实现设计，流程并不复杂，笔者认为<strong>真正考验的是基于Reactor库去实现常见的HTTP/1.x协议、TLS协议甚至HTTP/2.0协议等等</strong>，笔者在实现HTTP/1.x的时候就试了很多开源解析器，很多性能都不尽人意；在尝试直接使用Go官方自带的TLS协议解析器，发现TLS四次握手并不是连续的包，第三次握手时，客户端发送的信息可以等一会…大部分问题都比较棘手，这估计也是很多开源库没有实现这些协议的原因吧~</p>
<ul>
<li><h4 id="压测结果"><a href="#压测结果" class="headerlink" title="压测结果"></a>压测结果</h4></li>
</ul>
<p>在开发完Reactor网络库及在这个库的基础上实现常见的应用层协议后，我们需要一波压测检验网络库的性能。</p>
<p>区别于网上大部分开源库只做简单的Echo压测，笔者这里构建了两种场景压测：</p>
<ul>
<li><p>Echo场景：EchoServer不需要做协议解析，也不需要做什么业务逻辑，目的是跟同类型的Reactor库做横向对比。</p>
</li>
<li><p>HTTP场景：HTTPServer需要解析HTTP/1.x协议，加上10w循环计数模拟业务逻辑，目的是跑到10w连接上跟Go net对比。</p>
</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;    sum += i&#125;</span><br></pre></td></tr></table></figure>

<p>最终的结果如下4张图，可以忽略字节netpoll的数据，大概是因为这两种场景并不是netpoll的目标场景，即RPC场景，所以压测的姿势大概率不对。</p>
<p>Echo场景下是4核机器跑的EchoServer，HTTP场景下是8核跑的HTTPServer。</p>
<p>图1：Echo场景下，固定1KB数据包，不断增加连接数。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/11.png"></p>
<p>图2：Echo场景下，固定1K连接数，不断增加数据包大小。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/12.png"></p>
<p>图3和图4：HTTP场景下，固定1KB数据包，不断增加连接数，QPS和内存占用情况。</p>
<p><img src="/2022/09/19/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E5%BA%93/13.png"></p>
<ul>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li>
</ul>
<p>通过压测结果，可以看出大部分压测，Go原生网络库都没有什么拉胯表现，<strong>只有在连接数上去了之后，或者需要处理的数据包越来越大的情况下，Go原生网络库才逐渐显示出颓势</strong>。尤其是当连接上到30w到50w之后，Go原生网络库的内存开销增大的同时，伴随的GC时间也变长，到50w连接的时候，一波强制GC服务就down了。</p>
<p>这是Go原生网络库在50w连接时，强制GC后Down掉时的详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GC forcedgc 13 @146.006s 0%: 0.12+105+0.004 ms clock, 0.99+0/207/620+0.033 ms cpu, 5877-&gt;5877-&gt;4197 MB, 7006 MB goal, 8 Pgc 14 @197.643s 1%: 0.084+1084+0.061 ms clock, 0.67+5299/2139/1.8+0.49 ms cpu, 8187-&gt;8218-&gt;4825 MB, 8394 MB goal, 8 Pgc 15 @220.972s 1%: 4.1+1057+0.039 ms clock, 33+5215/2087/0+0.31 ms cpu, 9412-&gt;9442-&gt;4794 MB, 9651 MB goal, 8 PGC forced</span><br></pre></td></tr></table></figure>

<p>这是Reactor网络库(wnet) 100w连接时，依然坚挺的GC详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gc 23 @208.600s 1%: 0.20+374+0.090 ms clock, 1.6+233/723/0+0.72 ms cpu, 873-&gt;891-&gt;450MB, 896 MB goal, 8 Pgc 24 @213.872s 1%: 0.18+419+0.051 ms clock, 1.5+4.8/830/0+0.41 ms cpu, 878-&gt;899-&gt;453MB, 900 MB goal, 8 Pgc 25 @219.270s 1%: 1.2+403+0.071 ms clock, 10+160/790/0+0.57 ms cpu, 884-&gt;907-&gt;454 MB,907 MB goal, 8 Pgc 26 @224.601s 1%: 0.12+425+0.056 ms clock, 1.0+112/849/0+0.44 ms cpu, 885-&gt;906-&gt;452MB, 908 MB goal, 8 Pgc 27 @229.851s 1%: 0.20+424+0.079 ms clock, 1.6+107/836/0+0.63 ms cpu, 881-&gt;903-&gt;453MB, 904 MB goal, 8 Pgc 28 @235.256s 1%: 0.17+431+0.038 ms clock, 1.4+77/863/0+0.30 ms cpu, 884-&gt;907-&gt;454MB, 907 MB goal, 8 Pgc 29 @240.622s 1%: 0.15+402+0.039 ms clock, 1.2+117/804/0+0.31 ms cpu, 885-&gt;907-&gt;452MB, 908 MB goal, 8 PGC forced</span><br></pre></td></tr></table></figure>

<p>因此，综合来看，大部分应用场景，Go原生网络库就可以满足。相比Reactor网络库而言，<strong>Go原生网络库可以看作是以空间（内存、runtime）来换取时间（高吞吐量和低延时）。当空间紧张时，也就是连接数上来后，巨大的内存开销和相应的GC会导致服务不可用，而这种海量连接场景才是Reactor网络库的优势所在</strong>。比如电商大促等活动型场景，有预期的流量高峰，在高峰期会有海量的连接，海量的请求；还有一种直播弹幕、消息推送等长连接场景，也是有大量的长连接。</p>
<h4 id="关联阅读-》-https-github-com-panjf2000-gnet"><a href="#关联阅读-》-https-github-com-panjf2000-gnet" class="headerlink" title="关联阅读==》 https://github.com/panjf2000/gnet"></a>关联阅读==》 <a target="_blank" rel="noopener" href="https://github.com/panjf2000/gnet">https://github.com/panjf2000/gnet</a></h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weiming Zhuang</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>




</body>
</html>
